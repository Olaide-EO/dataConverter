[{"title":"C-Plus-Plus-master","id":"C-Plus-Plus-master"},{"title":"Backtracking","category":null,"id":"backtracking","index":0},{"title":"Graph Coloring","category":"backtracking","id":"graph_coloring_backtracking","algorithm":"/**\n * @file\n * @brief prints the assigned colors\n * using [Graph Coloring](https://en.wikipedia.org/wiki/Graph_coloring) algorithm\n *\n * @details\n * In graph theory, graph coloring is a special case of graph labeling; \n * it is an assignment of labels traditionally called \"colors\" to elements of a graph subject to certain constraints. \n * In its simplest form, it is a way of coloring the vertices of a graph such that no two adjacent vertices are of the same color; \n * this is called a vertex coloring. Similarly, an edge coloring assigns\n * a color to each edge so that no two adjacent edges are of the same color,\n * and a face coloring of a planar graph assigns a color to each face or\n * region so that no two faces that share a boundary have the same color.\n *\n * @author [Anup Kumar Panwar](https://github.com/AnupKumarPanwar)\n * @author [David Leal](https://github.com/Panquesito7)\n */\n#include <iostream>\n#include <array>\n#include <vector>\n\n/**\n * @namespace\n * @brief Backtracking algorithms\n */\nnamespace backtracking {\n    /** A utility function to print solution\n     * @tparam V number of vertices in the graph\n     * @param color array of colors assigned to the nodes\n     */\n    template <size_t V>\n    void printSolution(const std::array <int, V>& color) {\n        std::cout << \"Following are the assigned colors\\n\";\n        for (auto &col : color) {\n            std::cout << col;\n        }\n        std::cout << \"\\n\";\n    }\n\n    /** A utility function to check if the current color assignment is safe for\n     * vertex v\n     * @tparam V number of vertices in the graph\n     * @param v index of graph vertex to check\n     * @param graph matrix of graph nonnectivity\n     * @param color vector of colors assigned to the graph nodes/vertices\n     * @param c color value to check for the node `v`\n     * @returns `true` if the color is safe to be assigned to the node\n     * @returns `false` if the color is not safe to be assigned to the node\n     */\n    template <size_t V>\n    bool isSafe(int v, const std::array<std::array <int, V>, V>& graph, const std::array <int, V>& color, int c) {\n        for (int i = 0; i < V; i++) {\n            if (graph[v][i] && c == color[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /** A recursive utility function to solve m coloring problem\n     * @tparam V number of vertices in the graph\n     * @param graph matrix of graph nonnectivity\n     * @param m number of colors\n     * @param [in,out] color description // used in,out to notify in documentation\n     * that this parameter gets modified by the function\n     * @param v index of graph vertex to check\n     */\n    template <size_t V>\n    void graphColoring(const std::array<std::array <int, V>, V>& graph, int m, std::array <int, V> color, int v) {\n        // base case:\n        // If all vertices are assigned a color then return true\n        if (v == V) {\n            backtracking::printSolution<V>(color);\n            return;\n        }\n\n        // Consider this vertex v and try different colors\n        for (int c = 1; c <= m; c++) {\n            // Check if assignment of color c to v is fine\n            if (backtracking::isSafe<V>(v, graph, color, c)) {\n                color[v] = c;\n\n                // recur to assign colors to rest of the vertices\n                backtracking::graphColoring<V>(graph, m, color, v + 1);\n\n                // If assigning color c doesn't lead to a solution then remove it\n                color[v] = 0;\n            }\n        }\n    }\n}  // namespace backtracking\n\n/**\n * Main function\n */\nint main() {\n    // Create following graph and test whether it is 3 colorable\n    // (3)---(2)\n    // |   / |\n    // |  /  |\n    // | /   |\n    // (0)---(1)\n\n    const int V = 4;  // number of vertices in the graph\n    std::array <std::array <int, V>, V> graph = {\n        std::array <int, V>({0, 1, 1, 1}),\n        std::array <int, V>({1, 0, 1, 0}),\n        std::array <int, V>({1, 1, 0, 1}),\n        std::array <int, V>({1, 0, 1, 0})\n    };\n\n    int m = 3;  // Number of colors\n    std::array <int, V> color{};\n\n    backtracking::graphColoring<V>(graph, m, color, 0);\n    return 0;\n}\n","index":1},{"title":"Knight Tour","category":"backtracking","id":"knight_tour_backtracking","algorithm":"/**\n * @file\n * @brief [Knight's tour](https://en.wikipedia.org/wiki/Knight%27s_tour) algorithm\n *\n * @details\n * A knight's tour is a sequence of moves of a knight on a chessboard\n * such that the knight visits every square only once. If the knight\n * ends on a square that is one knight's move from the beginning\n * square (so that it could tour the board again immediately, following\n * the same path, the tour is closed; otherwise, it is open.\n *\n * @author [Nikhil Arora](https://github.com/nikhilarora068)\n * @author [David Leal](https://github.com/Panquesito7)\n */\n#include <iostream>\n#include <array>\n\n/**\n * @namespace backtracking\n * @brief Backtracking algorithms\n */\nnamespace backtracking {\n    /**\n     * A utility function to check if i,j are valid indexes for N*N chessboard\n     * @tparam V number of vertices in array\n     * @param x current index in rows\n     * @param y current index in columns\n     * @param sol matrix where numbers are saved\n     * @returns `true` if ....\n     * @returns `false` if ....\n     */\n    template <size_t V>\n    bool issafe(int x, int y, const std::array <std::array <int, V>, V>& sol) {\n        return (x < V && x >= 0 && y < V && y >= 0 && sol[x][y] == -1);\n    }\n\n    /**\n     * Knight's tour algorithm\n     * @tparam V number of vertices in array\n     * @param x current index in rows\n     * @param y current index in columns\n     * @param mov movement to be done\n     * @param sol matrix where numbers are saved\n     * @param xmov next move of knight (x coordinate)\n     * @param ymov next move of knight (y coordinate)\n     * @returns `true` if solution exists\n     * @returns `false` if solution does not exist\n     */\n    template <size_t V>\n    bool solve(int x, int y, int mov, std::array <std::array <int, V>, V> &sol,\n        const std::array <int, V> &xmov, std::array <int, V> &ymov) {\n        int k, xnext, ynext;\n\n        if (mov == V * V) {\n            return true;\n        }\n\n        for (k = 0; k < V; k++) {\n            xnext = x + xmov[k];\n            ynext = y + ymov[k];\n\n            if (backtracking::issafe<V>(xnext, ynext, sol)) {\n                sol[xnext][ynext] = mov;\n\n                if (backtracking::solve<V>(xnext, ynext, mov + 1, sol, xmov, ymov) == true) {\n                    return true;\n                }\n                else {\n                    sol[xnext][ynext] = -1;\n                }\n            }\n        }\n        return false;\n    }\n} // namespace backtracking\n\n/**\n * Main function\n */\nint main() {\n    const int n = 8;\n    std::array <std::array <int, n>, n> sol = { 0 };\n\n    int i, j;\n    for (i = 0; i < n; i++) {\n        for (j = 0; j < n; j++) { sol[i][j] = -1; }\n    }\n\n    std::array <int, n> xmov = { 2, 1, -1, -2, -2, -1, 1, 2 };\n    std::array <int, n> ymov = { 1, 2, 2, 1, -1, -2, -2, -1 };\n\n    sol[0][0] = 0;\n\n    bool flag = backtracking::solve<n>(0, 0, 1, sol, xmov, ymov);\n    if (flag == false) {\n        std::cout << \"Error: Solution does not exist\\n\";\n    }\n    else {\n        for (i = 0; i < n; i++) {\n            for (j = 0; j < n; j++) { std::cout << sol[i][j] << \"  \"; }\n            std::cout << \"\\n\";\n        }\n    }\n    return 0;\n}\n","index":2},{"title":"Minimax","category":"backtracking","id":"minimax_backtracking","algorithm":"/**\n * @file\n * @brief returns which is the longest/shortest number\n * using [minimax](https://en.wikipedia.org/wiki/Minimax) algorithm\n *\n * @details\n * Minimax (sometimes MinMax, MM or saddle point) is a decision rule used in\n * artificial intelligence, decision theory, game theory, statistics,\n * and philosophy for minimizing the possible loss for a worst case (maximum loss) scenario.\n * When dealing with gains, it is referred to as \"maximin\"—to maximize the minimum gain.\n * Originally formulated for two-player zero-sum game theory, covering both the cases where players take\n * alternate moves and those where they make simultaneous moves, it has also been extended to more\n * complex games and to general decision-making in the presence of uncertainty.\n * \n * @author [Gleison Batista](https://github.com/gleisonbs)\n * @author [David Leal](https://github.com/Panquesito7)\n */\n#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <array>\n\n/** \n * @namespace backtracking\n * @brief Backtracking algorithms\n */\nnamespace backtracking {\n/**\n * Check which number is the maximum/minimum in the array\n * @param depth current depth in game tree\n * @param node_index current index in array\n * @param is_max if current index is the longest number\n * @param scores saved numbers in array\n * @param height maximum height for game tree\n * @return maximum or minimum number\n */\ntemplate <size_t T>\nint minimax(int depth, int node_index, bool is_max,\n            const std::array<int, T> &scores, double height) {\n    if (depth == height) {\n        return scores[node_index];\n    }\n\n    int v1 = minimax(depth + 1, node_index * 2, !is_max, scores, height);\n    int v2 = minimax(depth + 1, node_index * 2 + 1, !is_max, scores, height);\n\n    return is_max ? std::max(v1, v2) : std::min(v1, v2);\n}\n} // namespace backtracking\n\n/**\n * Main function\n */\nint main() {\n    std::array<int, 8> scores = {90, 23, 6, 33, 21, 65, 123, 34423};\n    double height = log2(scores.size());\n\n    std::cout << \"Optimal value: \" << backtracking::minimax(0, 0, true, scores, height)\n              << std::endl;\n    return 0;\n}\n","index":3},{"title":"Nqueen Print All Solutions","category":"backtracking","id":"nqueen_print_all_solutions_backtracking","algorithm":"/**\r\n * @file\r\n * @brief [Eight Queens](https://en.wikipedia.org/wiki/Eight_queens_puzzle) \r\n * puzzle, printing all solutions\r\n *\r\n * @author [Himani Negi](https://github.com/Himani2000)\r\n * @author [David Leal](https://github.com/Panquesito7)\r\n *\r\n */\r\n#include <iostream>\r\n#include <array>\r\n\r\n/**\r\n * @namespace backtracking\r\n * @brief Backtracking algorithms\r\n */\r\nnamespace backtracking {\r\n/**\r\n * @namespace n_queens_all_solutions\r\n * @brief Functions for [Eight\r\n * Queens](https://en.wikipedia.org/wiki/Eight_queens_puzzle) puzzle with all solutions.\r\n */\r\nnamespace n_queens_all_solutions {\r\n/**\r\n * Utility function to print matrix\r\n * @tparam n number of matrix size\r\n * @param board matrix where numbers are saved\r\n */\r\ntemplate <size_t n>\r\nvoid PrintSol(const std::array<std::array<int, n>, n>& board) {\r\n    for (int i = 0; i < n; i++) {\r\n        for (int j = 0; j < n; j++) {\r\n            std::cout << board[i][j] << \" \";\r\n        }\r\n        std::cout << std::endl;\r\n    }\r\n    std::cout << std::endl;\r\n}\r\n\r\n/**\r\n * Check if a queen can be placed on matrix\r\n * @tparam n number of matrix size\r\n * @param board matrix where numbers are saved\r\n * @param row current index in rows\r\n * @param col current index in columns\r\n * @returns `true` if queen can be placed on matrix\r\n * @returns `false` if queen can't be placed on matrix\r\n */\r\ntemplate <size_t n>\r\nbool CanIMove(const std::array<std::array<int, n>, n>& board, int row, int col) {\r\n    /// check in the row\r\n    for (int i = 0; i < col; i++) {\r\n        if (board[row][i] == 1) {\r\n            return false;\r\n        }\r\n    }\r\n    /// check the first diagonal\r\n    for (int i = row, j = col; i >= 0 && j >= 0; i--, j--) {\r\n        if (board[i][j] == 1) {\r\n            return false;\r\n        }\r\n    }\r\n    /// check the second diagonal\r\n    for (int i = row, j = col; i <= n - 1 && j >= 0; i++, j--) {\r\n        if (board[i][j] == 1) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\n/**\r\n * Solve n queens problem\r\n * @tparam n number of matrix size\r\n * @param board matrix where numbers are saved\r\n * @param col current index in columns\r\n */\r\ntemplate <size_t n>\r\nvoid NQueenSol(std::array<std::array<int, n>, n> board, int col) {\r\n    if (col >= n) {\r\n        PrintSol(board);\r\n        return;\r\n    }\r\n    for (int i = 0; i < n; i++) {\r\n        if (CanIMove(board, i, col)) {\r\n            board[i][col] = 1;\r\n            NQueenSol(board, col + 1);\r\n            board[i][col] = 0;\r\n        }\r\n    }\r\n}\r\n}   // namespace n_queens_all_solutions\r\n}  // namespace backtracking\r\n\r\n/**\r\n * Main function\r\n */\r\nint main() {\r\n    const int n = 4;\r\n    std::array<std::array<int, n>, n> board{0};\r\n\r\n    backtracking::n_queens_all_solutions::NQueenSol(board, 0);\r\n}\r\n","index":4},{"title":"N Queens","category":"backtracking","id":"n_queens_backtracking","algorithm":"/**\n * @file\n * @brief [Eight Queens](https://en.wikipedia.org/wiki/Eight_queens_puzzle)\n * puzzle\n *\n * @details\n * The **eight queens puzzle** is the problem of placing eight chess queens on\n * an 8×8 chessboard so that no two queens threaten each other; thus, a solution\n * requires that no two queens share the same row, column, or diagonal. The\n * eight queens puzzle is an example of the more general **n queens problem** of\n * placing n non-attacking queens on an n×n chessboard, for which solutions\n * exist for all natural numbers n with the exception of n = 2 and n = 3.\n *\n * @author Unknown author\n * @author [David Leal](https://github.com/Panquesito7)\n *\n */\n#include <iostream>\n#include <array>\n\n/**\n * @namespace backtracking\n * @brief Backtracking algorithms\n */\nnamespace backtracking {\n  /**\n   * @namespace n_queens\n   * @brief Functions for [Eight Queens](https://en.wikipedia.org/wiki/Eight_queens_puzzle) puzzle.\n   */\n  namespace n_queens {\n    /**\n    * Utility function to print matrix\n    * @tparam n number of matrix size\n    * @param board matrix where numbers are saved\n    */\n    template <size_t n>\n    void printSolution(const std::array<std::array<int, n>, n> &board) {\n      std::cout << \"\\n\";\n      for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n          std::cout << \"\" << board[i][j] << \" \";\n        }\n        std::cout << \"\\n\";\n      }\n    }\n\n    /**\n    * Check if a queen can be placed on matrix\n    * @tparam n number of matrix size\n    * @param board matrix where numbers are saved\n    * @param row current index in rows\n    * @param col current index in columns\n    * @returns `true` if queen can be placed on matrix\n    * @returns `false` if queen can't be placed on matrix\n    */\n    template <size_t n>\n    bool isSafe(const std::array<std::array<int, n>, n> &board, const int &row,\n                const int &col) {\n      int i = 0, j = 0;\n\n      // Check this row on left side\n      for (i = 0; i < col; i++) {\n        if (board[row][i]) {\n          return false;\n        }\n      }\n\n      // Check upper diagonal on left side\n      for (i = row, j = col; i >= 0 && j >= 0; i--, j--) {\n        if (board[i][j]) {\n          return false;\n        }\n      }\n      // Check lower diagonal on left side\n      for (i = row, j = col; j >= 0 && i < n; i++, j--) {\n        if (board[i][j]) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n    * Solve n queens problem\n    * @tparam n number of matrix size\n    * @param board matrix where numbers are saved\n    * @param col current index in columns\n    */\n    template <size_t n>\n    void solveNQ(std::array<std::array<int, n>, n> board, const int &col) {\n      if (col >= n) {\n        printSolution<n>(board);\n        return;\n      }\n\n      // Consider this column and try placing\n      // this queen in all rows one by one\n      for (int i = 0; i < n; i++) {\n        // Check if queen can be placed\n        // on board[i][col]\n        if (isSafe<n>(board, i, col)) {\n          // Place this queen in matrix\n          board[i][col] = 1;\n\n          // Recursive to place rest of the queens\n          solveNQ<n>(board, col + 1);\n\n          board[i][col] = 0; // backtrack\n        }\n      }\n    }\n  } // namespace n_queens\n} // namespace backtracking\n\n/**\n * Main function\n */\nint main() {\n  const int n = 4;\n  std::array<std::array<int, n>, n> board = {\n    std::array<int, n>({0, 0, 0, 0}),\n    std::array<int, n>({0, 0, 0, 0}),\n    std::array<int, n>({0, 0, 0, 0}),\n    std::array<int, n>({0, 0, 0, 0})\n    };\n\n  backtracking::n_queens::solveNQ<n>(board, 0);\n  return 0;\n}\n","index":5},{"title":"N Queens All Solution Optimised","category":"backtracking","id":"n_queens_all_solution_optimised_backtracking","algorithm":"#include <iostream>\n#define n 4\n#define inc_loop(var, start, stop) for (int var = start; var <= stop; var++)\n#define dec_loop(var, start, stop) for (int var = start; var >= stop; var--)\nvoid PrintSol(int Board[n][n]) {\n    inc_loop(i, 0, n - 1) {\n        inc_loop(j, 0, n - 1) std::cout << Board[i][j] << \" \";\n        std::cout << std::endl;\n    }\n    std::cout << std::endl;\n    if (n % 2 == 0 || (n % 2 == 1 && Board[n / 2 + 1][0] != 1)) {\n        inc_loop(i, 0, n - 1) {\n            dec_loop(j, n - 1, 0) std::cout << Board[i][j] << \" \";\n            std::cout << std::endl;\n        }\n        std::cout << std::endl;\n    }\n}\n\nbool CanIMove(int Board[n][n], int row, int col) {\n    /// check in the row\n    inc_loop(i, 0, col - 1) {\n        if (Board[row][i] == 1)\n            return false;\n    }\n    /// check the first diagonal\n    for (int i = row, j = col; i >= 0 && j >= 0; i--, j--) {\n        if (Board[i][j] == 1)\n            return false;\n    }\n    /// check the second diagonal\n    for (int i = row, j = col; i <= n - 1 && j >= 0; i++, j--) {\n        if (Board[i][j] == 1)\n            return false;\n    }\n    return true;\n}\n\nvoid NQueenSol(int Board[n][n], int col) {\n    if (col >= n) {\n        PrintSol(Board);\n        return;\n    }\n    inc_loop(i, 0, n - 1) {\n        if (CanIMove(Board, i, col)) {\n            Board[i][col] = 1;\n            NQueenSol(Board, col + 1);\n            Board[i][col] = 0;\n        }\n    }\n}\n\nint main() {\n    int Board[n][n] = {0};\n    if (n % 2 == 0) {\n        inc_loop(i, 0, n / 2 - 1) {\n            if (CanIMove(Board, i, 0)) {\n                Board[i][0] = 1;\n                NQueenSol(Board, 1);\n                Board[i][0] = 0;\n            }\n        }\n    } else {\n        inc_loop(i, 0, n / 2) {\n            if (CanIMove(Board, i, 0)) {\n                Board[i][0] = 1;\n                NQueenSol(Board, 1);\n                Board[i][0] = 0;\n            }\n        }\n    }\n    return 0;\n}\n","index":6},{"title":"Rat Maze","category":"backtracking","id":"rat_maze_backtracking","algorithm":"/*\n    A Maze is given as N*N binary matrix of blocks where source block is the\n   upper left most block i.e., maze[0][0] and destination block is lower\n   rightmost block i.e., maze[N-1][N-1]. A rat starts from source and has to\n   reach destination. The rat can move only in two directions: forward and down.\n   In the maze matrix, 0 means the block is dead end and 1 means the block can\n   be used in the path from source to destination.\n*/\n#include <iostream>\n#define size 4\n\nusing namespace std;\n\nint solveMaze(int currposrow, int currposcol, int maze[size][size],\n              int soln[size][size]) {\n    if ((currposrow == size - 1) && (currposcol == size - 1)) {\n        soln[currposrow][currposcol] = 1;\n        for (int i = 0; i < size; ++i) {\n            for (int j = 0; j < size; ++j) {\n                cout << soln[i][j];\n            }\n            cout << endl;\n        }\n        return 1;\n    } else {\n        soln[currposrow][currposcol] = 1;\n\n        // if there exist a solution by moving one step ahead in a collumn\n        if ((currposcol < size - 1) && maze[currposrow][currposcol + 1] == 1 &&\n            solveMaze(currposrow, currposcol + 1, maze, soln)) {\n            return 1;\n        }\n\n        // if there exists a solution by moving one step ahead in a row\n        if ((currposrow < size - 1) && maze[currposrow + 1][currposcol] == 1 &&\n            solveMaze(currposrow + 1, currposcol, maze, soln)) {\n            return 1;\n        }\n\n        // the backtracking part\n        soln[currposrow][currposcol] = 0;\n        return 0;\n    }\n}\n\nint main(int argc, char const *argv[]) {\n    int maze[size][size] = {\n        {1, 0, 1, 0}, {1, 0, 1, 1}, {1, 0, 0, 1}, {1, 1, 1, 1}};\n\n    int soln[size][size];\n\n    for (int i = 0; i < size; ++i) {\n        for (int j = 0; j < size; ++j) {\n            soln[i][j] = 0;\n        }\n    }\n\n    int currposrow = 0;\n    int currposcol = 0;\n    solveMaze(currposrow, currposcol, maze, soln);\n    return 0;\n}\n","index":7},{"title":"Sudoku Solve","category":"backtracking","id":"sudoku_solve_backtracking","algorithm":"/**\r\n * @file\r\n * @brief [Sudoku Solver](https://en.wikipedia.org/wiki/Sudoku) algorithm.\r\n *\r\n * @details\r\n * Sudoku (数独, sūdoku, digit-single) (/suːˈdoʊkuː/, /-ˈdɒk-/, /sə-/, originally called\r\n * Number Place) is a logic-based, combinatorial number-placement puzzle. \r\n * In classic sudoku, the objective is to fill a 9×9 grid with digits so that each column,\r\n * each row, and each of the nine 3×3 subgrids that compose the grid (also called \"boxes\", \"blocks\", or \"regions\")\r\n * contain all of the digits from 1 to 9. The puzzle setter provides a\r\n * partially completed grid, which for a well-posed puzzle has a single solution.\r\n *\r\n * @author [DarthCoder3200](https://github.com/DarthCoder3200)\r\n * @author [David Leal](https://github.com/Panquesito7)\r\n */\r\n#include <iostream>\r\n#include <array>\r\n\r\n/**\r\n * @namespace backtracking\r\n * @brief Backtracking algorithms\r\n */\r\nnamespace backtracking {\r\n    /**\r\n     * Checks if it's possible to place a 'no'\r\n     * @tparam V number of vertices in the array\r\n     * @param mat matrix where numbers are saved\r\n     * @param i current index in rows\r\n     * @param j current index in columns\r\n     * @param no number to be added in matrix\r\n     * @param n number of times loop will run\r\n     * @returns `true` if 'mat' is different from 'no'\r\n     * @returns `false` if 'mat' equals to 'no'\r\n     */\r\n    template <size_t V>\r\n    bool isPossible(const std::array <std::array <int, V>, V> &mat, int i, int j, int no, int n) {\r\n        /// Row or col nahin hona chahiye\r\n        for (int x = 0; x < n; x++) {\r\n            if (mat[x][j] == no || mat[i][x] == no) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        /// Subgrid mein nahi hona chahiye\r\n        int sx = (i / 3) * 3;\r\n        int sy = (j / 3) * 3;\r\n\r\n        for (int x = sx; x < sx + 3; x++) {\r\n            for (int y = sy; y < sy + 3; y++) {\r\n                if (mat[x][y] == no) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n    /**\r\n     * Utility function to print matrix\r\n     * @tparam V number of vertices in array\r\n     * @param mat matrix where numbers are saved\r\n     * @param n number of times loop will run\r\n     * @return void\r\n     */\r\n    template <size_t V>\r\n    void printMat(const std::array <std::array <int, V>, V> &mat, int n) {\r\n        for (int i = 0; i < n; i++) {\r\n            for (int j = 0; j < n; j++) {\r\n                std::cout << mat[i][j] << \" \";\r\n                if ((j + 1) % 3 == 0) {\r\n                    std::cout << '\\t';\r\n                }\r\n            }\r\n            if ((i + 1) % 3 == 0) {\r\n                std::cout << std::endl;\r\n            }\r\n            std::cout << std::endl;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sudoku algorithm\r\n     * @tparam V number of vertices in array\r\n     * @param mat matrix where numbers are saved\r\n     * @param i current index in rows\r\n     * @param j current index in columns\r\n     * @returns `true` if 'no' was placed\r\n     * @returns `false` if 'no' was not placed\r\n     */\r\n    template <size_t V>\r\n    bool solveSudoku(std::array <std::array <int, V>, V> &mat, int i, int j) {\r\n        /// Base Case\r\n        if (i == 9) {\r\n            /// Solve kr chuke hain for 9 rows already\r\n            backtracking::printMat<V>(mat, 9);\r\n            return true;\r\n        }\r\n\r\n        /// Crossed the last  Cell in the row\r\n        if (j == 9) {\r\n            return backtracking::solveSudoku<V>(mat, i + 1, 0);\r\n        }\r\n\r\n        /// Blue Cell - Skip\r\n        if (mat[i][j] != 0) {\r\n            return backtracking::solveSudoku<V>(mat, i, j + 1);\r\n        }\r\n        /// White Cell\r\n        /// Try to place every possible no\r\n        for (int no = 1; no <= 9; no++) {\r\n            if (backtracking::isPossible<V>(mat, i, j, no, 9)) {\r\n                /// Place the no - assuming solution aa jayega\r\n                mat[i][j] = no;\r\n                bool aageKiSolveHui = backtracking::solveSudoku<V>(mat, i, j + 1);\r\n                if (aageKiSolveHui) {\r\n                    return true;\r\n                }\r\n                /// Nahin solve hui\r\n                /// loop will place the next no.\r\n            }\r\n        }\r\n        /// Sare no try kr liey, kisi se bhi solve nahi hui\r\n        mat[i][j] = 0;\r\n        return false;\r\n    }\r\n} // namespace backtracking\r\n\r\n/**\r\n * Main function\r\n */\r\nint main() {\r\n    const int V = 9;\r\n    std::array <std::array <int, V>, V> mat = { \r\n        std::array <int, V> {5, 3, 0, 0, 7, 0, 0, 0, 0},\r\n        std::array <int, V> {6, 0, 0, 1, 9, 5, 0, 0, 0},\r\n        std::array <int, V> {0, 9, 8, 0, 0, 0, 0, 6, 0},\r\n        std::array <int, V> {8, 0, 0, 0, 6, 0, 0, 0, 3},\r\n        std::array <int, V> {4, 0, 0, 8, 0, 3, 0, 0, 1},\r\n        std::array <int, V> {7, 0, 0, 0, 2, 0, 0, 0, 6},\r\n        std::array <int, V> {0, 6, 0, 0, 0, 0, 2, 8, 0},\r\n        std::array <int, V> {0, 0, 0, 4, 1, 9, 0, 0, 5},\r\n        std::array <int, V> {0, 0, 0, 0, 8, 0, 0, 7, 9}\r\n    };\r\n\r\n    backtracking::printMat<V>(mat, 9);\r\n    std::cout << \"Solution \" << std::endl;\r\n    backtracking::solveSudoku<V>(mat, 0, 0);\r\n\r\n    return 0;\r\n}\r\n","index":8},{"title":"Ciphers","category":null,"id":"ciphers","index":9},{"title":"Caesar Cipher","category":"ciphers","id":"caesar_cipher_ciphers","algorithm":"/**\n * @file caesar_cipher.cpp\n * @brief Implementation of [Caesar cipher](https://en.wikipedia.org/wiki/Caesar_cipher) algorithm.\n *\n * @details\n * In cryptography, a Caesar cipher, also known as Caesar's cipher, the shift cipher, \n * Caesar's code or Caesar shift, is one of the simplest and most widely known encryption \n * techniques. It is a type of substitution cipher in which each letter in the plaintext \n * is replaced by a letter some fixed number of positions down the alphabet. For example, \n * with a left shift of 3, D would be replaced by A, E would become B, and so on. \n * The method is named after Julius Caesar, who used it in his private correspondence.\n *\n * ### Algorithm\n * The encryption can also be represented using modular arithmetic by first transforming \n * the letters into numbers, according to the scheme, A → 0, B → 1, ..., Z → 25.\n * Encryption of a letter x by a shift n can be described mathematically as,\n * \\f[ E(x) = (x + n)\\;\\mbox{mod}\\; 26\\f]\n * while decryption can be described as,\n * \\f[ D(x) = (x - n) \\;\\mbox{mod}\\; 26\\f]\n * \n * \\note This program implements caesar cipher for only uppercase English alphabet characters (i.e. A-Z). \n * \n * @author [Deep Raval](https://github.com/imdeep2905)\n */\n#include <iostream>\n#include <string>\n#include <cassert>\n\n/** \\namespace ciphers\n * \\brief Algorithms for encryption and decryption\n */\nnamespace ciphers {\n    /** \\namespace caesar\n     * \\brief Functions for [Caesar cipher](https://en.wikipedia.org/wiki/Caesar_cipher) algorithm.\n     */\n    namespace caesar {   \n        namespace {\n            /**\n             * This function finds character for given value (i.e.A-Z)\n             * @param x value for which we want character \n             * @returns  corresponding character for perticular value\n             */        \n            inline char get_char(const int x) {\n                // By adding 65 we are scaling 0-25 to 65-90. \n                // Which are in fact ASCII values of A-Z. \n                return char(x + 65); \n            }\n            /**\n             * This function finds value for given character (i.e.0-25)\n             * @param c character for which we want value\n             * @returns returns corresponding value for perticular character\n             */  \n            inline int get_value(const char c) {\n                // A-Z have ASCII values in range 65-90.\n                // Hence subtracting 65 will scale them to 0-25.\n                return int(c - 65);\n            }\n        } // Unnamed namespace\n        /**\n         * Encrypt given text using caesar cipher.\n         * @param text text to be encrypted\n         * @param shift number of shifts to be applied\n         * @returns new encrypted text\n         */\n        std::string encrypt (const std::string &text, const int &shift) {\n            std::string encrypted_text = \"\"; // Empty string to store encrypted text\n            for (char c : text) { // Going through each character\n                int place_value = get_value(c); // Getting value of character (i.e. 0-25)\n                place_value = (place_value + shift) % 26; // Applying encryption formula\n                char new_char = get_char(place_value); // Getting new character from new value (i.e. A-Z)\n                encrypted_text += new_char; // Appending encrypted character\n            }\n            return encrypted_text; // Returning encrypted text\n        }\n        /**\n         * Decrypt given text using caesar cipher.\n         * @param text text to be decrypted\n         * @param shift number of shifts to be applied\n         * @returns new decrypted text\n         */        \n        std::string decrypt (const std::string &text, const int &shift) {\n            std::string decrypted_text = \"\"; // Empty string to store decrypted text\n            for (char c : text) { // Going through each character\n                int place_value = get_value(c); // Getting value of character (i.e. 0-25)\n                place_value = (place_value - shift) % 26;// Applying decryption formula\n                if(place_value < 0) { // Handling case where remainder is negative \n                    place_value = place_value + 26;\n                }\n                char new_char = get_char(place_value); // Getting original character from decrypted value (i.e. A-Z)\n                decrypted_text += new_char; // Appending decrypted character\n            }\n            return decrypted_text; // Returning decrypted text\n        }\n    } // namespace caesar\n} // namespace ciphers\n\n/**\n * Function to test above algorithm\n */\nvoid test() {\n    // Test 1\n    std::string text1 = \"ALANTURING\";\n    std::string encrypted1 = ciphers::caesar::encrypt(text1, 17);\n    std::string decrypted1 = ciphers::caesar::decrypt(encrypted1, 17);\n    assert(text1 == decrypted1);\n    std::cout << \"Original text : \" << text1;\n    std::cout << \" , Encrypted text (with shift = 21) : \" << encrypted1;\n    std::cout << \" , Decrypted text : \"<< decrypted1 << std::endl;\n    // Test 2\n    std::string text2 = \"HELLOWORLD\";\n    std::string encrypted2 = ciphers::caesar::encrypt(text2, 1729);\n    std::string decrypted2 = ciphers::caesar::decrypt(encrypted2, 1729);\n    assert(text2 == decrypted2);\n    std::cout << \"Original text : \" << text2;\n    std::cout << \" , Encrypted text (with shift = 1729) : \" << encrypted2;\n    std::cout << \" , Decrypted text : \"<< decrypted2 << std::endl;\n}\n\n/** Driver Code */\nint main() {\n    // Testing\n    test();\n    return 0;\n}\n","index":10},{"title":"Hill Cipher","category":"ciphers","id":"hill_cipher_ciphers","algorithm":"/**\n * @file hill_cipher.cpp\n * @brief Implementation of [Hill\n * cipher](https://en.wikipedia.org/wiki/Hill_cipher) algorithm.\n *\n * Program to generate the encryption-decryption key and perform encryption and\n * decryption of ASCII text using the famous block cipher algorithm. This is a\n * powerful encryption algorithm that is relatively easy to implement with a\n * given key. The strength of the algorithm depends on the size of the block\n * encryption matrix key; the bigger the matrix, the stronger the encryption and\n * more difficult to break it. However, the important requirement for the matrix\n * is that:\n * 1. matrix should be invertible - all inversion conditions should be satisfied\n * and\n * 2. its determinant must not have any common factors with the length of\n * character set\n * Due to this restriction, most implementations only implement with small 3x3\n * encryption keys and a small subset of ASCII alphabets.\n *\n * In the current implementation, I present to you an implementation for\n * generating larger encryption keys (I have attempted upto 10x10) and an ASCII\n * character set of 97 printable characters. Hence, a typical ASCII text file\n * could be easily encrypted with the module. The larger character set increases\n * the modulo of cipher and hence the matrix determinants can get very large\n * very quickly rendering them ill-defined.\n *\n * \\note This program uses determinant computation using LU decomposition from\n * the file lu_decomposition.h\n * \\note The matrix generation algorithm is very rudimentary and does not\n * guarantee an invertible modulus matrix. \\todo Better matrix generation\n * algorithm.\n *\n * @author [Krishna Vedala](https://github.com/kvedala)\n */\n\n#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <string>\n#ifdef _OPENMP\n#include <omp.h>\n#endif\n\n#include \"../numerical_methods/lu_decomposition.h\"\n\n/**\n * operator to print a matrix\n */\ntemplate <typename T>\nstatic std::ostream &operator<<(std::ostream &out, matrix<T> const &v) {\n    const int width = 15;\n    const char separator = ' ';\n\n    for (size_t row = 0; row < v.size(); row++) {\n        for (size_t col = 0; col < v[row].size(); col++)\n            out << std::left << std::setw(width) << std::setfill(separator)\n                << v[row][col];\n        out << std::endl;\n    }\n\n    return out;\n}\n\n/** \\namespace ciphers\n * \\brief Algorithms for encryption and decryption\n */\nnamespace ciphers {\n/** dictionary of characters that can be encrypted and decrypted */\nstatic const char *STRKEY =\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789~!@#$%^&\"\n    \"*()_+`-=[]{}|;':\\\",./<>?\\\\\\r\\n \\0\";\n\n/**\n * @brief Implementation of [Hill\n * Cipher](https://en.wikipedia.org/wiki/Hill_cipher) algorithm\n */\nclass HillCipher {\n private:\n    /**\n     * @brief Function to generate a random integer in a given interval\n     *\n     * @param a lower limit of interval\n     * @param b upper limit of interval\n     * @tparam T type of output\n     * @return random integer in the interval \\f$[a,b)\\f$\n     */\n    template <typename T1, typename T2>\n    static const T2 rand_range(T1 a, T1 b) {\n        // generate random number between 0 and 1\n        long double r = static_cast<long double>(std::rand()) / RAND_MAX;\n\n        // scale and return random number as integer\n        return static_cast<T2>(r * (b - a) + a);\n    }\n\n    /**\n     * @brief Function overload to fill a matrix with random integers in a given\n     * interval\n     *\n     * @param M pointer to matrix to be filled with random numbers\n     * @param a lower limit of interval\n     * @param b upper limit of interval\n     * @tparam T1 type of input range\n     * @tparam T2 type of matrix\n     * @return determinant of generated random matrix\n     *\n     * @warning There will need to be a balance between the matrix size and the\n     * range of random numbers. If the matrix is large, the range of random\n     * numbers must be small to have a well defined keys. Or if the matrix is\n     * smaller, the random numbers range can be larger. For an 8x8 matrix, range\n     * should be no more than \\f$[0,10]\\f$\n     */\n    template <typename T1, typename T2>\n    static double rand_range(matrix<T2> *M, T1 a, T1 b) {\n        for (size_t i = 0; i < M->size(); i++) {\n            for (size_t j = 0; j < M[0][0].size(); j++) {\n                M[0][i][j] = rand_range<T1, T2>(a, b);\n            }\n        }\n\n        return determinant_lu(*M);\n    }\n\n    /**\n     * @brief Compute\n     * [GCD](https://en.wikipedia.org/wiki/Greatest_common_divisor) of two\n     * integers using Euler's algorithm\n     *\n     * @param a first number\n     * @param b second number\n     * @return GCD of \\f$a\\f$ and \\f$b\\f$\n     */\n    template <typename T>\n    static const T gcd(T a, T b) {\n        if (b > a)  // ensure always a < b\n            std::swap(a, b);\n\n        while (b != 0) {\n            T tmp = b;\n            b = a % b;\n            a = tmp;\n        }\n\n        return a;\n    }\n\n    /**\n     * @brief helper function to perform vector multiplication with encryption\n     * or decryption matrix\n     *\n     * @param vector vector to multiply\n     * @param key encryption or decryption key matrix\n     * @return corresponding encrypted or decrypted text\n     */\n    static const std::valarray<uint8_t> mat_mul(\n        const std::valarray<uint8_t> &vector, const matrix<int> &key) {\n        std::valarray<uint8_t> out(vector);  // make a copy\n\n        size_t L = std::strlen(STRKEY);\n\n        for (size_t i = 0; i < key.size(); i++) {\n            int tmp = 0;\n            for (size_t j = 0; j < vector.size(); j++) {\n                tmp += key[i][j] * vector[j];\n            }\n            out[i] = static_cast<uint8_t>(tmp % L);\n        }\n\n        return out;\n    }\n\n    /**\n     * @brief Get the character at a given index in the ::STRKEY\n     *\n     * @param idx index value\n     * @return character at the index\n     */\n    static inline char get_idx_char(const uint8_t idx) { return STRKEY[idx]; }\n\n    /**\n     * @brief Get the index of a character in the ::STRKEY\n     *\n     * @param ch character to search\n     * @return index of character\n     */\n    static inline uint8_t get_char_idx(const char ch) {\n        size_t L = std::strlen(STRKEY);\n\n        for (size_t idx = 0; idx <= L; idx++)\n            if (STRKEY[idx] == ch)\n                return idx;\n\n        std::cerr << __func__ << \":\" << __LINE__ << \": (\" << ch\n                  << \") Should not reach here!\\n\";\n        return 0;\n    }\n\n    /**\n     * @brief Convenience function to perform block cipher operations. The\n     * operations are identical for both encryption and decryption.\n     *\n     * @param text input text to encrypt or decrypt\n     * @param key key for encryption or decryption\n     * @return encrypted/decrypted output\n     */\n    static const std::string codec(const std::string &text,\n                                   const matrix<int> &key) {\n        size_t text_len = text.length();\n        size_t key_len = key.size();\n\n        // length of output string must be a multiple of key_len\n        // create output string and initialize with '\\0' character\n        size_t L2 = text_len % key_len == 0\n                        ? text_len\n                        : text_len + key_len - (text_len % key_len);\n        std::string coded_text(L2, '\\0');\n\n        // temporary array for batch processing\n        int i;\n#ifdef _OPENMP\n#pragma parallel omp for private(i)\n#endif\n        for (i = 0; i < L2 - key_len + 1; i += key_len) {\n            std::valarray<uint8_t> batch_int(key_len);\n            for (size_t j = 0; j < key_len; j++) {\n                batch_int[j] = get_char_idx(text[i + j]);\n            }\n\n            batch_int = mat_mul(batch_int, key);\n\n            for (size_t j = 0; j < key_len; j++) {\n                coded_text[i + j] =\n                    STRKEY[batch_int[j]];  // get character at key\n            }\n        }\n\n        return coded_text;\n    }\n\n    /**\n     * Get matrix inverse using Row-transformations. Given matrix must\n     * be a square and non-singular.\n     * \\returns inverse matrix\n     **/\n    template <typename T>\n    static matrix<double> get_inverse(matrix<T> const &A) {\n        // Assuming A is square matrix\n        size_t N = A.size();\n\n        matrix<double> inverse(N, std::valarray<double>(N));\n        for (size_t row = 0; row < N; row++) {\n            for (size_t col = 0; col < N; col++) {\n                // create identity matrix\n                inverse[row][col] = (row == col) ? 1.f : 0.f;\n            }\n        }\n\n        if (A.size() != A[0].size()) {\n            std::cerr << \"A must be a square matrix!\" << std::endl;\n            return inverse;\n        }\n\n        // preallocate a temporary matrix identical to A\n        matrix<double> temp(N, std::valarray<double>(N));\n        for (size_t row = 0; row < N; row++) {\n            for (size_t col = 0; col < N; col++)\n                temp[row][col] = static_cast<double>(A[row][col]);\n        }\n\n        // start transformations\n        for (size_t row = 0; row < N; row++) {\n            for (size_t row2 = row; row2 < N && temp[row][row] == 0; row2++) {\n                // this to ensure diagonal elements are not 0\n                temp[row] = temp[row] + temp[row2];\n                inverse[row] = inverse[row] + inverse[row2];\n            }\n\n            for (size_t col2 = row; col2 < N && temp[row][row] == 0; col2++) {\n                // this to further ensure diagonal elements are not 0\n                for (size_t row2 = 0; row2 < N; row2++) {\n                    temp[row2][row] = temp[row2][row] + temp[row2][col2];\n                    inverse[row2][row] =\n                        inverse[row2][row] + inverse[row2][col2];\n                }\n            }\n\n            if (temp[row][row] == 0) {\n                // Probably a low-rank matrix and hence singular\n                std::cerr << \"Low-rank matrix, no inverse!\" << std::endl;\n                return inverse;\n            }\n\n            // set diagonal to 1\n            double divisor = temp[row][row];\n            temp[row] = temp[row] / divisor;\n            inverse[row] = inverse[row] / divisor;\n            // Row transformations\n            for (size_t row2 = 0; row2 < N; row2++) {\n                if (row2 == row)\n                    continue;\n                double factor = temp[row2][row];\n                temp[row2] = temp[row2] - factor * temp[row];\n                inverse[row2] = inverse[row2] - factor * inverse[row];\n            }\n        }\n\n        return inverse;\n    }\n\n    static int modulo(int a, int b) {\n        int ret = a % b;\n        if (ret < 0)\n            ret += b;\n        return ret;\n    }\n\n public:\n    /**\n     * @brief Generate encryption matrix of a given size. Larger size matrices\n     * are difficult to generate but provide more security. Important conditions\n     * are:\n     * 1. matrix should be invertible\n     * 2. determinant must not have any common factors with the length of\n     * character key\n     * There is no head-fast way to generate hte matrix under the given\n     * numerical restrictions of the machine but the conditions added achieve\n     * the goals. Bigger the matrix, greater is the probability of the matrix\n     * being ill-defined.\n     *\n     * @param size size of matrix (typically \\f$\\text{size}\\le10\\f$)\n     * @param limit1 lower limit of range of random elements (default=0)\n     * @param limit2 upper limit of range of random elements (default=10)\n     * @return Encryption martix\n     */\n    static matrix<int> generate_encryption_key(size_t size, int limit1 = 0,\n                                               int limit2 = 10) {\n        matrix<int> encrypt_key(size, std::valarray<int>(size));\n        matrix<int> min_mat = encrypt_key;\n        int mat_determinant = -1;  // because matrix has only ints, the\n                                   // determinant will also be an int\n        int L = std::strlen(STRKEY);\n\n        double dd;\n        do {\n            // keeping the random number range smaller generates better\n            // defined matrices with more ease of cracking\n            dd = rand_range(&encrypt_key, limit1, limit2);\n            mat_determinant = static_cast<int>(dd);\n\n            if (mat_determinant < 0)\n                mat_determinant = (mat_determinant % L);\n        } while (std::abs(dd) > 1e3 ||  // while ill-defined\n                 dd < 0.1 ||  // while singular or negative determinant\n                 !std::isfinite(dd) ||  // while determinant is not finite\n                 gcd(mat_determinant, L) != 1);  // while no common factors\n        // std::cout <<\n\n        return encrypt_key;\n    }\n\n    /**\n     * @brief Generate decryption matrix from an encryption matrix key.\n     *\n     * @param encrypt_key encryption key for which to create a decrypt key\n     * @return Decryption martix\n     */\n    static matrix<int> generate_decryption_key(matrix<int> const &encrypt_key) {\n        size_t size = encrypt_key.size();\n        int L = std::strlen(STRKEY);\n\n        matrix<int> decrypt_key(size, std::valarray<int>(size));\n        int det_encrypt = static_cast<int>(determinant_lu(encrypt_key));\n\n        int mat_determinant = det_encrypt < 0 ? det_encrypt % L : det_encrypt;\n\n        matrix<double> tmp_inverse = get_inverse(encrypt_key);\n        double d2 = determinant_lu(decrypt_key);\n\n        // find co-prime factor for inversion\n        int det_inv = -1;\n        for (int i = 0; i < L; i++) {\n            if (modulo(mat_determinant * i, L) == 1) {\n                det_inv = i;\n                break;\n            }\n        }\n\n        if (det_inv == -1) {\n            std::cerr << \"Could not find a co-prime for inversion\\n\";\n            std::exit(EXIT_FAILURE);\n        }\n\n        mat_determinant = det_inv * det_encrypt;\n\n        // perform modular inverse of encryption matrix\n        int i;\n#ifdef _OPENMP\n#pragma parallel omp for private(i)\n#endif\n        for (i = 0; i < size; i++) {\n            for (int j = 0; j < size; j++) {\n                int temp = std::round(tmp_inverse[i][j] * mat_determinant);\n                decrypt_key[i][j] = modulo(temp, L);\n            }\n        }\n        return decrypt_key;\n    }\n\n    /**\n     * @brief Generate encryption and decryption key pair\n     *\n     * @param size size of matrix key (typically \\f$\\text{size}\\le10\\f$)\n     * @param limit1 lower limit of range of random elements (default=0)\n     * @param limit2 upper limit of range of random elements (default=10)\n     * @return std::pair<matrix<int>, matrix<int>> encryption and decryption\n     * keys as a pair\n     *\n     * @see ::generate_encryption_key\n     */\n    static std::pair<matrix<int>, matrix<int>> generate_keys(size_t size,\n                                                             int limit1 = 0,\n                                                             int limit2 = 10) {\n        matrix<int> encrypt_key = generate_encryption_key(size);\n        matrix<int> decrypt_key = generate_decryption_key(encrypt_key);\n        double det2 = determinant_lu(decrypt_key);\n        while (std::abs(det2) < 0.1 || std::abs(det2) > 1e3) {\n            encrypt_key = generate_encryption_key(size, limit1, limit2);\n            decrypt_key = generate_decryption_key(encrypt_key);\n            det2 = determinant_lu(decrypt_key);\n        }\n        return std::make_pair(encrypt_key, decrypt_key);\n    }\n\n    /**\n     * @brief Encrypt a given text using a given key\n     *\n     * @param text string to encrypt\n     * @param encrypt_key  key for encryption\n     * @return encrypted text\n     */\n    static const std::string encrypt_text(const std::string &text,\n                                          const matrix<int> &encrypt_key) {\n        return codec(text, encrypt_key);\n    }\n\n    /**\n     * @brief Decrypt a given text using a given key\n     *\n     * @param text string to decrypt\n     * @param decrypt_key  key for decryption\n     * @return decrypted text\n     */\n    static const std::string decrypt_text(const std::string &text,\n                                          const matrix<int> &decrypt_key) {\n        return codec(text, decrypt_key);\n    }\n};\n\n}  // namespace ciphers\n\n/**\n * @brief Self test 1 - using 3x3 randomly generated key\n *\n * @param text string to encrypt and decrypt\n */\nvoid test1(const std::string &text) {\n    // std::string text = \"Hello world!\";\n    std::cout << \"======Test 1 (3x3 key) ======\\nOriginal text:\\n\\t\" << text\n              << std::endl;\n\n    std::pair<matrix<int>, matrix<int>> p =\n        ciphers::HillCipher::generate_keys(3, 0, 100);\n    matrix<int> ekey = p.first;\n    matrix<int> dkey = p.second;\n\n    // matrix<int> ekey = {{22, 28, 25}, {5, 26, 15}, {14, 18, 9}};\n    // std::cout << \"Encryption key: \\n\" << ekey;\n    std::string gibberish = ciphers::HillCipher::encrypt_text(text, ekey);\n    std::cout << \"Encrypted text:\\n\\t\" << gibberish << std::endl;\n\n    // matrix<int> dkey = ciphers::HillCipher::generate_decryption_key(ekey);\n    // std::cout << \"Decryption key: \\n\" << dkey;\n    std::string txt_back = ciphers::HillCipher::decrypt_text(gibberish, dkey);\n    std::cout << \"Reconstruct text:\\n\\t\" << txt_back << std::endl;\n\n    std::ofstream out_file(\"hill_cipher_test1.txt\");\n    out_file << \"Block size: \" << ekey.size() << \"\\n\";\n    out_file << \"Encryption Key:\\n\" << ekey;\n    out_file << \"\\nDecryption Key:\\n\" << dkey;\n    out_file.close();\n\n    assert(txt_back == text);\n    std::cout << \"Passed :)\\n\";\n}\n\n/**\n * @brief Self test 2 - using 8x8 randomly generated key\n *\n * @param text string to encrypt and decrypt\n */\nvoid test2(const std::string &text) {\n    // std::string text = \"Hello world!\";\n    std::cout << \"======Test 2 (8x8 key) ======\\nOriginal text:\\n\\t\" << text\n              << std::endl;\n\n    std::pair<matrix<int>, matrix<int>> p =\n        ciphers::HillCipher::generate_keys(8, 0, 3);\n    matrix<int> ekey = p.first;\n    matrix<int> dkey = p.second;\n\n    std::string gibberish = ciphers::HillCipher::encrypt_text(text, ekey);\n    std::cout << \"Encrypted text:\\n\\t\" << gibberish << std::endl;\n\n    std::string txt_back = ciphers::HillCipher::decrypt_text(gibberish, dkey);\n    std::cout << \"Reconstruct text:\\n\\t\" << txt_back << std::endl;\n\n    std::ofstream out_file(\"hill_cipher_test2.txt\");\n    out_file << \"Block size: \" << ekey.size() << \"\\n\";\n    out_file << \"Encryption Key:\\n\" << ekey;\n    out_file << \"\\nDecryption Key:\\n\" << dkey;\n    out_file.close();\n\n    assert(txt_back.compare(0, text.size(), text) == 0);\n    std::cout << \"Passed :)\\n\";\n}\n\n/** Main function */\nint main() {\n    std::srand(std::time(nullptr));\n    std::cout << \"Key dictionary: (\" << std::strlen(ciphers::STRKEY) << \")\\n\\t\"\n              << ciphers::STRKEY << \"\\n\";\n\n    std::string text = \"This is a simple text with numb3r5 and exclamat!0n.\";\n\n    test1(text);\n    test2(text);\n\n    return 0;\n}\n","index":11},{"title":"Vigenere Cipher","category":"ciphers","id":"vigenere_cipher_ciphers","algorithm":"/**\n * @file vigenere_cipher.cpp\n * @brief Implementation of [Vigenère cipher](https://en.wikipedia.org/wiki/Vigen%C3%A8re_cipher) algorithm.\n *\n * @details\n * The Vigenère cipher is a method of encrypting alphabetic text by using a series of interwoven vigenere \n * ciphers, based on the letters of a keyword. It employs a form of polyalphabetic substitution. \n *\n * ### Algorithm\n * The encryption can also be represented using modular arithmetic by first transforming \n * the letters into numbers, according to the scheme, A → 0, B → 1, ..., Z → 25.\n * Encryption of \\f$i^{th}\\f$ character in Message M by key K can be described mathematically as,\n * \n * \\f[ E_{K}(M_{i}) = (M_{i} + K_{i})\\;\\mbox{mod}\\; 26\\f]\n * \n * while decryption of \\f$i^{th}\\f$ character in Cipher C by key K can be described mathematically as,\n *\n * \\f[ D_{k}(C_{i}) = (C_{i} - K_{i} + 26)\\;\\mbox{mod}\\; 26\\f]\n * \n * Where \\f$K_{i}\\f$ denotes corresponding character in key. If \\f$|key| < |text|\\f$ than\n * same key is repeated untill their lengths are equal.\n * \n * For Example,\n * If M = \"ATTACKATDAWN\" and K = \"LEMON\" than K becomes \"LEMONLEMONLE\".\n * \n * \\note Rather than creating new key of equal length this program does this by using modular index for key\n * (i.e. \\f$(j + 1) \\;\\mbox{mod}\\; |\\mbox{key}|\\f$)\n * \n * \\note This program implements Vigenère cipher for only uppercase English alphabet characters (i.e. A-Z). \n * \n * @author [Deep Raval](https://github.com/imdeep2905)\n */\n#include <iostream>\n#include <string>\n#include <cassert>\n\n/** \\namespace ciphers\n * \\brief Algorithms for encryption and decryption\n */\nnamespace ciphers {\n    /** \\namespace vigenere\n     * \\brief Functions for [vigenère cipher](https://en.wikipedia.org/wiki/Vigen%C3%A8re_cipher) algorithm.\n     */\n    namespace vigenere {   \n        namespace {\n            /**\n             * This function finds character for given value (i.e.A-Z)\n             * @param x value for which we want character \n             * @return  corresponding character for perticular value\n             */        \n            inline char get_char(const int x) {\n                // By adding 65 we are scaling 0-25 to 65-90. \n                // Which are in fact ASCII values of A-Z. \n                return char(x + 65); \n            }\n            /**\n             * This function finds value for given character (i.e.0-25)\n             * @param c character for which we want value\n             * @return returns corresponding value for perticular character\n             */  \n            inline int get_value(const char c) {\n                // A-Z have ASCII values in range 65-90.\n                // Hence subtracting 65 will scale them to 0-25.\n                return int(c - 65);\n            }\n        } // Unnamed namespace\n        /**\n         * Encrypt given text using vigenere cipher.\n         * @param text text to be encrypted\n         * @param key to be used for encryption\n         * @return new encrypted text\n         */\n        std::string encrypt (const std::string &text, const std::string &key) {\n            std::string encrypted_text = \"\"; // Empty string to store encrypted text\n            // Going through each character of text and key\n            // Note that key is visited in circular way hence  j = (j + 1) % |key|\n            for(size_t i = 0, j = 0; i < text.length(); i++, j = (j + 1) % key.length()) {\n                int place_value_text = get_value(text[i]); // Getting value of character in text\n                int place_value_key = get_value(key[j]); // Getting value of character in key\n                place_value_text = (place_value_text + place_value_key) % 26; // Applying encryption\n                char encrypted_char = get_char(place_value_text); // Getting new character from encrypted value\n                encrypted_text += encrypted_char; // Appending encrypted character\n            }\n            return encrypted_text; // Returning encrypted text\n        }\n        /**\n         * Decrypt given text using vigenere cipher.\n         * @param text text to be decrypted\n         * @param key key to be used for decryption\n         * @return new decrypted text\n         */        \n        std::string decrypt (const std::string &text, const std::string &key) {\n            // Going through each character of text and key\n            // Note that key is visited in circular way hence  j = (j + 1) % |key|\n            std::string decrypted_text = \"\"; // Empty string to store decrypted text\n            for(size_t i = 0, j = 0; i < text.length(); i++, j = (j + 1) % key.length()) {\n                int place_value_text = get_value(text[i]); // Getting value of character in text\n                int place_value_key = get_value(key[j]); // Getting value of character in key\n                place_value_text = (place_value_text - place_value_key + 26) % 26; // Applying decryption\n                char decrypted_char = get_char(place_value_text); // Getting new character from decrypted value\n                decrypted_text += decrypted_char; // Appending decrypted character\n            }        \n            return decrypted_text; // Returning decrypted text\n        }\n    } // namespace vigenere\n} // namespace ciphers\n\n/**\n * Function to test above algorithm\n */\nvoid test() {\n    // Test 1\n    std::string text1 = \"NIKOLATESLA\";\n    std::string encrypted1 = ciphers::vigenere::encrypt(text1, \"TESLA\");\n    std::string decrypted1 = ciphers::vigenere::decrypt(encrypted1, \"TESLA\");\n    assert(text1 == decrypted1);\n    std::cout << \"Original text : \" << text1;\n    std::cout << \" , Encrypted text (with key = TESLA) : \" << encrypted1;\n    std::cout << \" , Decrypted text : \"<< decrypted1 << std::endl;\n    // Test 2\n    std::string text2 = \"GOOGLEIT\";\n    std::string encrypted2 = ciphers::vigenere::encrypt(text2, \"REALLY\");\n    std::string decrypted2 = ciphers::vigenere::decrypt(encrypted2, \"REALLY\");\n    assert(text2 == decrypted2);\n    std::cout << \"Original text : \" << text2;\n    std::cout << \" , Encrypted text (with key = REALLY) : \" << encrypted2;\n    std::cout << \" , Decrypted text : \"<< decrypted2 << std::endl;\n}\n\n/** Driver Code */\nint main() {\n    // Testing\n    test();\n    return 0;\n}\n","index":12},{"title":"Xor Cipher","category":"ciphers","id":"xor_cipher_ciphers","algorithm":"/**\n * @file xor_cipher.cpp\n * @brief Implementation of [XOR cipher](https://en.wikipedia.org/wiki/XOR_cipher) algorithm.\n *\n * @details\n * In cryptography, the simple XOR cipher is a type of additive cipher, an encryption \n * algorithm that operates according to the principles: \n *\n * * \\f$A {\\oplus} 0 = A\\f$\n * * \\f$A {\\oplus} A = 0\\f$\n * * \\f$ (A {\\oplus} B) {\\oplus} C = A {\\oplus} (B {\\oplus} C)\\f$\n * * \\f$ (B {\\oplus} A) {\\oplus} B = B {\\oplus} 0 = B \\f$\n * \n * \n * where \\f$\\oplus\\f$ symbol denotes the exclusive disjunction (XOR) operation.\n * This operation is sometimes called modulus 2 addition (or subtraction, which is identical).\n * With this logic, a string of text can be encrypted by applying the bitwise XOR operator to\n * every character using a given key. To decrypt the output, merely reapplying the XOR function \n * with the key will remove the cipher.\n * \n * ### Algorithm\n * Choose the key for encryption and apply XOR operation to each character of a string. \n * Reapplying XOR operation to each character of encrypted string will give original string back.\n * \n * \\note This program implements XOR Cipher for string with ASCII characters. \n * \n * @author [Deep Raval](https://github.com/imdeep2905)\n */\n#include <iostream>\n#include <string>\n#include <cassert>\n\n/** \\namespace ciphers\n * \\brief Algorithms for encryption and decryption\n */\nnamespace ciphers {\n    /** \\namespace XOR\n     * \\brief Functions for [XOR cipher](https://en.wikipedia.org/wiki/XOR_cipher) algorithm.\n     */\n    namespace XOR {   \n        /**\n         * Encrypt given text using XOR cipher.\n         * @param text text to be encrypted\n         * @param key to be used for encyption\n         * @return new encrypted text\n         */\n        std::string encrypt (const std::string &text, const int &key) {\n            std::string encrypted_text = \"\"; // Empty string to store encrypted text\n            for (auto &c: text) { // Going through each character\n                char encrypted_char = char(c ^ key); // Applying encyption\n                encrypted_text += encrypted_char; // Appending encrypted character\n            }\n            return encrypted_text; // Returning encrypted text\n        }\n        /**\n         * Decrypt given text using XOR cipher.\n         * @param text text to be encrypted\n         * @param key to be used for decryption\n         * @return new decrypted text\n         */        \n        std::string decrypt (const std::string &text, const int &key) {\n            std::string decrypted_text = \"\"; // Empty string to store decrypted text\n            for (auto &c : text) { // Going through each character\n                char decrypted_char = char(c ^ key); // Applying decryption\n                decrypted_text += decrypted_char; // Appending decrypted character\n            }\n            return decrypted_text; // Returning decrypted text\n        }\n    } // namespace XOR\n} // namespace ciphers\n\n/**\n * Function to test above algorithm\n */\nvoid test() {\n    // Test 1\n    std::string text1 = \"Whipalsh! : Do watch this movie...\";\n    std::string encrypted1 = ciphers::XOR::encrypt(text1, 17);\n    std::string decrypted1 = ciphers::XOR::decrypt(encrypted1, 17);\n    assert(text1 == decrypted1);\n    std::cout << \"Original text : \" << text1;\n    std::cout << \" , Encrypted text (with key = 17) : \" << encrypted1;\n    std::cout << \" , Decrypted text : \"<< decrypted1 << std::endl;\n    // Test 2\n    std::string text2 = \"->Valar M0rghulis<-\";\n    std::string encrypted2 = ciphers::XOR::encrypt(text2, 29);\n    std::string decrypted2 = ciphers::XOR::decrypt(encrypted2, 29);\n    assert(text2 == decrypted2);\n    std::cout << \"Original text : \" << text2;\n    std::cout << \" , Encrypted text (with key = 29) : \" << encrypted2;\n    std::cout << \" , Decrypted text : \"<< decrypted2 << std::endl;\n}\n\n/** Driver Code */\nint main() {\n    // Testing\n    test();\n    return 0;\n}\n","index":13},{"title":"Data Structures","category":null,"id":"data_structures","index":14},{"title":"Avltree","category":"data_structures","id":"avltree_data_structures","algorithm":"/**\n * \\file\n * \\brief A simple tree implementation using nodes\n *\n * \\todo update code to use C++ STL library features and OO structure\n * \\warning This program is a poor implementation and does not utilize any of\n * the C++ STL features.\n */\n#include <algorithm>\n#include <iostream>\n#include <queue>\n\ntypedef struct node {\n    int data;\n    int height;\n    struct node *left;\n    struct node *right;\n} node;\n\n/** Create and return a new Node */\nnode *createNode(int data) {\n    node *nn = new node();\n    nn->data = data;\n    nn->height = 0;\n    nn->left = NULL;\n    nn->right = NULL;\n    return nn;\n}\n\n/** Returns height of tree */\nint height(node *root) {\n    if (root == NULL)\n        return 0;\n    return 1 + std::max(height(root->left), height(root->right));\n}\n\n/** Returns difference between height of left and right subtree */\nint getBalance(node *root) { return height(root->left) - height(root->right); }\n\n/** Returns Node after Right Rotation */\nnode *rightRotate(node *root) {\n    node *t = root->left;\n    node *u = t->right;\n    t->right = root;\n    root->left = u;\n    return t;\n}\n\n/** Returns Node after Left Rotation */\nnode *leftRotate(node *root) {\n    node *t = root->right;\n    node *u = t->left;\n    t->left = root;\n    root->right = u;\n    return t;\n}\n\n/** Returns node with minimum value in the tree */\nnode *minValue(node *root) {\n    if (root->left == NULL)\n        return root;\n    return minValue(root->left);\n}\n\n/** Balanced Insertion */\nnode *insert(node *root, int item) {\n    node *nn = createNode(item);\n    if (root == NULL)\n        return nn;\n    if (item < root->data)\n        root->left = insert(root->left, item);\n    else\n        root->right = insert(root->right, item);\n    int b = getBalance(root);\n    if (b > 1) {\n        if (getBalance(root->left) < 0)\n            root->left = leftRotate(root->left);  // Left-Right Case\n        return rightRotate(root);                 // Left-Left Case\n    } else if (b < -1) {\n        if (getBalance(root->right) > 0)\n            root->right = rightRotate(root->right);  // Right-Left Case\n        return leftRotate(root);                     // Right-Right Case\n    }\n    return root;\n}\n\n/** Balanced Deletion */\nnode *deleteNode(node *root, int key) {\n    if (root == NULL)\n        return root;\n    if (key < root->data)\n        root->left = deleteNode(root->left, key);\n    else if (key > root->data)\n        root->right = deleteNode(root->right, key);\n\n    else {\n        // Node to be deleted is leaf node or have only one Child\n        if (!root->right) {\n            node *temp = root->left;\n            delete (root);\n            root = NULL;\n            return temp;\n        } else if (!root->left) {\n            node *temp = root->right;\n            delete (root);\n            root = NULL;\n            return temp;\n        }\n        // Node to be deleted have both left and right subtrees\n        node *temp = minValue(root->right);\n        root->data = temp->data;\n        root->right = deleteNode(root->right, temp->data);\n    }\n    // Balancing Tree after deletion\n    return root;\n}\n\n/** LevelOrder (Breadth First Search) */\nvoid levelOrder(node *root) {\n    std::queue<node *> q;\n    q.push(root);\n    while (!q.empty()) {\n        root = q.front();\n        std::cout << root->data << \" \";\n        q.pop();\n        if (root->left)\n            q.push(root->left);\n        if (root->right)\n            q.push(root->right);\n    }\n}\n\n/** Main function */\nint main() {\n    // Testing AVL Tree\n    node *root = NULL;\n    int i;\n    for (i = 1; i <= 7; i++) root = insert(root, i);\n    std::cout << \"LevelOrder: \";\n    levelOrder(root);\n    root = deleteNode(root, 1);  // Deleting key with value 1\n    std::cout << \"\\nLevelOrder: \";\n    levelOrder(root);\n    root = deleteNode(root, 4);  // Deletin key with value 4\n    std::cout << \"\\nLevelOrder: \";\n    levelOrder(root);\n    return 0;\n}\n","index":15},{"title":"Binaryheap","category":"data_structures","id":"binaryheap_data_structures","algorithm":"/**\n * \\file\n * \\brief A C++ program to demonstrate common Binary Heap Operations\n */\n#include <climits>\n#include <iostream>\n#include <utility>\n\n/** A class for Min Heap */\nclass MinHeap {\n    int *harr;      ///< pointer to array of elements in heap\n    int capacity;   ///< maximum possible size of min heap\n    int heap_size;  ///< Current number of elements in min heap\n\n public:\n    /** Constructor: Builds a heap from a given array a[] of given size\n     * \\param[in] capacity initial heap capacity\n     */\n    explicit MinHeap(int cap) {\n        heap_size = 0;\n        capacity = cap;\n        harr = new int[cap];\n    }\n\n    /** to heapify a subtree with the root at given index */\n    void MinHeapify(int);\n\n    int parent(int i) { return (i - 1) / 2; }\n\n    /** to get index of left child of node at index i */\n    int left(int i) { return (2 * i + 1); }\n\n    /** to get index of right child of node at index i */\n    int right(int i) { return (2 * i + 2); }\n\n    /** to extract the root which is the minimum element */\n    int extractMin();\n\n    /** Decreases key value of key at index i to new_val */\n    void decreaseKey(int i, int new_val);\n\n    /** Returns the minimum key (key at root) from min heap */\n    int getMin() { return harr[0]; }\n\n    /** Deletes a key stored at index i */\n    void deleteKey(int i);\n\n    /** Inserts a new key 'k' */\n    void insertKey(int k);\n\n    ~MinHeap() { delete[] harr; }\n};\n\n// Inserts a new key 'k'\nvoid MinHeap::insertKey(int k) {\n    if (heap_size == capacity) {\n        std::cout << \"\\nOverflow: Could not insertKey\\n\";\n        return;\n    }\n\n    // First insert the new key at the end\n    heap_size++;\n    int i = heap_size - 1;\n    harr[i] = k;\n\n    // Fix the min heap property if it is violated\n    while (i != 0 && harr[parent(i)] > harr[i]) {\n        std::swap(harr[i], harr[parent(i)]);\n        i = parent(i);\n    }\n}\n\n/** Decreases value of key at index 'i' to new_val.  It is assumed that new_val\n * is smaller than harr[i].\n */\nvoid MinHeap::decreaseKey(int i, int new_val) {\n    harr[i] = new_val;\n    while (i != 0 && harr[parent(i)] > harr[i]) {\n        std::swap(harr[i], harr[parent(i)]);\n        i = parent(i);\n    }\n}\n\n// Method to remove minimum element (or root) from min heap\nint MinHeap::extractMin() {\n    if (heap_size <= 0)\n        return INT_MAX;\n    if (heap_size == 1) {\n        heap_size--;\n        return harr[0];\n    }\n\n    // Store the minimum value, and remove it from heap\n    int root = harr[0];\n    harr[0] = harr[heap_size - 1];\n    heap_size--;\n    MinHeapify(0);\n\n    return root;\n}\n\n/** This function deletes key at index i. It first reduced value to minus\n * infinite, then calls extractMin()\n */\nvoid MinHeap::deleteKey(int i) {\n    decreaseKey(i, INT_MIN);\n    extractMin();\n}\n\n/** A recursive method to heapify a subtree with the root at given index\n *  This method assumes that the subtrees are already heapified\n */\nvoid MinHeap::MinHeapify(int i) {\n    int l = left(i);\n    int r = right(i);\n    int smallest = i;\n    if (l < heap_size && harr[l] < harr[i])\n        smallest = l;\n    if (r < heap_size && harr[r] < harr[smallest])\n        smallest = r;\n    if (smallest != i) {\n        std::swap(harr[i], harr[smallest]);\n        MinHeapify(smallest);\n    }\n}\n\n// Driver program to test above functions\nint main() {\n    MinHeap h(11);\n    h.insertKey(3);\n    h.insertKey(2);\n    h.deleteKey(1);\n    h.insertKey(15);\n    h.insertKey(5);\n    h.insertKey(4);\n    h.insertKey(45);\n    std::cout << h.extractMin() << \" \";\n    std::cout << h.getMin() << \" \";\n    h.decreaseKey(2, 1);\n    std::cout << h.getMin();\n    return 0;\n}\n","index":16},{"title":"Binary Search Tree","category":"data_structures","id":"binary_search_tree_data_structures","algorithm":"/**\n * \\file\n * \\brief A simple tree implementation using structured nodes\n *\n * \\todo update code to use C++ STL library features and OO structure\n * \\warning This program is a poor implementation - C style - and does not\n * utilize any of the C++ STL features.\n */\n#include <iostream>\n\nstruct node {\n    int val;\n    node *left;\n    node *right;\n};\n\nstruct Queue {\n    node *t[100];\n    int front;\n    int rear;\n};\n\nQueue queue;\n\nvoid enqueue(node *n) { queue.t[queue.rear++] = n; }\n\nnode *dequeue() { return (queue.t[queue.front++]); }\n\nvoid Insert(node *n, int x) {\n    if (x < n->val) {\n        if (n->left == NULL) {\n            node *temp = new node;\n            temp->val = x;\n            temp->left = NULL;\n            temp->right = NULL;\n            n->left = temp;\n        } else {\n            Insert(n->left, x);\n        }\n    } else {\n        if (n->right == NULL) {\n            node *temp = new node;\n            temp->val = x;\n            temp->left = NULL;\n            temp->right = NULL;\n            n->right = temp;\n        } else {\n            Insert(n->right, x);\n        }\n    }\n}\n\nint findMaxInLeftST(node *n) {\n    while (n->right != NULL) {\n        n = n->right;\n    }\n    return n->val;\n}\n\nvoid Remove(node *p, node *n, int x) {\n    if (n->val == x) {\n        if (n->right == NULL && n->left == NULL) {\n            if (x < p->val) {\n                p->right = NULL;\n            } else {\n                p->left = NULL;\n            }\n        } else if (n->right == NULL) {\n            if (x < p->val) {\n                p->right = n->left;\n            } else {\n                p->left = n->left;\n            }\n        } else if (n->left == NULL) {\n            if (x < p->val) {\n                p->right = n->right;\n            } else {\n                p->left = n->right;\n            }\n        } else {\n            int y = findMaxInLeftST(n->left);\n            n->val = y;\n            Remove(n, n->right, y);\n        }\n    } else if (x < n->val) {\n        Remove(n, n->left, x);\n    } else {\n        Remove(n, n->right, x);\n    }\n}\n\nvoid BFT(node *n) {\n    if (n != NULL) {\n        std::cout << n->val << \"  \";\n        enqueue(n->left);\n        enqueue(n->right);\n        BFT(dequeue());\n    }\n}\n\nvoid Pre(node *n) {\n    if (n != NULL) {\n        std::cout << n->val << \"  \";\n        Pre(n->left);\n        Pre(n->right);\n    }\n}\n\nvoid In(node *n) {\n    if (n != NULL) {\n        In(n->left);\n        std::cout << n->val << \"  \";\n        In(n->right);\n    }\n}\n\nvoid Post(node *n) {\n    if (n != NULL) {\n        Post(n->left);\n        Post(n->right);\n        std::cout << n->val << \"  \";\n    }\n}\n\nint main() {\n    queue.front = 0;\n    queue.rear = 0;\n    int value;\n    int ch;\n    node *root = new node;\n    std::cout << \"\\nEnter the value of root node :\";\n    std::cin >> value;\n    root->val = value;\n    root->left = NULL;\n    root->right = NULL;\n    do {\n        std::cout << \"\\n1. Insert\"\n                  << \"\\n2. Delete\"\n                  << \"\\n3. Breadth First\"\n                  << \"\\n4. Preorder Depth First\"\n                  << \"\\n5. Inorder Depth First\"\n                  << \"\\n6. Postorder Depth First\";\n\n        std::cout << \"\\nEnter Your Choice : \";\n        std::cin >> ch;\n        int x;\n        switch (ch) {\n        case 1:\n            std::cout << \"\\nEnter the value to be Inserted : \";\n            std::cin >> x;\n            Insert(root, x);\n            break;\n        case 2:\n            std::cout << \"\\nEnter the value to be Deleted : \";\n            std::cin >> x;\n            Remove(root, root, x);\n            break;\n        case 3:\n            BFT(root);\n            break;\n        case 4:\n            Pre(root);\n            break;\n        case 5:\n            In(root);\n            break;\n        case 6:\n            Post(root);\n            break;\n        }\n    } while (ch != 0);\n\n    return 0;\n}\n","index":17},{"title":"Circular Queue Using Linked List","category":"data_structures","id":"circular_queue_using_linked_list_data_structures","algorithm":"#include <iostream>\n\nstruct node {\n    int data;\n    struct node *next;\n};\nclass Queue {\n    node *front;\n    node *rear;\n\n public:\n    Queue() {\n        front = NULL;\n        rear = NULL;\n    }\n    void createNode(int val) {\n        node *ptr;\n        node *nn;\n        nn = new node;\n        ptr = front;\n        nn->data = val;\n        nn->next = NULL;\n        front = nn;\n        rear = nn;\n    }\n    void enqueue(int val) {\n        if (front == NULL || rear == NULL) {\n            createNode(val);\n        } else {\n            node *ptr;\n            node *nn;\n            ptr = front;\n            nn = new node;\n            nn->data = val;\n            rear->next = nn;\n            nn->next = front;\n            rear = nn;\n        }\n    }\n    void dequeue() {\n        node *n;\n        n = front;\n        front = front->next;\n        delete (n);\n    }\n    void traverse() {\n        node *ptr;\n        ptr = front;\n        do {\n            std::cout << ptr->data << \" \";\n            ptr = ptr->next;\n        } while (ptr != rear->next);\n        std::cout << front->data << std::endl;\n    }\n};\nint main(void) {\n    Queue q;\n    q.enqueue(10);\n    q.enqueue(20);\n    q.enqueue(30);\n    q.enqueue(40);\n    q.enqueue(50);\n    q.enqueue(60);\n    q.enqueue(70);\n    q.traverse();\n    q.dequeue();\n    q.traverse();\n    return 0;\n}","index":18},{"title":"Cll","category":"data_structures","id":"cll","index":19},{"title":"Cll","category":"cll","id":"cll_cll","algorithm":"/*\n    A simple class for Cicular Linear Linked List\n*/\n#include \"cll.h\"\nusing namespace std;\n\n/* Constructor */\ncll::cll() {\n    head = NULL;\n    total = 0;\n}\n\ncll::~cll() { /* Desstructure, no need to fill */\n}\n\n/* Display a list. and total element */\nvoid cll::display() {\n    if (head == NULL)\n        cout << \"List is empty !\" << endl;\n    else {\n        cout << \"CLL list: \";\n        node *current = head;\n        for (int i = 0; i < total; i++) {\n            cout << current->data << \" -> \";\n            current = current->next;\n        }\n        cout << head->data << endl;\n        cout << \"Total element: \" << total << endl;\n    }\n}\n\n/* List insert a new value at head in list */\nvoid cll::insert_front(int new_data) {\n    node *newNode;\n    newNode = new node;\n    newNode->data = new_data;\n    newNode->next = NULL;\n    if (head == NULL) {\n        head = newNode;\n        head->next = head;\n    } else {\n        node *current = head;\n        while (current->next != head) {\n            current = current->next;\n        }\n        newNode->next = head;\n        current->next = newNode;\n        head = newNode;\n    }\n    total++;\n}\n\n/* List insert a new value at head in list */\nvoid cll::insert_tail(int new_data) {\n    node *newNode;\n    newNode = new node;\n    newNode->data = new_data;\n    newNode->next = NULL;\n    if (head == NULL) {\n        head = newNode;\n        head->next = head;\n    } else {\n        node *current = head;\n        while (current->next != head) {\n            current = current->next;\n        }\n        current->next = newNode;\n        newNode->next = head;\n    }\n    total++;\n}\n\n/* Get total element in list */\nint cll::get_size() { return total; }\n\n/* Return true if the requested item (sent in as an argument)\nis in the list, otherwise return false */\nbool cll::find_item(int item_to_find) {\n    if (head == NULL) {\n        cout << \"List is empty !\" << endl;\n        return false;\n    } else {\n        node *current = head;\n        while (current->next != head) {\n            if (current->data == item_to_find)\n                return true;\n            current = current->next;\n        }\n        return false;\n    }\n}\n\n/* Overloading method*/\nint cll::operator*() { return head->data; }\n\n/* Overload the pre-increment operator.\n   The iterator is advanced to the next node. */\nvoid cll::operator++() {\n    if (head == NULL) {\n        cout << \"List is empty !\" << endl;\n    } else {\n        node *current = head;\n        while (current->next != head) {\n            current = current->next;\n        }\n        current->next = head->next;\n        head = head->next;\n    }\n    total--;\n}\n","index":20},{"title":"Cll.h","category":"cll","id":"cll.h_cll","algorithm":"/*\n * Simple data structure CLL (Cicular Linear Linked List)\n * */\n#include <cctype>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n\n#ifndef CLL_H\n#define CLL_H\n/*The data structure is a linear linked list of integers */\nstruct node {\n    int data;\n    node* next;\n};\n\nclass cll {\n public:\n    cll(); /* Construct without parameter */\n    ~cll();\n    void display(); /* Show the list */\n\n    /******************************************************\n     * Useful method for list\n     *******************************************************/\n    void insert_front(int new_data);  /* Insert a new value at head  */\n    void insert_tail(int new_data);   /* Insert a new value at tail */\n    int get_size();                   /* Get total element in list */\n    bool find_item(int item_to_find); /* Find an item in list */\n\n    /******************************************************\n     * Overloading method for list\n     *******************************************************/\n    int operator*(); /* Returns the info contained in head */\n    /* Overload the pre-increment operator.\n       The iterator is advanced to the next node. */\n    void operator++();\n\n protected:\n    node* head;\n    int total; /* Total element in a list */\n};\n#endif\n","index":21},{"title":"Main Cll","category":"cll","id":"main_cll_cll","algorithm":"#include \"cll.h\"\nusing namespace std;\n\nint main() {\n    /* Test CLL */\n    cout << \"----------- Test construct -----------\" << endl;\n    cll list1;\n    list1.display();\n    cout << \"----------- Test insert front -----------\" << endl;\n    list1.insert_front(5);\n    cout << \"After insert 5 at front: \" << endl;\n    list1.display();\n    cout << \"After insert 10 3 7 at front: \" << endl;\n    list1.insert_front(10);\n    list1.insert_front(3);\n    list1.insert_front(7);\n    list1.display();\n    cout << \"----------- Test insert tail -----------\" << endl;\n    cout << \"After insert 18 19 20 at tail: \" << endl;\n    list1.insert_tail(18);\n    list1.insert_tail(19);\n    list1.insert_tail(20);\n    list1.display();\n    cout << \"----------- Test find item -----------\" << endl;\n    if (list1.find_item(10))\n        cout << \"PASS\" << endl;\n    else\n        cout << \"FAIL\" << endl;\n    if (!list1.find_item(30))\n        cout << \"PASS\" << endl;\n    else\n        cout << \"FAIL\" << endl;\n    cout << \"----------- Test * operator -----------\" << endl;\n    int value = *list1;\n    cout << \"Value at *list1: \" << value << endl;\n    cout << \"----------- Test ++ operator -----------\" << endl;\n    list1.display();\n    ++list1;\n    cout << \"After ++list1: \" << endl;\n    list1.display();\n\n    return 0;\n}\n","index":22},{"title":"Disjoint Set","category":"data_structures","id":"disjoint_set_data_structures","algorithm":"/**\n *\n * \\file\n * \\brief [Disjoint Sets Data Structure\n * (Disjoint Sets)](https://en.wikipedia.org/wiki/Disjoint-set_data_structure)\n *\n * \\author [leoyang429](https://github.com/leoyang429)\n *\n * \\details\n * A disjoint set data structure (also called union find or merge find set)\n * is a data structure that tracks a set of elements partitioned into a number\n * of disjoint (non-overlapping) subsets.\n * Some situations where disjoint sets can be used are-\n * to find connected components of a graph, kruskal's algorithm for finding\n * Minimum Spanning Tree etc.\n * There are two operation which we perform on disjoint sets -\n * 1) Union\n * 2) Find\n *\n */\n\n#include <iostream>\n#include <vector>\n\nusing std::cout;\nusing std::endl;\nusing std::vector;\n\nvector<int> root, rank;\n\n/**\n *\n * Function to create a set\n * @param n number of element\n *\n */\nvoid CreateSet(int n) {\n    root = vector<int>(n + 1);\n    rank = vector<int>(n + 1, 1);\n    for (int i = 1; i <= n; ++i) {\n        root[i] = i;\n    }\n}\n\n/**\n *\n * Find operation takes a number x and returns the set to which this number\n * belongs to.\n * @param x element of some set\n * @return set to which x belongs to\n *\n */\nint Find(int x) {\n    if (root[x] == x) {\n        return x;\n    }\n    return root[x] = Find(root[x]);\n}\n\n/**\n *\n * A utility function to check if x and y are from same set or not\n * @param x element of some set\n * @param y element of some set\n *\n */\nbool InSameUnion(int x, int y) { return Find(x) == Find(y); }\n\n/**\n *\n * Union operation combines two disjoint sets to make a single set\n * in this union function we pass two elements and check if they are\n * from different sets then combine those sets\n * @param x element of some set\n * @param y element of some set\n *\n */\nvoid Union(int x, int y) {\n    int a = Find(x), b = Find(y);\n    if (a != b) {\n        if (rank[a] < rank[b]) {\n            root[a] = b;\n        } else if (rank[a] > rank[b]) {\n            root[b] = a;\n        } else {\n            root[a] = b;\n            ++rank[b];\n        }\n    }\n}\n\n/** Main function */\nint main() {\n    // tests CreateSet & Find\n    int n = 100;\n    CreateSet(n);\n    for (int i = 1; i <= 100; ++i) {\n        if (root[i] != i) {\n            cout << \"Fail\" << endl;\n            break;\n        }\n    }\n    // tests InSameUnion & Union\n    cout << \"1 and 2 are initially not in the same subset\" << endl;\n    if (InSameUnion(1, 2)) {\n        cout << \"Fail\" << endl;\n    }\n    Union(1, 2);\n    cout << \"1 and 2 are now in the same subset\" << endl;\n    if (!InSameUnion(1, 2)) {\n        cout << \"Fail\" << endl;\n    }\n    return 0;\n}\n","index":23},{"title":"Doubly Linked List","category":"data_structures","id":"doubly_linked_list_data_structures","algorithm":"#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n\nstruct node {\n    int val;\n    node *prev;\n    node *next;\n} * start;\n\nclass double_linked_list {\n public:\n    double_linked_list() { start = NULL; }\n    void insert(int x);\n    void remove(int x);\n    void search(int x);\n    void show();\n    void reverseShow();\n};\n\nvoid double_linked_list::insert(int x) {\n    node *t = start;\n    if (start != NULL) {\n        while (t->next != NULL) {\n            t = t->next;\n        }\n        node *n = new node;\n        t->next = n;\n        n->prev = t;\n        n->val = x;\n        n->next = NULL;\n    } else {\n        node *n = new node;\n        n->val = x;\n        n->prev = NULL;\n        n->next = NULL;\n        start = n;\n    }\n}\n\nvoid double_linked_list::remove(int x) {\n    node *t = start;\n    while (t != NULL && t->val != x) {\n        t = t->next;\n    }\n    if (t == NULL) {\n        return;\n    }\n    if (t->prev == NULL) {\n        if (t->next == NULL) {\n            start = NULL;\n        } else {\n            start = t->next;\n            start->prev = NULL;\n        }\n    } else if (t->next == NULL) {\n        t->prev->next = NULL;\n    } else {\n        t->prev->next = t->next;\n        t->next->prev = t->prev;\n    }\n    delete t;\n}\n\nvoid double_linked_list::search(int x) {\n    node *t = start;\n    int found = 0;\n    while (t != NULL) {\n        if (t->val == x) {\n            std::cout << \"\\nFound\";\n            found = 1;\n            break;\n        }\n        t = t->next;\n    }\n    if (found == 0) {\n        std::cout << \"\\nNot Found\";\n    }\n}\n\nvoid double_linked_list::show() {\n    node *t = start;\n    while (t != NULL) {\n        std::cout << t->val << \"\\t\";\n        t = t->next;\n    }\n}\n\nvoid double_linked_list::reverseShow() {\n    node *t = start;\n    while (t != NULL && t->next != NULL) {\n        t = t->next;\n    }\n    while (t != NULL) {\n        std::cout << t->val << \"\\t\";\n        t = t->prev;\n    }\n}\n\nint main() {\n    int choice, x;\n    double_linked_list ob;\n    do {\n        std::cout << \"\\n1. Insert\";\n        std::cout << \"\\n2. Delete\";\n        std::cout << \"\\n3. Search\";\n        std::cout << \"\\n4. Forward print\";\n        std::cout << \"\\n5. Reverse print\";\n        std::cout << \"\\n\\nEnter you choice : \";\n        std::cin >> choice;\n        switch (choice) {\n        case 1:\n            std::cout << \"\\nEnter the element to be inserted : \";\n            std::cin >> x;\n            ob.insert(x);\n            break;\n        case 2:\n            std::cout << \"\\nEnter the element to be removed : \";\n            std::cin >> x;\n            ob.remove(x);\n            break;\n        case 3:\n            std::cout << \"\\nEnter the element to be searched : \";\n            std::cin >> x;\n            ob.search(x);\n            break;\n        case 4:\n            ob.show();\n            break;\n        case 5:\n            ob.reverseShow();\n            break;\n        }\n    } while (choice != 0);\n    return 0;\n}\n","index":24},{"title":"Linkedlist Implentation Usingarray","category":"data_structures","id":"linkedlist_implentation_usingarray_data_structures","algorithm":"/**\n * \\file\n * \\brief Linked list implementation using Arrays\n *\n * The difference between the pointer implementation of linked list and array\n * implementation of linked list:\n * 1. The NULL is represented by -1;\n * 2. Limited size. (in the following case it is 100 nodes at max). But we can\n * reuse the nodes that are to be deleted by again linking it bacj to the list.\n */\n\n#include <iostream>\n\nstruct Node {\n    int data;\n    int next;\n};\n\nNode AvailArray[100];  ///< array that will act as nodes of a linked list.\n\nint head = -1;\nint avail = 0;\nvoid initialise_list() {\n    for (int i = 0; i <= 98; i++) {\n        AvailArray[i].next = i + 1;\n    }\n    AvailArray[99].next = -1;  // indicating the end of the linked list.\n}\n\n/** This will return the index of the first free node present in the avail list\n */\nint getnode() {\n    int NodeIndexToBeReturned = avail;\n    avail = AvailArray[avail].next;\n    return NodeIndexToBeReturned;\n}\n\n/** This function when called will delete the node with\n * the index presented as an argument, and will put\n * back that node into the array.\n */\nvoid freeNode(int nodeToBeDeleted) {\n    AvailArray[nodeToBeDeleted].next = avail;\n    avail = nodeToBeDeleted;\n}\n\n/** The function will insert the given data\n * into the front of the linked list.\n */\nvoid insertAtTheBeginning(int data) {\n    int newNode = getnode();\n    AvailArray[newNode].data = data;\n    AvailArray[newNode].next = head;\n    head = newNode;\n}\n\nvoid insertAtTheEnd(int data) {\n    int newNode = getnode();\n    int temp = head;\n    while (AvailArray[temp].next != -1) {\n        temp = AvailArray[temp].next;\n    }\n    // temp is now pointing to the end node.\n    AvailArray[newNode].data = data;\n    AvailArray[newNode].next = -1;\n    AvailArray[temp].next = newNode;\n}\n\nvoid display() {\n    int temp = head;\n    while (temp != -1) {\n        std::cout << AvailArray[temp].data << \"->\";\n        temp = AvailArray[temp].next;\n    }\n    std::cout << \"-1\" << std::endl;\n}\n\n/** Main function */\nint main() {\n    initialise_list();\n    int x, y, z;\n    for (;;) {\n        std::cout << \"1. Insert At The Beginning\" << std::endl;\n        std::cout << \"2. Insert At The End\" << std::endl;\n        std::cout << \"3. Display\" << std::endl;\n        std::cout << \"4.Exit\" << std::endl;\n        std::cout << \"Enter Your choice\" << std::endl;\n        std::cin >> z;\n        switch (z) {\n        case 1:\n            std::cout << \"Enter the number you want to enter\" << std::endl;\n            std::cin >> x;\n            insertAtTheBeginning(x);\n            break;\n        case 2:\n            std::cout << \"Enter the number you want to enter\" << std::endl;\n            std::cin >> y;\n            insertAtTheEnd(y);\n            break;\n        case 3:\n            std::cout\n                << \"The linked list contains the following element in order\"\n                << std::endl;\n            display();\n            break;\n        case 4:\n            return 0;\n        default:\n            std::cout << \"The entered choice is not correct\" << std::endl;\n        }\n    }\n\n    return 0;\n}\n","index":25},{"title":"Linked List","category":"data_structures","id":"linked_list_data_structures","algorithm":"#include <iostream>\n\nstruct node {\n    int val;\n    node *next;\n};\n\nnode *start;\n\nvoid insert(int x) {\n    node *t = start;\n    node *n = new node;\n    n->val = x;\n    n->next = NULL;\n    if (start != NULL) {\n        while (t->next != NULL) {\n            t = t->next;\n        }\n        t->next = n;\n    } else {\n        start = n;\n    }\n}\n\nvoid remove(int x) {\n    if (start == NULL) {\n        std::cout << \"\\nLinked List is empty\\n\";\n        return;\n    } else if (start->val == x) {\n        node *temp = start;\n        start = start->next;\n        delete temp;\n        return;\n    }\n\n    node *temp = start, *parent = start;\n\n    while (temp != NULL && temp->val != x) {\n        parent = temp;\n        temp = temp->next;\n    }\n\n    if (temp == NULL) {\n        std::cout << std::endl << x << \" not found in list\\n\";\n        return;\n    }\n\n    parent->next = temp->next;\n    delete temp;\n}\n\nvoid search(int x) {\n    node *t = start;\n    int found = 0;\n    while (t != NULL) {\n        if (t->val == x) {\n            std::cout << \"\\nFound\";\n            found = 1;\n            break;\n        }\n        t = t->next;\n    }\n    if (found == 0) {\n        std::cout << \"\\nNot Found\";\n    }\n}\n\nvoid show() {\n    node *t = start;\n    while (t != NULL) {\n        std::cout << t->val << \"\\t\";\n        t = t->next;\n    }\n}\n\nvoid reverse() {\n    node *first = start;\n    if (first != NULL) {\n        node *second = first->next;\n        while (second != NULL) {\n            node *tem = second->next;\n            second->next = first;\n            first = second;\n            second = tem;\n        }\n        start->next = NULL;\n        start = first;\n    } else {\n        std::cout << \"\\nEmpty list\";\n    }\n}\n\nint main() {\n    int choice, x;\n    do {\n        std::cout << \"\\n1. Insert\";\n        std::cout << \"\\n2. Delete\";\n        std::cout << \"\\n3. Search\";\n        std::cout << \"\\n4. Print\";\n        std::cout << \"\\n5. Reverse\";\n        std::cout << \"\\n0. Exit\";\n        std::cout << \"\\n\\nEnter you choice : \";\n        std::cin >> choice;\n        switch (choice) {\n        case 1:\n            std::cout << \"\\nEnter the element to be inserted : \";\n            std::cin >> x;\n            insert(x);\n            break;\n        case 2:\n            std::cout << \"\\nEnter the element to be removed : \";\n            std::cin >> x;\n            remove(x);\n            break;\n        case 3:\n            std::cout << \"\\nEnter the element to be searched : \";\n            std::cin >> x;\n            search(x);\n            break;\n        case 4:\n            show();\n            std::cout << \"\\n\";\n            break;\n        case 5:\n            std::cout << \"The reversed list: \\n\";\n            reverse();\n            show();\n            std::cout << \"\\n\";\n            break;\n        }\n    } while (choice != 0);\n\n    return 0;\n}\n","index":26},{"title":"List Array","category":"data_structures","id":"list_array_data_structures","algorithm":"/**\n * @file list_array.cpp\n * @todo Add documentation\n * @warning The sorting algorithm is erroneous\n */\n#include <iostream>\n\nstruct list {\n    int data[50];\n    int top = 0;\n    bool isSorted = false;\n\n    int BinarySearch(int *array, int first, int last, int x) {\n        if (last < first) {\n            return -1;\n        }\n        int mid = (first + last) / 2;\n        if (array[mid] == x)\n            return mid;\n        else if (x < array[mid])\n            return (BinarySearch(array, first, mid - 1, x));\n        else if (x > array[mid])\n            return (BinarySearch(array, mid + 1, last, x));\n\n        std::cerr << __func__ << \":\" << __LINE__ << \": Undefined condition\\n\";\n        return -1;\n    }\n\n    int LinarSearch(int *array, int x) {\n        for (int i = 0; i < top; i++) {\n            if (array[i] == x) {\n                return i;\n            }\n        }\n\n        return -1;\n    }\n\n    int Search(int x) {\n        int pos = -1;\n\n        if (isSorted) {\n            pos = BinarySearch(data, 0, top - 1, x);\n        } else {\n            pos = LinarSearch(data, x);\n        }\n\n        if (pos != -1) {\n            std::cout << \"\\nElement found at position : \" << pos;\n        } else {\n            std::cout << \"\\nElement not found\";\n        }\n        return pos;\n    }\n\n    void Sort() {\n        int i, j, pos;\n        for (i = 0; i < top; i++) {\n            int min = data[i];\n            for (j = i + 1; j < top; j++) {\n                if (data[j] < min) {\n                    pos = j;\n                    min = data[pos];\n                }\n            }\n\n            int temp = data[i];\n            data[i] = data[pos];\n            data[pos] = temp;\n        }\n        isSorted = true;\n    }\n\n    void insert(int x) {\n        if (!isSorted) {\n            if (top == 49) {\n                std::cout << \"\\nOverflow\";\n            } else {\n                data[top] = x;\n                top++;\n            }\n        } else {\n            int pos = 0;\n\n            for (int i = 0; i < top - 1; i++) {\n                if (data[i] <= x && x <= data[i + 1]) {\n                    pos = i + 1;\n                    break;\n                }\n            }\n            if (pos == 0) {\n                pos = top - 1;\n            }\n\n            for (int i = top; i > pos; i--) {\n                data[i] = data[i - 1];\n            }\n            top++;\n            data[pos] = x;\n        }\n    }\n\n    void Remove(int x) {\n        int pos = Search(x);\n        std::cout << \"\\n\" << data[pos] << \" deleted\";\n        for (int i = pos; i < top; i++) {\n            data[i] = data[i + 1];\n        }\n        top--;\n    }\n\n    void Show() {\n        for (int i = 0; i < top; i++) {\n            std::cout << data[i] << \"\\t\";\n        }\n    }\n};\n\nint main() {\n    list L;\n    int choice;\n    int x;\n    do {\n        std::cout << \"\\n1.Insert\";\n        std::cout << \"\\n2.Delete\";\n        std::cout << \"\\n3.Search\";\n        std::cout << \"\\n4.Sort\";\n        std::cout << \"\\n5.Print\";\n        std::cout << \"\\n\\nEnter Your Choice : \";\n        std::cin >> choice;\n        switch (choice) {\n        case 1:\n            std::cout << \"\\nEnter the element to be inserted : \";\n            std::cin >> x;\n            L.insert(x);\n            break;\n        case 2:\n            std::cout << \"\\nEnter the element to be removed : \";\n            std::cin >> x;\n            L.Remove(x);\n            break;\n        case 3:\n            std::cout << \"\\nEnter the element to be searched : \";\n            std::cin >> x;\n            L.Search(x);\n            break;\n        case 4:\n            L.Sort();\n            break;\n        case 5:\n            L.Show();\n            break;\n        }\n    } while (choice != 0);\n    return 0;\n}\n","index":27},{"title":"Morrisinorder","category":"data_structures","id":"morrisinorder_data_structures","algorithm":"#include <iostream>\n#include <queue>\n\n/**************************\n    @author shrutisheoran\n**************************/\n\nusing namespace std;\n\nstruct Btree {\n    int data;\n    struct Btree *left;   // Pointer to left subtree\n    struct Btree *right;  // Pointer to right subtree\n};\n\nvoid insert(Btree **root, int d) {\n    Btree *nn = new Btree();  // Creating new node\n    nn->data = d;\n    nn->left = NULL;\n    nn->right = NULL;\n    if (*root == NULL) {\n        *root = nn;\n        return;\n    } else {\n        queue<Btree *> q;\n        // Adding root node to queue\n        q.push(*root);\n        while (!q.empty()) {\n            Btree *node = q.front();\n            // Removing parent node from queue\n            q.pop();\n            if (node->left)\n                // Adding left child of removed node to queue\n                q.push(node->left);\n            else {\n                // Adding new node if no left child is present\n                node->left = nn;\n                return;\n            }\n            if (node->right)\n                // Adding right child of removed node to queue\n                q.push(node->right);\n            else {\n                // Adding new node if no right child is present\n                node->right = nn;\n                return;\n            }\n        }\n    }\n}\n\nvoid morrisInorder(Btree *root) {\n    Btree *curr = root;\n    Btree *temp;\n    while (curr) {\n        if (curr->left == NULL) {\n            cout << curr->data << \" \";\n            // If left of current node is NULL then curr is shifted to right\n            curr = curr->right;\n        } else {\n            // Left of current node is stored in temp\n            temp = curr->left;\n            // Moving to extreme right of temp\n            while (temp->right && temp->right != curr) temp = temp->right;\n            // If extreme right is null it is made to point to currrent node\n            // (will be used for backtracking)\n            if (temp->right == NULL) {\n                temp->right = curr;\n                // current node is made to point its left subtree\n                curr = curr->left;\n            }\n            // If extreme right already points to currrent node it it set to\n            // null\n            else if (temp->right == curr) {\n                cout << curr->data << \" \";\n                temp->right = NULL;\n                // current node is made to point its right subtree\n                curr = curr->right;\n            }\n        }\n    }\n}\n\nint main() {\n    // Testing morrisInorder funtion\n    Btree *root = NULL;\n    int i;\n    for (i = 1; i <= 7; i++) insert(&root, i);\n    cout << \"Morris Inorder: \";\n    morrisInorder(root);\n    return 0;\n}\n","index":28},{"title":"Queue.h","category":"data_structures","id":"queue.h_data_structures","algorithm":"/* This class specifies the basic operation on a queue as a linked list */\n#ifndef DATA_STRUCTURES_QUEUE_H_\n#define DATA_STRUCTURES_QUEUE_H_\n\n#include <cassert>\n#include <iostream>\n\n/** Definition of the node */\ntemplate <class Kind>\nstruct node {\n    Kind data;\n    node<Kind> *next;\n};\n\n/** Definition of the queue class */\ntemplate <class Kind>\nclass queue {\n public:\n    /** Show queue */\n    void display() {\n        node<Kind> *current = queueFront;\n        std::cout << \"Front --> \";\n        while (current != NULL) {\n            std::cout << current->data << \"    \";\n            current = current->next;\n        }\n        std::cout << std::endl;\n        std::cout << \"Size of queue: \" << size << std::endl;\n    }\n\n    /** Default constructor*/\n    queue() {\n        queueFront = NULL;\n        queueRear = NULL;\n        size = 0;\n    }\n\n    /** Destructor */\n    ~queue() {}\n\n    /** Determine whether the queue is empty */\n    bool isEmptyQueue() { return (queueFront == NULL); }\n\n    /** Add new item to the queue */\n    void enQueue(Kind item) {\n        node<Kind> *newNode;\n        newNode = new node<Kind>;\n        newNode->data = item;\n        newNode->next = NULL;\n        if (queueFront == NULL) {\n            queueFront = newNode;\n            queueRear = newNode;\n        } else {\n            queueRear->next = newNode;\n            queueRear = queueRear->next;\n        }\n        size++;\n    }\n\n    /** Return the first element of the queue */\n    Kind front() {\n        assert(queueFront != NULL);\n        return queueFront->data;\n    }\n\n    /** Remove the top element of the queue */\n    void deQueue() {\n        node<Kind> *temp;\n        if (!isEmptyQueue()) {\n            temp = queueFront;\n            queueFront = queueFront->next;\n            delete temp;\n            size--;\n        } else {\n            std::cout << \"Queue is empty !\" << std::endl;\n        }\n    }\n\n    /** Clear queue */\n    void clear() { queueFront = NULL; }\n\n private:\n    node<Kind> *queueFront; /**< Pointer to the front of the queue */\n    node<Kind> *queueRear;  /**< Pointer to the rear of the queue  */\n    int size;\n};\n\n#endif  // DATA_STRUCTURES_QUEUE_H_\n","index":29},{"title":"Queue Using Array","category":"data_structures","id":"queue_using_array_data_structures","algorithm":"/*\n    Write a program to implement Linear Queue using array.\n\n    Functions to implement\n        Enqueue (Insertion)\n        Dequeue (Deletion)\n\n*/\n#include <iostream>\n\n#define MAXSIZE 10\n\nclass Queue_Array {\n    int front;\n    int rear;\n    int size;\n\n public:\n    Queue_Array() {\n        front = -1;\n        rear = -1;\n        size = MAXSIZE;\n    }\n    int *arr = new int[size];\n    void enqueue(int);\n    int dequeue();\n    void display();\n};\n\nvoid Queue_Array::enqueue(int ele) {\n    if (rear == size - 1) {\n        std::cout << \"\\nStack is full\";\n    } else if (front == -1 && rear == -1) {\n        front = rear = 0;\n        arr[rear] = ele;\n    } else if (rear < size) {\n        rear++;\n        arr[rear] = ele;\n    }\n}\n\nint Queue_Array::dequeue() {\n    int d;\n    if (front == -1) {\n        std::cout << \"\\nstack is empty \";\n        return 0;\n    } else if (front == rear) {\n        d = arr[front];\n        front = rear = -1;\n    } else {\n        d = arr[front++];\n    }\n\n    return d;\n}\n\nvoid Queue_Array::display() {\n    if (front == -1) {\n        std::cout << \"\\nStack is empty\";\n    } else {\n        for (int i = front; i <= rear; i++) std::cout << arr[i] << \" \";\n    }\n}\n\nint main() {\n    int op, data;\n\n    Queue_Array ob;\n\n    std::cout << \"\\n1. enqueue(Insertion) \";\n    std::cout << \"\\n2. dequeue(Deletion)\";\n    std::cout << \"\\n3. Display\";\n    std::cout << \"\\n4. Exit\";\n    while (1) {\n        std::cout << \"\\nEnter your choice \";\n        std::cin >> op;\n        if (op == 1) {\n            std::cout << \"Enter data  \";\n            std::cin >> data;\n            ob.enqueue(data);\n        } else if (op == 2) {\n            data = ob.dequeue();\n            std::cout << \"\\ndequeue element is:\\t\" << data;\n        } else if (op == 3) {\n            ob.display();\n        } else if (op == 4) {\n            exit(0);\n        } else {\n            std::cout << \"\\nWrong choice \";\n        }\n    }\n}\n","index":30},{"title":"Queue Using Array2","category":"data_structures","id":"queue_using_array2_data_structures","algorithm":"#include <iostream>\nusing namespace std;\n\nint queue[10];\nint front = 0;\nint rear = 0;\n\nvoid Enque(int x) {\n    if (rear == 10) {\n        cout << \"\\nOverflow\";\n    } else {\n        queue[rear++] = x;\n    }\n}\n\nvoid Deque() {\n    if (front == rear) {\n        cout << \"\\nUnderflow\";\n    }\n\n    else {\n        cout << \"\\n\" << queue[front++] << \" deleted\";\n        for (int i = front; i < rear; i++) {\n            queue[i - front] = queue[i];\n        }\n        rear = rear - front;\n        front = 0;\n    }\n}\n\nvoid show() {\n    for (int i = front; i < rear; i++) {\n        cout << queue[i] << \"\\t\";\n    }\n}\n\nint main() {\n    int ch, x;\n    do {\n        cout << \"\\n1. Enque\";\n        cout << \"\\n2. Deque\";\n        cout << \"\\n3. Print\";\n        cout << \"\\nEnter Your Choice : \";\n        cin >> ch;\n        if (ch == 1) {\n            cout << \"\\nInsert : \";\n            cin >> x;\n            Enque(x);\n        } else if (ch == 2) {\n            Deque();\n        } else if (ch == 3) {\n            show();\n        }\n    } while (ch != 0);\n\n    return 0;\n}\n","index":31},{"title":"Queue Using Linkedlist","category":"data_structures","id":"queue_using_linkedlist_data_structures","algorithm":"/*\n    Write a program to implement Queue using linkedlist.\n*/\n#include <iostream>\n\nstruct linkedlist {\n    int data;\n    linkedlist *next;\n};\nclass stack_linkedList {\n public:\n    linkedlist *front;\n    linkedlist *rear;\n\n    stack_linkedList() { front = rear = NULL; }\n    void enqueue(int);\n    int dequeue();\n    void display();\n};\nvoid stack_linkedList::enqueue(int ele) {\n    linkedlist *temp = new linkedlist();\n    temp->data = ele;\n    temp->next = NULL;\n\n    if (front == NULL)\n        front = rear = temp;\n    else {\n        rear->next = temp;\n        rear = temp;\n    }\n}\nint stack_linkedList::dequeue() {\n    linkedlist *temp;\n    int ele;\n    if (front == NULL)\n        std::cout << \"\\nStack is empty\";\n    else {\n        temp = front;\n        ele = temp->data;\n        if (front == rear)  // if length of queue is 1;\n            rear = rear->next;\n        front = front->next;\n        delete (temp);\n    }\n    return ele;\n}\nvoid stack_linkedList::display() {\n    if (front == NULL)\n        std::cout << \"\\nStack is empty\";\n\n    else {\n        linkedlist *temp;\n        temp = front;\n        while (temp != NULL) {\n            std::cout << temp->data << \" \";\n            temp = temp->next;\n        }\n    }\n}\n\nint main() {\n    int op, data;\n    stack_linkedList ob;\n    std::cout << \"\\n1. enqueue(Insertion) \";\n    std::cout << \"\\n2. dequeue(Deletion)\";\n    std::cout << \"\\n3. Display\";\n    std::cout << \"\\n4. Exit\";\n\n    while (1) {\n        std::cout << \"\\nEnter your choice \";\n        std::cin >> op;\n        if (op == 1) {\n            std::cout << \"Enter data \";\n            std::cin >> data;\n            ob.enqueue(data);\n        } else if (op == 2)\n            data = ob.dequeue();\n        else if (op == 3)\n            ob.display();\n        else if (op == 4)\n            exit(0);\n        else\n            std::cout << \"\\nWrong choice \";\n    }\n    return 0;\n}\n","index":32},{"title":"Queue Using Linked List","category":"data_structures","id":"queue_using_linked_list_data_structures","algorithm":"#include <iostream>\nusing namespace std;\n\nstruct node {\n    int val;\n    node *next;\n};\n\nnode *front, *rear;\n\nvoid Enque(int x) {\n    if (rear == NULL) {\n        node *n = new node;\n        n->val = x;\n        n->next = NULL;\n        rear = n;\n        front = n;\n    }\n\n    else {\n        node *n = new node;\n        n->val = x;\n        n->next = NULL;\n        rear->next = n;\n        rear = n;\n    }\n}\n\nvoid Deque() {\n    if (rear == NULL && front == NULL) {\n        cout << \"\\nUnderflow\";\n    } else {\n        node *t = front;\n        cout << \"\\n\" << t->val << \" deleted\";\n        front = front->next;\n        delete t;\n        if (front == NULL)\n            rear = NULL;\n    }\n}\n\nvoid show() {\n    node *t = front;\n    while (t != NULL) {\n        cout << t->val << \"\\t\";\n        t = t->next;\n    }\n}\n\nint main() {\n    int ch, x;\n    do {\n        cout << \"\\n1. Enque\";\n        cout << \"\\n2. Deque\";\n        cout << \"\\n3. Print\";\n        cout << \"\\nEnter Your Choice : \";\n        cin >> ch;\n        if (ch == 1) {\n            cout << \"\\nInsert : \";\n            cin >> x;\n            Enque(x);\n        } else if (ch == 2) {\n            Deque();\n        } else if (ch == 3) {\n            show();\n        }\n    } while (ch != 0);\n\n    return 0;\n}\n","index":33},{"title":"Queue Using Two Stacks","category":"data_structures","id":"queue_using_two_stacks_data_structures","algorithm":"/**\n * @author [shoniavika](https://github.com/shoniavika)\n * @file\n *\n * Implementation of a Queue using two Stacks.\n */\n\n#include <cassert>\n#include <iostream>\n#include <stack>\n\nnamespace {\n/**\n * @brief Queue data structure. Stores elements in FIFO\n * (first-in-first-out) manner.\n * @tparam T datatype to store in the queue\n */\ntemplate <typename T>\nclass MyQueue {\n private:\n    std::stack<T> s1, s2;\n\n public:\n    /**\n     * Constructor for queue.\n     */\n    MyQueue() = default;\n\n    /**\n     * Pushes x to the back of queue.\n     */\n    void push(T x);\n\n    /**\n     * Removes an element from the front of the queue.\n     */\n    const T& pop();\n\n    /**\n     * Returns first element, without removing it.\n     */\n    const T& peek() const;\n\n    /**\n     * Returns whether the queue is empty.\n     */\n    bool empty() const;\n};\n\n/**\n * Appends element to the end of the queue\n */\ntemplate <typename T>\nvoid MyQueue<T>::push(T x) {\n    while (!s2.empty()) {\n        s1.push(s2.top());\n        s2.pop();\n    }\n    s2.push(x);\n    while (!s1.empty()) {\n        s2.push(s1.top());\n        s1.pop();\n    }\n}\n\n/**\n * Removes element from the front of the queue\n */\ntemplate <typename T>\nconst T& MyQueue<T>::pop() {\n    const T& temp = MyQueue::peek();\n    s2.pop();\n    return temp;\n}\n\n/**\n * Returns element in the front.\n * Does not remove it.\n */\ntemplate <typename T>\nconst T& MyQueue<T>::peek() const {\n    if (!empty()) {\n        return s2.top();\n    }\n    std::cerr << \"Queue is empty\" << std::endl;\n    exit(0);\n}\n\n/**\n * Checks whether a queue is empty\n */\ntemplate <typename T>\nbool MyQueue<T>::empty() const {\n    return s2.empty() && s1.empty();\n}\n}  // namespace\n\n/**\n * Testing function\n */\nvoid queue_test() {\n    MyQueue<int> que;\n    std::cout << \"Test #1\\n\";\n    que.push(2);\n    que.push(5);\n    que.push(0);\n    assert(que.peek() == 2);\n    assert(que.pop() == 2);\n    assert(que.peek() == 5);\n    assert(que.pop() == 5);\n    assert(que.peek() == 0);\n    assert(que.pop() == 0);\n    assert(que.empty() == true);\n    std::cout << \"PASSED\\n\";\n\n    std::cout << \"Test #2\\n\";\n    que.push(-1);\n    assert(que.empty() == false);\n    assert(que.peek() == -1);\n    assert(que.pop() == -1);\n    std::cout << \"PASSED\\n\";\n\n    MyQueue<double> que2;\n    std::cout << \"Test #3\\n\";\n    que2.push(2.31223);\n    que2.push(3.1415926);\n    que2.push(2.92);\n\n    assert(que2.peek() == 2.31223);\n    assert(que2.pop() == 2.31223);\n    assert(que2.peek() == 3.1415926);\n    assert(que2.pop() == 3.1415926);\n    assert(que2.peek() == 2.92);\n    assert(que2.pop() == 2.92);\n    std::cout << \"PASSED\\n\";\n}\n\n/**\n * Main function, calls testing function\n */\nint main() {\n    queue_test();\n    return 0;\n}\n","index":34},{"title":"Skip List","category":"data_structures","id":"skip_list_data_structures","algorithm":"/**\n * @file skip_list.cpp\n * @brief Data structure for fast searching and insertion in \\f$O(\\log n)\\f$\n * time\n * @details\n * A skip list is a data structure that is used for storing a sorted list of\n * items with a help of hierarchy of linked lists that connect increasingly\n * sparse subsequences of the items\n *\n * References used: [GeeksForGeek](https://www.geeksforgeeks.org/skip-list/),\n * [OpenGenus](https://iq.opengenus.org/skip-list) for PseudoCode and Code\n * @author [enqidu](https://github.com/enqidu)\n * @author [Krishna Vedala](https://github.com/kvedala)\n */\n\n#include <array>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <memory>\n#include <vector>\n\n/** \\namespace data_structures\n * \\brief Data-structure algorithms\n */\nnamespace data_structures {\nconstexpr int MAX_LEVEL = 2;        ///< Maximum level of skip list\nconstexpr float PROBABILITY = 0.5;  ///< Current probability for \"coin toss\"\n\n/**\n *  Node structure [Key][Node*, Node*...]\n */\nstruct Node {\n    int key;      ///< key integer\n    void* value;  ///< pointer of value\n    std::vector<std::shared_ptr<Node>>\n        forward;  ///< nodes of the given one in all levels\n\n    /**\n     * Creates node with provided key, level and value\n     * @param key is number that is used for comparision\n     * @param level is the maximum level node's going to added\n     */\n    Node(int key, int level, void* value = nullptr) : key(key), value(value) {\n        // Initialization of forward vector\n        for (int i = 0; i < (level + 1); i++) {\n            forward.push_back(nullptr);\n        }\n    }\n};\n\n/**\n * SkipList class implementation with basic methods\n */\nclass SkipList {\n    int level;                     ///< Maximum level of the skiplist\n    std::shared_ptr<Node> header;  ///< Pointer to the header node\n\n public:\n    /**\n     * Skip List constructor. Initializes header, start\n     * Node for searching in the list\n     */\n    SkipList() {\n        level = 0;\n        // Header initialization\n        header = std::shared_ptr<Node>(new Node(-1, MAX_LEVEL));\n    }\n\n    /**\n     * Returns random level of the skip list.\n     * Every higher level is 2 times less likely.\n     * @return random level for skip list\n     */\n    int randomLevel() {\n        int lvl = 0;\n        while (static_cast<float>(std::rand()) / RAND_MAX < PROBABILITY &&\n               lvl < MAX_LEVEL)\n            lvl++;\n        return lvl;\n    }\n\n    /**\n     * Inserts elements with given key and value;\n     * It's level is computed by randomLevel() function.\n     * @param key is number that is used for comparision\n     * @param value pointer to a value, that can be any type\n     */\n    void insertElement(int key, void* value) {\n        std::cout << \"Inserting\" << key << \"...\";\n        std::shared_ptr<Node> x = header;\n        std::array<std::shared_ptr<Node>, MAX_LEVEL + 1> update;\n        update.fill(nullptr);\n\n        for (int i = level; i >= 0; i--) {\n            while (x->forward[i] != nullptr && x->forward[i]->key < key)\n                x = x->forward[i];\n            update[i] = x;\n        }\n\n        x = x->forward[0];\n\n        bool doesnt_exist = (x == nullptr || x->key != key);\n        if (doesnt_exist) {\n            int rlevel = randomLevel();\n\n            if (rlevel > level) {\n                for (int i = level + 1; i < rlevel + 1; i++) update[i] = header;\n\n                // Update current level\n                level = rlevel;\n            }\n\n            std::shared_ptr<Node> n =\n                std::shared_ptr<Node>(new Node(key, rlevel, value));\n            for (int i = 0; i <= rlevel; i++) {\n                n->forward[i] = update[i]->forward[i];\n                update[i]->forward[i] = n;\n            }\n            std::cout << \"Inserted\" << std::endl;\n\n        } else {\n            std::cout << \"Exists\" << std::endl;\n        }\n    }\n\n    /**\n     * Deletes an element by key and prints if has been removed successfully\n     * @param key is number that is used for comparision.\n     */\n    void deleteElement(int key) {\n        std::shared_ptr<Node> x = header;\n\n        std::array<std::shared_ptr<Node>, MAX_LEVEL + 1> update;\n        update.fill(nullptr);\n\n        for (int i = level; i >= 0; i--) {\n            while (x->forward[i] != nullptr && x->forward[i]->key < key)\n                x = x->forward[i];\n            update[i] = x;\n        }\n\n        x = x->forward[0];\n\n        bool doesnt_exist = (x == nullptr || x->key != key);\n\n        if (!doesnt_exist) {\n            for (int i = 0; i <= level; i++) {\n                if (update[i]->forward[i] != x)\n                    break;\n                update[i]->forward[i] = x->forward[i];\n            }\n            /* Remove empty levels*/\n            while (level > 0 && header->forward[level] == nullptr) level--;\n            std::cout << \"Deleted\" << std::endl;\n        } else {\n            std::cout << \"Doesn't exist\" << std::endl;\n        }\n    }\n\n    /**\n     * Searching element in skip list structure\n     * @param key is number that is used for comparision\n     * @return pointer to the value of the node\n     */\n    void* searchElement(int key) {\n        std::shared_ptr<Node> x = header;\n        std::cout << \"Searching for \" << key << std::endl;\n\n        for (int i = level; i >= 0; i--) {\n            while (x->forward[i] && x->forward[i]->key < key) x = x->forward[i];\n        }\n\n        x = x->forward[0];\n        if (x && x->key == key) {\n            std::cout << \"Found\" << std::endl;\n            return x->value;\n        } else {\n            std::cout << \"Not Found\" << std::endl;\n            return nullptr;\n        }\n    }\n\n    /**\n     * Display skip list level\n     */\n    void displayList() {\n        std::cout << \"Displaying list:\\n\";\n        for (int i = 0; i <= level; i++) {\n            std::shared_ptr<Node> node = header->forward[i];\n            std::cout << \"Level \" << (i) << \": \";\n            while (node != nullptr) {\n                std::cout << node->key << \" \";\n                node = node->forward[i];\n            }\n            std::cout << std::endl;\n        }\n    }\n};\n\n}  // namespace data_structures\n\n/**\n * Main function:\n * Creates and inserts random 2^[number of levels]\n * elements into the skip lists and than displays it\n */\nint main() {\n    std::srand(std::time(nullptr));\n\n    data_structures::SkipList lst;\n\n    for (int j = 0; j < (1 << (data_structures::MAX_LEVEL + 1)); j++) {\n        int k = (std::rand() % (1 << (data_structures::MAX_LEVEL + 2)) + 1);\n        lst.insertElement(k, &j);\n    }\n\n    lst.displayList();\n\n    return 0;\n}\n","index":35},{"title":"Stack.h","category":"data_structures","id":"stack.h_data_structures","algorithm":"/**\n * @file stack.h\n * @author danghai\n * @brief  This class specifies the basic operation on a stack as a linked list\n **/\n#ifndef DATA_STRUCTURES_STACK_H_\n#define DATA_STRUCTURES_STACK_H_\n\n#include <cassert>\n#include <iostream>\n\n/** Definition of the node as a linked-list\n * \\tparam Type type of data nodes of the linked list should contain\n */\ntemplate <class Type>\nstruct node {\n    Type data;         ///< data at current node\n    node<Type> *next;  ///< pointer to the next ::node instance\n};\n\n/** Definition of the stack class\n * \\tparam Type type of data nodes of the linked list in the stack should\n * contain\n */\ntemplate <class Type>\nclass stack {\n public:\n    /** Show stack */\n    void display() {\n        node<Type> *current = stackTop;\n        std::cout << \"Top --> \";\n        while (current != nullptr) {\n            std::cout << current->data << \"  \";\n            current = current->next;\n        }\n        std::cout << std::endl;\n        std::cout << \"Size of stack: \" << size << std::endl;\n    }\n\n    /** Default constructor*/\n    stack() {\n        stackTop = nullptr;\n        size = 0;\n    }\n\n    /** Copy constructor*/\n    explicit stack(const stack<Type> &otherStack) {\n        node<Type> *newNode, *current, *last;\n\n        /* If stack is no empty, make it empty */\n        if (stackTop != nullptr) {\n            stackTop = nullptr;\n        }\n        if (otherStack.stackTop == nullptr) {\n            stackTop = nullptr;\n        } else {\n            current = otherStack.stackTop;\n            stackTop = new node<Type>;\n            stackTop->data = current->data;\n            stackTop->next = nullptr;\n            last = stackTop;\n            current = current->next;\n            /* Copy the remaining stack */\n            while (current != nullptr) {\n                newNode = new node<Type>;\n                newNode->data = current->data;\n                newNode->next = nullptr;\n                last->next = newNode;\n                last = newNode;\n                current = current->next;\n            }\n        }\n        size = otherStack.size;\n    }\n\n    /** Destructor */\n    ~stack() {}\n\n    /** Determine whether the stack is empty */\n    bool isEmptyStack() { return (stackTop == nullptr); }\n\n    /** Add new item to the stack */\n    void push(Type item) {\n        node<Type> *newNode;\n        newNode = new node<Type>;\n        newNode->data = item;\n        newNode->next = stackTop;\n        stackTop = newNode;\n        size++;\n    }\n\n    /** Return the top element of the stack */\n    Type top() {\n        assert(stackTop != nullptr);\n        return stackTop->data;\n    }\n\n    /** Remove the top element of the stack */\n    void pop() {\n        node<Type> *temp;\n        if (!isEmptyStack()) {\n            temp = stackTop;\n            stackTop = stackTop->next;\n            delete temp;\n            size--;\n        } else {\n            std::cout << \"Stack is empty !\" << std::endl;\n        }\n    }\n\n    /** Clear stack */\n    void clear() { stackTop = nullptr; }\n\n    /** Overload \"=\" the assignment operator */\n    stack<Type> &operator=(const stack<Type> &otherStack) {\n        node<Type> *newNode, *current, *last;\n\n        /* If stack is no empty, make it empty */\n        if (stackTop != nullptr) {\n            stackTop = nullptr;\n        }\n        if (otherStack.stackTop == nullptr) {\n            stackTop = nullptr;\n        } else {\n            current = otherStack.stackTop;\n            stackTop = new node<Type>;\n            stackTop->data = current->data;\n            stackTop->next = nullptr;\n            last = stackTop;\n            current = current->next;\n            /* Copy the remaining stack */\n            while (current != nullptr) {\n                newNode = new node<Type>;\n                newNode->data = current->data;\n                newNode->next = nullptr;\n                last->next = newNode;\n                last = newNode;\n                current = current->next;\n            }\n        }\n        size = otherStack.size;\n        return *this;\n    }\n\n private:\n    node<Type> *stackTop; /**< Pointer to the stack */\n    int size;             ///< size of stack\n};\n\n#endif  // DATA_STRUCTURES_STACK_H_\n","index":36},{"title":"Stack Using Array","category":"data_structures","id":"stack_using_array_data_structures","algorithm":"#include <iostream>\n\nint *stack;\nint stack_idx = 0, stack_size;\n\nvoid push(int x) {\n    if (stack_idx == stack_size) {\n        std::cout << \"\\nOverflow\";\n    } else {\n        stack[stack_idx++] = x;\n    }\n}\n\nvoid pop() {\n    if (stack_idx == 0) {\n        std::cout << \"\\nUnderflow\";\n    } else {\n        std::cout << \"\\n\" << stack[--stack_idx] << \" deleted\";\n    }\n}\n\nvoid show() {\n    for (int i = 0; i < stack_idx; i++) {\n        std::cout << stack[i] << \"\\n\";\n    }\n}\n\nvoid topmost() { std::cout << \"\\nTopmost element: \" << stack[stack_idx - 1]; }\nint main() {\n    std::cout << \"\\nEnter stack_size of stack : \";\n    std::cin >> stack_size;\n    stack = new int[stack_size];\n    int ch, x;\n    do {\n        std::cout << \"\\n0. Exit\";\n        std::cout << \"\\n1. Push\";\n        std::cout << \"\\n2. Pop\";\n        std::cout << \"\\n3. Print\";\n        std::cout << \"\\n4. Print topmost element:\";\n        std::cout << \"\\nEnter Your Choice : \";\n        std::cin >> ch;\n        if (ch == 1) {\n            std::cout << \"\\nInsert : \";\n            std::cin >> x;\n            push(x);\n        } else if (ch == 2) {\n            pop();\n        } else if (ch == 3) {\n            show();\n        } else if (ch == 4) {\n            topmost();\n        }\n    } while (ch != 0);\n\n    delete[] stack;\n\n    return 0;\n}\n","index":37},{"title":"Stack Using Linked List","category":"data_structures","id":"stack_using_linked_list_data_structures","algorithm":"#include <iostream>\n\nstruct node {\n    int val;\n    node *next;\n};\n\nnode *top_var;\n\nvoid push(int x) {\n    node *n = new node;\n    n->val = x;\n    n->next = top_var;\n    top_var = n;\n}\n\nvoid pop() {\n    if (top_var == NULL) {\n        std::cout << \"\\nUnderflow\";\n    } else {\n        node *t = top_var;\n        std::cout << \"\\n\" << t->val << \" deleted\";\n        top_var = top_var->next;\n        delete t;\n    }\n}\n\nvoid show() {\n    node *t = top_var;\n    while (t != NULL) {\n        std::cout << t->val << \"\\n\";\n        t = t->next;\n    }\n}\n\nint main() {\n    int ch, x;\n    do {\n        std::cout << \"\\n1. Push\";\n        std::cout << \"\\n2. Pop\";\n        std::cout << \"\\n3. Print\";\n        std::cout << \"\\nEnter Your Choice : \";\n        std::cin >> ch;\n        if (ch == 1) {\n            std::cout << \"\\nInsert : \";\n            std::cin >> x;\n            push(x);\n        } else if (ch == 2) {\n            pop();\n        } else if (ch == 3) {\n            show();\n        }\n    } while (ch != 0);\n\n    return 0;\n}\n","index":38},{"title":"Test Queue","category":"data_structures","id":"test_queue_data_structures","algorithm":"#include <iostream>\n#include <string>\n\n#include \"./queue.h\"\n\nint main() {\n    queue<std::string> q;\n    std::cout << \"---------------------- Test construct ----------------------\"\n              << std::endl;\n    q.display();\n    std::cout\n        << \"---------------------- Test isEmptyQueue ----------------------\"\n        << std::endl;\n    if (q.isEmptyQueue())\n        std::cout << \"PASS\" << std::endl;\n    else\n        std::cout << \"FAIL\" << std::endl;\n    std::cout << \"---------------------- Test enQueue ----------------------\"\n              << std::endl;\n    std::cout << \"After Hai, Jeff, Tom, Jkingston go into queue: \" << std::endl;\n    q.enQueue(\"Hai\");\n    q.enQueue(\"Jeff\");\n    q.enQueue(\"Tom\");\n    q.enQueue(\"Jkingston\");\n    q.display();\n    std::cout << \"---------------------- Test front ----------------------\"\n              << std::endl;\n    std::string value = q.front();\n    if (value == \"Hai\")\n        std::cout << \"PASS\" << std::endl;\n    else\n        std::cout << \"FAIL\" << std::endl;\n    std::cout << \"---------------------- Test deQueue ----------------------\"\n              << std::endl;\n    q.display();\n    q.deQueue();\n    q.deQueue();\n    std::cout << \"After Hai, Jeff left the queue: \" << std::endl;\n    q.display();\n    return 0;\n}\n","index":39},{"title":"Test Stack","category":"data_structures","id":"test_stack_data_structures","algorithm":"#include <iostream>\n\n#include \"./stack.h\"\n\nint main() {\n    stack<int> stk;\n    std::cout << \"---------------------- Test construct ----------------------\"\n              << std::endl;\n    stk.display();\n    std::cout\n        << \"---------------------- Test isEmptyStack ----------------------\"\n        << std::endl;\n    if (stk.isEmptyStack())\n        std::cout << \"PASS\" << std::endl;\n    else\n        std::cout << \"FAIL\" << std::endl;\n    std::cout << \"---------------------- Test push ----------------------\"\n              << std::endl;\n    std::cout << \"After pushing 10 20 30 40 into stack: \" << std::endl;\n    stk.push(10);\n    stk.push(20);\n    stk.push(30);\n    stk.push(40);\n    stk.display();\n    std::cout << \"---------------------- Test top ----------------------\"\n              << std::endl;\n    int value = stk.top();\n    if (value == 40)\n        std::cout << \"PASS\" << std::endl;\n    else\n        std::cout << \"FAIL\" << std::endl;\n    std::cout << \"---------------------- Test pop ----------------------\"\n              << std::endl;\n    stk.display();\n    stk.pop();\n    stk.pop();\n    std::cout << \"After popping 2 times: \" << std::endl;\n    stk.display();\n    std::cout << \"---------------------- Test overload = operator \"\n                 \"----------------------\"\n              << std::endl;\n    stack<int> stk1;\n    std::cout << \"stk current: \" << std::endl;\n    stk.display();\n    std::cout << std::endl << \"Assign stk1 = stk \" << std::endl;\n    stk1 = stk;\n    stk1.display();\n    std::cout << std::endl << \"After pushing 8 9 10 into stk1:\" << std::endl;\n    stk1.push(8);\n    stk1.push(9);\n    stk1.push(10);\n    stk1.display();\n    std::cout << std::endl << \"stk current: \" << std::endl;\n    stk.display();\n    std::cout << \"Assign back stk = stk1:\" << std::endl;\n    stk = stk1;\n    stk.display();\n    return 0;\n}\n","index":40},{"title":"Test Stack Students","category":"data_structures","id":"test_stack_students_data_structures","algorithm":"/*\n * This program reads a data file consisting of students' GPAs\n * followed by their names. The program then prints the highest\n * GPA and the names of the students with the highest GPA.\n * It uses stack to store the names of the students\n * Run:\n *     make all\n *     ./main student.txt\n ************************************************************\n * */\n#include <cassert>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <string>\n\n#include \"./stack.h\"\n\nint main(int argc, char* argv[]) {\n    double GPA;\n    double highestGPA;\n    std::string name;\n\n    assert(argc == 2);\n    std::ifstream infile;\n    stack<std::string> stk;\n\n    infile.open(argv[1]);\n    std::cout << std::fixed << std::showpoint;\n    std::cout << std::setprecision(2);\n    infile >> GPA >> name;\n    highestGPA = GPA;\n\n    while (infile) {\n        if (GPA > highestGPA) {\n            stk.clear();\n            stk.push(name);\n            highestGPA = GPA;\n        } else if (GPA == highestGPA) {\n            stk.push(name);\n        }\n        infile >> GPA >> name;\n    }\n    std::cout << \"Highest GPA: \" << highestGPA << std::endl;\n    std::cout << \"Students the highest GPA are: \" << std::endl;\n    while (!stk.isEmptyStack()) {\n        std::cout << stk.top() << std::endl;\n        stk.pop();\n    }\n    std::cout << std::endl;\n    return 0;\n}\n","index":41},{"title":"Tree","category":"data_structures","id":"tree_data_structures","algorithm":"#include <iostream>\n#include <list>\nusing namespace std;\n\nstruct node {\n    int val;\n    node *left;\n    node *right;\n};\n\nvoid CreateTree(node *curr, node *n, int x, char pos) {\n    if (n != NULL) {\n        char ch;\n        cout << \"\\nLeft or Right of \" << n->val << \" : \";\n        cin >> ch;\n        if (ch == 'l')\n            CreateTree(n, n->left, x, ch);\n        else if (ch == 'r')\n            CreateTree(n, n->right, x, ch);\n    } else {\n        node *t = new node;\n        t->val = x;\n        t->left = NULL;\n        t->right = NULL;\n        if (pos == 'l') {\n            curr->left = t;\n        } else if (pos == 'r') {\n            curr->right = t;\n        }\n    }\n}\n\nvoid BFT(node *n) {\n    list<node *> queue;\n\n    queue.push_back(n);\n\n    while (!queue.empty()) {\n        n = queue.front();\n        cout << n->val << \"  \";\n        queue.pop_front();\n\n        if (n->left != NULL)\n            queue.push_back(n->left);\n        if (n->right != NULL)\n            queue.push_back(n->right);\n    }\n}\n\nvoid Pre(node *n) {\n    if (n != NULL) {\n        cout << n->val << \"  \";\n        Pre(n->left);\n        Pre(n->right);\n    }\n}\n\nvoid In(node *n) {\n    if (n != NULL) {\n        In(n->left);\n        cout << n->val << \"  \";\n        In(n->right);\n    }\n}\n\nvoid Post(node *n) {\n    if (n != NULL) {\n        Post(n->left);\n        Post(n->right);\n        cout << n->val << \"  \";\n    }\n}\n\nint main() {\n    int value;\n    int ch;\n    node *root = new node;\n    cout << \"\\nEnter the value of root node :\";\n    cin >> value;\n    root->val = value;\n    root->left = NULL;\n    root->right = NULL;\n    do {\n        cout << \"\\n1. Insert\";\n        cout << \"\\n2. Breadth First\";\n        cout << \"\\n3. Preorder Depth First\";\n        cout << \"\\n4. Inorder Depth First\";\n        cout << \"\\n5. Postorder Depth First\";\n\n        cout << \"\\nEnter Your Choice : \";\n        cin >> ch;\n        switch (ch) {\n        case 1:\n            int x;\n            char pos;\n            cout << \"\\nEnter the value to be Inserted : \";\n            cin >> x;\n            cout << \"\\nLeft or Right of Root : \";\n            cin >> pos;\n            if (pos == 'l')\n                CreateTree(root, root->left, x, pos);\n            else if (pos == 'r')\n                CreateTree(root, root->right, x, pos);\n            break;\n        case 2:\n            BFT(root);\n            break;\n        case 3:\n            Pre(root);\n            break;\n        case 4:\n            In(root);\n            break;\n        case 5:\n            Post(root);\n            break;\n        }\n    } while (ch != 0);\n}\n","index":42},{"title":"Trie Modern","category":"data_structures","id":"trie_modern_data_structures","algorithm":"/**\n * @file\n *\n * @author Anmol3299\n * \\brief A basic implementation of trie class to store only lower-case strings.\n */\n#include <iostream>  // for io operations\n#include <memory>    // for std::shared_ptr<>\n#include <string>    // for std::string class\n\n/**\n * A basic implementation of trie class to store only lower-case strings.\n * You can extend the implementation to all the ASCII characters by changing the\n * value of @ ALPHABETS to 128.\n */\nclass Trie {\n private:\n    static constexpr size_t ALPHABETS = 26;\n\n    /**\n     * Structure of trie node.\n     * This struct doesn't need a constructor as we are initializing using\n     * intializer list which is more efficient than if we had done so with\n     * constructor.\n     */\n    struct TrieNode {\n        // An array of pointers of size 26 which tells if a character of word is\n        // present or not.\n        std::shared_ptr<TrieNode> character[ALPHABETS]{nullptr};\n\n        bool isEndOfWord{false};\n    };\n\n    /**\n     * Function to check if a node has some children which can form words.\n     * @param node whose character array of pointers need to be checked for\n     * children.\n     * @return `true` if a child is found\n     * @return `false` if a child is not found\n     */\n    inline static bool hasChildren(std::shared_ptr<TrieNode> node) {\n        for (size_t i = 0; i < ALPHABETS; i++) {\n            if (node->character[i]) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * A recursive helper function to remove a word from the trie. First, it\n     * recursively traverses to the location of last character of word in the\n     * trie. However, if the word is not found, the function returns a runtime\n     * error. Upon successfully reaching the last character of word in trie, if\n     * sets the isEndOfWord to false and deletes the node if and only if it has\n     * no children, else it returns the current node.\n     * @param word is the string which needs to be removed from trie.\n     * @param curr is the current node we are at.\n     * @param index is the index of the @word we are at.\n     * @return if current node has childern, it returns @ curr, else it returns\n     * nullptr.\n     * @throw a runtime error in case @ word is not found in the trie.\n     */\n    std::shared_ptr<TrieNode> removeWordHelper(const std::string& word,\n                                               std::shared_ptr<TrieNode> curr,\n                                               size_t index) {\n        if (word.size() == index) {\n            if (curr->isEndOfWord) {\n                curr->isEndOfWord = false;\n            }\n            if (hasChildren(curr)) {\n                return curr;\n            }\n            return nullptr;\n        }\n\n        size_t idx = word[index] - 'a';\n\n        // Throw a runtime error in case the user enters a word which is not\n        // present in the trie.\n        if (!curr->character[idx]) {\n            throw std::runtime_error(std::move(std::string(\"Word not found.\")));\n        }\n\n        curr->character[idx] =\n            removeWordHelper(word, curr->character[idx], index + 1);\n\n        // This if condition checks if the node has some childern.\n        // The 1st if check, i.e. (curr->character[idx]) is checked specifically\n        // because if the older string is a prefix of some other string, then,\n        // there would be no need to check all 26 characters. Example- str1 =\n        // abbey, str2 = abbex and we want to delete string \"abbey\", then in\n        // this case, there would be no need to check all characters for the\n        // chars a,b,b.\n        if (curr->character[idx] || hasChildren(curr)) {\n            return curr;\n        }\n        return nullptr;\n    }\n\n public:\n    /// constructor to initialise the root of the trie.\n    Trie() : m_root(std::make_shared<TrieNode>()) {}\n\n    /**\n     * Insert a word into the trie.\n     * @param word which needs to be inserted into the string.\n     */\n    void insert(const std::string& word) {\n        auto curr = m_root;\n        for (char ch : word) {\n            size_t index = ch - 'a';\n\n            // if a node for current word is not already present in trie, create\n            // a new node for it.\n            if (!curr->character[index]) {\n                curr->character[index] = std::make_shared<TrieNode>();\n            }\n\n            curr = curr->character[index];\n        }\n        curr->isEndOfWord = true;\n    }\n\n    /**\n     * Search if a word is present in trie or not.\n     * @param word which is needed to be searched in the trie.\n     * @return True if the word is found in trie and isEndOfWord is set to true.\n     * @return False if word is not found in trie or isEndOfWord is set to\n     * false.\n     */\n    bool search(const std::string& word) {\n        auto curr = m_root;\n        for (char ch : word) {\n            size_t index = ch - 'a';\n\n            // if any node for a character is not found, then return that the\n            // word cannot be formed.\n            if (!curr->character[index]) {\n                return false;\n            }\n            curr = curr->character[index];\n        }\n        return curr->isEndOfWord;\n    }\n\n    // Function to remove the word which calls the helper function.\n    void removeWord(const std::string& word) {\n        m_root = removeWordHelper(word, m_root, 0);\n    }\n\n private:\n    // data member to store the root of the trie.\n    std::shared_ptr<TrieNode> m_root;\n};\n\n/**\n * Main function\n */\nint main() {\n    Trie trie;\n    trie.insert(\"hel\");\n    trie.insert(\"hello\");\n    trie.removeWord(\"hel\");\n    std::cout << trie.search(\"hello\") << '\\n';\n\n    return 0;\n}\n","index":43},{"title":"Trie Tree","category":"data_structures","id":"trie_tree_data_structures","algorithm":"/**\n * @file\n * @author [@Arctic2333](https://github.com/Arctic2333)\n * @author [Krishna Vedala](https://github.com/kvedala)\n * @brief Implementation of [Trie](https://en.wikipedia.org/wiki/Trie) data\n * structure for English alphabets in small characters.\n * @note the function ::data_structure::trie::deleteString might be erroneous\n * @see trie_modern.cpp\n */\n#include <array>\n#include <cassert>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n\n/** \\namespace data_structures\n * \\brief Data-structure algorithms\n */\nnamespace data_structures {\n/**\n * @brief [Trie](https://en.wikipedia.org/wiki/Trie) implementation for\n * small-case English alphabets `a-z`\n */\nclass trie {\n private:\n    static constexpr uint8_t NUM_CHARS = 26;  ///< Number of alphabets\n    /** @brief Recursive tree nodes as an array of shared-pointers */\n    std::array<std::shared_ptr<trie>, NUM_CHARS << 1> arr;\n    bool isEndofWord = false;  ///< identifier if a node is terminal node\n\n    /**\n     * @brief Convert a character to integer for indexing\n     *\n     * @param ch character to index\n     * @return unsigned integer index\n     */\n    uint8_t char_to_int(const char& ch) const {\n        if (ch >= 'A' && ch <= 'Z') {\n            return ch - 'A';\n        } else if (ch >= 'a' && ch <= 'z') {\n            return ch - 'a' + NUM_CHARS;\n        }\n\n        std::cerr << \"Invalid character present. Exiting...\";\n        std::exit(EXIT_FAILURE);\n        return 0;\n    }\n\n    /** search a string exists inside a given root trie\n     * @param str string to search for\n     * @param index start index to search from\n     * @returns `true` if found\n     * @returns `false` if not found\n     */\n    bool search(const std::shared_ptr<trie>& root, const std::string& str,\n                int index) {\n        if (index == str.length()) {\n            if (!root->isEndofWord) {\n                return false;\n            }\n            return true;\n        }\n        int j = char_to_int(str[index]);\n        if (!root->arr[j]) {\n            return false;\n        }\n        return search(root->arr[j], str, index + 1);\n    }\n\n public:\n    trie() = default;  ///< Class default constructor\n\n    /** insert string into the trie\n     * @param str String to insert in the tree\n     */\n    void insert(const std::string& str) {\n        std::shared_ptr<trie> root(nullptr);\n\n        for (const char& ch : str) {\n            int j = char_to_int(ch);\n            if (root) {\n                if (root->arr[j]) {\n                    root = root->arr[j];\n                } else {\n                    std::shared_ptr<trie> temp(new trie());\n                    root->arr[j] = temp;\n                    root = temp;\n                }\n            } else if (arr[j]) {\n                root = arr[j];\n            } else {\n                std::shared_ptr<trie> temp(new trie());\n                arr[j] = temp;\n                root = temp;\n            }\n        }\n        root->isEndofWord = true;\n    }\n\n    /** search a string exists inside the trie\n     * @param str string to search for\n     * @param index start index to search from\n     * @returns `true` if found\n     * @returns `false` if not found\n     */\n    bool search(const std::string& str, int index) {\n        if (index == str.length()) {\n            if (!isEndofWord) {\n                return false;\n            }\n            return true;\n        }\n        int j = char_to_int(str[index]);\n        if (!arr[j]) {\n            return false;\n        }\n        return search(arr[j], str, index + 1);\n    }\n\n    /**\n     * removes the string if it is not a prefix of any  other\n     * string, if it is then just sets the ::data_structure::trie::isEndofWord\n     * to false, else removes the given string\n     * @note the function ::data_structure::trie::deleteString might be\n     * erroneous\n     * @todo review the function ::data_structure::trie::deleteString and the\n     * commented lines\n     * @param str string to remove\n     * @param index index to remove from\n     * @returns `true` if successful\n     * @returns `false` if unsuccessful\n     */\n    bool deleteString(const std::string& str, int index) {\n        if (index == str.length()) {\n            if (!isEndofWord) {\n                return false;\n            }\n            isEndofWord = false;\n            // following lines - possible source of error?\n            // for (int i = 0; i < NUM_CHARS; i++)\n            //     if (!arr[i])\n            //         return false;\n            return true;\n        }\n        int j = char_to_int(str[index]);\n        if (!arr[j]) {\n            return false;\n        }\n        bool var = deleteString(str, index + 1);\n        if (var) {\n            arr[j].reset();\n            if (isEndofWord) {\n                return false;\n            } else {\n                int i = 0;\n                for (i = 0; i < NUM_CHARS; i++) {\n                    if (arr[i]) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        }\n\n        /* should not return here */\n        std::cout << __func__ << \":\" << __LINE__\n                  << \"Should not reach this line\\n\";\n        return false;\n    }\n};\n}  // namespace data_structures\n\n/**\n * @brief Testing function\n * @returns void\n */\nstatic void test() {\n    data_structures::trie root;\n    root.insert(\"Hello\");\n    root.insert(\"World\");\n\n    assert(!root.search(\"hello\", 0));\n    std::cout << \"hello - \" << root.search(\"hello\", 0) << \"\\n\";\n\n    assert(root.search(\"Hello\", 0));\n    std::cout << \"Hello - \" << root.search(\"Hello\", 0) << \"\\n\";\n\n    assert(!root.search(\"Word\", 0));\n    std::cout << \"Word - \" << root.search(\"Word\", 0) << \"\\n\";\n\n    assert(root.search(\"World\", 0));\n    std::cout << \"World - \" << root.search(\"World\", 0) << \"\\n\";\n\n    // Following lines of code give erroneous output\n    // root.deleteString(\"hello\", 0);\n    // assert(!root.search(\"hello\", 0));\n    // std::cout << \"hello - \" << root.search(\"world\", 0) << \"\\n\";\n}\n\n/**\n * @brief Main function\n * @return 0 on exit\n */\nint main() {\n    test();\n\n    return 0;\n}\n","index":44},{"title":"Dynamic Programming","category":null,"id":"dynamic_programming","index":45},{"title":"0 1 Knapsack","category":"dynamic_programming","id":"0_1_knapsack_dynamic_programming","algorithm":"// 0-1 Knapsack problem - Dynamic programming\n//#include <bits/stdc++.h>\n#include <iostream>\nusing namespace std;\n\n// void Print(int res[20][20], int i, int j, int capacity)\n//{\n//\tif(i==0 || j==0)\n//\t{\n//\t\treturn;\n//\t}\n//\tif(res[i-1][j]==res[i][j-1])\n//\t{\n//\t\tif(i<=capacity)\n//\t\t{\n//\t\t\tcout<<i<<\" \";\n//\t\t}\n//\n//\t\tPrint(res, i-1, j-1, capacity-i);\n//\t}\n//\telse if(res[i-1][j]>res[i][j-1])\n//\t{\n//\t\tPrint(res, i-1,j, capacity);\n//\t}\n//\telse if(res[i][j-1]>res[i-1][j])\n//\t{\n//\t\tPrint(res, i,j-1, capacity);\n//\t}\n//}\n\nint Knapsack(int capacity, int n, int weight[], int value[]) {\n    int res[20][20];\n    for (int i = 0; i < n + 1; ++i) {\n        for (int j = 0; j < capacity + 1; ++j) {\n            if (i == 0 || j == 0)\n                res[i][j] = 0;\n            else if (weight[i - 1] <= j)\n                res[i][j] = max(value[i - 1] + res[i - 1][j - weight[i - 1]],\n                                res[i - 1][j]);\n            else\n                res[i][j] = res[i - 1][j];\n        }\n    }\n    //\tPrint(res, n, capacity, capacity);\n    //\tcout<<\"\\n\";\n    return res[n][capacity];\n}\nint main() {\n    int n;\n    cout << \"Enter number of items: \";\n    cin >> n;\n    int weight[n], value[n];\n    cout << \"Enter weights: \";\n    for (int i = 0; i < n; ++i) {\n        cin >> weight[i];\n    }\n    cout << \"Enter values: \";\n    for (int i = 0; i < n; ++i) {\n        cin >> value[i];\n    }\n    int capacity;\n    cout << \"Enter capacity: \";\n    cin >> capacity;\n    cout << Knapsack(capacity, n, weight, value);\n    return 0;\n}\n","index":46},{"title":"Armstrong Number","category":"dynamic_programming","id":"armstrong_number_dynamic_programming","algorithm":"// Program to check whether a number is an armstrong number or not\n#include <iostream>\n\nusing std::cin;\nusing std::cout;\n\nint main() {\n    int n, k, d, s = 0;\n    cout << \"Enter a number:\";\n    cin >> n;\n    k = n;\n    while (k != 0) {\n        d = k % 10;\n        s += d * d * d;\n        k /= 10;\n    }\n    if (s == n)\n        cout << n << \"is an armstrong number\";\n    else\n        cout << n << \"is not an armstrong number\";\n}\n","index":47},{"title":"Bellman Ford","category":"dynamic_programming","id":"bellman_ford_dynamic_programming","algorithm":"#include <limits.h>\n#include <iostream>\n\nusing namespace std;\n\n// Wrapper class for storing an edge\nclass Edge {\n public:\n    int src, dst, weight;\n};\n\n// Wrapper class for storing a graph\nclass Graph {\n public:\n    int vertexNum, edgeNum;\n    Edge *edges;\n\n    // Constructs a graph with V vertices and E edges\n    Graph(int V, int E) {\n        this->vertexNum = V;\n        this->edgeNum = E;\n        this->edges = (Edge *)malloc(E * sizeof(Edge));\n    }\n\n    // Adds the given edge to the graph\n    void addEdge(int src, int dst, int weight) {\n        static int edgeInd = 0;\n        if (edgeInd < this->edgeNum) {\n            Edge newEdge;\n            newEdge.src = src;\n            newEdge.dst = dst;\n            newEdge.weight = weight;\n            this->edges[edgeInd++] = newEdge;\n        }\n    }\n};\n\n// Utility function to print distances\nvoid print(int dist[], int V) {\n    cout << \"\\nVertex  Distance\" << endl;\n    for (int i = 0; i < V; i++) {\n        if (dist[i] != INT_MAX)\n            cout << i << \"\\t\" << dist[i] << endl;\n        else\n            cout << i << \"\\tINF\" << endl;\n    }\n}\n\n// The main function that finds the shortest path from given source\n// to all other vertices using Bellman-Ford.It also detects negative\n// weight cycle\nvoid BellmanFord(Graph graph, int src) {\n    int V = graph.vertexNum;\n    int E = graph.edgeNum;\n    int dist[V];\n\n    // Initialize distances array as INF for all except source\n    // Intialize source as zero\n    for (int i = 0; i < V; i++) dist[i] = INT_MAX;\n    dist[src] = 0;\n\n    // Calculate shortest path distance from source to all edges\n    // A path can contain maximum (|V|-1) edges\n    for (int i = 0; i <= V - 1; i++)\n        for (int j = 0; j < E; j++) {\n            int u = graph.edges[j].src;\n            int v = graph.edges[j].dst;\n            int w = graph.edges[j].weight;\n\n            if (dist[u] != INT_MAX && dist[u] + w < dist[v])\n                dist[v] = dist[u] + w;\n        }\n\n    // Iterate inner loop once more to check for negative cycle\n    for (int j = 0; j < E; j++) {\n        int u = graph.edges[j].src;\n        int v = graph.edges[j].dst;\n        int w = graph.edges[j].weight;\n\n        if (dist[u] != INT_MAX && dist[u] + w < dist[v]) {\n            cout << \"Graph contains negative weight cycle. Hence, shortest \"\n                    \"distance not guaranteed.\"\n                 << endl;\n            return;\n        }\n    }\n\n    print(dist, V);\n\n    return;\n}\n\n// Driver Function\nint main() {\n    int V, E, gsrc;\n    int src, dst, weight;\n    cout << \"Enter number of vertices: \";\n    cin >> V;\n    cout << \"Enter number of edges: \";\n    cin >> E;\n    Graph G(V, E);\n    for (int i = 0; i < E; i++) {\n        cout << \"\\nEdge \" << i + 1 << \"\\nEnter source: \";\n        cin >> src;\n        cout << \"Enter destination: \";\n        cin >> dst;\n        cout << \"Enter weight: \";\n        cin >> weight;\n        G.addEdge(src, dst, weight);\n    }\n    cout << \"\\nEnter source: \";\n    cin >> gsrc;\n    BellmanFord(G, gsrc);\n\n    return 0;\n}\n","index":48},{"title":"Catalan Numbers","category":"dynamic_programming","id":"catalan_numbers_dynamic_programming","algorithm":"/** Print all the Catalan numbers from 0 to n, n being the user input.\n\n * A Catalan number satifies the following two properties:\n * C(0) = C(1) = 1; C(n) = sum(C(i).C(n-i-1)), from i = 0 to n-1\n * Read more about Catalan numbers here:\n    https://en.wikipedia.org/wiki/Catalan_number\n */\n\n#include <iostream>\nusing namespace std;\n\nint *cat;  // global array to hold catalan numbers\n\nunsigned long int catalan_dp(int n) {\n    /** Using the tabulation technique in dynamic programming,\n        this function computes the first `n+1` Catalan numbers\n\n        Parameter\n        ---------\n        n: The number of catalan numbers to be computed.\n\n        Returns\n        -------\n        cat[n]: An array containing the first `n+1` Catalan numbers\n    */\n\n    // By definition, the first two Catalan numbers are 1\n    cat[0] = cat[1] = 1;\n\n    // Compute the remaining numbers from index 2 to index n, using tabulation\n    for (int i = 2; i <= n; i++) {\n        cat[i] = 0;\n        for (int j = 0; j < i; j++)\n            cat[i] += cat[j] * cat[i - j - 1];  // applying the definition here\n    }\n\n    // Return the result\n    return cat[n];\n}\n\nint main(int argc, char *argv[]) {\n    int n;\n    cout << \"Enter n: \";\n    cin >> n;\n\n    cat = new int[n + 1];\n\n    cout << \"Catalan numbers from 0 to \" << n << \" are:\\n\";\n    for (int i = 0; i <= n; i++) {\n        cout << \"catalan (\" << i << \") = \" << catalan_dp(i) << endl;\n        // NOTE: Since `cat` is a global array, calling `catalan_dp`\n        // repeatedly will not recompute the the values already computed\n        // as in case of pre-computed values, the array will simply return them,\n        // instead of recomputing them.\n    }\n\n    return 0;\n}\n\n/** Sample Test Case:\n\n$ cd \"Dynamic Programming\"\n$ g++ Catalan-Numbers.cpp\n$ ./a.exe\n\nEnter n: 5\nCatalan numbers from 0 to 5 are:\ncatalan (0) = 1\ncatalan (1) = 1\ncatalan (2) = 2\ncatalan (3) = 5\ncatalan (4) = 14\ncatalan (5) = 42\n\n*/\n","index":49},{"title":"Coin Change","category":"dynamic_programming","id":"coin_change_dynamic_programming","algorithm":"#include <climits>\n#include <iostream>\nusing namespace std;\n\n// Function to find the Minimum number of coins required to get Sum S\nint findMinCoins(int arr[], int n, int N) {\n    // dp[i] = no of coins required to get a total of i\n    int dp[N + 1];\n\n    // 0 coins are needed for 0 sum\n\n    dp[0] = 0;\n\n    for (int i = 1; i <= N; i++) {\n        // initialize minimum number of coins needed to infinity\n        dp[i] = INT_MAX;\n        int res = INT_MAX;\n\n        // do for each coin\n        for (int c = 0; c < n; c++) {\n            if (i - arr[c] >=\n                0)  // check if coins doesn't become negative by including it\n                res = dp[i - arr[c]];\n\n            // if total can be reached by including current coin c,\n            // update minimum number of coins needed dp[i]\n            if (res != INT_MAX)\n                dp[i] = min(dp[i], res + 1);\n        }\n    }\n\n    // The Minimum No of Coins Required for N = dp[N]\n    return dp[N];\n}\n\nint main() {\n    // No of Coins We Have\n    int arr[] = {1, 2, 3, 4};\n    int n = sizeof(arr) / sizeof(arr[0]);\n\n    // Total Change Required\n    int N = 15;\n\n    cout << \"Minimum Number of Coins Required \" << findMinCoins(arr, n, N)\n         << \"\\n\";\n\n    return 0;\n}","index":50},{"title":"Cut Rod","category":"dynamic_programming","id":"cut_rod_dynamic_programming","algorithm":"/*Given a rod of length n inches and an array of prices that\ncontains prices of all pieces of size smaller than n. Determine\nthe maximum value obtainable by cutting up the rod and selling\nthe pieces.*/\n\n#include <iostream>\nusing namespace std;\nint cutrod(int p[], int n) {\n    int r[n + 1];\n    r[0] = 0;\n    for (int j = 0; j < n; j++) {\n        int q = INT_MIN;\n        for (int i = 0; i <= j; i++) {\n            q = max(q, p[i] + r[j - i]);\n        }\n        r[j + 1] = q;\n    }\n    return r[n];\n}\nint main() {\n    int price[] = {1,  5,  8,  9,  10, 17, 17, 20, 24, 30, 31, 32, 33, 34, 35,\n                   36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50};\n    cout << cutrod(price, 30);\n    return 0;\n}\n","index":51},{"title":"Edit Distance","category":"dynamic_programming","id":"edit_distance_dynamic_programming","algorithm":"/* Given two strings str1 & str2\n * and below operations that can\n * be performed on str1. Find\n * minimum number of edits\n * (operations) required to convert\n * 'str1' into 'str2'/\n * a. Insert\n * b. Remove\n * c. Replace\n * All of the above operations are\n * of equal cost\n */\n\n#include <iostream>\n#include <string>\nusing namespace std;\n\nint min(int x, int y, int z) { return min(min(x, y), z); }\n\n/* A Naive recursive C++ program to find\n * minimum number of operations to convert\n * str1 to str2.\n * O(3^m)\n */\nint editDist(string str1, string str2, int m, int n) {\n    if (m == 0)\n        return n;\n    if (n == 0)\n        return m;\n\n    // If last characters are same then continue\n    // for the rest of them.\n    if (str1[m - 1] == str2[n - 1])\n        return editDist(str1, str2, m - 1, n - 1);\n\n    // If last not same, then 3 possibilities\n    // a.Insert b.Remove c. Replace\n    // Get min of three and continue for rest.\n    return 1 + min(editDist(str1, str2, m, n - 1),\n                   editDist(str1, str2, m - 1, n),\n                   editDist(str1, str2, m - 1, n - 1));\n}\n\n/* A DP based program\n * O(m x n)\n */\nint editDistDP(string str1, string str2, int m, int n) {\n    // Create Table for SubProblems\n    int dp[m + 1][n + 1];\n\n    // Fill d[][] in bottom up manner\n    for (int i = 0; i <= m; i++) {\n        for (int j = 0; j <= n; j++) {\n            // If str1 empty. Then add all of str2\n            if (i == 0)\n                dp[i][j] = j;\n\n            // If str2 empty. Then add all of str1\n            else if (j == 0)\n                dp[i][j] = i;\n\n            // If character same. Recur for remaining\n            else if (str1[i - 1] == str2[j - 1])\n                dp[i][j] = dp[i - 1][j - 1];\n\n            else\n                dp[i][j] = 1 + min(dp[i][j - 1],     // Insert\n                                   dp[i - 1][j],     // Remove\n                                   dp[i - 1][j - 1]  // Replace\n                               );\n        }\n    }\n\n    return dp[m][n];\n}\n\nint main() {\n    string str1 = \"sunday\";\n    string str2 = \"saturday\";\n\n    cout << editDist(str1, str2, str1.length(), str2.length()) << endl;\n    cout << editDistDP(str1, str2, str1.length(), str2.length()) << endl;\n\n    return 0;\n}\n","index":52},{"title":"Egg Dropping Puzzle","category":"dynamic_programming","id":"egg_dropping_puzzle_dynamic_programming","algorithm":"/* Function to get minimun number of trials needed\n * in worst case with n eggs and k floors\n */\n\n#include <climits>\n#include <iostream>\nusing namespace std;\n\nint eggDrop(int n, int k) {\n    int eggFloor[n + 1][k + 1];\n    int result;\n\n    for (int i = 1; i <= n; i++) {\n        eggFloor[i][1] = 1;  // n eggs..1 Floor\n        eggFloor[i][0] = 0;  // n eggs..0 Floor\n    }\n\n    // Only one egg available\n    for (int j = 1; j <= k; j++) {\n        eggFloor[1][j] = j;\n    }\n\n    for (int i = 2; i <= n; i++) {\n        for (int j = 2; j <= k; j++) {\n            eggFloor[i][j] = INT_MAX;\n            for (int x = 1; x <= j; x++) {\n                // 1+max(eggBreak[one less egg, lower floors],\n                //       eggDoesntBreak[same # of eggs, upper floors]);\n                result = 1 + max(eggFloor[i - 1][x - 1], eggFloor[i][j - x]);\n                if (result < eggFloor[i][j])\n                    eggFloor[i][j] = result;\n            }\n        }\n    }\n\n    return eggFloor[n][k];\n}\n\nint main() {\n    int n, k;\n    cout << \"Enter number of eggs and floors: \";\n    cin >> n >> k;\n    cout << \"Minimum number of trials in worst case: \" << eggDrop(n, k) << endl;\n    return 0;\n}\n","index":53},{"title":"Fibonacci Bottom Up","category":"dynamic_programming","id":"fibonacci_bottom_up_dynamic_programming","algorithm":"#include <iostream>\nusing namespace std;\nint fib(int n) {\n    int res[3];\n    res[0] = 0;\n    res[1] = 1;\n    for (int i = 2; i <= n; i++) {\n        res[2] = res[1] + res[0];\n        res[0] = res[1];\n        res[1] = res[2];\n    }\n    return res[1];\n}\nint main(int argc, char const *argv[]) {\n    int n;\n    cout << \"Enter n: \";\n    cin >> n;\n    cout << \"Fibonacci number is \";\n    cout << fib(n) << endl;\n    return 0;\n}\n","index":54},{"title":"Fibonacci Top Down","category":"dynamic_programming","id":"fibonacci_top_down_dynamic_programming","algorithm":"#include <iostream>\nusing namespace std;\nint arr[1000000];\nint fib(int n) {\n    if (arr[n] == -1) {\n        if (n <= 1)\n            arr[n] = n;\n        else\n            arr[n] = fib(n - 1) + fib(n - 2);\n    }\n    return arr[n];\n}\nint main(int argc, char const *argv[]) {\n    int n;\n    cout << \"Enter n: \";\n    cin >> n;\n    for (int i = 0; i < n + 1; ++i) {\n        arr[i] = -1;\n    }\n    cout << \"Fibonacci number is \" << fib(n) << endl;\n    return 0;\n}","index":55},{"title":"Floyd Warshall","category":"dynamic_programming","id":"floyd_warshall_dynamic_programming","algorithm":"#include <climits>\n#include <iostream>\n#include <string>\n\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\n// Wrapper class for storing a graph\nclass Graph {\n public:\n    int vertexNum;\n    int **edges;\n\n    // Constructs a graph with V vertices and E edges\n    Graph(int V) {\n        this->vertexNum = V;\n        this->edges = new int *[V];\n        for (int i = 0; i < V; i++) {\n            this->edges[i] = new int[V];\n            for (int j = 0; j < V; j++) this->edges[i][j] = INT_MAX;\n            this->edges[i][i] = 0;\n        }\n    }\n\n    ~Graph() {\n        for (int i = 0; i < vertexNum; i++) delete[] edges[i];\n        delete[] edges;\n    }\n\n    // Adds the given edge to the graph\n    void addEdge(int src, int dst, int weight) {\n        this->edges[src][dst] = weight;\n    }\n};\n\n// Utility function to print distances\nvoid print(int dist[], int V) {\n    cout << \"\\nThe Distance matrix for Floyd - Warshall\" << endl;\n    for (int i = 0; i < V; i++) {\n        for (int j = 0; j < V; j++) {\n            if (dist[i * V + j] != INT_MAX)\n                cout << dist[i * V + j] << \"\\t\";\n            else\n                cout << \"INF\"\n                     << \"\\t\";\n        }\n        cout << endl;\n    }\n}\n\n// The main function that finds the shortest path from a vertex\n// to all other vertices using Floyd-Warshall Algorithm.\nvoid FloydWarshall(Graph graph) {\n    int V = graph.vertexNum;\n    int dist[V][V];\n\n    // Initialise distance array\n    for (int i = 0; i < V; i++)\n        for (int j = 0; j < V; j++) dist[i][j] = graph.edges[i][j];\n\n    // Calculate distances\n    for (int k = 0; k < V; k++)\n        // Choose an intermediate vertex\n\n        for (int i = 0; i < V; i++)\n            // Choose a source vertex for given intermediate\n\n            for (int j = 0; j < V; j++)\n                // Choose a destination vertex for above source vertex\n\n                if (dist[i][k] != INT_MAX && dist[k][j] != INT_MAX &&\n                    dist[i][k] + dist[k][j] < dist[i][j])\n                    // If the distance through intermediate vertex is less than\n                    // direct edge then update value in distance array\n                    dist[i][j] = dist[i][k] + dist[k][j];\n\n    // Convert 2d array to 1d array for print\n    int dist1d[V * V];\n    for (int i = 0; i < V; i++)\n        for (int j = 0; j < V; j++) dist1d[i * V + j] = dist[i][j];\n\n    print(dist1d, V);\n}\n\n// Driver Function\nint main() {\n    int V, E;\n    int src, dst, weight;\n    cout << \"Enter number of vertices: \";\n    cin >> V;\n    cout << \"Enter number of edges: \";\n    cin >> E;\n    Graph G(V);\n    for (int i = 0; i < E; i++) {\n        cout << \"\\nEdge \" << i + 1 << \"\\nEnter source: \";\n        cin >> src;\n        cout << \"Enter destination: \";\n        cin >> dst;\n        cout << \"Enter weight: \";\n        cin >> weight;\n        G.addEdge(src, dst, weight);\n    }\n    FloydWarshall(G);\n\n    return 0;\n}\n","index":56},{"title":"Kadane","category":"dynamic_programming","id":"kadane_dynamic_programming","algorithm":"#include <climits>\n#include <iostream>\n\nint maxSubArraySum(int a[], int size) {\n    int max_so_far = INT_MIN, max_ending_here = 0;\n\n    for (int i = 0; i < size; i++) {\n        max_ending_here = max_ending_here + a[i];\n        if (max_so_far < max_ending_here)\n            max_so_far = max_ending_here;\n\n        if (max_ending_here < 0)\n            max_ending_here = 0;\n    }\n    return max_so_far;\n}\n\nint main() {\n    int n, i;\n    std::cout << \"Enter the number of elements \\n\";\n    std::cin >> n;\n    int a[n];  // NOLINT\n    for (i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    int max_sum = maxSubArraySum(a, n);\n    std::cout << \"Maximum contiguous sum is \" << max_sum;\n    return 0;\n}\n","index":57},{"title":"Longest Common String","category":"dynamic_programming","id":"longest_common_string_dynamic_programming","algorithm":"#include <iosrteam>\nusing namespace std;\n\nint max(int a, int b) { return (a > b) ? a : b; }\n\nint main() {\n    char str1[] = \"DEFBCD\";\n    char str2[] = \"ABDEFJ\";\n    int i, j, k;\n    int n = strlen(str1) + 1;\n    int m = strlen(str2) + 1;\n    // cout<<n<<\" \"<<m<<\"\\n\";\n    int a[m][n];\n\n    for (i = 0; i < m; i++) {\n        for (j = 0; j < n; j++) {\n            if (i == 0 || j == 0)\n                a[i][j] = 0;\n\n            else if (str1[i - 1] == str2[j - 1])\n                a[i][j] = a[i - 1][j - 1] + 1;\n\n            else\n                a[i][j] = 0;\n        }\n    }\n\n    /*for(i=0;i<m;i++)\n        {\n            for(j=0;j<n;j++)\n                cout<<a[i][j]<<\" \";\n            cout<<\"\\n\";\n        }*/\n\n    int ma = -1;\n    int indi, indj;\n    for (i = 0; i < m; i++) {\n        for (j = 0; j < n; j++) {\n            if (a[i][j] > ma) {\n                ma = a[i][j];\n                indi = i;\n                indj = j;\n            }\n        }\n    }\n\n    cout << str1 << \"\\n\";\n    cout << str2 << \"\\n\";\n\n    cout << \"longest string size = \" << ma /*<<\" \"<<indi<<\" \"<<indj*/ << \"\\n\";\n    for (i = indi - 3; i < indi; i++) cout << str1[i];\n    cout << \"\\n\";\n}\n","index":58},{"title":"Longest Common Subsequence","category":"dynamic_programming","id":"longest_common_subsequence_dynamic_programming","algorithm":"// Longest common subsequence - Dynamic Programming\n#include <iostream>\nusing namespace std;\n\nvoid Print(int trace[20][20], int m, int n, string a) {\n    if (m == 0 || n == 0) {\n        return;\n    }\n    if (trace[m][n] == 1) {\n        Print(trace, m - 1, n - 1, a);\n        cout << a[m - 1];\n    } else if (trace[m][n] == 2) {\n        Print(trace, m - 1, n, a);\n    } else if (trace[m][n] == 3) {\n        Print(trace, m, n - 1, a);\n    }\n}\n\nint lcs(string a, string b) {\n    int m = a.length(), n = b.length();\n    int res[m + 1][n + 1];\n    int trace[20][20];\n\n    // fills up the arrays with zeros.\n    for (int i = 0; i < m + 1; i++) {\n        for (int j = 0; j < n + 1; j++) {\n            res[i][j] = 0;\n            trace[i][j] = 0;\n        }\n    }\n\n    for (int i = 0; i < m + 1; ++i) {\n        for (int j = 0; j < n + 1; ++j) {\n            if (i == 0 || j == 0) {\n                res[i][j] = 0;\n                trace[i][j] = 0;\n            }\n\n            else if (a[i - 1] == b[j - 1]) {\n                res[i][j] = 1 + res[i - 1][j - 1];\n                trace[i][j] = 1;  // 1 means trace the matrix in upper left\n                                  // diagonal direction.\n            } else {\n                if (res[i - 1][j] > res[i][j - 1]) {\n                    res[i][j] = res[i - 1][j];\n                    trace[i][j] =\n                        2;  // 2 means trace the matrix in upwards direction.\n                } else {\n                    res[i][j] = res[i][j - 1];\n                    trace[i][j] =\n                        3;  //  means trace the matrix in left direction.\n                }\n            }\n        }\n    }\n    Print(trace, m, n, a);\n    return res[m][n];\n}\n\nint main() {\n    string a, b;\n    cin >> a >> b;\n    cout << lcs(a, b);\n    return 0;\n}\n","index":59},{"title":"Longest Increasing Subsequence","category":"dynamic_programming","id":"longest_increasing_subsequence_dynamic_programming","algorithm":"// Program to calculate length of longest increasing subsequence in an array\n#include <bits/stdc++.h>\nusing namespace std;\nint LIS(int a[], int n) {\n    int lis[n];\n    for (int i = 0; i < n; ++i) {\n        lis[i] = 1;\n    }\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            if (a[i] > a[j] && lis[i] < lis[j] + 1)\n                lis[i] = lis[j] + 1;\n        }\n    }\n    int res = 0;\n    for (int i = 0; i < n; ++i) {\n        res = max(res, lis[i]);\n    }\n    return res;\n}\nint main(int argc, char const *argv[]) {\n    int n;\n    cout << \"Enter size of array: \";\n    cin >> n;\n    int a[n];\n    cout << \"Enter array elements: \";\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n    }\n    cout << LIS(a, n) << endl;\n    return 0;\n}","index":60},{"title":"Longest Increasing Subsequence (nlogn)","category":"dynamic_programming","id":"longest_increasing_subsequence_(nlogn)_dynamic_programming","algorithm":"// Program to calculate length of longest increasing subsequence in an array\n// in O(n log n)\n// tested on : https://cses.fi/problemset/task/1145/\n\n#include <iostream>\n\nusing namespace std;\nint LIS(int arr[], int n) {\n    set<int> active;  // The current built LIS.\n    active.insert(arr[0]);\n    // Loop through every element.\n    for (int i = 1; i < n; ++i) {\n        auto get = active.lower_bound(arr[i]);\n        if (get == active.end()) {\n            active.insert(arr[i]);\n        }  // current element is the greatest so LIS increases by 1.\n        else {\n            int val = *get;  // we find the position where arr[i] will be in the\n                             // LIS. If it is in the LIS already we do nothing\n            if (val > arr[i]) {\n                // else we remove the bigger element and add a smaller element\n                // (which is arr[i]) and continue;\n                active.erase(get);\n                active.insert(arr[i]);\n            }\n        }\n    }\n    return active.size();  // size of the LIS.\n}\nint main(int argc, char const* argv[]) {\n    int n;\n    cout << \"Enter size of array: \";\n    cin >> n;\n    int a[n];\n    cout << \"Enter array elements: \";\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n    }\n    cout << LIS(a, n) << endl;\n    return 0;\n}\n","index":61},{"title":"Matrix Chain Multiplication","category":"dynamic_programming","id":"matrix_chain_multiplication_dynamic_programming","algorithm":"#include <climits>\n#include <iostream>\nusing namespace std;\n\n#define MAX 10\n\n// dp table to store the solution for already computed sub problems\nint dp[MAX][MAX];\n\n// Function to find the most efficient way to multiply the given sequence of\n// matrices\nint MatrixChainMultiplication(int dim[], int i, int j) {\n    // base case: one matrix\n    if (j <= i + 1)\n        return 0;\n\n    // stores minimum number of scalar multiplications (i.e., cost)\n    // needed to compute the matrix M[i+1]...M[j] = M[i..j]\n    int min = INT_MAX;\n\n    // if dp[i][j] is not calculated (calculate it!!)\n\n    if (dp[i][j] == 0) {\n        // take the minimum over each possible position at which the\n        // sequence of matrices can be split\n\n        for (int k = i + 1; k <= j - 1; k++) {\n            // recur for M[i+1]..M[k] to get a i x k matrix\n            int cost = MatrixChainMultiplication(dim, i, k);\n\n            // recur for M[k+1]..M[j] to get a k x j matrix\n            cost += MatrixChainMultiplication(dim, k, j);\n\n            // cost to multiply two (i x k) and (k x j) matrix\n            cost += dim[i] * dim[k] * dim[j];\n\n            if (cost < min)\n                min = cost;  // store the minimum cost\n        }\n        dp[i][j] = min;\n    }\n\n    // return min cost to multiply M[j+1]..M[j]\n    return dp[i][j];\n}\n\n// main function\nint main() {\n    // Matrix i has Dimensions dim[i-1] & dim[i] for i=1..n\n    // input is 10 x 30 matrix, 30 x 5 matrix, 5 x 60 matrix\n    int dim[] = {10, 30, 5, 60};\n    int n = sizeof(dim) / sizeof(dim[0]);\n\n    // Function Calling: MatrixChainMultiplications(dimensions_array, starting,\n    // ending);\n\n    cout << \"Minimum cost is \" << MatrixChainMultiplication(dim, 0, n - 1)\n         << \"\\n\";\n\n    return 0;\n}","index":62},{"title":"Searching Of Element In Dynamic Array","category":"dynamic_programming","id":"searching_of_element_in_dynamic_array_dynamic_programming","algorithm":"/*\n *this program is use to find any elemet in any row with variable array size\n *aplication of pointer is use in it\n *important point start from here to:\n *the index value of array can be go to 1 to 100000\n *check till array[1000]\n *end here\n *how to work example:\n **Question:\n ***number of array 2\n ***quarry 3\n ***array 1 is {1 2 3 4 5}\n ***array 2 is {6 7}\n ****i) what is 2nd element in 1st array\n ****ii) what is 1st element in 2nd array\n ****iii) what is 5th element in 1st array\n *****output:\n *****Enter Number of array you want to Store : 2\n *****Enter Number of Question or Quary you want to do Related to Array : 3\n *****Enter number of element in 1 rows : 5\n *****Enter the element of Array 1 2 3 4 5\n *****Enter number of element in 2 rows : 2\n *****Enter the element of Array 6 7\n *****enter the number of row which element You want to find : 1\n *****enter the position of element which You want to find : 2\n *****The element is 2\n *****enter the number of row which element You want to find : 2\n *****enter the position of element which You want to find : 1\n *****The element is 6\n *****enter the number of row which element You want to find : 1\n *****enter the position of element which You want to find : 5\n *****The element is 5\n */\n#include <iostream>\n\n// this is main fuction\n// ***\nint main() {\n    int64_t r, mr = 0, x, q, i, z;\n    std::cout << \"Enter Number of array you want to Store :\";\n    std::cin >> x;\n    std::cout << \"Enter Number of \";\n    std::cout << \"Question or Quary you \";\n    std::cout << \"want to do Related to Array :\";\n    std::cin >> q;\n    // create a Array in run time because use can\n    // change the size of each array which he/she is going to store\n    // create a 2D array\n    int** ar = new int*[x]();\n    // this for loop is use for entering different variable size array\n    // ***\n    for (r = 0; r < x; r++) {\n        std::cout << \"Enter number of element in \" << r + 1 << \" rows :\";\n        std::cin >> mr;\n        // creating a 1D array\n        int* ac = new int[mr]();\n        std::cout << \"Enter the element of Array \";\n        // this for loop is use for storing values in array\n        // ***\n        for (i = 0; i < mr; i++) {\n            // entering the value of rows in array in Horizontal\n            std::cin >> ac[i];\n        }\n        // Change the position of Array so that new arrays entery will be done\n        ar[r] = ac;\n    }\n    // this for loop is use for display result of querry\n    // ***\n    for (z = 0; z < q; z++) {\n        int64_t r1 = 0, q1 = 0;\n        std::cout << \"enter the number of row which element you want to find :\";\n        std::cin >> r1;\n        r1 = r1 - 1;\n        std::cout << \"enter the position of element which you want to find :\";\n        std::cin >> q1;\n        q1 = q1 - 1;\n        // use this to find desire position of element in desire array\n        std::cout << \"The element is \" << ar[r1][q1] << std::endl;\n    }\n}\n","index":63},{"title":"Shortest Common Supersequence","category":"dynamic_programming","id":"shortest_common_supersequence_dynamic_programming","algorithm":"/**\n * @file\n * @brief SCS is a string Z which is the shortest supersequence of strings X and Y (may not be continuous in Z, but order is maintained).\n *\n * @details\n * The idea is to use lookup table method as used in LCS.\n * For example: example 1:-\n * X: 'ABCXYZ', Y: 'ABZ' then Z will be 'ABCXYZ' (y is not continuous but in order)\n * \n * For example: example 2:-\n * X: 'AGGTAB', Y: 'GXTXAYB' then Z will be 'AGGXTXAYB'\n * @author [Ridhish Jain](https://github.com/ridhishjain)\n * @see more on [SCS](https://en.wikipedia.org/wiki/Shortest_common_supersequence_problem)\n * @see related problem [Leetcode](https://leetcode.com/problems/shortest-common-supersequence/)\n*/\n\n// header files\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\n/**\n * @namespace dynamic_programming\n * @brief Dynamic Programming algorithms\n*/\nnamespace dynamic_programming {\n\n    /**\n    * @namespace shortest_common_supersequence\n    * @brief Shortest Common Super Sequence algorithm\n    */\n    namespace shortest_common_supersequence {\n        \n        /**\n         * Function implementing Shortest Common Super-Sequence algorithm using look-up table method.\n         * @param str1 first string 'X'\n         * @param str2 second string 'Y'\n         * @returns string 'Z', superSequence of X and Y \n        */\n        std::string scs(const std::string &str1, const std::string &str2) {\n\n            // Edge cases\n            // If either str1 or str2 or both are empty\n            if(str1.empty() && str2.empty()) {\n                return \"\";\n            }\n            else if(str1.empty()) {\n                return str2;\n            }\n            else if(str2.empty()) {\n                return str1;\n            }\n\n            // creating lookup table\n            std::vector <std::vector <int>> lookup(str1.length() + 1, std::vector <int> (str2.length() + 1, 0));\n      \n            for(int i=1; i <= str1.length(); i++) {\n                for(int j=1; j <= str2.length(); j++) {\n                    if(str1[i-1] == str2[j-1]) {\n                        lookup[i][j] = lookup[i-1][j-1] + 1;\n                    }\n                    else {\n                        lookup[i][j] = std::max(lookup[i-1][j], lookup[i][j-1]);\n                    }\n                }\n            }\n\n            // making supersequence\n            // i and j are initially pointed towards end of strings\n            // Super-sequence will be constructed backwards\n            int i=str1.length();\n            int j=str2.length();\n            std::string s;\n      \n            while(i>0 && j>0) {\n\n                // If the characters at i and j of both strings are same\n                // We only need to add them once in s\n                if(str1[i-1] == str2[j-1]) {\n                    s.push_back(str1[i-1]);\n                    i--;\n                    j--;\n                }\n                // otherwise we check lookup table for recurrences of characters\n                else {\n                    if(lookup[i-1][j] > lookup[i][j-1]) {\n                        s.push_back(str1[i-1]);\n                        i--;\n                    }\n                    else {\n                        s.push_back(str2[j-1]);\n                        j--;\n                    }\n                }\n            }\n\n            // copying remaining elements\n            // if j becomes 0 before i\n            while(i > 0) {\n                s.push_back(str1[i-1]);\n                i--;\n            }\n\n            // if i becomes 0 before j\n            while(j > 0) {\n                s.push_back(str2[j-1]);\n                j--;\n            }\n\n            // As the super sequence is constructd backwards\n            // reversing the string before returning gives us the correct output  \n            reverse(s.begin(), s.end());\n            return s;\n        }\n    } // namespace shortest_common_supersequence\n} // namespace dynamic_programming\n\n/** \n * Test Function\n * @return void \n*/\nstatic void test() {\n    // custom input vector\n    std::vector <std::vector <std::string>> scsStrings {\n        {\"ABCXYZ\", \"ABZ\"},\n        {\"ABZ\", \"ABCXYZ\"},\n        {\"AGGTAB\", \"GXTXAYB\"},\n        {\"X\", \"Y\"},\n    };\n\n    // calculated output vector by scs function\n    std::vector <std::string> calculatedOutput(4, \"\");\n    int i=0;\n    for(auto & scsString : scsStrings) {\n        \n        calculatedOutput[i] = dynamic_programming::shortest_common_supersequence::scs(\n            scsString[0], scsString[1]\n        );\n        i++;\n    }\n\n    // expected output vector acc to problem statement\n    std::vector <std::string> expectedOutput {\n        \"ABCXYZ\",\n        \"ABCXYZ\",\n        \"AGGXTXAYB\",\n        \"XY\"\n    };\n\n    // Testing implementation via assert function\n    // It will throw error if any of the expected test fails\n    // Else it will give nothing\n    for(int i=0; i < scsStrings.size(); i++) {\n        assert(expectedOutput[i] == calculatedOutput[i]);\n    }\n\n    std::cout << \"All tests passed successfully!\\n\";\n    return;\n}\n\n/** Main function (driver code)*/\nint main() {\n    // test for implementation\n    test();\n\n    // user input\n    std::string s1, s2;\n    std::cin >> s1;\n    std::cin >> s2;\n\n    std::string ans;\n\n    // user output\n    ans = dynamic_programming::shortest_common_supersequence::scs(s1, s2);\n    std::cout << ans;\n    return 0;\n}\n","index":64},{"title":"Tree Height","category":"dynamic_programming","id":"tree_height_dynamic_programming","algorithm":"// C++ Program to find height of the tree using bottom-up dynamic programming.\n\n/*\n * Given a rooted tree with node 1.\n * Task is to find the height of the tree.\n * Example: -\n * 4\n * 1 2\n * 1 3\n * 2 4\n * which can be represented as\n *   1\n *  / \\\n * 2   3\n * |\n * 4\n *\n * Height of the tree : - 2\n */\n\n#include <iostream>\n#include <vector>\n\n// global declarations\n// no of nodes max limit.\nconst int MAX = 1e5;\n// adjacency list\nstd::vector<int> adj[MAX];\nstd::vector<bool> visited;\nstd::vector<int> dp;\n\nvoid depth_first_search(int u) {\n    visited[u] = true;\n    int child_height = 1;\n    for (int v : adj[u]) {\n        if (!visited[v]) {\n            depth_first_search(v);\n\n            // select maximum sub-tree height from all children.\n            child_height = std::max(child_height, dp[v] + 1);\n        }\n    }\n    // assigned the max child height to current visited node.\n    dp[u] = child_height;\n}\n\nint main() {\n    // number of nodes\n    int number_of_nodes;\n    std::cout << \"Enter number of nodes of the tree : \" << std::endl;\n    std::cin >> number_of_nodes;\n\n    // u, v denotes an undirected edge of tree.\n    int u, v;\n    // Tree contains exactly n-1 edges where n denotes the number of nodes.\n    std::cout << \"Enter edges of the tree : \" << std::endl;\n    for (int i = 0; i < number_of_nodes - 1; i++) {\n        std::cin >> u >> v;\n        // undirected tree u -> v and v -> u.\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    // initialize all nodes as unvisited.\n    visited.assign(number_of_nodes + 1, false);\n    // initialize depth of all nodes to 0.\n    dp.assign(number_of_nodes + 1, 0);\n    // function call which will initialize the height of all nodes.\n    depth_first_search(1);\n    std::cout << \"Height of the Tree : \" << dp[1] << std::endl;\n}\n","index":65},{"title":"Geometry","category":null,"id":"geometry","index":66},{"title":"Jarvis Algorithm","category":"geometry","id":"jarvis_algorithm_geometry","algorithm":"/**\n * @file\n * @brief Implementation of [Jarvis’s](https://en.wikipedia.org/wiki/Gift_wrapping_algorithm) algorithm.\n *\n * @details\n * Given a set of points in the plane. the convex hull of the set\n * is the smallest convex polygon that contains all the points of it.\n *\n * ### Algorithm\n * The idea of Jarvis’s Algorithm is simple, we start from the leftmost point\n * (or point with minimum x coordinate value) and we\n * keep wrapping points in counterclockwise direction.\n *\n * The idea is to use orientation() here. Next point is selected as the\n * point that beats all other points at counterclockwise orientation, i.e.,\n * next point is q if for any other point r,\n * we have “orientation(p, q, r) = counterclockwise”.\n *\n * For Example,\n * If points = {{0, 3}, {2, 2}, {1, 1}, {2, 1},\n                      {3, 0}, {0, 0}, {3, 3}};\n *\n * then the convex hull is\n * (0, 3), (0, 0), (3, 0), (3, 3)\n *\n * @author [Rishabh Agarwal](https://github.com/rishabh-997)\n */\n\n#include <vector>\n#include <cassert>\n#include <iostream>\n\n/**\n *  @namespace geometry\n *  @brief Geometry algorithms\n */\nnamespace geometry {\n    /**\n     * @namespace jarvis\n     * @brief Functions for [Jarvis’s](https://en.wikipedia.org/wiki/Gift_wrapping_algorithm) algorithm\n     */\n    namespace jarvis {\n        /**\n         * Structure defining the x and y co-ordinates of the given\n         * point in space\n         */\n        struct Point {\n            int x, y;\n        };\n\n        /**\n         * Class which can be called from main and is globally available\n         * throughout the code\n         */\n        class Convexhull {\n            std::vector<Point> points;\n            int size;\n\n        public:\n            /**\n             * Constructor of given class\n             *\n             * @param pointList list of all points in the space\n             * @param n number of points in space\n             */\n            explicit Convexhull(const std::vector<Point> &pointList) {\n                points = pointList;\n                size = points.size();\n            }\n\n            /**\n             * Creates convex hull of a set of n points.\n             * There must be 3 points at least for the convex hull to exist\n             *\n             * @returns an vector array containing points in space\n             * which enclose all given points thus forming a hull\n             */\n            std::vector<Point> getConvexHull() const {\n                // Initialize Result\n                std::vector<Point> hull;\n\n                // Find the leftmost point\n                int leftmost_point = 0;\n                for (int i = 1; i < size; i++) {\n                    if (points[i].x < points[leftmost_point].x) {\n                        leftmost_point = i;\n                    }\n                }\n                // Start from leftmost point, keep moving counterclockwise\n                // until reach the start point again.  This loop runs O(h)\n                // times where h is number of points in result or output.\n                int p = leftmost_point, q = 0;\n                do {\n                    // Add current point to result\n                    hull.push_back(points[p]);\n\n                    // Search for a point 'q' such that orientation(p, x, q)\n                    // is counterclockwise for all points 'x'. The idea\n                    // is to keep track of last visited most counter clock-\n                    // wise point in q. If any point 'i' is more counter clock-\n                    // wise than q, then update q.\n                    q = (p + 1) % size;\n                    for (int i = 0; i < size; i++) {\n                        // If i is more counterclockwise than current q, then\n                        // update q\n                        if (orientation(points[p], points[i], points[q]) == 2) {\n                            q = i;\n                        }\n                    }\n\n                    // Now q is the most counterclockwise with respect to p\n                    // Set p as q for next iteration, so that q is added to\n                    // result 'hull'\n                    p = q;\n\n                } while (p != leftmost_point);        // While we don't come to first point\n\n                return hull;\n            }\n\n            /**\n             * This function returns the geometric orientation for the three points\n             * in a space, ie, whether they are linear ir clockwise or\n             * anti-clockwise\n             * @param p first point selected\n             * @param q adjacent point for q\n             * @param r adjacent point for q\n             *\n             * @returns 0 -> Linear\n             * @returns 1 -> Clock Wise\n             * @returns 2 -> Anti Clock Wise\n             */\n            static int orientation(const Point &p, const Point &q, const Point &r) {\n                int val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n\n                if (val == 0) {\n                    return 0;\n                }\n                return (val > 0) ? 1 : 2;\n            }\n\n        };\n\n    } // namespace jarvis\n} // namespace geometry\n\n/**\n * Test function\n * @returns void\n */\nstatic void test() {\n    std::vector<geometry::jarvis::Point> points = {{0, 3},\n                                                   {2, 2},\n                                                   {1, 1},\n                                                   {2, 1},\n                                                   {3, 0},\n                                                   {0, 0},\n                                                   {3, 3}\n    };\n    geometry::jarvis::Convexhull hull(points);\n    std::vector<geometry::jarvis::Point> actualPoint;\n    actualPoint = hull.getConvexHull();\n\n    std::vector<geometry::jarvis::Point> expectedPoint = {{0, 3},\n                                                          {0, 0},\n                                                          {3, 0},\n                                                          {3, 3}};\n    for (int i = 0; i < expectedPoint.size(); i++) {\n        assert(actualPoint[i].x == expectedPoint[i].x);\n        assert(actualPoint[i].y == expectedPoint[i].y);\n    }\n    std::cout << \"Test implementations passed!\\n\";\n}\n\n/** Driver Code */\nint main() {\n    test();\n    return 0;\n}\n","index":67},{"title":"Line Segment Intersection","category":"geometry","id":"line_segment_intersection_geometry","algorithm":"/**\n * @file\n * @brief check whether two line segments intersect each other\n * or not.\n */\n#include <algorithm>\n#include <iostream>\n\n/**\n * Define a Point.\n */\nstruct Point {\n    int x;  /// Point respect to x coordinate\n    int y;  /// Point respect to y coordinate\n};\n\n/**\n * intersect returns true if segments of two line intersects and\n * false if they do not. It calls the subroutines direction\n * which computes the orientation.\n */\nstruct SegmentIntersection {\n    inline bool intersect(Point first_point, Point second_point,\n                          Point third_point, Point forth_point) {\n        int direction1 = direction(third_point, forth_point, first_point);\n        int direction2 = direction(third_point, forth_point, second_point);\n        int direction3 = direction(first_point, second_point, third_point);\n        int direction4 = direction(first_point, second_point, forth_point);\n\n        if ((direction1 < 0 || direction2 > 0) &&\n            (direction3 < 0 || direction4 > 0))\n            return true;\n\n        else if (direction1 == 0 &&\n                 on_segment(third_point, forth_point, first_point))\n            return true;\n\n        else if (direction2 == 0 &&\n                 on_segment(third_point, forth_point, second_point))\n            return true;\n\n        else if (direction3 == 0 &&\n                 on_segment(first_point, second_point, third_point))\n            return true;\n\n        else if (direction3 == 0 &&\n                 on_segment(first_point, second_point, forth_point))\n            return true;\n\n        else\n            return false;\n    }\n\n    /**\n     * We will find direction of line here respect to @first_point.\n     * Here @second_point and @third_point is first and second points\n     * of the line respectively. we want a method to determine which way a\n     * given angle these three points turns. If returned number is negative,\n     * then the angle is counter-clockwise. That means the line is going to\n     * right to left. We will fount angle as clockwise if the method returns\n     * positive number.\n     */\n    inline int direction(Point first_point, Point second_point,\n                         Point third_point) {\n        return ((third_point.x - first_point.x) *\n                (second_point.y - first_point.y)) -\n               ((second_point.x - first_point.x) *\n                (third_point.y - first_point.y));\n    }\n\n    /**\n     * This method determines whether a point known to be colinear\n     * with a segment lies on that segment.\n     */\n    inline bool on_segment(Point first_point, Point second_point,\n                           Point third_point) {\n        if (std::min(first_point.x, second_point.x) <= third_point.x &&\n            third_point.x <= std::max(first_point.x, second_point.x) &&\n            std::min(first_point.y, second_point.y) <= third_point.y &&\n            third_point.y <= std::max(first_point.y, second_point.y))\n            return true;\n\n        else\n            return false;\n    }\n};\n\n/**\n * This is the main function to test whether the algorithm is\n * working well.\n */\nint main() {\n    SegmentIntersection segment;\n    Point first_point, second_point, third_point, forth_point;\n\n    std::cin >> first_point.x >> first_point.y;\n    std::cin >> second_point.x >> second_point.y;\n    std::cin >> third_point.x >> third_point.y;\n    std::cin >> forth_point.x >> forth_point.y;\n\n    printf(\"%d\", segment.intersect(first_point, second_point, third_point,\n                                   forth_point));\n    std::cout << std::endl;\n}\n","index":68},{"title":"Graph","category":null,"id":"graph","index":69},{"title":"Breadth First Search","category":"graph","id":"breadth_first_search_graph","algorithm":"/**\n *\n * \\file\n * \\brief [Breadth First Search Algorithm\n * (Breadth First Search)](https://en.wikipedia.org/wiki/Breadth-first_search)\n *\n * \\author [Ayaan Khan](http://github.com/ayaankhan98)\n *\n * \\details\n * Breadth First Search also quoted as BFS is a Graph Traversal Algorithm.\n * Time Complexity O(|V| + |E|) where V are the number of vertices and E\n * are the number of edges in the graph.\n *\n * Applications of Breadth First Search are\n *\n * 1. Finding shortest path between two vertices say u and v, with path\n *    length measured by number of edges (an advantage over depth first\n *    search algorithm)\n * 2. Ford-Fulkerson Method for computing the maximum flow in a flow network.\n * 3. Testing bipartiteness of a graph.\n * 4. Cheney's Algorithm, Copying garbage collection.\n *\n * And there are many more...\n *\n * <h4>working</h4>\n * In the implementation below we first created a graph using the adjacency\n * list representation of graph.\n * Breadth First Search Works as follows\n * it requires a vertex as a start vertex, Start vertex is that vertex\n * from where you want to start traversing the graph.\n * We maintain a bool array or a vector to keep track of the vertices\n * which we have visited so that we do not traverse the visited vertices\n * again and again and eventually fall into an infinite loop. Along with this\n * boolen array we use a Queue.\n *\n * 1. First we mark the start vertex as visited.\n * 2. Push this visited vertex in the Queue.\n * 3. while the queue is not empty we repeat the following steps\n *\n *      1. Take out an element from the front of queue\n *      2. Explore the adjacency list of this vertex\n *         if element in the adjacency list is not visited then we\n *         push that element into the queue and mark this as visited\n *\n */\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <queue>\n#include <vector>\n\n/**\n * \\namespace graph\n * \\brief Graph algorithms\n */\nnamespace graph {\n/**\n * \\brief\n * Adds a directed edge from vertex u to vertex v.\n *\n * @param graph Adjacency list representation of graph\n * @param u first vertex\n * @param v second vertex\n *\n */\nvoid add_directed_edge(std::vector<std::vector<int>> *graph, int u, int v) {\n    (*graph)[u].push_back(v);\n}\n\n/**\n * \\brief\n * Adds an undirected edge from vertex u to vertex v.\n * Essentially adds too directed edges to the adjacency list reprsentation\n * of the graph.\n *\n * @param graph Adjacency list representation of graph\n * @param u first vertex\n * @param v second vertex\n *\n */\nvoid add_undirected_edge(std::vector<std::vector<int>> *graph, int u, int v) {\n    add_directed_edge(graph, u, v);\n    add_directed_edge(graph, v, u);\n}\n\n/**\n * \\brief\n * Function performs the breadth first search algorithm over the graph\n *\n * @param graph Adjacency list representation of graph\n * @param start vertex from where traversing starts\n * @returns a binary vector indicating which vertices were visited during the\n * search.\n *\n */\nstd::vector<bool> breadth_first_search(\n    const std::vector<std::vector<int>> &graph, int start) {\n    /// vector to keep track of visited vertices\n    std::vector<bool> visited(graph.size(), false);\n    /// a queue that stores vertices that need to be further explored\n    std::queue<int> tracker;\n\n    /// mark the starting vertex as visited\n    visited[start] = true;\n    tracker.push(start);\n    while (!tracker.empty()) {\n        size_t vertex = tracker.front();\n        tracker.pop();\n        for (auto x : graph[vertex]) {\n            /// if the vertex is not visited then mark it as visited\n            /// and push it to the queue\n            if (!visited[x]) {\n                visited[x] = true;\n                tracker.push(x);\n            }\n        }\n    }\n    return visited;\n}\n}  // namespace graph\n\nvoid tests() {\n    /// Test 1 Begin\n    std::vector<std::vector<int>> graph(4, std::vector<int>());\n    graph::add_undirected_edge(&graph, 0, 1);\n    graph::add_undirected_edge(&graph, 1, 2);\n    graph::add_undirected_edge(&graph, 2, 3);\n\n    std::vector<bool> returned_result = graph::breadth_first_search(graph, 2);\n    std::vector<bool> correct_result = {true, true, true, true};\n\n    assert(std::equal(correct_result.begin(), correct_result.end(),\n                      returned_result.begin()));\n    std::cout << \"Test 1 Passed...\" << std::endl;\n\n    /// Test 2 Begin\n    returned_result = graph::breadth_first_search(graph, 0);\n\n    assert(std::equal(correct_result.begin(), correct_result.end(),\n                      returned_result.begin()));\n    std::cout << \"Test 2 Passed...\" << std::endl;\n\n    /// Test 3 Begins\n    graph.clear();\n    graph.resize(6);\n    graph::add_directed_edge(&graph, 0, 1);\n    graph::add_directed_edge(&graph, 0, 2);\n    graph::add_directed_edge(&graph, 1, 3);\n    graph::add_directed_edge(&graph, 2, 3);\n    graph::add_directed_edge(&graph, 1, 4);\n    graph::add_directed_edge(&graph, 3, 5);\n\n    returned_result = graph::breadth_first_search(graph, 2);\n    correct_result = {false, false, true, true, false, true};\n\n    assert(std::equal(correct_result.begin(), correct_result.end(),\n                      returned_result.begin()));\n    std::cout << \"Test 3 Passed...\" << std::endl;\n}\n\n/** Main function */\nint main() {\n    tests();\n\n    size_t vertices = 0, edges = 0;\n    std::cout << \"Enter the number of vertices: \";\n    std::cin >> vertices;\n    std::cout << \"Enter the number of edges: \";\n    std::cin >> edges;\n\n    std::vector<std::vector<int>> graph(vertices);\n\n    std::cout << \"Enter space-separated pairs of vertices that form edges: \"\n              << std::endl;\n    while (edges--) {\n        int u = 0, v = 0;\n        std::cin >> u >> v;\n        // Decrement the vertex index so that we can read more convenint\n        // 1-based indexing from the user input.\n        graph::add_directed_edge(&graph, u - 1, v - 1);\n    }\n\n    graph::breadth_first_search(graph, 0);\n    return 0;\n}\n","index":70},{"title":"Bridge Finding With Tarjan Algorithm","category":"graph","id":"bridge_finding_with_tarjan_algorithm_graph","algorithm":"/*\n *  Copyright : 2020 , MIT\n *  Author : Amit Kumar (offamitkumar)\n *  Last Modified Date: May 24, 2020\n *\n */\n#include <algorithm>  //  for min & max\n#include <iostream>   //  for cout\n#include <vector>     //  for std::vector\n\nclass Solution {\n    std::vector<std::vector<int>> graph;\n    std::vector<int> in_time, out_time;\n    int timer = 0;\n    std::vector<std::vector<int>> bridge;\n    std::vector<bool> visited;\n    void dfs(int current_node, int parent) {\n        visited.at(current_node) = true;\n        in_time[current_node] = out_time[current_node] = timer++;\n        for (auto& itr : graph[current_node]) {\n            if (itr == parent) {\n                continue;\n            }\n            if (!visited[itr]) {\n                dfs(itr, current_node);\n                if (out_time[itr] > in_time[current_node]) {\n                    bridge.push_back({itr, current_node});\n                }\n            }\n            out_time[current_node] =\n                std::min(out_time[current_node], out_time[itr]);\n        }\n    }\n\n public:\n    std::vector<std::vector<int>> search_bridges(\n        int n, const std::vector<std::vector<int>>& connections) {\n        timer = 0;\n        graph.resize(n);\n        in_time.assign(n, 0);\n        visited.assign(n, false);\n        out_time.assign(n, 0);\n        for (auto& itr : connections) {\n            graph.at(itr[0]).push_back(itr[1]);\n            graph.at(itr[1]).push_back(itr[0]);\n        }\n        dfs(0, -1);\n        return bridge;\n    }\n};\n\n/**\n * Main function\n */\nint main() {\n    Solution s1;\n    int number_of_node = 5;\n    std::vector<std::vector<int>> node;\n    node.push_back({0, 1});\n    node.push_back({1, 3});\n    node.push_back({1, 2});\n    node.push_back({2, 4});\n    /*\n     *     0 <--> 1 <---> 2\n     *            ^       ^\n     *            |       |\n     *            |       |\n     *            \\/     \\/\n     *            3       4\n     *\n     *    In this graph there are 4 bridges [0,2] , [2,4] , [3,5] , [1,2]\n     *\n     *    I assumed that the graph is bi-directional and connected.\n     *\n     */\n    std::vector<std::vector<int>> bridges =\n        s1.search_bridges(number_of_node, node);\n    std::cout << bridges.size() << \" bridges found!\\n\";\n    for (auto& itr : bridges) {\n        std::cout << itr[0] << \" --> \" << itr[1] << '\\n';\n    }\n    return 0;\n}\n","index":71},{"title":"Connected Components","category":"graph","id":"connected_components_graph","algorithm":"/**\n *\n * \\file\n * \\brief [Graph Connected Components\n * (Connected Components)]\n * (https://en.wikipedia.org/wiki/Component_(graph_theory))\n *\n * \\author [Ayaan Khan](http://github.com/ayaankhan98)\n *\n * \\details\n * A graph is a collection of nodes also called vertices and these vertices\n * are connected by edges. A connected component in a graph refers to a set of\n * vertices which are reachable form one another.\n *\n * <pre>\n * Example - Here is graph with 3 connected components\n *\n *      1   4           5               8\n *     / \\ /           / \\             / \\\n *    2---3           6   7           9   10\n *\n *    first          second           third\n *    component      component        component\n * </pre>\n *\n */\n\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\n\n/**\n * @namespace graph\n * @brief Graph Algorithms\n */\n\nnamespace graph {\n/**\n * @brief Function that add edge between two nodes or vertices of graph\n *\n * @param adj adjacency list of graph.\n * @param u any node or vertex of graph.\n * @param v any node or vertex of graph.\n */\nvoid addEdge(std::vector<std::vector<int>> *adj, int u, int v) {\n    (*adj)[u - 1].push_back(v - 1);\n    (*adj)[v - 1].push_back(u - 1);\n}\n\n/**\n * @brief Utility function for depth first seach algorithm\n * this function explores the vertex which is passed into.\n *\n * @param adj adjacency list of graph.\n * @param u vertex or node to be explored.\n * @param visited already visited vertices.\n */\nvoid explore(const std::vector<std::vector<int>> *adj, int u,\n             std::vector<bool> *visited) {\n    (*visited)[u] = true;\n    for (auto v : (*adj)[u]) {\n        if (!(*visited)[v]) {\n            explore(adj, v, visited);\n        }\n    }\n}\n\n/**\n * @brief Function that perfoms depth first search algorithm on graph\n * and calculated the number of connected components.\n *\n * @param adj adjacency list of graph.\n *\n * @return connected_components number of connected components in graph.\n */\nint getConnectedComponents(const std::vector<std::vector<int>> *adj) {\n    int n = adj->size();\n    int connected_components = 0;\n    std::vector<bool> visited(n, false);\n\n    for (int i = 0; i < n; i++) {\n        if (!visited[i]) {\n            explore(adj, i, &visited);\n            connected_components++;\n        }\n    }\n    return connected_components;\n}\n}  // namespace graph\n\n/** Function to test the algorithm */\nvoid tests() {\n    std::cout << \"Running predefined tests...\" << std::endl;\n    std::cout << \"Initiating Test 1...\" << std::endl;\n    std::vector<std::vector<int>> adj1(9, std::vector<int>());\n    graph::addEdge(&adj1, 1, 2);\n    graph::addEdge(&adj1, 1, 3);\n    graph::addEdge(&adj1, 3, 4);\n    graph::addEdge(&adj1, 5, 7);\n    graph::addEdge(&adj1, 5, 6);\n    graph::addEdge(&adj1, 8, 9);\n\n    assert(graph::getConnectedComponents(&adj1) == 3);\n    std::cout << \"Test 1 Passed...\" << std::endl;\n\n    std::cout << \"Innitiating Test 2...\" << std::endl;\n    std::vector<std::vector<int>> adj2(10, std::vector<int>());\n    graph::addEdge(&adj2, 1, 2);\n    graph::addEdge(&adj2, 1, 3);\n    graph::addEdge(&adj2, 1, 4);\n    graph::addEdge(&adj2, 2, 3);\n    graph::addEdge(&adj2, 3, 4);\n    graph::addEdge(&adj2, 4, 8);\n    graph::addEdge(&adj2, 4, 10);\n    graph::addEdge(&adj2, 8, 10);\n    graph::addEdge(&adj2, 8, 9);\n    graph::addEdge(&adj2, 5, 7);\n    graph::addEdge(&adj2, 5, 6);\n    graph::addEdge(&adj2, 6, 7);\n\n    assert(graph::getConnectedComponents(&adj2) == 2);\n    std::cout << \"Test 2 Passed...\" << std::endl;\n}\n\n/** Main function */\nint main() {\n    /// running predefined tests\n    tests();\n\n    int vertices = int(), edges = int();\n    std::cout << \"Enter the number of vertices : \";\n    std::cin >> vertices;\n    std::cout << \"Enter the number of edges : \";\n    std::cin >> edges;\n\n    std::vector<std::vector<int>> adj(vertices, std::vector<int>());\n\n    int u = int(), v = int();\n    while (edges--) {\n        std::cin >> u >> v;\n        graph::addEdge(&adj, u, v);\n    }\n\n    int cc = graph::getConnectedComponents(&adj);\n    std::cout << cc << std::endl;\n    return 0;\n}\n","index":72},{"title":"Connected Components With Dsu","category":"graph","id":"connected_components_with_dsu_graph","algorithm":"#include <iostream>\n#include <set>\n#include <vector>\n\nint number_of_nodes;  // denotes number of nodes;\nstd::vector<int> parent;\nstd::vector<int> connected_set_size;\nvoid make_set() {  // function the initialize every node as it's own parent\n    for (int i = 1; i <= number_of_nodes; i++) {\n        parent[i] = i;\n        connected_set_size[i] = 1;\n    }\n}\n// To find the component where following node belongs to\nint find_set(int v) {\n    if (v == parent[v]) {\n        return v;\n    }\n    return parent[v] = find_set(parent[v]);\n}\n\nvoid union_sets(int a, int b) {  // To join 2 components to belong to one\n    a = find_set(a);\n    b = find_set(b);\n    if (a != b) {\n        if (connected_set_size[a] < connected_set_size[b]) {\n            std::swap(a, b);\n        }\n        parent[b] = a;\n        connected_set_size[a] += connected_set_size[b];\n    }\n}\n\nint no_of_connected_components() {  // To find total no of connected components\n    std::set<int> temp;  // temp set to count number of connected components\n    for (int i = 1; i <= number_of_nodes; i++) temp.insert(find_set(i));\n    return temp.size();\n}\n\n// All critical/corner cases have been taken care of.\n// Input your required values: (not hardcoded)\nint main() {\n    std::cin >> number_of_nodes;\n    parent.resize(number_of_nodes + 1);\n    connected_set_size.resize(number_of_nodes + 1);\n    make_set();\n    int edges = 0;\n    std::cin >> edges;  // no of edges in the graph\n    while (edges--) {\n        int node_a = 0, node_b = 0;\n        std::cin >> node_a >> node_b;\n        union_sets(node_a, node_b);\n    }\n    std::cout << no_of_connected_components() << std::endl;\n    return 0;\n}\n","index":73},{"title":"Cycle Check Directed Graph","category":"graph","id":"cycle_check_directed_graph_graph","algorithm":"/**\n * @file cycle_check_directed graph.cpp\n *\n * @brief BFS and DFS algorithms to check for cycle in a directed graph.\n *\n * @author [Anmol3299](mailto:mittalanmol22@gmail.com)\n *\n */\n\n#include <iostream>     // for std::cout\n#include <map>          // for std::map\n#include <queue>        // for std::queue\n#include <stdexcept>    // for throwing errors\n#include <type_traits>  // for std::remove_reference\n#include <utility>      // for std::move\n#include <vector>       // for std::vector\n\n/**\n * Implementation of non-weighted directed edge of a graph.\n *\n * The source vertex of the edge is labelled \"src\" and destination vertex is\n * labelled \"dest\".\n */\nstruct Edge {\n    unsigned int src;\n    unsigned int dest;\n\n    Edge() = delete;\n    ~Edge() = default;\n    Edge(Edge&&) = default;\n    Edge& operator=(Edge&&) = default;\n    Edge(Edge const&) = default;\n    Edge& operator=(Edge const&) = default;\n\n    /** Set the source and destination of the vertex.\n     *\n     * @param source is the source vertex of the edge.\n     * @param destination is the destination vertex of the edge.\n     */\n    Edge(unsigned int source, unsigned int destination)\n        : src(source), dest(destination) {}\n};\n\nusing AdjList = std::map<unsigned int, std::vector<unsigned int>>;\n\n/**\n * Implementation of graph class.\n *\n * The graph will be represented using Adjacency List representation.\n * This class contains 2 data members \"m_vertices\" & \"m_adjList\" used to\n * represent the number of vertices and adjacency list of the graph\n * respectively. The vertices are labelled 0 - (m_vertices - 1).\n */\nclass Graph {\n public:\n    Graph() : m_adjList({}) {}\n    ~Graph() = default;\n    Graph(Graph&&) = default;\n    Graph& operator=(Graph&&) = default;\n    Graph(Graph const&) = default;\n    Graph& operator=(Graph const&) = default;\n\n    /** Create a graph from vertices and adjacency list.\n     *\n     * @param vertices specify the number of vertices the graph would contain.\n     * @param adjList is the adjacency list representation of graph.\n     */\n    Graph(unsigned int vertices, AdjList adjList)\n        : m_vertices(vertices), m_adjList(std::move(adjList)) {}\n\n    /** Create a graph from vertices and adjacency list.\n     *\n     * @param vertices specify the number of vertices the graph would contain.\n     * @param adjList is the adjacency list representation of graph.\n     */\n    Graph(unsigned int vertices, AdjList&& adjList)\n        : m_vertices(vertices), m_adjList(std::move(adjList)) {}\n\n    /** Create a graph from vertices and a set of edges.\n     *\n     * Adjacency list of the graph would be created from the set of edges. If\n     * the source or destination of any edge has a value greater or equal to\n     * number of vertices, then it would throw a range_error.\n     *\n     * @param vertices specify the number of vertices the graph would contain.\n     * @param edges is a vector of edges.\n     */\n    Graph(unsigned int vertices, std::vector<Edge> const& edges)\n        : m_vertices(vertices) {\n        for (auto const& edge : edges) {\n            if (edge.src >= vertices || edge.dest >= vertices) {\n                throw std::range_error(\n                    \"Either src or dest of edge out of range\");\n            }\n            m_adjList[edge.src].emplace_back(edge.dest);\n        }\n    }\n\n    /** Return a const reference of the adjacency list.\n     *\n     * @return const reference to the adjacency list\n     */\n    std::remove_reference<AdjList>::type const& getAdjList() const {\n        return m_adjList;\n    }\n\n    /**\n     * @return number of vertices in the graph.\n     */\n    unsigned int getVertices() const { return m_vertices; }\n\n    /** Add vertices in the graph.\n     *\n     * @param num is the number of vertices to be added. It adds 1 vertex by\n     * default.\n     *\n     */\n    void addVertices(unsigned int num = 1) { m_vertices += num; }\n\n    /** Add an edge in the graph.\n     *\n     * @param edge that needs to be added.\n     */\n    void addEdge(Edge const& edge) {\n        if (edge.src >= m_vertices || edge.dest >= m_vertices) {\n            throw std::range_error(\"Either src or dest of edge out of range\");\n        }\n        m_adjList[edge.src].emplace_back(edge.dest);\n    }\n\n    /** Add an Edge in the graph\n     *\n     * @param source is source vertex of the edge.\n     * @param destination is the destination vertex of the edge.\n     */\n    void addEdge(unsigned int source, unsigned int destination) {\n        if (source >= m_vertices || destination >= m_vertices) {\n            throw std::range_error(\n                \"Either source or destination of edge out of range\");\n        }\n        m_adjList[source].emplace_back(destination);\n    }\n\n private:\n    unsigned int m_vertices = 0;\n    AdjList m_adjList;\n};\n\n/**\n * Check if a directed graph has a cycle or not.\n *\n * This class provides 2 methods to check for cycle in a directed graph:\n * isCyclicDFS & isCyclicBFS.\n *\n * - isCyclicDFS uses DFS traversal method to check for cycle in a graph.\n * - isCyclidBFS used BFS traversal method to check for cycle in a graph.\n */\nclass CycleCheck {\n private:\n    enum nodeStates : uint8_t { not_visited = 0, in_stack, visited };\n\n    /** Helper function of \"isCyclicDFS\".\n     *\n     * @param adjList is the adjacency list representation of some graph.\n     * @param state is the state of the nodes of the graph.\n     * @param node is the node being evaluated.\n     *\n     * @return true if graph has a cycle, else false.\n     */\n    static bool isCyclicDFSHelper(AdjList const& adjList,\n                                  std::vector<nodeStates>* state,\n                                  unsigned int node) {\n        // Add node \"in_stack\" state.\n        (*state)[node] = in_stack;\n\n        // If the node has children, then recursively visit all children of the\n        // node.\n        auto const it = adjList.find(node);\n        if (it != adjList.end()) {\n            for (auto child : it->second) {\n                // If state of child node is \"not_visited\", evaluate that child\n                // for presence of cycle.\n                auto state_of_child = (*state)[child];\n                if (state_of_child == not_visited) {\n                    if (isCyclicDFSHelper(adjList, state, child)) {\n                        return true;\n                    }\n                } else if (state_of_child == in_stack) {\n                    // If child node was \"in_stack\", then that means that there\n                    // is a cycle in the graph. Return true for presence of the\n                    // cycle.\n                    return true;\n                }\n            }\n        }\n\n        // Current node has been evaluated for the presence of cycle and had no\n        // cycle. Mark current node as \"visited\".\n        (*state)[node] = visited;\n        // Return that current node didn't result in any cycles.\n        return false;\n    }\n\n public:\n    /** Driver function to check if a graph has a cycle.\n     *\n     * This function uses DFS to check for cycle in the graph.\n     *\n     * @param graph which needs to be evaluated for the presence of cycle.\n     * @return true if a cycle is detected, else false.\n     */\n    static bool isCyclicDFS(Graph const& graph) {\n        auto vertices = graph.getVertices();\n\n        /** State of the node.\n         *\n         * It is a vector of \"nodeStates\" which represents the state node is in.\n         * It can take only 3 values: \"not_visited\", \"in_stack\", and \"visited\".\n         *\n         * Initially, all nodes are in \"not_visited\" state.\n         */\n        std::vector<nodeStates> state(vertices, not_visited);\n\n        // Start visiting each node.\n        for (unsigned int node = 0; node < vertices; node++) {\n            // If a node is not visited, only then check for presence of cycle.\n            // There is no need to check for presence of cycle for a visited\n            // node as it has already been checked for presence of cycle.\n            if (state[node] == not_visited) {\n                // Check for cycle.\n                if (isCyclicDFSHelper(graph.getAdjList(), &state, node)) {\n                    return true;\n                }\n            }\n        }\n\n        // All nodes have been safely traversed, that means there is no cycle in\n        // the graph. Return false.\n        return false;\n    }\n\n    /** Check if a graph has cycle or not.\n     *\n     * This function uses BFS to check if a graph is cyclic or not.\n     *\n     * @param graph which needs to be evaluated for the presence of cycle.\n     * @return true if a cycle is detected, else false.\n     */\n    static bool isCyclicBFS(Graph const& graph) {\n        auto graphAjdList = graph.getAdjList();\n        auto vertices = graph.getVertices();\n\n        std::vector<unsigned int> indegree(vertices, 0);\n        // Calculate the indegree i.e. the number of incident edges to the node.\n        for (auto const& list : graphAjdList) {\n            auto children = list.second;\n            for (auto const& child : children) {\n                indegree[child]++;\n            }\n        }\n\n        std::queue<unsigned int> can_be_solved;\n        for (unsigned int node = 0; node < vertices; node++) {\n            // If a node doesn't have any input edges, then that node will\n            // definately not result in a cycle and can be visited safely.\n            if (!indegree[node]) {\n                can_be_solved.emplace(node);\n            }\n        }\n\n        // Vertices that need to be traversed.\n        auto remain = vertices;\n        // While there are safe nodes that we can visit.\n        while (!can_be_solved.empty()) {\n            auto solved = can_be_solved.front();\n            // Visit the node.\n            can_be_solved.pop();\n            // Decrease number of nodes that need to be traversed.\n            remain--;\n\n            // Visit all the children of the visited node.\n            auto it = graphAjdList.find(solved);\n            if (it != graphAjdList.end()) {\n                for (auto child : it->second) {\n                    // Check if we can visited the node safely.\n                    if (--indegree[child] == 0) {\n                        // if node can be visited safely, then add that node to\n                        // the visit queue.\n                        can_be_solved.emplace(child);\n                    }\n                }\n            }\n        }\n\n        // If there are still nodes that we can't visit, then it means that\n        // there is a cycle and return true, else return false.\n        return !(remain == 0);\n    }\n};\n\n/**\n * Main function.\n */\nint main() {\n    // Instantiate the graph.\n    Graph g(7, std::vector<Edge>{{0, 1}, {1, 2}, {2, 0}, {2, 5}, {3, 5}});\n    // Check for cycle using BFS method.\n    std::cout << CycleCheck::isCyclicBFS(g) << '\\n';\n\n    // Check for cycle using DFS method.\n    std::cout << CycleCheck::isCyclicDFS(g) << '\\n';\n    return 0;\n}\n","index":74},{"title":"Depth First Search","category":"graph","id":"depth_first_search_graph","algorithm":"/**\n *\n * \\file\n * \\brief [Depth First Search Algorithm\n * (Depth First Search)](https://en.wikipedia.org/wiki/Depth-first_search)\n *\n * \\author [Ayaan Khan](http://github.com/ayaankhan98)\n *\n * \\details\n * Depth First Search also quoted as DFS is a Graph Traversal Algorithm.\n * Time Complexity O(|V| + |E|) where V is number of vertices and E\n * is number of edges in graph.\n *\n * Application of Depth First Search are\n *\n * 1. Finding connected components\n * 2. Finding 2-(edge or vertex)-connected components.\n * 3. Finding 3-(edge or vertex)-connected components.\n * 4. Finding the bridges of a graph.\n * 5. Generating words in order to plot the limit set of a group.\n * 6. Finding strongly connected components.\n *\n * And there are many more...\n *\n * <h4>Working</h4>\n * 1. Mark all vertices as unvisited first\n * 2. start exploring from some starting vertex.\n *\n *      While exploring vertex we mark the vertex as visited\n *      and start exploring the vertices connected to this\n *      vertex in recursive way.\n *\n */\n\n#include <algorithm>\n#include <iostream>\n#include <vector>\n\n/**\n *\n * \\namespace graph\n * \\brief Graph Algorithms\n *\n */\nnamespace graph {\n/**\n * \\brief\n * Adds and edge between two vertices of graph say u and v in this\n * case.\n *\n * @param adj Adjacency list representation of graph\n * @param u first vertex\n * @param v second vertex\n *\n */\nvoid addEdge(std::vector<std::vector<size_t>> *adj, size_t u, size_t v) {\n    /*\n     *\n     * Here we are considering undirected graph that's the\n     * reason we are adding v to the adjacency list representation of u\n     * and also adding u to the adjacency list representation of v\n     *\n     */\n    (*adj)[u - 1].push_back(v - 1);\n    (*adj)[v - 1].push_back(u - 1);\n}\n\n/**\n *\n * \\brief\n * Explores the given vertex, exploring a vertex means traversing\n * over all the vertices which are connected to the vertex that is\n * currently being explored.\n *\n * @param adj garph\n * @param v vertex to be explored\n * @param visited already visited vertices\n *\n */\nvoid explore(const std::vector<std::vector<size_t>> &adj, size_t v,\n             std::vector<bool> *visited) {\n    std::cout << v + 1 << \" \";\n    (*visited)[v] = true;\n    for (auto x : adj[v]) {\n        if (!(*visited)[x]) {\n            explore(adj, x, visited);\n        }\n    }\n}\n\n/**\n * \\brief\n * initiates depth first search algorithm.\n *\n * @param adj adjacency list of graph\n * @param start vertex from where DFS starts traversing.\n *\n */\nvoid depth_first_search(const std::vector<std::vector<size_t>> &adj,\n                        size_t start) {\n    size_t vertices = adj.size();\n\n    std::vector<bool> visited(vertices, false);\n    explore(adj, start, &visited);\n}\n}  // namespace graph\n\n/** Main function */\nint main() {\n    size_t vertices = 0, edges = 0;\n    std::cout << \"Enter the Vertices : \";\n    std::cin >> vertices;\n    std::cout << \"Enter the Edges : \";\n    std::cin >> edges;\n\n    /// creating graph\n    std::vector<std::vector<size_t>> adj(vertices, std::vector<size_t>());\n\n    /// taking input for edges\n    std::cout << \"Enter the vertices which have edges between them : \"\n              << std::endl;\n    while (edges--) {\n        size_t u = 0, v = 0;\n        std::cin >> u >> v;\n        graph::addEdge(&adj, u, v);\n    }\n\n    /// running depth first search over graph\n    graph::depth_first_search(adj, 2);\n\n    std::cout << std::endl;\n    return 0;\n}\n","index":75},{"title":"Depth First Search With Stack","category":"graph","id":"depth_first_search_with_stack_graph","algorithm":"#include <iostream>\n#include <list>\n#include <stack>\n#include <vector>\n\nconstexpr int WHITE = 0;\nconstexpr int GREY = 1;\nconstexpr int BLACK = 2;\nconstexpr int INF = 99999;\n\nvoid dfs(const std::vector<std::list<int> > &graph, int start) {\n    std::vector<int> checked(graph.size(), WHITE);\n    checked[start] = GREY;\n    std::stack<int> stack;\n    stack.push(start);\n    while (!stack.empty()) {\n        int act = stack.top();\n        stack.pop();\n\n        if (checked[act] == GREY) {\n            std::cout << act << ' ';\n            for (auto it : graph[act]) {\n                stack.push(it);\n                if (checked[it] != BLACK) {\n                    checked[it] = GREY;\n                }\n            }\n            checked[act] = BLACK;  // nodo controllato\n        }\n    }\n}\n\nint main() {\n    int n = 0;\n    std::cin >> n;\n    std::vector<std::list<int> > graph(INF);\n    for (int i = 0; i < n; ++i) {\n        int u = 0, w = 0;\n        std::cin >> u >> w;\n        graph[u].push_back(w);\n    }\n\n    dfs(graph, 0);\n\n    return 0;\n}\n","index":76},{"title":"Dijkstra","category":"graph","id":"dijkstra_graph","algorithm":"/**\n * @file\n * @brief [Graph Dijkstras Shortest Path Algorithm\n * (Dijkstra's Shortest Path)]\n * (https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm)\n *\n * @author [Ayaan Khan](http://github.com/ayaankhan98)\n *\n * @details\n * Dijkstra's Algorithm is used to find the shortest path from a source\n * vertex to all other reachable vertex in the graph.\n * The algorithm initially assumes all the nodes are unreachable from the\n * given source vertex so we mark the distances of all vertices as INF\n * (infinity) from source vertex (INF / infinity denotes unable to reach).\n *\n * in similar fashion with BFS we assume the distance of source vertex as 0\n * and pushes the vertex in a priority queue with it's distance.\n * we maintain the priority queue as a min heap so that we can get the\n * minimum element at the top of heap\n *\n * Basically what we do in this algorithm is that we try to minimize the\n * distances of all the reachable vertices from the current vertex, look\n * at the code below to understand in better way.\n *\n */\n#include <cassert>\n#include <iostream>\n#include <limits>\n#include <memory>\n#include <queue>\n#include <utility>\n#include <vector>\n\nconstexpr int64_t INF = std::numeric_limits<int64_t>::max();\n\n/**\n * @namespace graph\n * @brief Graph Algorithms\n */\n\nnamespace graph {\n/**\n * @brief Function that add edge between two nodes or vertices of graph\n *\n * @param u any node or vertex of graph\n * @param v any node or vertex of graph\n */\nvoid addEdge(std::vector<std::vector<std::pair<int, int>>> *adj, int u, int v,\n             int w) {\n    (*adj)[u - 1].push_back(std::make_pair(v - 1, w));\n    // (*adj)[v - 1].push_back(std::make_pair(u - 1, w));\n}\n\n/**\n * @brief Function runs the dijkstra algorithm for some source vertex and\n * target vertex in the graph and returns the shortest distance of target\n * from the source.\n *\n * @param adj input graph\n * @param s source vertex\n * @param t target vertex\n *\n * @return shortest distance if target is reachable from source else -1 in\n * case if target is not reachable from source.\n */\nint dijkstra(std::vector<std::vector<std::pair<int, int>>> *adj, int s, int t) {\n    /// n denotes the number of vertices in graph\n    int n = adj->size();\n\n    /// setting all the distances initially to INF\n    std::vector<int64_t> dist(n, INF);\n\n    /// creating a min heap using priority queue\n    /// first element of pair contains the distance\n    /// second element of pair contains the vertex\n    std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>,\n                        std::greater<std::pair<int, int>>>\n        pq;\n\n    /// pushing the source vertex 's' with 0 distance in min heap\n    pq.push(std::make_pair(0, s));\n\n    /// marking the distance of source as 0\n    dist[s] = 0;\n\n    while (!pq.empty()) {\n        /// second element of pair denotes the node / vertex\n        int currentNode = pq.top().second;\n\n        /// first element of pair denotes the distance\n        int currentDist = pq.top().first;\n\n        pq.pop();\n\n        /// for all the reachable vertex from the currently exploring vertex\n        /// we will try to minimize the distance\n        for (std::pair<int, int> edge : (*adj)[currentNode]) {\n            /// minimizing distances\n            if (currentDist + edge.second < dist[edge.first]) {\n                dist[edge.first] = currentDist + edge.second;\n                pq.push(std::make_pair(dist[edge.first], edge.first));\n            }\n        }\n    }\n    if (dist[t] != INF) {\n        return dist[t];\n    }\n    return -1;\n}\n}  // namespace graph\n\n/** Function to test the Algorithm */\nvoid tests() {\n    std::cout << \"Initiatinig Predefined Tests...\" << std::endl;\n    std::cout << \"Initiating Test 1...\" << std::endl;\n    std::vector<std::vector<std::pair<int, int>>> adj1(\n        4, std::vector<std::pair<int, int>>());\n    graph::addEdge(&adj1, 1, 2, 1);\n    graph::addEdge(&adj1, 4, 1, 2);\n    graph::addEdge(&adj1, 2, 3, 2);\n    graph::addEdge(&adj1, 1, 3, 5);\n\n    int s = 1, t = 3;\n    assert(graph::dijkstra(&adj1, s - 1, t - 1) == 3);\n    std::cout << \"Test 1 Passed...\" << std::endl;\n\n    s = 4, t = 3;\n    std::cout << \"Initiating Test 2...\" << std::endl;\n    assert(graph::dijkstra(&adj1, s - 1, t - 1) == 5);\n    std::cout << \"Test 2 Passed...\" << std::endl;\n\n    std::vector<std::vector<std::pair<int, int>>> adj2(\n        5, std::vector<std::pair<int, int>>());\n    graph::addEdge(&adj2, 1, 2, 4);\n    graph::addEdge(&adj2, 1, 3, 2);\n    graph::addEdge(&adj2, 2, 3, 2);\n    graph::addEdge(&adj2, 3, 2, 1);\n    graph::addEdge(&adj2, 2, 4, 2);\n    graph::addEdge(&adj2, 3, 5, 4);\n    graph::addEdge(&adj2, 5, 4, 1);\n    graph::addEdge(&adj2, 2, 5, 3);\n    graph::addEdge(&adj2, 3, 4, 4);\n\n    s = 1, t = 5;\n    std::cout << \"Initiating Test 3...\" << std::endl;\n    assert(graph::dijkstra(&adj2, s - 1, t - 1) == 6);\n    std::cout << \"Test 3 Passed...\" << std::endl;\n    std::cout << \"All Test Passed...\" << std::endl << std::endl;\n}\n\n/** Main function */\nint main() {\n    // running predefined tests\n    tests();\n\n    int vertices = int(), edges = int();\n    std::cout << \"Enter the number of vertices : \";\n    std::cin >> vertices;\n    std::cout << \"Enter the number of edges : \";\n    std::cin >> edges;\n\n    std::vector<std::vector<std::pair<int, int>>> adj(\n        vertices, std::vector<std::pair<int, int>>());\n\n    int u = int(), v = int(), w = int();\n    while (edges--) {\n        std::cin >> u >> v >> w;\n        graph::addEdge(&adj, u, v, w);\n    }\n\n    int s = int(), t = int();\n    std::cin >> s >> t;\n    int dist = graph::dijkstra(&adj, s - 1, t - 1);\n    if (dist == -1) {\n        std::cout << \"Target not reachable from source\" << std::endl;\n    } else {\n        std::cout << \"Shortest Path Distance : \" << dist << std::endl;\n    }\n    return 0;\n}\n","index":77},{"title":"Hamiltons Cycle","category":"graph","id":"hamiltons_cycle_graph","algorithm":"/**\n * @file\n * @brief The implementation of [Hamilton's\n * cycle](https://en.wikipedia.org/wiki/Hamiltonian_path) dynamic solution for\n * vertices number less than 20.\n * @details\n * I use \\f$2^n\\times n\\f$ matrix and for every \\f$[i, j]\\f$ (\\f$i < 2^n\\f$ and\n * \\f$j < n\\f$) in the matrix I store `true` if it is possible to get to all\n * vertices on which position in `i`'s binary representation is `1` so as\n * \\f$j\\f$ would be the last one.\n *\n * In the the end if any cell in \\f$(2^n - 1)^{\\mbox{th}}\\f$ row is `true` there\n * exists hamiltonian cycle.\n *\n * @author [vakhokoto](https://github.com/vakhokoto)\n * @author [Krishna Vedala](https://github.com/kvedala)\n */\n#include <cassert>\n#include <iostream>\n#include <vector>\n\n/**\n * The function determines if there is a hamilton's cycle in the graph\n *\n * @param routes nxn boolean matrix of \\f$[i, j]\\f$ where \\f$[i, j]\\f$ is `true`\n * if there is a road from \\f$i\\f$ to \\f$j\\f$\n * @return `true` if there is Hamiltonian cycle in the graph\n * @return `false` if there is no Hamiltonian cycle in the graph\n */\nbool hamilton_cycle(const std::vector<std::vector<bool>> &routes) {\n    const size_t n = routes.size();\n    // height of dp array which is 2^n\n    const size_t height = 1 << n;\n    std::vector<std::vector<bool>> dp(height, std::vector<bool>(n, false));\n\n    // to fill in the [2^i, i] cells with true\n    for (size_t i = 0; i < n; ++i) {\n        dp[1 << i][i] = true;\n    }\n    for (size_t i = 1; i < height; i++) {\n        std::vector<size_t> zeros, ones;\n        // finding positions with 1s and 0s and separate them\n        for (size_t pos = 0; pos < n; ++pos) {\n            if ((1 << pos) & i) {\n                ones.push_back(pos);\n            } else {\n                zeros.push_back(pos);\n            }\n        }\n\n        for (auto &o : ones) {\n            if (!dp[i][o]) {\n                continue;\n            }\n\n            for (auto &z : zeros) {\n                if (!routes[o][z]) {\n                    continue;\n                }\n                dp[i + (1 << z)][z] = true;\n            }\n        }\n    }\n\n    bool is_cycle = false;\n    for (size_t i = 0; i < n; i++) {\n        is_cycle |= dp[height - 1][i];\n        if (is_cycle) {  // if true, all subsequent loop will be true. hence\n                         // break\n            break;\n        }\n    }\n    return is_cycle;\n}\n\n/**\n * this test is testing if ::hamilton_cycle returns `true` for\n * graph: `1 -> 2 -> 3 -> 4`\n * @return None\n */\nstatic void test1() {\n    std::vector<std::vector<bool>> arr{\n        std::vector<bool>({true, true, false, false}),\n        std::vector<bool>({false, true, true, false}),\n        std::vector<bool>({false, false, true, true}),\n        std::vector<bool>({false, false, false, true})};\n\n    bool ans = hamilton_cycle(arr);\n    std::cout << \"Test 1... \";\n    assert(ans);\n    std::cout << \"passed\\n\";\n}\n\n/**\n * this test is testing if ::hamilton_cycle returns `false` for\n * \\n graph:<pre>\n *  1 -> 2 -> 3\n *       |\n *       V\n *       4</pre>\n * @return None\n */\nstatic void test2() {\n    std::vector<std::vector<bool>> arr{\n        std::vector<bool>({true, true, false, false}),\n        std::vector<bool>({false, true, true, true}),\n        std::vector<bool>({false, false, true, false}),\n        std::vector<bool>({false, false, false, true})};\n\n    bool ans = hamilton_cycle(arr);\n\n    std::cout << \"Test 2... \";\n    assert(!ans);  // not a cycle\n    std::cout << \"passed\\n\";\n}\n\n/**\n * this test is testing if ::hamilton_cycle returns `true` for\n * clique with 4 vertices\n * @return None\n */\nstatic void test3() {\n    std::vector<std::vector<bool>> arr{\n        std::vector<bool>({true, true, true, true}),\n        std::vector<bool>({true, true, true, true}),\n        std::vector<bool>({true, true, true, true}),\n        std::vector<bool>({true, true, true, true})};\n\n    bool ans = hamilton_cycle(arr);\n\n    std::cout << \"Test 3... \";\n    assert(ans);\n    std::cout << \"passed\\n\";\n}\n\n/**\n * Main function\n *\n * @param argc commandline argument count (ignored)\n * @param argv commandline array of arguments (ignored)\n */\nint main(int argc, char **argv) {\n    test1();\n    test2();\n    test3();\n    return 0;\n}\n","index":78},{"title":"Is Graph Bipartite","category":"graph","id":"is_graph_bipartite_graph","algorithm":"/**\n * @file\n *\n * @brief Algorithm to check whether a graph is\n * [bipartite](https://en.wikipedia.org/wiki/Bipartite_graph)\n *\n * @details\n * A graph is a collection of nodes also called vertices and these vertices\n * are connected by edges. A graph is bipartite if its vertices can be\n * divided into two disjoint and independent sets U and V such that every edge\n * connects a vertex in U to one in V.\n *\n * The algorithm implemented in this file determines whether the given graph\n * is bipartite or not.\n *\n * <pre>\n *  Example - Here is a graph g1 with 5 vertices and is bipartite\n *\n *     1   4\n *    / \\ / \\\n *   2   3   5\n *\n * Example - Here is a graph G2 with 3 vertices and is not bipartite\n *\n *   1 --- 2\n *    \\   /\n *      3\n *\n * </pre>\n *\n * @author [Akshat Vaya](https://github.com/AkVaya)\n *\n */\n#include <iostream>\n#include <queue>\n#include <vector>\n\n/**\n * @namespace graph\n * @brief Graph algorithms\n */\nnamespace graph {\n/**\n * @namespace is_graph_bipartite\n * @brief Functions for checking whether a graph is bipartite or not\n */\nnamespace is_graph_bipartite {\n/**\n * @brief Class for representing graph as an adjacency list.\n */\nclass Graph {\n private:\n    int n;  ///< size of the graph\n\n    std::vector<std::vector<int> >\n        adj;  ///< adj stores the graph as an adjacency list\n\n    std::vector<int> side;  ///< stores the side of the vertex\n\n public:\n    /**\n     * @brief Constructor that initializes the graph on creation\n     * @param size number of vertices of the graph\n     */\n    explicit Graph(int size) {\n        n = size;\n        adj.resize(n);\n        side.resize(n, -1);\n    }\n\n    void addEdge(int u, int v);  /// function to add edges to our graph\n\n    bool\n    is_bipartite();  /// function to check whether the graph is bipartite or not\n};\n\n/**\n * @brief Function that add an edge between two nodes or vertices of graph\n *\n * @param u is a node or vertex of graph\n * @param v is a node or vertex of graph\n */\nvoid Graph::addEdge(int u, int v) {\n    adj[u - 1].push_back(v - 1);\n    adj[v - 1].push_back(u - 1);\n}\n\n/**\n * @brief function that checks whether the graph is bipartite or not\n * the function returns true if the graph is a bipartite graph\n * the function returns false if the graph is not a bipartite graph\n *\n * @details\n * Here, side refers to the two disjoint subsets of the bipartite graph.\n * Initially, the values of side are set to -1 which is an unassigned state. A\n * for loop is run for every vertex of the graph. If the current edge has no\n * side assigned to it, then a Breadth First Search operation is performed. If\n * two neighbours have the same side then the graph will not be bipartite and\n * the value of check becomes false. If and only if each pair of neighbours have\n * different sides, the value of check will be true and hence the graph\n * bipartite.\n *\n * @returns `true` if th graph is bipartite\n * @returns `false` otherwise\n */\nbool Graph::is_bipartite() {\n    bool check = true;\n    std::queue<int> q;\n    for (int current_edge = 0; current_edge < n; ++current_edge) {\n        if (side[current_edge] == -1) {\n            q.push(current_edge);\n            side[current_edge] = 0;\n            while (q.size()) {\n                int current = q.front();\n                q.pop();\n                for (auto neighbour : adj[current]) {\n                    if (side[neighbour] == -1) {\n                        side[neighbour] = (1 ^ side[current]);\n                        q.push(neighbour);\n                    } else {\n                        check &= (side[neighbour] != side[current]);\n                    }\n                }\n            }\n        }\n    }\n    return check;\n}\n}  // namespace is_graph_bipartite\n}  // namespace graph\n\n/**\n * Function to test the above algorithm\n * @returns none\n */\nstatic void test() {\n    graph::is_graph_bipartite::Graph G1(\n        5);  /// creating graph G1 with 5 vertices\n    /// adding edges to the graphs as per the illustrated example\n    G1.addEdge(1, 2);\n    G1.addEdge(1, 3);\n    G1.addEdge(3, 4);\n    G1.addEdge(4, 5);\n\n    graph::is_graph_bipartite::Graph G2(\n        3);  /// creating graph G2 with 3 vertices\n    /// adding edges to the graphs as per the illustrated example\n    G2.addEdge(1, 2);\n    G2.addEdge(1, 3);\n    G2.addEdge(2, 3);\n\n    /// checking whether the graphs are bipartite or not\n    if (G1.is_bipartite()) {\n        std::cout << \"The given graph G1 is a bipartite graph\\n\";\n    } else {\n        std::cout << \"The given graph G1 is not a bipartite graph\\n\";\n    }\n    if (G2.is_bipartite()) {\n        std::cout << \"The given graph G2 is a bipartite graph\\n\";\n    } else {\n        std::cout << \"The given graph G2 is not a bipartite graph\\n\";\n    }\n}\n\n/**\n * Main function\n */\nint main() {\n    test();  /// Testing\n    return 0;\n}\n","index":79},{"title":"Kosaraju","category":"graph","id":"kosaraju_graph","algorithm":"/* Implementation of Kosaraju's Algorithm to find out the strongly connected\n   components (SCCs) in a graph. Author:Anirban166\n*/\n\n#include <iostream>\n#include <stack>\n#include <vector>\n\n/**\n * Iterative function/method to print graph:\n * @param a adjacency list representation of the graph\n * @param V number of vertices\n * @return void\n **/\nvoid print(const std::vector<std::vector<int> > &a, int V) {\n    for (int i = 0; i < V; i++) {\n        if (!a[i].empty()) {\n            std::cout << \"i=\" << i << \"-->\";\n        }\n        for (int j : a[i]) {\n            std::cout << j << \" \";\n        }\n        if (!a[i].empty()) {\n            std::cout << std::endl;\n        }\n    }\n}\n\n/**\n * //Recursive function/method to push vertices into stack passed as parameter:\n * @param v vertices\n * @param st stack passed by reference\n * @param vis array to keep track of visited nodes (boolean type)\n * @param adj adjacency list representation of the graph\n * @return void\n **/\nvoid push_vertex(int v, std::stack<int> *st, std::vector<bool> *vis,\n                 const std::vector<std::vector<int> > &adj) {\n    (*vis)[v] = true;\n    for (auto i = adj[v].begin(); i != adj[v].end(); i++) {\n        if ((*vis)[*i] == false) {\n            push_vertex(*i, st, vis, adj);\n        }\n    }\n    st->push(v);\n}\n\n/**\n * //Recursive function/method to implement depth first traversal(dfs):\n * @param v vertices\n * @param vis array to keep track of visited nodes (boolean type)\n * @param grev graph with reversed edges\n * @return void\n **/\nvoid dfs(int v, std::vector<bool> *vis,\n         const std::vector<std::vector<int> > &grev) {\n    (*vis)[v] = true;\n    // cout<<v<<\" \";\n    for (auto i = grev[v].begin(); i != grev[v].end(); i++) {\n        if ((*vis)[*i] == false) {\n            dfs(*i, vis, grev);\n        }\n    }\n}\n\n// function/method to implement Kosaraju's Algorithm:\n/**\n* Info about the method\n* @param V vertices in graph\n* @param adj array of vectors that represent a graph (adjacency list/array)\n* @return int ( 0, 1, 2..and so on, only unsigned values as either there can be\nno SCCs i.e. none(0) or there will be x no. of SCCs (x>0)) i.e. it returns the\ncount of (number of) strongly connected components (SCCs) in the graph.\n(variable 'count_scc' within function)\n**/\nint kosaraju(int V, const std::vector<std::vector<int> > &adj) {\n    std::vector<bool> vis(V, false);\n    std::stack<int> st;\n    for (int v = 0; v < V; v++) {\n        if (vis[v] == false) {\n            push_vertex(v, &st, &vis, adj);\n        }\n    }\n    // making new graph (grev) with reverse edges as in adj[]:\n    std::vector<std::vector<int> > grev(V);\n    for (int i = 0; i < V + 1; i++) {\n        for (auto j = adj[i].begin(); j != adj[i].end(); j++) {\n            grev[*j].push_back(i);\n        }\n    }\n    // cout<<\"grev=\"<<endl; ->debug statement\n    // print(grev,V);       ->debug statement\n    // reinitialise visited to 0\n    for (int i = 0; i < V; i++) vis[i] = false;\n    int count_scc = 0;\n    while (!st.empty()) {\n        int t = st.top();\n        st.pop();\n        if (vis[t] == false) {\n            dfs(t, &vis, grev);\n            count_scc++;\n        }\n    }\n    // cout<<\"count_scc=\"<<count_scc<<endl; //in case you want to print here\n    // itself, uncomment & change return type of function to void.\n    return count_scc;\n}\n\n// All critical/corner cases have been taken care of.\n// Input your required values: (not hardcoded)\nint main() {\n    int t = 0;\n    std::cin >> t;\n    while (t--) {\n        int a = 0, b = 0;  // a->number of nodes, b->directed edges.\n        std::cin >> a >> b;\n        int m = 0, n = 0;\n        std::vector<std::vector<int> > adj(a + 1);\n        for (int i = 0; i < b; i++)  // take total b inputs of 2 vertices each\n                                     // required to form an edge.\n        {\n            std::cin >> m >> n;  // take input m,n denoting edge from m->n.\n            adj[m].push_back(n);\n        }\n        // pass number of nodes and adjacency array as parameters to function:\n        std::cout << kosaraju(a, adj) << std::endl;\n    }\n    return 0;\n}\n","index":80},{"title":"Kruskal","category":"graph","id":"kruskal_graph","algorithm":"#include <algorithm>\n#include <array>\n#include <iostream>\n#include <vector>\n//#include <boost/multiprecision/cpp_int.hpp>\n// using namespace boost::multiprecision;\nconst int mx = 1e6 + 5;\nusing ll = int64_t;\n\nstd::array<ll, mx> parent;\nll node, edge;\nstd::vector<std::pair<ll, std::pair<ll, ll>>> edges;\nvoid initial() {\n    for (int i = 0; i < node + edge; ++i) {\n        parent[i] = i;\n    }\n}\n\nint root(int i) {\n    while (parent[i] != i) {\n        parent[i] = parent[parent[i]];\n        i = parent[i];\n    }\n    return i;\n}\n\nvoid join(int x, int y) {\n    int root_x = root(x);  // Disjoint set union by rank\n    int root_y = root(y);\n    parent[root_x] = root_y;\n}\n\nll kruskal() {\n    ll mincost = 0;\n    for (int i = 0; i < edge; ++i) {\n        ll x = edges[i].second.first;\n        ll y = edges[i].second.second;\n        if (root(x) != root(y)) {\n            mincost += edges[i].first;\n            join(x, y);\n        }\n    }\n    return mincost;\n}\n\nint main() {\n    while (true) {\n        int from = 0, to = 0, cost = 0, totalcost = 0;\n        std::cin >> node >> edge;  // Enter the nodes and edges\n        if (node == 0 && edge == 0) {\n            break;  // Enter 0 0 to break out\n        }\n        initial();  // Initialise the parent array\n        for (int i = 0; i < edge; ++i) {\n            std::cin >> from >> to >> cost;\n            edges.emplace_back(make_pair(cost, std::make_pair(from, to)));\n            totalcost += cost;\n        }\n        sort(edges.begin(), edges.end());\n        std::cout << kruskal() << std::endl;\n        edges.clear();\n    }\n    return 0;\n}\n","index":81},{"title":"Lowest Common Ancestor","category":"graph","id":"lowest_common_ancestor_graph","algorithm":"/**\n *\n * \\file\n *\n * \\brief Data structure for finding the lowest common ancestor\n * of two vertices in a rooted tree using binary lifting.\n *\n * \\details\n * Algorithm: https://cp-algorithms.com/graph/lca_binary_lifting.html\n *\n * Complexity:\n *   - Precomputation: \\f$O(N \\log N)\\f$ where \\f$N\\f$ is the number of vertices\n * in the tree\n *   - Query: \\f$O(\\log N)\\f$\n *   - Space: \\f$O(N \\log N)\\f$\n *\n * Example:\n * <br/>  Tree:\n * <pre>\n *             _  3  _\n *          /     |     \\\n *        1       6       4\n *      / |     /   \\       \\\n *    7   5   2       8       0\n *            |\n *            9\n * </pre>\n *\n * <br/>  lowest_common_ancestor(7, 4) = 3\n * <br/>  lowest_common_ancestor(9, 6) = 6\n * <br/>  lowest_common_ancestor(0, 0) = 0\n * <br/>  lowest_common_ancestor(8, 2) = 6\n *\n *   The query is symmetrical, therefore\n *     lowest_common_ancestor(x, y) = lowest_common_ancestor(y, x)\n */\n\n#include <cassert>\n#include <iostream>\n#include <queue>\n#include <utility>\n#include <vector>\n\n/**\n * \\namespace graph\n * \\brief Graph algorithms\n */\nnamespace graph {\n/**\n * Class for representing a graph as an adjacency list.\n * Its vertices are indexed 0, 1, ..., N - 1.\n */\nclass Graph {\n public:\n    /**\n     * \\brief Populate the adjacency list for each vertex in the graph.\n     * Assumes that evey edge is a pair of valid vertex indices.\n     *\n     * @param N number of vertices in the graph\n     * @param undirected_edges list of graph's undirected edges\n     */\n    Graph(size_t N, const std::vector<std::pair<int, int> > &undirected_edges) {\n        neighbors.resize(N);\n        for (auto &edge : undirected_edges) {\n            neighbors[edge.first].push_back(edge.second);\n            neighbors[edge.second].push_back(edge.first);\n        }\n    }\n\n    /**\n     * Function to get the number of vertices in the graph\n     * @return the number of vertices in the graph.\n     */\n    int number_of_vertices() const { return neighbors.size(); }\n\n    /** \\brief for each vertex it stores a list indicies of its neighbors */\n    std::vector<std::vector<int> > neighbors;\n};\n\n/**\n * Representation of a rooted tree. For every vertex its parent is\n * precalculated.\n */\nclass RootedTree : public Graph {\n public:\n    /**\n     * \\brief Constructs the tree by calculating parent for every vertex.\n     * Assumes a valid description of a tree is provided.\n     *\n     * @param undirected_edges list of graph's undirected edges\n     * @param root_ index of the root vertex\n     */\n    RootedTree(const std::vector<std::pair<int, int> > &undirected_edges,\n               int root_)\n        : Graph(undirected_edges.size() + 1, undirected_edges), root(root_) {\n        populate_parents();\n    }\n\n    /**\n     * \\brief Stores parent of every vertex and for root its own index.\n     * The root is technically not its own parent, but it's very practical\n     * for the lowest common ancestor algorithm.\n     */\n    std::vector<int> parent;\n    /** \\brief Stores the distance from the root. */\n    std::vector<int> level;\n    /** \\brief Index of the root vertex. */\n    int root;\n\n protected:\n    /**\n     * \\brief Calculate the parents for all the vertices in the tree.\n     * Implements the breadth first search algorithm starting from the root\n     * vertex searching the entire tree and labeling parents for all vertices.\n     * @returns none\n     */\n    void populate_parents() {\n        // Initialize the vector with -1 which indicates the vertex\n        // wasn't yet visited.\n        parent = std::vector<int>(number_of_vertices(), -1);\n        level = std::vector<int>(number_of_vertices());\n        parent[root] = root;\n        level[root] = 0;\n        std::queue<int> queue_of_vertices;\n        queue_of_vertices.push(root);\n        while (!queue_of_vertices.empty()) {\n            int vertex = queue_of_vertices.front();\n            queue_of_vertices.pop();\n            for (int neighbor : neighbors[vertex]) {\n                // As long as the vertex was not yet visited.\n                if (parent[neighbor] == -1) {\n                    parent[neighbor] = vertex;\n                    level[neighbor] = level[vertex] + 1;\n                    queue_of_vertices.push(neighbor);\n                }\n            }\n        }\n    }\n};\n\n/**\n * A structure that holds a rooted tree and allow for effecient\n * queries of the lowest common ancestor of two given vertices in the tree.\n */\nclass LowestCommonAncestor {\n public:\n    /**\n     * \\brief Stores the tree and precomputs \"up lifts\".\n     * @param tree_ rooted tree.\n     */\n    explicit LowestCommonAncestor(const RootedTree &tree_) : tree(tree_) {\n        populate_up();\n    }\n\n    /**\n     * \\brief Query the structure to find the lowest common ancestor.\n     * Assumes that the provided numbers are valid indices of vertices.\n     * Iterativelly modifies (\"lifts\") u an v until it finnds their lowest\n     * common ancestor.\n     * @param u index of one of the queried vertex\n     * @param v index of the other queried vertex\n     * @return index of the vertex which is the lowet common ancestor of u and v\n     */\n    int lowest_common_ancestor(int u, int v) const {\n        // Ensure u is the deeper (higher level) of the two vertices\n        if (tree.level[v] > tree.level[u]) {\n            std::swap(u, v);\n        }\n\n        // \"Lift\" u to the same level as v.\n        int level_diff = tree.level[u] - tree.level[v];\n        for (int i = 0; (1 << i) <= level_diff; ++i) {\n            if (level_diff & (1 << i)) {\n                u = up[u][i];\n            }\n        }\n        assert(tree.level[u] == tree.level[v]);\n\n        if (u == v) {\n            return u;\n        }\n\n        // \"Lift\" u and v to their 2^i th ancestor if they are different\n        for (int i = static_cast<int>(up[u].size()) - 1; i >= 0; --i) {\n            if (up[u][i] != up[v][i]) {\n                u = up[u][i];\n                v = up[v][i];\n            }\n        }\n\n        // As we regressed u an v such that they cannot further be lifted so\n        // that their ancestor would be different, the only logical\n        // consequence is that their parent is the sought answer.\n        assert(up[u][0] == up[v][0]);\n        return up[u][0];\n    }\n\n    /* \\brief reference to the rooted tree this structure allows to query */\n    const RootedTree &tree;\n    /**\n     * \\brief for every vertex stores a list of its ancestors by powers of two\n     * For each vertex, the first element of the corresponding list contains\n     * the index of its parent. The i-th element of the list is an index of\n     * the (2^i)-th ancestor of the vertex.\n     */\n    std::vector<std::vector<int> > up;\n\n protected:\n    /**\n     * Populate the \"up\" structure. See above.\n     */\n    void populate_up() {\n        up.resize(tree.number_of_vertices());\n        for (int vertex = 0; vertex < tree.number_of_vertices(); ++vertex) {\n            up[vertex].push_back(tree.parent[vertex]);\n        }\n        for (int level = 0; (1 << level) < tree.number_of_vertices(); ++level) {\n            for (int vertex = 0; vertex < tree.number_of_vertices(); ++vertex) {\n                // up[vertex][level + 1] = 2^(level + 1) th ancestor of vertex =\n                // = 2^level th ancestor of 2^level th ancestor of vertex =\n                // = 2^level th ancestor of up[vertex][level]\n                up[vertex].push_back(up[up[vertex][level]][level]);\n            }\n        }\n    }\n};\n\n}  // namespace graph\n\n/**\n * Unit tests\n * @returns none\n */\nstatic void tests() {\n    /**\n     *             _  3  _\n     *          /     |     \\\n     *        1       6       4\n     *      / |     /   \\       \\\n     *    7   5   2       8       0\n     *            |\n     *            9\n     */\n    std::vector<std::pair<int, int> > edges = {\n        {7, 1}, {1, 5}, {1, 3}, {3, 6}, {6, 2}, {2, 9}, {6, 8}, {4, 3}, {0, 4}};\n    graph::RootedTree t(edges, 3);\n    graph::LowestCommonAncestor lca(t);\n    assert(lca.lowest_common_ancestor(7, 4) == 3);\n    assert(lca.lowest_common_ancestor(9, 6) == 6);\n    assert(lca.lowest_common_ancestor(0, 0) == 0);\n    assert(lca.lowest_common_ancestor(8, 2) == 6);\n}\n\n/** Main function */\nint main() {\n    tests();\n    return 0;\n}\n","index":82},{"title":"Max Flow With Ford Fulkerson And Edmond Karp Algo","category":"graph","id":"max_flow_with_ford_fulkerson_and_edmond_karp_algo_graph","algorithm":"/*\n * Author: Amit Kumar\n * Created: May 24, 2020\n * Copyright: 2020, Open-Source\n * Last Modified: May 25, 2020\n */\n#include <algorithm>\n#include <bitset>\n#include <cstring>\n#include <iostream>\n#include <limits>\n#include <queue>\n#include <tuple>\n#include <utility>\n#include <vector>\n// std::max capacity of node in graph\nconst int MAXN = 505;\nclass Graph {\n    std::vector<std::vector<int> > residual_capacity, capacity;\n    int total_nodes = 0;\n    int total_edges = 0, source = 0, sink = 0;\n    std::vector<int> parent;\n    std::vector<std::tuple<int, int, int> > edge_participated;\n    std::bitset<MAXN> visited;\n    int max_flow = 0;\n    bool bfs(int source, int sink) {  //  to find the augmented - path\n        visited.reset();\n        std::queue<int> q;\n        q.push(source);\n        bool is_path_found = false;\n        while (q.empty() == false && is_path_found == false) {\n            int current_node = q.front();\n            visited.set(current_node);\n            q.pop();\n            for (int i = 0; i < total_nodes; ++i) {\n                if (residual_capacity[current_node][i] > 0 && !visited[i]) {\n                    visited.set(i);\n                    parent[i] = current_node;\n                    if (i == sink) {\n                        return true;\n                    }\n                    q.push(i);\n                }\n            }\n        }\n        return false;\n    }\n\n public:\n    void set_graph() {\n        std::cin >> total_nodes >> total_edges >> source >> sink;\n        parent = std::vector<int>(total_nodes, -1);\n        capacity = residual_capacity = std::vector<std::vector<int> >(\n            total_nodes, std::vector<int>(total_nodes));\n        for (int start = 0, destination = 0, capacity_ = 0, i = 0;\n             i < total_edges; ++i) {\n            std::cin >> start >> destination >> capacity_;\n            residual_capacity[start][destination] = capacity_;\n            capacity[start][destination] = capacity_;\n        }\n    }\n    void ford_fulkerson() {\n        while (bfs(source, sink)) {\n            int current_node = sink;\n            int flow = std::numeric_limits<int>::max();\n            while (current_node != source) {\n                int parent_ = parent[current_node];\n                flow = std::min(flow, residual_capacity[parent_][current_node]);\n                current_node = parent_;\n            }\n            current_node = sink;\n            max_flow += flow;\n            while (current_node != source) {\n                int parent_ = parent[current_node];\n                residual_capacity[parent_][current_node] -= flow;\n                residual_capacity[current_node][parent_] += flow;\n                current_node = parent_;\n            }\n        }\n    }\n    void print_flow_info() {\n        for (int i = 0; i < total_nodes; ++i) {\n            for (int j = 0; j < total_nodes; ++j) {\n                if (capacity[i][j] &&\n                    residual_capacity[i][j] < capacity[i][j]) {\n                    edge_participated.emplace_back(std::make_tuple(\n                        i, j, capacity[i][j] - residual_capacity[i][j]));\n                }\n            }\n        }\n        std::cout << \"\\nNodes : \" << total_nodes << \"\\nMax flow: \" << max_flow\n                  << \"\\nEdge present in flow: \" << edge_participated.size()\n                  << '\\n';\n        std::cout << \"\\nSource\\tDestination\\tCapacity\\total_nodes\";\n        for (auto& edge_data : edge_participated) {\n            int source = 0, destination = 0, capacity_ = 0;\n            std::tie(source, destination, capacity_) = edge_data;\n            std::cout << source << \"\\t\" << destination << \"\\t\\t\" << capacity_\n                      << '\\t';\n        }\n    }\n};\nint main() {\n    /*\n       Input Graph: (for testing )\n        4 5 0 3\n        0 1 10\n        1 2 1\n        1 3 1\n        0 2 1\n        2 3 10\n     */\n    Graph graph;\n    graph.set_graph();\n    graph.ford_fulkerson();\n    graph.print_flow_info();\n    return 0;\n}\n","index":83},{"title":"Prim","category":"graph","id":"prim_graph","algorithm":"// C++ program to implement Prim's Algorithm\n#include <iostream>\n#include <queue>\n#include <vector>\n\nusing PII = std::pair<int, int>;\n\nint prim(int x, const std::vector<std::vector<PII> > &graph) {\n    // priority queue to maintain edges with respect to weights\n    std::priority_queue<PII, std::vector<PII>, std::greater<PII> > Q;\n    std::vector<bool> marked(graph.size(), false);\n    int minimum_cost = 0;\n\n    Q.push(std::make_pair(0, x));\n    while (!Q.empty()) {\n        // Select the edge with minimum weight\n        PII p = Q.top();\n        Q.pop();\n        x = p.second;\n        // Checking for cycle\n        if (marked[x] == true) {\n            continue;\n        }\n        minimum_cost += p.first;\n        marked[x] = true;\n        for (const PII &neighbor : graph[x]) {\n            int y = neighbor.second;\n            if (marked[y] == false) {\n                Q.push(neighbor);\n            }\n        }\n    }\n    return minimum_cost;\n}\n\nint main() {\n    int nodes = 0, edges = 0;\n    std::cin >> nodes >> edges;  // number of nodes & edges in graph\n    if (nodes == 0 || edges == 0) {\n        return 0;\n    }\n\n    std::vector<std::vector<PII> > graph(nodes);\n\n    // Edges with their nodes & weight\n    for (int i = 0; i < edges; ++i) {\n        int x = 0, y = 0, weight = 0;\n        std::cin >> x >> y >> weight;\n        graph[x].push_back(std::make_pair(weight, y));\n        graph[y].push_back(std::make_pair(weight, x));\n    }\n\n    // Selecting 1 as the starting node\n    int minimum_cost = prim(1, graph);\n    std::cout << minimum_cost << std::endl;\n    return 0;\n}\n","index":84},{"title":"Topological Sort","category":"graph","id":"topological_sort_graph","algorithm":"#include <algorithm>\n#include <iostream>\n#include <vector>\n\nint number_of_vertices,\n    number_of_edges;  // For number of Vertices (V) and number of edges (E)\nstd::vector<std::vector<int>> graph;\nstd::vector<bool> visited;\nstd::vector<int> topological_order;\n\nvoid dfs(int v) {\n    visited[v] = true;\n    for (int u : graph[v]) {\n        if (!visited[u]) {\n            dfs(u);\n        }\n    }\n    topological_order.push_back(v);\n}\n\nvoid topological_sort() {\n    visited.assign(number_of_vertices, false);\n    topological_order.clear();\n    for (int i = 0; i < number_of_vertices; ++i) {\n        if (!visited[i]) {\n            dfs(i);\n        }\n    }\n    reverse(topological_order.begin(), topological_order.end());\n}\nint main() {\n    std::cout\n        << \"Enter the number of vertices and the number of directed edges\\n\";\n    std::cin >> number_of_vertices >> number_of_edges;\n    int x = 0, y = 0;\n    graph.resize(number_of_vertices, std::vector<int>());\n    for (int i = 0; i < number_of_edges; ++i) {\n        std::cin >> x >> y;\n        x--, y--;  // to convert 1-indexed to 0-indexed\n        graph[x].push_back(y);\n    }\n    topological_sort();\n    std::cout << \"Topological Order : \\n\";\n    for (int v : topological_order) {\n        std::cout << v + 1\n                  << ' ';  // converting zero based indexing back to one based.\n    }\n    std::cout << '\\n';\n    return 0;\n}\n","index":85},{"title":"Topological Sort By Kahns Algo","category":"graph","id":"topological_sort_by_kahns_algo_graph","algorithm":"#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <queue>\n#include <vector>\n\nstd::vector<int> topoSortKahn(int N, const std::vector<std::vector<int> > &adj);\n\nint main() {\n    int nodes = 0, edges = 0;\n    std::cin >> edges >> nodes;\n    if (edges == 0 || nodes == 0) {\n        return 0;\n    }\n    int u = 0, v = 0;\n\n    std::vector<std::vector<int> > graph(nodes);\n    // create graph\n    // example\n    // 6 6\n    // 5 0 5 2 2 3 4 0 4 1 1 3\n\n    for (int i = 0; i < edges; i++) {\n        std::cin >> u >> v;\n        graph[u].push_back(v);\n    }\n\n    std::vector<int> topo = topoSortKahn(nodes, graph);\n    // topologically sorted nodes\n    for (int i = 0; i < nodes; i++) {\n        std::cout << topo[i] << \" \";\n    }\n}\n\nstd::vector<int> topoSortKahn(int V,\n                              const std::vector<std::vector<int> > &adj) {\n    std::vector<bool> vis(V + 1, false);\n    std::vector<int> deg(V + 1, 0);\n    for (int i = 0; i < V; i++) {\n        for (int j : adj[i]) {\n            deg[j]++;\n        }\n    }\n    std::queue<int> q;\n    for (int i = 0; i < V; i++) {\n        if (deg[i] == 0) {\n            q.push(i);\n            vis[i] = true;\n        }\n    }\n    std::vector<int> arr(V + 1, 0);\n    int count = 0;\n    while (!q.empty()) {\n        int cur = q.front();\n        q.pop();\n        arr[count++] = cur;\n        for (int i : adj[cur]) {\n            if (!vis[i]) {\n                deg[i]--;\n                if (deg[i] == 0) {\n                    q.push(i);\n                    vis[i] = true;\n                }\n            }\n        }\n    }\n    return arr;\n}\n","index":86},{"title":"Graphics","category":null,"id":"graphics","index":87},{"title":"Spirograph","category":"graphics","id":"spirograph_graphics","algorithm":"/**\n * @file\n * @author [Krishna Vedala](https://github.com/kvedala)\n * @brief Implementation of\n * [Spirograph](https://en.wikipedia.org/wiki/Spirograph)\n *\n * @details\n * Implementation of the program is based on the geometry shown in the figure\n * below:\n *\n * <a\n * href=\"https://commons.wikimedia.org/wiki/File:Resonance_Cascade.svg\"><img\n * src=\"https://upload.wikimedia.org/wikipedia/commons/3/39/Resonance_Cascade.svg\"\n * alt=\"Spirograph geometry from Wikipedia\" style=\"width: 250px\"/></a>\n */\n#ifdef USE_GLUT\n#ifdef __APPLE__\n#include <GLUT/glut.h>  // include path on Macs is different\n#else\n#include <GL/glut.h>\n#endif  // __APPLE__\n#endif\n#define _USE_MATH_DEFINES /**< required for MSVC compiler */\n#include <array>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <sstream>\n#ifdef _OPENMP\n#include <omp.h>\n#endif\n\n/**\n * @namespace spirograph Functions related to spirograph.cpp\n */\nnamespace spirograph {\n/** Generate spirograph curve into arrays `x` and `y` such that the i^th point\n * in 2D is represented by `(x[i],y[i])`. The generating function is given by:\n * \\f{eqnarray*}{\n * x &=& R\\left[ (1-k) \\cos (t) + l\\cdot k\\cdot\\cos \\left(\\frac{1-k}{k}t\\right)\n * \\right]\\\\\n * y &=& R\\left[ (1-k) \\sin (t) - l\\cdot k\\cdot\\sin \\left(\\frac{1-k}{k}t\\right)\n * \\right] \\f}\n * where\n * * \\f$R\\f$ is the scaling parameter that we will consider \\f$=1\\f$\n * * \\f$l=\\frac{\\rho}{r}\\f$ is the relative distance of marker from the centre\n * of inner circle and \\f$0\\le l\\le1\\f$\n * * \\f$\\rho\\f$ is physical distance of marker from centre of inner circle\n * * \\f$r\\f$ is the radius of inner circle\n * * \\f$k=\\frac{r}{R}\\f$ is the ratio of radius of inner circle to outer circle\n * and \\f$0<k<1\\f$\n * * \\f$R\\f$ is the radius of outer circle\n * * \\f$t\\f$ is the angle of rotation of the point i.e., represents the time\n * parameter\n *\n * Since we are considering ratios, the actual values of \\f$r\\f$ and\n * \\f$R\\f$ are immaterial.\n *\n * @tparam N number of points = size of array\n * @param [out] points Array of 2D points represented as std::pair\n * @param l the relative distance of marker from the centre of\n * inner circle and \\f$0\\le l\\le1\\f$\n * @param k the ratio of radius of inner circle to outer circle and \\f$0<k<1\\f$\n * @param rot the number of rotations to perform (can be fractional value)\n */\ntemplate <std::size_t N>\nvoid spirograph(std::array<std::pair<double, double>, N> *points, double l,\n                double k, double rot) {\n    double dt = rot * 2.f * M_PI / N;\n    double R = 1.f;\n    const double k1 = 1.f - k;\n    int32_t step = 0;\n\n#ifdef _OPENMP\n#pragma omp for\n#endif\n    for (step = 0; step < N; step++) {\n        double t = dt * step;\n        double first = R * (k1 * std::cos(t) + l * k * std::cos(k1 * t / k));\n        double second = R * (k1 * std::sin(t) - l * k * std::sin(k1 * t / k));\n        points[0][step].first = first;\n        points[0][step].second = second;\n    }\n}\n\n/**\n * @brief Test function to save resulting points to a CSV file.\n *\n */\nvoid test() {\n    const size_t N = 500;\n    double l = 0.3, k = 0.75, rot = 10.;\n    std::stringstream fname;\n    fname << std::setw(3) << \"spirograph_\" << l << \"_\" << k << \"_\" << rot\n          << \".csv\";\n    std::ofstream fp(fname.str());\n    if (!fp.is_open()) {\n        perror(fname.str().c_str());\n        exit(EXIT_FAILURE);\n    }\n\n    std::array<std::pair<double, double>, N> points;\n\n    spirograph(&points, l, k, rot);\n\n    for (size_t i = 0; i < N; i++) {\n        fp << points[i].first << \",\" << points[i].first;\n        if (i < N - 1) {\n            fp << '\\n';\n        }\n    }\n\n    fp.close();\n}\n\n#ifdef USE_GLUT\nstatic bool paused = 0; /**< flag to set pause/unpause animation */\nstatic const int animation_speed = 25; /**< animation delate in ms */\n\nstatic const double step = 0.01;   /**< animation step size */\nstatic double l_ratio = step * 10; /**< the l-ratio defined in docs */\nstatic double k_ratio = step;      /**< the k-ratio defined in docs */\nstatic const double num_rot = 20.; /**< number of rotations to simulate */\n\n/** A wrapper that is not available in all GLUT implementations.\n */\nstatic inline void glutBitmapString(void *font, char *message) {\n    for (char *ch = message; *ch != '\\0'; ch++) glutBitmapCharacter(font, *ch);\n}\n\n/**\n * @brief Function to graph (x,y) points on the OpenGL graphics window.\n *\n * @tparam N number of points = size of array\n * @param [in] points Array of 2D points represented as std::pair\n * @param l the relative distance of marker from the centre of\n * inner circle and \\f$0\\le l\\le1\\f$ to display info\n * @param k the ratio of radius of inner circle to outer circle and \\f$0<k<1\\f$\n * to display info\n */\ntemplate <size_t N>\nvoid display_graph(const std::array<std::pair<double, double>, N> &points,\n                   double l, double k) {\n    glClearColor(1.0f, 1.0f, 1.0f,\n                 0.0f);            // Set background color to white and opaque\n    glClear(GL_COLOR_BUFFER_BIT);  // Clear the color buffer (background)\n\n    glBegin(GL_LINES);         // draw line segments\n    glColor3f(0.f, 0.f, 1.f);  // blue\n    glPointSize(2.f);          // point size in pixels\n\n    for (size_t i = 1; i < N; i++) {\n        glVertex2f(points[i - 1].first, points[i - 1].second);  // line from\n        glVertex2f(points[i].first, points[i].second);          // line to\n    }\n    glEnd();\n\n    glColor3f(0.f, 0.f, 0.f);\n    std::stringstream buffer;\n    buffer << std::setw(3) << \"l = \" << l;\n    glRasterPos2f(-.85, .85);\n    glutBitmapString(GLUT_BITMAP_TIMES_ROMAN_24,\n                     const_cast<char *>(buffer.str().c_str()));\n    buffer.str(\"\");\n    buffer.clear();\n    buffer << std::setw(3) << \"k = \" << k;\n    glRasterPos2f(-.85, .70);\n    glutBitmapString(GLUT_BITMAP_TIMES_ROMAN_24,\n                     const_cast<char *>(buffer.str().c_str()));\n\n    glutSwapBuffers();\n}\n\n/**\n * @brief Test function with animation\n *\n */\nvoid test2() {\n    const size_t N = 5000;  // number of samples\n\n    static bool direction1 = true;  // increment if true, otherwise decrement\n    static bool direction2 = true;  // increment if true, otherwise decrement\n\n    std::array<std::pair<double, double>, N> points;\n\n    spirograph(&points, l_ratio, k_ratio, num_rot);\n    display_graph(points, l_ratio, k_ratio);\n\n    if (paused)\n        // if paused, do not update l_ratio and k_ratio\n        return;\n\n    if (direction1) {                 // increment k_ratio\n        if (k_ratio >= (1.f - step))  // maximum limit\n            direction1 = false;       // reverse direction of k_ratio\n        else\n            k_ratio += step;\n    } else {                    // decrement k_ratio\n        if (k_ratio <= step) {  // minimum limit\n            direction1 = true;  // reverse direction of k_ratio\n\n            if (direction2) {                 // increment l_ratio\n                if (l_ratio >= (1.f - step))  // max limit of l_ratio\n                    direction2 = false;       // reverse direction of l_ratio\n                else\n                    l_ratio += step;\n            } else {                    // decrement l_ratio\n                if (l_ratio <= step)    // minimum limit of l_ratio\n                    direction2 = true;  // reverse direction of l_ratio\n                else\n                    l_ratio -= step;\n            }\n        } else {  // no min limit of k_ratio\n            k_ratio -= step;\n        }\n    }\n}\n\n/**\n * @brief GLUT timer callback function to add animation delay.\n */\nvoid timer_cb(int t) {\n    glutTimerFunc(animation_speed, timer_cb, 0);\n    glutPostRedisplay();\n}\n\n/**\n * @brief Keypress event call back function.\n *\n * @param key ID of the key pressed\n * @param x mouse pointer position at event\n * @param y mouse pointer position at event\n */\nvoid keyboard_cb(unsigned char key, int x, int y) {\n    switch (key) {\n        case ' ':              // spacebar toggles pause\n            paused = !paused;  // toggle\n            break;\n        case GLUT_KEY_UP:\n        case '+':  // up arrow key\n            k_ratio += step;\n            break;\n        case GLUT_KEY_DOWN:\n        case '_':  // down arrow key\n            k_ratio -= step;\n            break;\n        case GLUT_KEY_RIGHT:\n        case '=':  // left arrow key\n            l_ratio += step;\n            break;\n        case GLUT_KEY_LEFT:\n        case '-':  // right arrow key\n            l_ratio -= step;\n            break;\n        case 0x1B:  // escape key exits\n            exit(EXIT_SUCCESS);\n        default:\n            return;\n    }\n}\n#endif\n}  // namespace spirograph\n\n/** Main function */\nint main(int argc, char **argv) {\n    spirograph::test();\n\n#ifdef USE_GLUT\n    glutInit(&argc, argv);\n    glutInitDisplayMode(GLUT_RGB | GLUT_DOUBLE);\n    glutCreateWindow(\"Spirograph\");\n    glutInitWindowSize(400, 400);\n    // glutIdleFunc(glutPostRedisplay);\n    glutTimerFunc(spirograph::animation_speed, spirograph::timer_cb, 0);\n    glutKeyboardFunc(spirograph::keyboard_cb);\n    glutDisplayFunc(spirograph::test2);\n    glutMainLoop();\n#endif\n\n    return 0;\n}\n","index":88},{"title":"Greedy Algorithms","category":null,"id":"greedy_algorithms","index":89},{"title":"Dijkstra","category":"greedy_algorithms","id":"dijkstra_greedy_algorithms","algorithm":"#include <limits.h>\n#include <iostream>\n\nusing namespace std;\n\n// Wrapper class for storing a graph\nclass Graph {\n public:\n    int vertexNum;\n    int **edges;\n\n    // Constructs a graph with V vertices and E edges\n    Graph(const int V) {\n        // initializes the array edges.\n        this->edges = new int *[V];\n        for (int i = 0; i < V; i++) {\n            edges[i] = new int[V];\n        }\n\n        // fills the array with zeros.\n        for (int i = 0; i < V; i++) {\n            for (int j = 0; j < V; j++) {\n                edges[i][j] = 0;\n            }\n        }\n\n        this->vertexNum = V;\n    }\n\n    // Adds the given edge to the graph\n    void addEdge(int src, int dst, int weight) {\n        this->edges[src][dst] = weight;\n    }\n};\n// Utility function to find minimum distance vertex in mdist\nint minDistance(int mdist[], bool vset[], int V) {\n    int minVal = INT_MAX, minInd = 0;\n    for (int i = 0; i < V; i++) {\n        if (!vset[i] && (mdist[i] < minVal)) {\n            minVal = mdist[i];\n            minInd = i;\n        }\n    }\n\n    return minInd;\n}\n\n// Utility function to print distances\nvoid print(int dist[], int V) {\n    cout << \"\\nVertex  Distance\" << endl;\n    for (int i = 0; i < V; i++) {\n        if (dist[i] < INT_MAX)\n            cout << i << \"\\t\" << dist[i] << endl;\n        else\n            cout << i << \"\\tINF\" << endl;\n    }\n}\n\n// The main function that finds the shortest path from given source\n// to all other vertices using Dijkstra's Algorithm.It doesn't work on negative\n// weights\nvoid Dijkstra(Graph graph, int src) {\n    int V = graph.vertexNum;\n    int mdist[V];  // Stores updated distances to vertex\n    bool vset[V];  // vset[i] is true if the vertex i included\n    // in the shortest path tree\n\n    // Initialise mdist and vset. Set distance of source as zero\n    for (int i = 0; i < V; i++) {\n        mdist[i] = INT_MAX;\n        vset[i] = false;\n    }\n\n    mdist[src] = 0;\n\n    // iterate to find shortest path\n    for (int count = 0; count < V - 1; count++) {\n        int u = minDistance(mdist, vset, V);\n\n        vset[u] = true;\n\n        for (int v = 0; v < V; v++) {\n            if (!vset[v] && graph.edges[u][v] &&\n                mdist[u] + graph.edges[u][v] < mdist[v]) {\n                mdist[v] = mdist[u] + graph.edges[u][v];\n            }\n        }\n    }\n\n    print(mdist, V);\n}\n\n// Driver Function\nint main() {\n    int V, E, gsrc;\n    int src, dst, weight;\n    cout << \"Enter number of vertices: \";\n    cin >> V;\n    cout << \"Enter number of edges: \";\n    cin >> E;\n    Graph G(V);\n    for (int i = 0; i < E; i++) {\n        cout << \"\\nEdge \" << i + 1 << \"\\nEnter source: \";\n        cin >> src;\n        cout << \"Enter destination: \";\n        cin >> dst;\n        cout << \"Enter weight: \";\n        cin >> weight;\n\n        // makes sure source and destionation are in the proper bounds.\n        if (src >= 0 && src < V && dst >= 0 && dst < V) {\n            G.addEdge(src, dst, weight);\n        } else {\n            cout << \"source and/or destination out of bounds\" << endl;\n            i--;\n            continue;\n        }\n    }\n    cout << \"\\nEnter source:\";\n    cin >> gsrc;\n    Dijkstra(G, gsrc);\n\n    return 0;\n}\n","index":90},{"title":"Huffman","category":"greedy_algorithms","id":"huffman_greedy_algorithms","algorithm":"// C++ program for Huffman Coding\n#include <iostream>\n#include <queue>\nusing namespace std;\n\n// A Huffman tree node\nstruct MinHeapNode {\n    // One of the input characters\n    char data;\n\n    // Frequency of the character\n    unsigned freq;\n\n    // Left and right child\n    MinHeapNode *left, *right;\n\n    MinHeapNode(char data, unsigned freq)\n\n    {\n        left = right = NULL;\n        this->data = data;\n        this->freq = freq;\n    }\n};\n\n// For comparison of\n// two heap nodes (needed in min heap)\nstruct compare {\n    bool operator()(MinHeapNode* l, MinHeapNode* r)\n\n    {\n        return (l->freq > r->freq);\n    }\n};\n\n// Prints huffman codes from\n// the root of Huffman Tree.\nvoid printCodes(struct MinHeapNode* root, string str) {\n    if (!root)\n        return;\n\n    if (root->data != '$')\n        cout << root->data << \": \" << str << \"\\n\";\n\n    printCodes(root->left, str + \"0\");\n    printCodes(root->right, str + \"1\");\n}\n\n// The main function that builds a Huffman Tree and\n// print codes by traversing the built Huffman Tree\nvoid HuffmanCodes(char data[], int freq[], int size) {\n    struct MinHeapNode *left, *right, *top;\n\n    // Create a min heap & inserts all characters of data[]\n    priority_queue<MinHeapNode*, vector<MinHeapNode*>, compare> minHeap;\n\n    for (int i = 0; i < size; ++i)\n        minHeap.push(new MinHeapNode(data[i], freq[i]));\n\n    // Iterate while size of heap doesn't become 1\n    while (minHeap.size() != 1) {\n        // Extract the two minimum\n        // freq items from min heap\n        left = minHeap.top();\n        minHeap.pop();\n\n        right = minHeap.top();\n        minHeap.pop();\n\n        // Create a new internal node with\n        // frequency equal to the sum of the\n        // two nodes frequencies. Make the\n        // two extracted node as left and right children\n        // of this new node. Add this node\n        // to the min heap '$' is a special value\n        // for internal nodes, not used\n        top = new MinHeapNode('$', left->freq + right->freq);\n\n        top->left = left;\n        top->right = right;\n\n        minHeap.push(top);\n    }\n\n    // Print Huffman codes using\n    // the Huffman tree built above\n    printCodes(minHeap.top(), \"\");\n}\n\n// Driver program to test above functions\nint main() {\n    char arr[] = {'a', 'b', 'c', 'd', 'e', 'f'};\n    int freq[] = {5, 9, 12, 13, 16, 45};\n\n    int size = sizeof(arr) / sizeof(arr[0]);\n\n    HuffmanCodes(arr, freq, size);\n\n    return 0;\n}\n","index":91},{"title":"Knapsack","category":"greedy_algorithms","id":"knapsack_greedy_algorithms","algorithm":"#include <iostream>\nusing namespace std;\n\nstruct Item {\n    int weight;\n    int profit;\n};\n\nfloat profitPerUnit(Item x) { return (float)x.profit / (float)x.weight; }\n\nint partition(Item arr[], int low, int high) {\n    Item pivot = arr[high];  // pivot\n    int i = (low - 1);       // Index of smaller element\n\n    for (int j = low; j < high; j++) {\n        // If current element is smaller than or\n        // equal to pivot\n        if (profitPerUnit(arr[j]) <= profitPerUnit(pivot)) {\n            i++;  // increment index of smaller element\n            Item temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n        }\n    }\n    Item temp = arr[i + 1];\n    arr[i + 1] = arr[high];\n    arr[high] = temp;\n    return (i + 1);\n}\n\nvoid quickSort(Item arr[], int low, int high) {\n    if (low < high) {\n        int p = partition(arr, low, high);\n\n        quickSort(arr, low, p - 1);\n        quickSort(arr, p + 1, high);\n    }\n}\n\nint main() {\n    cout << \"\\nEnter the capacity of the knapsack : \";\n    float capacity;\n    cin >> capacity;\n    cout << \"\\n Enter the number of Items : \";\n    int n;\n    cin >> n;\n    Item itemArray[n];\n    for (int i = 0; i < n; i++) {\n        cout << \"\\nEnter the weight and profit of item \" << i + 1 << \" : \";\n        cin >> itemArray[i].weight;\n        cin >> itemArray[i].profit;\n    }\n\n    quickSort(itemArray, 0, n - 1);\n\n    // show(itemArray, n);\n\n    float maxProfit = 0;\n    int i = n;\n    while (capacity > 0 && --i >= 0) {\n        if (capacity >= itemArray[i].weight) {\n            maxProfit += itemArray[i].profit;\n            capacity -= itemArray[i].weight;\n            cout << \"\\n\\t\" << itemArray[i].weight << \"\\t\"\n                 << itemArray[i].profit;\n        } else {\n            maxProfit += profitPerUnit(itemArray[i]) * capacity;\n            cout << \"\\n\\t\" << capacity << \"\\t\"\n                 << profitPerUnit(itemArray[i]) * capacity;\n            capacity = 0;\n            break;\n        }\n    }\n\n    cout << \"\\nMax Profit : \" << maxProfit;\n\n    return 0;\n}\n","index":92},{"title":"Kruskals Minimum Spanning Tree","category":"greedy_algorithms","id":"kruskals_minimum_spanning_tree_greedy_algorithms","algorithm":"#include <iostream>\nusing namespace std;\n\n#define V 6\n#define INFINITY 99999\n\nint graph[V][V] = {{0, 4, 1, 4, INFINITY, INFINITY},\n                   {4, 0, 3, 8, 3, INFINITY},\n                   {1, 3, 0, INFINITY, 1, INFINITY},\n                   {4, 8, INFINITY, 0, 5, 7},\n                   {INFINITY, 3, 1, 5, 0, INFINITY},\n                   {INFINITY, INFINITY, INFINITY, 7, INFINITY, 0}};\n\nvoid findMinimumEdge() {\n    for (int i = 0; i < V; i++) {\n        int min = INFINITY;\n        int minIndex = 0;\n        for (int j = 0; j < V; j++) {\n            if (graph[i][j] != 0 && graph[i][j] < min) {\n                min = graph[i][j];\n                minIndex = j;\n            }\n        }\n        cout << i << \"  -  \" << minIndex << \"\\t\" << graph[i][minIndex] << \"\\n\";\n    }\n}\n\nint main() {\n    findMinimumEdge();\n    return 0;\n}\n","index":93},{"title":"Prims Minimum Spanning Tree","category":"greedy_algorithms","id":"prims_minimum_spanning_tree_greedy_algorithms","algorithm":"#include <iostream>\nusing namespace std;\n\n#define V 4\n#define INFINITY 99999\n\nint graph[V][V] = {{0, 5, 1, 2}, {5, 0, 3, 3}, {1, 3, 0, 4}, {2, 3, 4, 0}};\n\nstruct mst {\n    bool visited;\n    int key;\n    int near;\n};\n\nmst MST_Array[V];\n\nvoid initilize() {\n    for (int i = 0; i < V; i++) {\n        MST_Array[i].visited = false;\n        MST_Array[i].key = INFINITY;  // considering INFINITY as inifinity\n        MST_Array[i].near = i;\n    }\n\n    MST_Array[0].key = 0;\n}\n\nvoid updateNear() {\n    for (int v = 0; v < V; v++) {\n        int min = INFINITY;\n        int minIndex = 0;\n        for (int i = 0; i < V; i++) {\n            if (MST_Array[i].key < min && MST_Array[i].visited == false &&\n                MST_Array[i].key != INFINITY) {\n                min = MST_Array[i].key;\n                minIndex = i;\n            }\n        }\n\n        MST_Array[minIndex].visited = true;\n\n        for (int i = 0; i < V; i++) {\n            if (graph[minIndex][i] != 0 && graph[minIndex][i] < INFINITY) {\n                if (graph[minIndex][i] < MST_Array[i].key) {\n                    MST_Array[i].key = graph[minIndex][i];\n                    MST_Array[i].near = minIndex;\n                }\n            }\n        }\n    }\n}\n\nvoid show() {\n    for (int i = 0; i < V; i++) {\n        cout << i << \"  -  \" << MST_Array[i].near << \"\\t\"\n             << graph[i][MST_Array[i].near] << \"\\n\";\n    }\n}\n\nint main() {\n    initilize();\n    updateNear();\n    show();\n    return 0;\n}\n","index":94},{"title":"Hashing","category":null,"id":"hashing","index":95},{"title":"Chaining","category":"hashing","id":"chaining_hashing","algorithm":"/**\n * @file chaining.cpp\n * @author [vasutomar](https://github.com/vasutomar)\n * @author [Krishna Vedala](https://github.com/kvedala)\n * @brief Implementation of [hash\n * chains](https://en.wikipedia.org/wiki/Hash_chain).\n */\n#include <cmath>\n#include <iostream>\n#include <memory>\n#include <vector>\n\n/**\n * @brief Chain class with a given modulus\n */\nclass hash_chain {\n private:\n    /**\n     * @brief Define a linked node\n     */\n    using Node = struct Node {\n        int data{};                         ///< data stored in the node\n        std::shared_ptr<struct Node> next;  ///< pointer to the next node\n    };\n\n    std::vector<std::shared_ptr<Node>> head;  ///< array of nodes\n    int _mod;                                        ///< modulus of the class\n\n public:\n    /**\n     * @brief Construct a new chain object\n     *\n     * @param mod modulus of the chain\n     */\n    explicit hash_chain(int mod) : _mod(mod) {\n        while (mod--) head.push_back(nullptr);\n    }\n\n    /**\n     * @brief create and add a new node with a give value and at a given height\n     *\n     * @param x value at the new node\n     * @param h height of the node\n     */\n    void add(int x, int h) {\n        std::shared_ptr<Node> curr;\n        std::shared_ptr<Node> temp(new Node);\n        temp->data = x;\n        temp->next = nullptr;\n        if (!head[h]) {\n            head[h] = temp;\n            curr = head[h];\n        } else {\n            curr = head[h];\n            while (curr->next) curr = curr->next;\n            curr->next = temp;\n        }\n    }\n\n    /**\n     * @brief Display the chain\n     */\n    void display() {\n        std::shared_ptr<Node> temp = nullptr;\n        int i = 0;\n        for (i = 0; i < _mod; i++) {\n            if (!head[i]) {\n                std::cout << \"Key \" << i << \" is empty\" << std::endl;\n            } else {\n                std::cout << \"Key \" << i << \" has values = \";\n                temp = head[i];\n                while (temp->next) {\n                    std::cout << temp->data << \" \";\n                    temp = temp->next;\n                }\n                std::cout << temp->data;\n                std::cout << std::endl;\n            }\n        }\n    }\n\n    /**\n     * @brief Compute the hash of a value for current chain\n     *\n     * @param x value to compute modulus of\n     * @return modulus of `x`\n     * @note declared as a\n     * [`virtual`](https://en.cppreference.com/w/cpp/language/virtual) so that\n     * custom implementations of the class can modify the hash function.\n     */\n    virtual int hash(int x) const { return x % _mod; }\n\n    /**\n     * @brief Find if a value and corresponding hash exist\n     *\n     * @param x value to search for\n     * @param h corresponding hash key\n     * @returns `true` if element found\n     * @returns `false` if element not found\n     */\n    bool find(int x, int h) const {\n        std::shared_ptr<Node> temp = head[h];\n        if (!head[h]) {\n            // index does not exist!\n            std::cout << \"Element not found\";\n            return false;\n        }\n\n        // scan for data value\n        while (temp->data != x && temp->next) temp = temp->next;\n\n        if (temp->next) {\n            std::cout << \"Element found\";\n            return true;\n        }\n\n        // implicit else condition\n        // i.e., temp->next == nullptr\n        if (temp->data == x) {\n            std::cout << \"Element found\";\n            return true;\n        }\n\n        // further implicit else condition\n        std::cout << \"Element not found\";\n        return false;\n    }\n};\n\n/** Main function\n * @returns `0` always\n */\nint main() {\n    int c = 0, x = 0, mod = 0, h = 0;\n    std::cout << \"Enter the size of Hash Table. = \";\n    std::cin >> mod;\n\n    hash_chain mychain(mod);\n\n    bool loop = true;\n    while (loop) {\n        std::cout << std::endl;\n        std::cout << \"PLEASE CHOOSE -\" << std::endl;\n        std::cout << \"1. Add element.\" << std::endl;\n        std::cout << \"2. Find element.\" << std::endl;\n        std::cout << \"3. Generate Hash.\" << std::endl;\n        std::cout << \"4. Display Hash table.\" << std::endl;\n        std::cout << \"5. Exit.\" << std::endl;\n        std::cin >> c;\n        switch (c) {\n            case 1:\n                std::cout << \"Enter element to add = \";\n                std::cin >> x;\n                h = mychain.hash(x);\n                h = std::abs(h);\n                mychain.add(x, h);\n                break;\n            case 2:\n                std::cout << \"Enter element to search = \";\n                std::cin >> x;\n                h = mychain.hash(x);\n                mychain.find(x, h);\n                break;\n            case 3:\n                std::cout << \"Enter element to generate hash = \";\n                std::cin >> x;\n                std::cout << \"Hash of \" << x << \" is = \" << mychain.hash(x);\n                break;\n            case 4:\n                mychain.display();\n                break;\n            default:\n                loop = false;\n                break;\n        }\n        std::cout << std::endl;\n    }\n    /*add(1,&head1);\n    add(2,&head1);\n    add(3,&head2);\n    add(5,&head1);\n    display(&head1);\n    display(&head2);*/\n    return 0;\n}\n","index":96},{"title":"Double Hash Hash Table","category":"hashing","id":"double_hash_hash_table_hashing","algorithm":"/**\n * @file double_hash_hash_table.cpp\n * @author [achance6](https://github.com/achance6)\n * @author [Krishna Vedala](https://github.com/kvedala)\n * @brief Storage mechanism using [double-hashed\n * keys](https://en.wikipedia.org/wiki/Double_hashing).\n * @note The implementation can be optimized by using OOP style.\n */\n#include <iostream>\n#include <memory>\n#include <vector>\n\n/**\n * @addtogroup open_addressing Open Addressing\n * @{\n * @namespace double_hashing\n * @brief An implementation of hash table using [double\n * hashing](https://en.wikipedia.org/wiki/Double_hashing) algorithm.\n */\nnamespace double_hashing {\n// fwd declarations\nusing Entry = struct Entry;\nbool putProber(const Entry& entry, int key);\nbool searchingProber(const Entry& entry, int key);\nvoid add(int key);\n\n// Undocumented globals\nint notPresent;\nstd::vector<Entry> table;\nint totalSize;\nint tomb = -1;\nint size;\nbool rehashing;\n\n/** Node object that holds key */\nstruct Entry {\n    explicit Entry(int key = notPresent) : key(key) {}  ///< constructor\n    int key;                                            ///< key value\n};\n\n/**\n * @brief Hash a key. Uses the STL library's `std::hash()` function.\n *\n * @param key value to hash\n * @return hash value of the key\n */\nsize_t hashFxn(int key) {\n    std::hash<int> hash;\n    return hash(key);\n}\n\n/**\n * @brief Used for second hash function\n *\n * @param key key value to hash\n * @return  hash value of the key\n */\nsize_t otherHashFxn(int key) {\n    std::hash<int> hash;\n    return 1 + (7 - (hash(key) % 7));\n}\n\n/**\n * @brief Performs double hashing to resolve collisions\n *\n * @param key key value to apply double-hash on\n * @param searching `true` to check for conflicts\n * @return Index of key when found\n * @return new hash if no conflicts present\n */\nint doubleHash(int key, bool searching) {\n    int hash = static_cast<int>(hashFxn(key));\n    int i = 0;\n    Entry entry;\n    do {\n        int index =\n            static_cast<int>(hash + (i * otherHashFxn(key))) % totalSize;\n        entry = table[index];\n        if (searching) {\n            if (entry.key == notPresent) {\n                return notPresent;\n            }\n            if (searchingProber(entry, key)) {\n                std::cout << \"Found key!\" << std::endl;\n                return index;\n            }\n            std::cout << \"Found tombstone or equal hash, checking next\"\n                      << std::endl;\n            i++;\n        } else {\n            if (putProber(entry, key)) {\n                if (!rehashing) {\n                    std::cout << \"Spot found!\" << std::endl;\n                }\n                return index;\n            }\n            if (!rehashing) {\n                std::cout << \"Spot taken, looking at next (next index:\"\n                          << \" \"\n                          << static_cast<int>(hash + (i * otherHashFxn(key))) %\n                                 totalSize\n                          << \")\" << std::endl;\n            }\n            i++;\n        }\n        if (i == totalSize * 100) {\n            std::cout << \"DoubleHash probe failed\" << std::endl;\n            return notPresent;\n        }\n    } while (entry.key != notPresent);\n    return notPresent;\n}\n\n/** Finds empty spot in a vector\n * @param entry vector to search in\n * @param key key to search for\n * @returns `true` if key is not present or is a `toumb`\n * @returns `false` is already occupied\n */\nbool putProber(const Entry& entry, int key) {\n    if (entry.key == notPresent || entry.key == tomb) {\n        return true;\n    }\n    return false;\n}\n\n/** Looks for a matching key\n * @param entry vector to search in\n * @param key key value to search\n * @returns `true` if found\n * @returns `false` if not found\n */\nbool searchingProber(const Entry& entry, int key) {\n    if (entry.key == key) {\n        return true;\n    }\n    return false;\n}\n\n/** Displays the table\n * @returns None\n */\nvoid display() {\n    for (int i = 0; i < totalSize; i++) {\n        if (table[i].key == notPresent) {\n            std::cout << \" Empty \";\n        } else if (table[i].key == tomb) {\n            std::cout << \" Tomb \";\n        } else {\n            std::cout << \" \";\n            std::cout << table[i].key;\n            std::cout << \" \";\n        }\n    }\n    std::cout << std::endl;\n}\n\n/** Rehashes the table into a bigger table\n * @returns None\n */\nvoid rehash() {\n    // Necessary so wall of add info isn't printed all at once\n    rehashing = true;\n    int oldSize = totalSize;\n    std::vector<Entry> oldTable(table);\n    // Really this should use the next prime number greater than totalSize * 2\n    table = std::vector<Entry>(totalSize * 2);\n    totalSize *= 2;\n    for (int i = 0; i < oldSize; i++) {\n        if (oldTable[i].key != -1 && oldTable[i].key != notPresent) {\n            size--;  // Size stays the same (add increments size)\n            add(oldTable[i].key);\n        }\n    }\n    // delete[] oldTable;\n    // oldTable.reset();\n\n    rehashing = false;\n    std::cout << \"Table was rehashed, new size is: \" << totalSize << std::endl;\n}\n\n/** Checks for load factor here\n * @param key key value to add to the table\n */\nvoid add(int key) {\n    // auto* entry = new Entry();\n    // entry->key = key;\n    int index = doubleHash(key, false);\n    table[index].key = key;\n    // Load factor greater than 0.5 causes resizing\n    if (++size / static_cast<double>(totalSize) >= 0.5) {\n        rehash();\n    }\n}\n\n/** Removes key. Leaves tombstone upon removal.\n * @param key key value to remove\n */\nvoid remove(int key) {\n    int index = doubleHash(key, true);\n    if (index == notPresent) {\n        std::cout << \"key not found\" << std::endl;\n    }\n    table[index].key = tomb;\n    std::cout << \"Removal successful, leaving tombstone\" << std::endl;\n    size--;\n}\n\n/** Information about the adding process\n * @param key key value to add to table\n */\nvoid addInfo(int key) {\n    std::cout << \"Initial table: \";\n    display();\n    std::cout << std::endl;\n    std::cout << \"hash of \" << key << \" is \" << hashFxn(key) << \" % \"\n              << totalSize << \" == \" << hashFxn(key) % totalSize;\n    std::cout << std::endl;\n    add(key);\n    std::cout << \"New table: \";\n    display();\n}\n\n/** Information about removal process\n * @param key key value to remove from table\n */\nvoid removalInfo(int key) {\n    std::cout << \"Initial table: \";\n    display();\n    std::cout << std::endl;\n    std::cout << \"hash of \" << key << \" is \" << hashFxn(key) << \" % \"\n              << totalSize << \" == \" << hashFxn(key) % totalSize;\n    std::cout << std::endl;\n    remove(key);\n    std::cout << \"New table: \";\n    display();\n}\n}  // namespace double_hashing\n/**\n * @}\n */\n\nusing double_hashing::Entry;\nusing double_hashing::table;\nusing double_hashing::totalSize;\n\n/** Main program\n * @returns 0 on success\n */\nint main() {\n    int cmd = 0, hash = 0, key = 0;\n    std::cout << \"Enter the initial size of Hash Table. = \";\n    std::cin >> totalSize;\n    table = std::vector<Entry>(totalSize);\n    bool loop = true;\n    while (loop) {\n        std::cout << std::endl;\n        std::cout << \"PLEASE CHOOSE -\" << std::endl;\n        std::cout << \"1. Add key. (Numeric only)\" << std::endl;\n        std::cout << \"2. Remove key.\" << std::endl;\n        std::cout << \"3. Find key.\" << std::endl;\n        std::cout << \"4. Generate Hash. (Numeric only)\" << std::endl;\n        std::cout << \"5. Display Hash table.\" << std::endl;\n        std::cout << \"6. Exit.\" << std::endl;\n        std::cin >> cmd;\n        switch (cmd) {\n            case 1:\n                std::cout << \"Enter key to add = \";\n                std::cin >> key;\n                double_hashing::addInfo(key);\n                break;\n            case 2:\n                std::cout << \"Enter key to remove = \";\n                std::cin >> key;\n                double_hashing::removalInfo(key);\n                break;\n            case 3: {\n                std::cout << \"Enter key to search = \";\n                std::cin >> key;\n                Entry entry = table[double_hashing::doubleHash(key, true)];\n                if (entry.key == double_hashing::notPresent) {\n                    std::cout << \"Key not present\";\n                }\n                break;\n            }\n            case 4:\n                std::cout << \"Enter element to generate hash = \";\n                std::cin >> key;\n                std::cout << \"Hash of \" << key\n                          << \" is = \" << double_hashing::hashFxn(key);\n                break;\n            case 5:\n                double_hashing::display();\n                break;\n            default:\n                loop = false;\n                break;\n                // delete[] table;\n        }\n        std::cout << std::endl;\n    }\n    return 0;\n}\n","index":97},{"title":"Linear Probing Hash Table","category":"hashing","id":"linear_probing_hash_table_hashing","algorithm":"/**\n * @file\n * @author [achance6](https://github.com/achance6)\n * @author [Krishna Vedala](https://github.com/kvedala)\n * @brief Storage mechanism using [linear probing\n * hash](https://en.wikipedia.org/wiki/Linear_probing) keys.\n * @note The implementation can be optimized by using OOP style.\n */\n#include <iostream>\n#include <vector>\n\n/**\n * @addtogroup open_addressing Open Addressing\n * @{\n * @namespace linear_probing\n * @brief An implementation of hash table using [linear\n * probing](https://en.wikipedia.org/wiki/Linear_probing) algorithm.\n */\nnamespace linear_probing {\n// fwd declarations\nusing Entry = struct Entry;\nbool putProber(const Entry& entry, int key);\nbool searchingProber(const Entry& entry, int key);\nvoid add(int key);\n\n// Undocumented globals\nint notPresent;\nstd::vector<Entry> table;\nint totalSize;\nint tomb = -1;\nint size;\nbool rehashing;\n\n/** Node object that holds key */\nstruct Entry {\n    explicit Entry(int key = notPresent) : key(key) {}  ///< constructor\n    int key;                                            ///< key value\n};\n\n/**\n * @brief Hash a key. Uses the STL library's `std::hash()` function.\n *\n * @param key value to hash\n * @return hash value of the key\n */\nsize_t hashFxn(int key) {\n    std::hash<int> hash;\n    return hash(key);\n}\n\n/** Performs linear probing to resolve collisions\n * @param key key value to hash\n * @return hash value of the key\n */\nint linearProbe(int key, bool searching) {\n    int hash = static_cast<int>(hashFxn(key));\n    int i = 0;\n    Entry entry;\n    do {\n        int index = static_cast<int>((hash + i) % totalSize);\n        entry = table[index];\n        if (searching) {\n            if (entry.key == notPresent) {\n                return notPresent;\n            }\n            if (searchingProber(entry, key)) {\n                std::cout << \"Found key!\" << std::endl;\n                return index;\n            }\n            std::cout << \"Found tombstone or equal hash, checking next\"\n                      << std::endl;\n            i++;\n        } else {\n            if (putProber(entry, key)) {\n                if (!rehashing) {\n                    std::cout << \"Spot found!\" << std::endl;\n                }\n                return index;\n            }\n            if (!rehashing) {\n                std::cout << \"Spot taken, looking at next\" << std::endl;\n            }\n            i++;\n        }\n        if (i == totalSize) {\n            std::cout << \"Linear probe failed\" << std::endl;\n            return notPresent;\n        }\n    } while (entry.key != notPresent);\n    return notPresent;\n}\n\n/** Finds empty spot\n * @param entry instance to check in\n * @param key key value to hash\n * @return hash value of the key\n */\nbool putProber(const Entry& entry, int key) {\n    if (entry.key == notPresent || entry.key == tomb) {\n        return true;\n    }\n    return false;\n}\n\n/** Looks for a matching key\n * @param entry instance to check in\n * @param key key value to hash\n * @return hash value of the key\n */\nbool searchingProber(const Entry& entry, int key) {\n    if (entry.key == key) {\n        return true;\n    }\n    return false;\n}\n\n/** Function to displays the table\n * @returns none\n */\nvoid display() {\n    for (int i = 0; i < totalSize; i++) {\n        if (table[i].key == notPresent) {\n            std::cout << \" Empty \";\n        } else if (table[i].key == tomb) {\n            std::cout << \" Tomb \";\n        } else {\n            std::cout << \" \";\n            std::cout << table[i].key;\n            std::cout << \" \";\n        }\n    }\n    std::cout << std::endl;\n}\n\n/** Rehashes the table into a bigger table\n * @returns None\n */\nvoid rehash() {\n    // Necessary so wall of add info isn't printed all at once\n    rehashing = true;\n    int oldSize = totalSize;\n    std::vector<Entry> oldTable(table);\n    // Really this should use the next prime number greater than totalSize *\n    // 2\n    totalSize *= 2;\n    table = std::vector<Entry>(totalSize);\n    for (int i = 0; i < oldSize; i++) {\n        if (oldTable[i].key != -1 && oldTable[i].key != notPresent) {\n            size--;  // Size stays the same (add increments size)\n            add(oldTable[i].key);\n        }\n    }\n    // delete[] oldTable;\n    rehashing = false;\n    std::cout << \"Table was rehashed, new size is: \" << totalSize << std::endl;\n}\n\n/** Adds entry using linear probing. Checks for load factor here\n * @param key key value to hash and add\n */\nvoid add(int key) {\n    int index = linearProbe(key, false);\n    table[index].key = key;\n    // Load factor greater than 0.5 causes resizing\n    if (++size / static_cast<double>(totalSize) >= 0.5) {\n        rehash();\n    }\n}\n\n/** Removes key. Leaves tombstone upon removal.\n * @param key key value to hash and remove\n */\nvoid remove(int key) {\n    int index = linearProbe(key, true);\n    if (index == notPresent) {\n        std::cout << \"key not found\" << std::endl;\n    }\n    std::cout << \"Removal Successful, leaving tomb\" << std::endl;\n    table[index].key = tomb;\n    size--;\n}\n\n/** Information about the adding process\n * @param key key value to hash and add\n */\nvoid addInfo(int key) {\n    std::cout << \"Initial table: \";\n    display();\n    std::cout << std::endl;\n    std::cout << \"hash of \" << key << \" is \" << hashFxn(key) << \" % \"\n              << totalSize << \" == \" << hashFxn(key) % totalSize;\n    std::cout << std::endl;\n    add(key);\n    std::cout << \"New table: \";\n    display();\n}\n\n/** Information about removal process\n * @param key key value to hash and remove\n */\nvoid removalInfo(int key) {\n    std::cout << \"Initial table: \";\n    display();\n    std::cout << std::endl;\n    std::cout << \"hash of \" << key << \" is \" << hashFxn(key) << \" % \"\n              << totalSize << \" == \" << hashFxn(key) % totalSize;\n    std::cout << std::endl;\n    remove(key);\n    std::cout << \"New table: \";\n    display();\n}\n}  // namespace linear_probing\n/**\n * @}\n */\n\nusing linear_probing::Entry;\nusing linear_probing::table;\nusing linear_probing::totalSize;\n\n/** Main function\n * @returns 0 on success\n */\nint main() {\n    int cmd = 0, hash = 0, key = 0;\n    std::cout << \"Enter the initial size of Hash Table. = \";\n    std::cin >> totalSize;\n    table = std::vector<Entry>(totalSize);\n    bool loop = true;\n    while (loop) {\n        std::cout << std::endl;\n        std::cout << \"PLEASE CHOOSE -\" << std::endl;\n        std::cout << \"1. Add key. (Numeric only)\" << std::endl;\n        std::cout << \"2. Remove key.\" << std::endl;\n        std::cout << \"3. Find key.\" << std::endl;\n        std::cout << \"4. Generate Hash. (Numeric only)\" << std::endl;\n        std::cout << \"5. Display Hash table.\" << std::endl;\n        std::cout << \"6. Exit.\" << std::endl;\n        std::cin >> cmd;\n        switch (cmd) {\n            case 1:\n                std::cout << \"Enter key to add = \";\n                std::cin >> key;\n                linear_probing::addInfo(key);\n                break;\n            case 2:\n                std::cout << \"Enter key to remove = \";\n                std::cin >> key;\n                linear_probing::removalInfo(key);\n                break;\n            case 3: {\n                std::cout << \"Enter key to search = \";\n                std::cin >> key;\n                Entry entry = table[linear_probing::linearProbe(key, true)];\n                if (entry.key == linear_probing::notPresent) {\n                    std::cout << \"Key not present\";\n                }\n                break;\n            }\n            case 4:\n                std::cout << \"Enter element to generate hash = \";\n                std::cin >> key;\n                std::cout << \"Hash of \" << key\n                          << \" is = \" << linear_probing::hashFxn(key);\n                break;\n            case 5:\n                linear_probing::display();\n                break;\n            default:\n                loop = false;\n                break;\n                // delete[] table;\n        }\n        std::cout << std::endl;\n    }\n    return 0;\n}\n","index":98},{"title":"Quadratic Probing Hash Table","category":"hashing","id":"quadratic_probing_hash_table_hashing","algorithm":"/**\n * @file\n * @author [achance6](https://github.com/achance6)\n * @author [Krishna Vedala](https://github.com/kvedala)\n * @brief Storage mechanism using [quadratic probing\n * hash](https://en.wikipedia.org/wiki/Quadratic_probing) keys.\n * @note The implementation can be optimized by using OOP style.\n */\n#include <cmath>\n#include <iostream>\n#include <vector>\n\n/**\n * @addtogroup open_addressing Open Addressing\n * @{\n * @namespace quadratic_probing\n * @brief An implementation of hash table using [quadratic\n * probing](https://en.wikipedia.org/wiki/Quadratic_probing) algorithm.\n */\nnamespace quadratic_probing {\n// fwd declarations\nusing Entry = struct Entry;\nbool putProber(const Entry& entry, int key);\nbool searchingProber(const Entry& entry, int key);\nvoid add(int key);\n\n// globals\nint notPresent;\nstd::vector<Entry> table;\nint totalSize;\nint tomb = -1;\nint size;\nbool rehashing;\n\n/** Node that holds key\n */\nstruct Entry {\n    explicit Entry(int key = notPresent) : key(key) {}  ///< constructor\n    int key;                                            ///< key value\n};\n\n/** Hash a key\n * @param key key value to hash\n * @returns hash of the key\n */\nsize_t hashFxn(int key) {\n    std::hash<int> hash;\n    return hash(key);\n}\n\n/** Performs quadratic probing to resolve collisions\n * @param key key value to search/probe\n * @param searching `true` if only searching, `false1 if assigning\n * @returns value of `notPresent`.\n */\nint quadraticProbe(int key, bool searching) {\n    int hash = static_cast<int>(hashFxn(key));\n    int i = 0;\n    Entry entry;\n    do {\n        size_t index =\n            (hash + static_cast<size_t>(std::round(std::pow(i, 2)))) %\n            totalSize;\n        entry = table[index];\n        if (searching) {\n            if (entry.key == notPresent) {\n                return notPresent;\n            }\n            if (searchingProber(entry, key)) {\n                std::cout << \"Found key!\" << std::endl;\n                return index;\n            }\n            std::cout << \"Found tombstone or equal hash, checking next\"\n                      << std::endl;\n            i++;\n        } else {\n            if (putProber(entry, key)) {\n                if (!rehashing) {\n                    std::cout << \"Spot found!\" << std::endl;\n                }\n                return index;\n            }\n            if (!rehashing) {\n                std::cout << \"Spot taken, looking at next (next index = \"\n                          << (hash + static_cast<size_t>(\n                                         std::round(std::pow(i + 1, 2)))) %\n                                 totalSize\n                          << std::endl;\n            }\n            i++;\n        }\n        if (i == totalSize * 100) {\n            std::cout << \"Quadratic probe failed (infinite loop)\" << std::endl;\n            return notPresent;\n        }\n    } while (entry.key != notPresent);\n    return notPresent;\n}\n\n/** Finds empty spot\n * @param entry Instance of table entry\n * @param key key value to search/probe\n * @returns `true` if key is present\n * @returns `false` if key is absent\n */\nbool putProber(const Entry& entry, int key) {\n    if (entry.key == notPresent || entry.key == tomb) {\n        return true;\n    }\n    return false;\n}\n\n/** Looks for a matching key\n * @param entry Instance of table entry\n * @param key key value to search/probe\n * @returns `true` if key matches the entry\n * @returns `false` if key does not match the entry\n */\nbool searchingProber(const Entry& entry, int key) {\n    if (entry.key == key) {\n        return true;\n    }\n    return false;\n}\n\n/** Get the entry instance corresponding to a key\n * @param key key value to search/probe\n * @returns if present, the entry instance\n * @returns if not present, a new instance\n */\nEntry find(int key) {\n    int index = quadraticProbe(key, true);\n    if (index == notPresent) {\n        return Entry();\n    }\n    return table[index];\n}\n\n/** Displays the table\n * @returns None\n */\nvoid display() {\n    for (int i = 0; i < totalSize; i++) {\n        if (table[i].key == notPresent) {\n            std::cout << \" Empty \";\n        } else if (table[i].key == tomb) {\n            std::cout << \" Tomb \";\n        } else {\n            std::cout << \" \";\n            std::cout << table[i].key;\n            std::cout << \" \";\n        }\n    }\n    std::cout << std::endl;\n}\n\n/** Rehashes the table into a bigger table\n * @returns none\n */\nvoid rehash() {\n    // Necessary so wall of add info isn't printed all at once\n    rehashing = true;\n    int oldSize = totalSize;\n    std::vector<Entry> oldTable(table);\n    // Really this should use the next prime number greater than totalSize * 2\n    totalSize *= 2;\n    table = std::vector<Entry>(totalSize);\n    for (int i = 0; i < oldSize; i++) {\n        if (oldTable[i].key != -1 && oldTable[i].key != notPresent) {\n            size--;  // Size stays the same (add increments size)\n            add(oldTable[i].key);\n        }\n    }\n    // delete[] oldTable;\n    rehashing = false;\n    std::cout << \"Table was rehashed, new size is: \" << totalSize << std::endl;\n}\n\n/** Checks for load factor here\n * @param key  key value to hash and add to table\n */\nvoid add(int key) {\n    int index = quadraticProbe(key, false);\n    table[index].key = key;\n    // Load factor greater than 0.5 causes resizing\n    if (++size / static_cast<double>(totalSize) >= 0.5) {\n        rehash();\n    }\n}\n\n/** Removes key. Leaves tombstone upon removal.\n * @param key  key value to hash and remove from table\n */\nvoid remove(int key) {\n    int index = quadraticProbe(key, true);\n    if (index == notPresent) {\n        std::cout << \"key not found\" << std::endl;\n    }\n    table[index].key = tomb;\n    std::cout << \"Removal successful, leaving tombstone\" << std::endl;\n    size--;\n}\n\n/** Information about the adding process\n * @param key  key value to hash and add to table\n */\nvoid addInfo(int key) {\n    std::cout << \"Initial table: \";\n    display();\n    std::cout << std::endl;\n    std::cout << \"hash of \" << key << \" is \" << hashFxn(key) << \" % \"\n              << totalSize << \" == \" << hashFxn(key) % totalSize;\n    std::cout << std::endl;\n    add(key);\n    std::cout << \"New table: \";\n    display();\n}\n\n/** Information about removal process\n * @param key  key value to hash and remove from table\n */\nvoid removalInfo(int key) {\n    std::cout << \"Initial table: \";\n    display();\n    std::cout << std::endl;\n    std::cout << \"hash of \" << key << \" is \" << hashFxn(key) << \" % \"\n              << totalSize << \" == \" << hashFxn(key) % totalSize;\n    std::cout << std::endl;\n    remove(key);\n    std::cout << \"New table: \";\n    display();\n}\n\n}  // namespace quadratic_probing\n/**\n * @}\n */\n\nusing quadratic_probing::Entry;\nusing quadratic_probing::table;\nusing quadratic_probing::totalSize;\n\n/** Main function\n * @returns None\n */\nint main() {\n    int cmd = 0, hash = 0, key = 0;\n    std::cout << \"Enter the initial size of Hash Table. = \";\n    std::cin >> totalSize;\n    table = std::vector<Entry>(totalSize);\n    bool loop = true;\n    while (loop) {\n        std::cout << std::endl;\n        std::cout << \"PLEASE CHOOSE -\" << std::endl;\n        std::cout << \"1. Add key. (Numeric only)\" << std::endl;\n        std::cout << \"2. Remove key.\" << std::endl;\n        std::cout << \"3. Find key.\" << std::endl;\n        std::cout << \"4. Generate Hash. (Numeric only)\" << std::endl;\n        std::cout << \"5. Display Hash table.\" << std::endl;\n        std::cout << \"6. Exit.\" << std::endl;\n        std::cin >> cmd;\n        switch (cmd) {\n            case 1:\n                std::cout << \"Enter key to add = \";\n                std::cin >> key;\n                quadratic_probing::addInfo(key);\n                break;\n            case 2:\n                std::cout << \"Enter key to remove = \";\n                std::cin >> key;\n                quadratic_probing::removalInfo(key);\n                break;\n            case 3: {\n                std::cout << \"Enter key to search = \";\n                std::cin >> key;\n                quadratic_probing::Entry entry =\n                    quadratic_probing::table[quadratic_probing::quadraticProbe(\n                        key, true)];\n                if (entry.key == quadratic_probing::notPresent) {\n                    std::cout << \"Key not present\";\n                }\n                break;\n            }\n            case 4:\n                std::cout << \"Enter element to generate hash = \";\n                std::cin >> key;\n                std::cout << \"Hash of \" << key\n                          << \" is = \" << quadratic_probing::hashFxn(key);\n                break;\n            case 5:\n                quadratic_probing::display();\n                break;\n            default:\n                loop = false;\n                break;\n                // delete[] table;\n        }\n        std::cout << std::endl;\n    }\n    return 0;\n}\n","index":99},{"title":"Machine Learning","category":null,"id":"machine_learning","index":100},{"title":"Adaline Learning","category":"machine_learning","id":"adaline_learning_machine_learning","algorithm":"/**\n * \\addtogroup machine_learning Machine Learning Algorithms\n * @{\n * \\file\n * \\brief [Adaptive Linear Neuron\n * (ADALINE)](https://en.wikipedia.org/wiki/ADALINE) implementation\n *\n * \\author [Krishna Vedala](https://github.com/kvedala)\n *\n * \\details\n * <a href=\"https://commons.wikimedia.org/wiki/File:Adaline_flow_chart.gif\"><img\n * src=\"https://upload.wikimedia.org/wikipedia/commons/b/be/Adaline_flow_chart.gif\"\n * alt=\"Structure of an ADALINE network. Source: Wikipedia\"\n * style=\"width:200px; float:right;\"></a>\n *\n * ADALINE is one of the first and simplest single layer artificial neural\n * network. The algorithm essentially implements a linear function\n * \\f[ f\\left(x_0,x_1,x_2,\\ldots\\right) =\n * \\sum_j x_jw_j+\\theta\n * \\f]\n * where \\f$x_j\\f$ are the input features of a sample, \\f$w_j\\f$ are the\n * coefficients of the linear function and \\f$\\theta\\f$ is a constant. If we\n * know the \\f$w_j\\f$, then for any given set of features, \\f$y\\f$ can be\n * computed. Computing the \\f$w_j\\f$ is a supervised learning algorithm wherein\n * a set of features and their corresponding outputs are given and weights are\n * computed using stochastic gradient descent method.\n */\n\n#include <array>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <numeric>\n#include <vector>\n\n/** Maximum number of iterations to learn */\nconstexpr int MAX_ITER = 500;  // INT_MAX\n\n/** \\namespace machine_learning\n * \\brief Machine learning algorithms\n */\nnamespace machine_learning {\nclass adaline {\n public:\n    /**\n     * Default constructor\n     * \\param[in] num_features number of features present\n     * \\param[in] eta learning rate (optional, default=0.1)\n     * \\param[in] convergence accuracy (optional,\n     * default=\\f$1\\times10^{-5}\\f$)\n     */\n    explicit adaline(int num_features, const double eta = 0.01f,\n                     const double accuracy = 1e-5)\n        : eta(eta), accuracy(accuracy) {\n        if (eta <= 0) {\n            std::cerr << \"learning rate should be positive and nonzero\"\n                      << std::endl;\n            std::exit(EXIT_FAILURE);\n        }\n\n        weights = std::vector<double>(\n            num_features +\n            1);  // additional weight is for the constant bias term\n\n        // initialize with random weights in the range [-50, 49]\n        for (double &weight : weights) weight = 1.f;\n        // weights[i] = (static_cast<double>(std::rand() % 100) - 50);\n    }\n\n    /**\n     * Operator to print the weights of the model\n     */\n    friend std::ostream &operator<<(std::ostream &out, const adaline &ada) {\n        out << \"<\";\n        for (int i = 0; i < ada.weights.size(); i++) {\n            out << ada.weights[i];\n            if (i < ada.weights.size() - 1) {\n                out << \", \";\n            }\n        }\n        out << \">\";\n        return out;\n    }\n\n    /**\n     * predict the output of the model for given set of features\n     * \\param[in] x input vector\n     * \\param[out] out optional argument to return neuron output before\n     * applying activation function (optional, `nullptr` to ignore) \\returns\n     * model prediction output\n     */\n    int predict(const std::vector<double> &x, double *out = nullptr) {\n        if (!check_size_match(x)) {\n            return 0;\n        }\n\n        double y = weights.back();  // assign bias value\n\n        // for (int i = 0; i < x.size(); i++) y += x[i] * weights[i];\n        y = std::inner_product(x.begin(), x.end(), weights.begin(), y);\n\n        if (out != nullptr) {  // if out variable is provided\n            *out = y;\n        }\n\n        return activation(y);  // quantizer: apply ADALINE threshold function\n    }\n\n    /**\n     * Update the weights of the model using supervised learning for one\n     * feature vector\n     * \\param[in] x feature vector\n     * \\param[in] y known output value\n     * \\returns correction factor\n     */\n    double fit(const std::vector<double> &x, const int &y) {\n        if (!check_size_match(x)) {\n            return 0;\n        }\n\n        /* output of the model with current weights */\n        int p = predict(x);\n        int prediction_error = y - p;  // error in estimation\n        double correction_factor = eta * prediction_error;\n\n        /* update each weight, the last weight is the bias term */\n        for (int i = 0; i < x.size(); i++) {\n            weights[i] += correction_factor * x[i];\n        }\n        weights[x.size()] += correction_factor;  // update bias\n\n        return correction_factor;\n    }\n\n    /**\n     * Update the weights of the model using supervised learning for an\n     * array of vectors.\n     * \\param[in] X array of feature vector\n     * \\param[in] y known output value for each feature vector\n     */\n    template <size_t N>\n    void fit(std::array<std::vector<double>, N> const &X,\n             std::array<int, N> const &Y) {\n        double avg_pred_error = 1.f;\n\n        int iter = 0;\n        for (iter = 0; (iter < MAX_ITER) && (avg_pred_error > accuracy);\n             iter++) {\n            avg_pred_error = 0.f;\n\n            // perform fit for each sample\n            for (int i = 0; i < N; i++) {\n                double err = fit(X[i], Y[i]);\n                avg_pred_error += std::abs(err);\n            }\n            avg_pred_error /= N;\n\n            // Print updates every 200th iteration\n            // if (iter % 100 == 0)\n            std::cout << \"\\tIter \" << iter << \": Training weights: \" << *this\n                      << \"\\tAvg error: \" << avg_pred_error << std::endl;\n        }\n\n        if (iter < MAX_ITER) {\n            std::cout << \"Converged after \" << iter << \" iterations.\"\n                      << std::endl;\n        } else {\n            std::cout << \"Did not converge after \" << iter << \" iterations.\"\n                      << std::endl;\n        }\n    }\n\n    /** Defines activation function as Heaviside's step function.\n     * \\f[\n     * f(x) = \\begin{cases}\n     * -1 & \\forall x \\le 0\\\\\n     *  1 & \\forall x > 0\n     * \\end{cases}\n     * \\f]\n     * @param x input value to apply activation on\n     * @return activation output\n     */\n    int activation(double x) { return x > 0 ? 1 : -1; }\n\n private:\n    /**\n     * convenient function to check if input feature vector size matches the\n     * model weights size\n     * \\param[in] x fecture vector to check\n     * \\returns `true` size matches\n     * \\returns `false` size does not match\n     */\n    bool check_size_match(const std::vector<double> &x) {\n        if (x.size() != (weights.size() - 1)) {\n            std::cerr << __func__ << \": \"\n                      << \"Number of features in x does not match the feature \"\n                         \"dimension in model!\"\n                      << std::endl;\n            return false;\n        }\n        return true;\n    }\n\n    const double eta;             ///< learning rate of the algorithm\n    const double accuracy;        ///< model fit convergence accuracy\n    std::vector<double> weights;  ///< weights of the neural network\n};\n\n}  // namespace machine_learning\n\nusing machine_learning::adaline;\n\n/** @} */\n\n/**\n * test function to predict points in a 2D coordinate system above the line\n * \\f$x=y\\f$ as +1 and others as -1.\n * Note that each point is defined by 2 values or 2 features.\n * \\param[in] eta learning rate (optional, default=0.01)\n */\nvoid test1(double eta = 0.01) {\n    adaline ada(2, eta);  // 2 features\n\n    const int N = 10;  // number of sample points\n\n    std::array<std::vector<double>, N> X = {\n        std::vector<double>({0, 1}),   std::vector<double>({1, -2}),\n        std::vector<double>({2, 3}),   std::vector<double>({3, -1}),\n        std::vector<double>({4, 1}),   std::vector<double>({6, -5}),\n        std::vector<double>({-7, -3}), std::vector<double>({-8, 5}),\n        std::vector<double>({-9, 2}),  std::vector<double>({-10, -15})};\n    std::array<int, N> y = {1,  -1, 1, -1, -1,\n                            -1, 1,  1, 1,  -1};  // corresponding y-values\n\n    std::cout << \"------- Test 1 -------\" << std::endl;\n    std::cout << \"Model before fit: \" << ada << std::endl;\n\n    ada.fit<N>(X, y);\n    std::cout << \"Model after fit: \" << ada << std::endl;\n\n    int predict = ada.predict({5, -3});\n    std::cout << \"Predict for x=(5,-3): \" << predict;\n    assert(predict == -1);\n    std::cout << \" ...passed\" << std::endl;\n\n    predict = ada.predict({5, 8});\n    std::cout << \"Predict for x=(5,8): \" << predict;\n    assert(predict == 1);\n    std::cout << \" ...passed\" << std::endl;\n}\n\n/**\n * test function to predict points in a 2D coordinate system above the line\n * \\f$x+3y=-1\\f$ as +1 and others as -1.\n * Note that each point is defined by 2 values or 2 features.\n * The function will create random sample points for training and test purposes.\n * \\param[in] eta learning rate (optional, default=0.01)\n */\nvoid test2(double eta = 0.01) {\n    adaline ada(2, eta);  // 2 features\n\n    const int N = 50;  // number of sample points\n\n    std::array<std::vector<double>, N> X;\n    std::array<int, N> Y{};  // corresponding y-values\n\n    // generate sample points in the interval\n    // [-range2/100 , (range2-1)/100]\n    int range = 500;          // sample points full-range\n    int range2 = range >> 1;  // sample points half-range\n    for (int i = 0; i < N; i++) {\n        double x0 = (static_cast<double>(std::rand() % range) - range2) / 100.f;\n        double x1 = (static_cast<double>(std::rand() % range) - range2) / 100.f;\n        X[i] = std::vector<double>({x0, x1});\n        Y[i] = (x0 + 3. * x1) > -1 ? 1 : -1;\n    }\n\n    std::cout << \"------- Test 2 -------\" << std::endl;\n    std::cout << \"Model before fit: \" << ada << std::endl;\n\n    ada.fit(X, Y);\n    std::cout << \"Model after fit: \" << ada << std::endl;\n\n    int N_test_cases = 5;\n    for (int i = 0; i < N_test_cases; i++) {\n        double x0 = (static_cast<double>(std::rand() % range) - range2) / 100.f;\n        double x1 = (static_cast<double>(std::rand() % range) - range2) / 100.f;\n\n        int predict = ada.predict({x0, x1});\n\n        std::cout << \"Predict for x=(\" << x0 << \",\" << x1 << \"): \" << predict;\n\n        int expected_val = (x0 + 3. * x1) > -1 ? 1 : -1;\n        assert(predict == expected_val);\n        std::cout << \" ...passed\" << std::endl;\n    }\n}\n\n/**\n * test function to predict points in a 3D coordinate system lying within the\n * sphere of radius 1 and centre at origin as +1 and others as -1. Note that\n * each point is defined by 3 values but we use 6 features. The function will\n * create random sample points for training and test purposes.\n * The sphere centred at origin and radius 1 is defined as:\n * \\f$x^2+y^2+z^2=r^2=1\\f$ and if the \\f$r^2<1\\f$, point lies within the sphere\n * else, outside.\n *\n * \\param[in] eta learning rate (optional, default=0.01)\n */\nvoid test3(double eta = 0.01) {\n    adaline ada(6, eta);  // 2 features\n\n    const int N = 100;  // number of sample points\n\n    std::array<std::vector<double>, N> X;\n    std::array<int, N> Y{};  // corresponding y-values\n\n    // generate sample points in the interval\n    // [-range2/100 , (range2-1)/100]\n    int range = 200;          // sample points full-range\n    int range2 = range >> 1;  // sample points half-range\n    for (int i = 0; i < N; i++) {\n        double x0 = (static_cast<double>(std::rand() % range) - range2) / 100.f;\n        double x1 = (static_cast<double>(std::rand() % range) - range2) / 100.f;\n        double x2 = (static_cast<double>(std::rand() % range) - range2) / 100.f;\n        X[i] = std::vector<double>({x0, x1, x2, x0 * x0, x1 * x1, x2 * x2});\n        Y[i] = ((x0 * x0) + (x1 * x1) + (x2 * x2)) <= 1.f ? 1 : -1;\n    }\n\n    std::cout << \"------- Test 3 -------\" << std::endl;\n    std::cout << \"Model before fit: \" << ada << std::endl;\n\n    ada.fit(X, Y);\n    std::cout << \"Model after fit: \" << ada << std::endl;\n\n    int N_test_cases = 5;\n    for (int i = 0; i < N_test_cases; i++) {\n        double x0 = (static_cast<double>(std::rand() % range) - range2) / 100.f;\n        double x1 = (static_cast<double>(std::rand() % range) - range2) / 100.f;\n        double x2 = (static_cast<double>(std::rand() % range) - range2) / 100.f;\n\n        int predict = ada.predict({x0, x1, x2, x0 * x0, x1 * x1, x2 * x2});\n\n        std::cout << \"Predict for x=(\" << x0 << \",\" << x1 << \",\" << x2\n                  << \"): \" << predict;\n\n        int expected_val = ((x0 * x0) + (x1 * x1) + (x2 * x2)) <= 1.f ? 1 : -1;\n        assert(predict == expected_val);\n        std::cout << \" ...passed\" << std::endl;\n    }\n}\n\n/** Main function */\nint main(int argc, char **argv) {\n    std::srand(std::time(nullptr));  // initialize random number generator\n\n    double eta = 0.1;  // default value of eta\n    if (argc == 2) {   // read eta value from commandline argument if present\n        eta = strtof(argv[1], nullptr);\n    }\n\n    test1(eta);\n\n    std::cout << \"Press ENTER to continue...\" << std::endl;\n    std::cin.get();\n\n    test2(eta);\n\n    std::cout << \"Press ENTER to continue...\" << std::endl;\n    std::cin.get();\n\n    test3(eta);\n\n    return 0;\n}\n","index":101},{"title":"Kohonen Som Topology","category":"machine_learning","id":"kohonen_som_topology_machine_learning","algorithm":"/**\n * \\addtogroup machine_learning Machine Learning Algorithms\n * @{\n * \\file\n * \\author [Krishna Vedala](https://github.com/kvedala)\n *\n * \\brief [Kohonen self organizing\n * map](https://en.wikipedia.org/wiki/Self-organizing_map) (topological map)\n *\n * \\details\n * This example implements a powerful unsupervised learning algorithm called as\n * a self organizing map. The algorithm creates a connected network of weights\n * that closely follows the given data points. This thus creates a topological\n * map of the given data i.e., it maintains the relationship between varipus\n * data points in a much higher dimesional space by creating an equivalent in a\n * 2-dimensional space.\n * <img alt=\"Trained topological maps for the test cases in the program\"\n * src=\"https://raw.githubusercontent.com/TheAlgorithms/C-Plus-Plus/docs/images/machine_learning/2D_Kohonen_SOM.svg\"\n * />\n * \\note This C++ version of the program is considerable slower than its [C\n * counterpart](https://github.com/kvedala/C/blob/master/machine_learning/kohonen_som_trace.c)\n * \\note The compiled code is much slower when compiled with MS Visual C++ 2019\n * than with GCC on windows\n * \\see kohonen_som_trace.cpp\n */\n#define _USE_MATH_DEFINES  //< required for MS Visual C++\n#include <algorithm>\n#include <array>\n#include <cerrno>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <iostream>\n#include <valarray>\n#include <vector>\n#ifdef _OPENMP  // check if OpenMP based parallellization is available\n#include <omp.h>\n#endif\n\n/**\n * Helper function to generate a random number in a given interval.\n * \\n Steps:\n * 1. `r1 = rand() % 100` gets a random number between 0 and 99\n * 2. `r2 = r1 / 100` converts random number to be between 0 and 0.99\n * 3. scale and offset the random number to given range of \\f$[a,b]\\f$\n *\n * \\param[in] a lower limit\n * \\param[in] b upper limit\n * \\returns random number in the range \\f$[a,b]\\f$\n */\ndouble _random(double a, double b) {\n    return ((b - a) * (std::rand() % 100) / 100.f) + a;\n}\n\n/**\n * Save a given n-dimensional data martix to file.\n *\n * \\param[in] fname filename to save in (gets overwriten without confirmation)\n * \\param[in] X matrix to save\n * \\returns 0 if all ok\n * \\returns -1 if file creation failed\n */\nint save_2d_data(const char *fname,\n                 const std::vector<std::valarray<double>> &X) {\n    size_t num_points = X.size();       // number of rows\n    size_t num_features = X[0].size();  // number of columns\n\n    std::ofstream fp;\n    fp.open(fname);\n    if (!fp.is_open()) {\n        // error with opening file to write\n        std::cerr << \"Error opening file \" << fname << \": \"\n                  << std::strerror(errno) << \"\\n\";\n        return -1;\n    }\n\n    // for each point in the array\n    for (int i = 0; i < num_points; i++) {\n        // for each feature in the array\n        for (int j = 0; j < num_features; j++) {\n            fp << X[i][j];               // print the feature value\n            if (j < num_features - 1) {  // if not the last feature\n                fp << \",\";               // suffix comma\n            }\n        }\n        if (i < num_points - 1) {  // if not the last row\n            fp << \"\\n\";            // start a new line\n        }\n    }\n\n    fp.close();\n    return 0;\n}\n\n/**\n * Get minimum value and index of the value in a matrix\n * \\param[in] X matrix to search\n * \\param[in] N number of points in the vector\n * \\param[out] val minimum value found\n * \\param[out] idx_x x-index where minimum value was found\n * \\param[out] idx_y y-index where minimum value was found\n */\nvoid get_min_2d(const std::vector<std::valarray<double>> &X, double *val,\n                int *x_idx, int *y_idx) {\n    val[0] = INFINITY;  // initial min value\n    size_t N = X.size();\n\n    for (int i = 0; i < N; i++) {  // traverse each x-index\n        auto result = std::min_element(std::begin(X[i]), std::end(X[i]));\n        double d_min = *result;\n        std::ptrdiff_t j = std::distance(std::begin(X[i]), result);\n\n        if (d_min < val[0]) {  // if a lower value is found\n                               // save the value and its index\n            x_idx[0] = i;\n            y_idx[0] = j;\n            val[0] = d_min;\n        }\n    }\n}\n\n/** \\namespace machine_learning\n * \\brief Machine learning algorithms\n */\nnamespace machine_learning {\n/** Minimum average distance of image nodes */\nconstexpr double MIN_DISTANCE = 1e-4;\n\n/**\n * Create the distance matrix or\n * [U-matrix](https://en.wikipedia.org/wiki/U-matrix) from the trained\n * 3D weiths matrix and save to disk.\n *\n * \\param [in] fname filename to save in (gets overwriten without\n * confirmation)\n * \\param [in] W model matrix to save\n * \\returns 0 if all ok\n * \\returns -1 if file creation failed\n */\nint save_u_matrix(const char *fname,\n                  const std::vector<std::vector<std::valarray<double>>> &W) {\n    std::ofstream fp(fname);\n    if (!fp) {  // error with fopen\n        std::cerr << \"File error (\" << fname << \"): \" << std::strerror(errno)\n                  << std::endl;\n        return -1;\n    }\n\n    // neighborhood range\n    unsigned int R = 1;\n\n    for (int i = 0; i < W.size(); i++) {         // for each x\n        for (int j = 0; j < W[0].size(); j++) {  // for each y\n            double distance = 0.f;\n\n            int from_x = std::max<int>(0, i - R);\n            int to_x = std::min<int>(W.size(), i + R + 1);\n            int from_y = std::max<int>(0, j - R);\n            int to_y = std::min<int>(W[0].size(), j + R + 1);\n            int l = 0, m = 0;\n#ifdef _OPENMP\n#pragma omp parallel for reduction(+ : distance)\n#endif\n            for (l = from_x; l < to_x; l++) {      // scan neighborhoor in x\n                for (m = from_y; m < to_y; m++) {  // scan neighborhood in y\n                    auto d = W[i][j] - W[l][m];\n                    double d2 = std::pow(d, 2).sum();\n                    distance += std::sqrt(d2);\n                    // distance += d2;\n                }\n            }\n\n            distance /= R * R;          // mean distance from neighbors\n            fp << distance;             // print the mean separation\n            if (j < W[0].size() - 1) {  // if not the last column\n                fp << ',';              // suffix comma\n            }\n        }\n        if (i < W.size() - 1) {  // if not the last row\n            fp << '\\n';          // start a new line\n        }\n    }\n\n    fp.close();\n    return 0;\n}\n\n/**\n * Update weights of the SOM using Kohonen algorithm\n *\n * \\param[in] X data point - N features\n * \\param[in,out] W weights matrix - PxQxN\n * \\param[in,out] D temporary vector to store distances PxQ\n * \\param[in] alpha learning rate \\f$0<\\alpha\\le1\\f$\n * \\param[in] R neighborhood range\n * \\returns minimum distance of sample and trained weights\n */\ndouble update_weights(const std::valarray<double> &X,\n                      std::vector<std::vector<std::valarray<double>>> *W,\n                      std::vector<std::valarray<double>> *D, double alpha,\n                      int R) {\n    int x = 0, y = 0;\n    int num_out_x = static_cast<int>(W->size());       // output nodes - in X\n    int num_out_y = static_cast<int>(W[0][0].size());  // output nodes - in Y\n    // int num_features = static_cast<int>(W[0][0][0].size());  //  features =\n    // in Z\n    double d_min = 0.f;\n\n#ifdef _OPENMP\n#pragma omp for\n#endif\n    // step 1: for each output point\n    for (x = 0; x < num_out_x; x++) {\n        for (y = 0; y < num_out_y; y++) {\n            (*D)[x][y] = 0.f;\n            // compute Euclidian distance of each output\n            // point from the current sample\n            auto d = ((*W)[x][y] - X);\n            (*D)[x][y] = (d * d).sum();\n            (*D)[x][y] = std::sqrt((*D)[x][y]);\n        }\n    }\n\n    // step 2:  get closest node i.e., node with snallest Euclidian distance\n    // to the current pattern\n    int d_min_x = 0, d_min_y = 0;\n    get_min_2d(*D, &d_min, &d_min_x, &d_min_y);\n\n    // step 3a: get the neighborhood range\n    int from_x = std::max(0, d_min_x - R);\n    int to_x = std::min(num_out_x, d_min_x + R + 1);\n    int from_y = std::max(0, d_min_y - R);\n    int to_y = std::min(num_out_y, d_min_y + R + 1);\n\n    // step 3b: update the weights of nodes in the\n    // neighborhood\n#ifdef _OPENMP\n#pragma omp for\n#endif\n    for (x = from_x; x < to_x; x++) {\n        for (y = from_y; y < to_y; y++) {\n            /* you can enable the following normalization if needed.\n   personally, I found it detrimental to convergence */\n            // const double s2pi = sqrt(2.f * M_PI);\n            // double normalize = 1.f / (alpha * s2pi);\n\n            /* apply scaling inversely proportional to distance from the\n               current node */\n            double d2 =\n                (d_min_x - x) * (d_min_x - x) + (d_min_y - y) * (d_min_y - y);\n            double scale_factor = std::exp(-d2 / (2.f * alpha * alpha));\n\n            (*W)[x][y] += (X - (*W)[x][y]) * alpha * scale_factor;\n        }\n    }\n    return d_min;\n}\n\n/**\n * Apply incremental algorithm with updating neighborhood and learning\n * rates on all samples in the given datset.\n *\n * \\param[in] X data set\n * \\param[in,out] W weights matrix\n * \\param[in] alpha_min terminal value of alpha\n */\nvoid kohonen_som(const std::vector<std::valarray<double>> &X,\n                 std::vector<std::vector<std::valarray<double>>> *W,\n                 double alpha_min) {\n    size_t num_samples = X.size();  // number of rows\n    // size_t num_features = X[0].size();  // number of columns\n    size_t num_out = W->size();  // output matrix size\n    size_t R = num_out >> 2, iter = 0;\n    double alpha = 1.f;\n\n    std::vector<std::valarray<double>> D(num_out);\n    for (int i = 0; i < num_out; i++) D[i] = std::valarray<double>(num_out);\n\n    double dmin = 1.f;        // average minimum distance of all samples\n    double past_dmin = 1.f;   // average minimum distance of all samples\n    double dmin_ratio = 1.f;  // change per step\n\n    // Loop alpha from 1 to slpha_min\n    for (; alpha > 0 && dmin_ratio > 1e-5; alpha -= 1e-4, iter++) {\n        // Loop for each sample pattern in the data set\n        for (int sample = 0; sample < num_samples; sample++) {\n            // update weights for the current input pattern sample\n            dmin += update_weights(X[sample], W, &D, alpha, R);\n        }\n\n        // every 100th iteration, reduce the neighborhood range\n        if (iter % 300 == 0 && R > 1) {\n            R--;\n        }\n\n        dmin /= num_samples;\n\n        // termination condition variable -> % change in minimum distance\n        dmin_ratio = (past_dmin - dmin) / past_dmin;\n        if (dmin_ratio < 0) {\n            dmin_ratio = 1.f;\n        }\n        past_dmin = dmin;\n\n        std::cout << \"iter: \" << iter << \"\\t alpha: \" << alpha << \"\\t R: \" << R\n                  << \"\\t d_min: \" << dmin_ratio << \"\\r\";\n    }\n\n    std::cout << \"\\n\";\n}\n\n}  // namespace machine_learning\n\nusing machine_learning::kohonen_som;\nusing machine_learning::save_u_matrix;\n\n/** @} */\n\n/** Creates a random set of points distributed in four clusters in\n * 3D space with centroids at the points\n * * \\f$(0,5, 0.5, 0.5)\\f$\n * * \\f$(0,5,-0.5, -0.5)\\f$\n * * \\f$(-0,5, 0.5, 0.5)\\f$\n * * \\f$(-0,5,-0.5, -0.5)\\f$\n *\n * \\param[out] data matrix to store data in\n */\nvoid test_2d_classes(std::vector<std::valarray<double>> *data) {\n    const int N = data->size();\n    const double R = 0.3;  // radius of cluster\n    int i = 0;\n    const int num_classes = 4;\n    std::array<std::array<double, 2>, num_classes> centres = {\n        // centres of each class cluster\n        std::array<double, 2>({.5, .5}),   // centre of class 1\n        std::array<double, 2>({.5, -.5}),  // centre of class 2\n        std::array<double, 2>({-.5, .5}),  // centre of class 3\n        std::array<double, 2>({-.5, -.5})  // centre of class 4\n    };\n\n#ifdef _OPENMP\n#pragma omp for\n#endif\n    for (i = 0; i < N; i++) {\n        // select a random class for the point\n        int cls = std::rand() % num_classes;\n\n        // create random coordinates (x,y,z) around the centre of the class\n        data[0][i][0] = _random(centres[cls][0] - R, centres[cls][0] + R);\n        data[0][i][1] = _random(centres[cls][1] - R, centres[cls][1] + R);\n\n        /* The follosing can also be used\n        for (int j = 0; j < 2; j++)\n            data[i][j] = _random(centres[class][j] - R, centres[class][j] + R);\n        */\n    }\n}\n\n/** Test that creates a random set of points distributed in four clusters in\n * circumference of a circle and trains an SOM that finds that circular pattern.\n * The following [CSV](https://en.wikipedia.org/wiki/Comma-separated_values)\n * files are created to validate the execution:\n * * `test1.csv`: random test samples points with a circular pattern\n * * `w11.csv`: initial random map\n * * `w12.csv`: trained SOM map\n */\nvoid test1() {\n    int j = 0, N = 300;\n    int features = 2;\n    int num_out = 30;\n    std::vector<std::valarray<double>> X(N);\n    std::vector<std::vector<std::valarray<double>>> W(num_out);\n    for (int i = 0; i < std::max(num_out, N); i++) {\n        // loop till max(N, num_out)\n        if (i < N) {  // only add new arrays if i < N\n            X[i] = std::valarray<double>(features);\n        }\n        if (i < num_out) {  // only add new arrays if i < num_out\n            W[i] = std::vector<std::valarray<double>>(num_out);\n            for (int k = 0; k < num_out; k++) {\n                W[i][k] = std::valarray<double>(features);\n#ifdef _OPENMP\n#pragma omp for\n#endif\n                for (j = 0; j < features; j++) {\n                    // preallocate with random initial weights\n                    W[i][k][j] = _random(-10, 10);\n                }\n            }\n        }\n    }\n\n    test_2d_classes(&X);  // create test data around circumference of a circle\n    save_2d_data(\"test1.csv\", X);  // save test data points\n    save_u_matrix(\"w11.csv\", W);   // save initial random weights\n    kohonen_som(X, &W, 1e-4);      // train the SOM\n    save_u_matrix(\"w12.csv\", W);   // save the resultant weights\n}\n\n/** Creates a random set of points distributed in four clusters in\n * 3D space with centroids at the points\n * * \\f$(0,5, 0.5, 0.5)\\f$\n * * \\f$(0,5,-0.5, -0.5)\\f$\n * * \\f$(-0,5, 0.5, 0.5)\\f$\n * * \\f$(-0,5,-0.5, -0.5)\\f$\n *\n * \\param[out] data matrix to store data in\n */\nvoid test_3d_classes1(std::vector<std::valarray<double>> *data) {\n    const size_t N = data->size();\n    const double R = 0.3;  // radius of cluster\n    int i = 0;\n    const int num_classes = 4;\n    const std::array<std::array<double, 3>, num_classes> centres = {\n        // centres of each class cluster\n        std::array<double, 3>({.5, .5, .5}),    // centre of class 1\n        std::array<double, 3>({.5, -.5, -.5}),  // centre of class 2\n        std::array<double, 3>({-.5, .5, .5}),   // centre of class 3\n        std::array<double, 3>({-.5, -.5 - .5})  // centre of class 4\n    };\n\n#ifdef _OPENMP\n#pragma omp for\n#endif\n    for (i = 0; i < N; i++) {\n        // select a random class for the point\n        int cls = std::rand() % num_classes;\n\n        // create random coordinates (x,y,z) around the centre of the class\n        data[0][i][0] = _random(centres[cls][0] - R, centres[cls][0] + R);\n        data[0][i][1] = _random(centres[cls][1] - R, centres[cls][1] + R);\n        data[0][i][2] = _random(centres[cls][2] - R, centres[cls][2] + R);\n\n        /* The follosing can also be used\n        for (int j = 0; j < 3; j++)\n            data[i][j] = _random(centres[class][j] - R, centres[class][j] + R);\n        */\n    }\n}\n\n/** Test that creates a random set of points distributed in 4 clusters in\n * 3D space and trains an SOM that finds the topological pattern. The following\n * [CSV](https://en.wikipedia.org/wiki/Comma-separated_values) files are created\n * to validate the execution:\n * * `test2.csv`: random test samples points with a lamniscate pattern\n * * `w21.csv`: initial random map\n * * `w22.csv`: trained SOM map\n */\nvoid test2() {\n    int j = 0, N = 300;\n    int features = 3;\n    int num_out = 30;\n    std::vector<std::valarray<double>> X(N);\n    std::vector<std::vector<std::valarray<double>>> W(num_out);\n    for (int i = 0; i < std::max(num_out, N); i++) {\n        // loop till max(N, num_out)\n        if (i < N) {  // only add new arrays if i < N\n            X[i] = std::valarray<double>(features);\n        }\n        if (i < num_out) {  // only add new arrays if i < num_out\n            W[i] = std::vector<std::valarray<double>>(num_out);\n            for (int k = 0; k < num_out; k++) {\n                W[i][k] = std::valarray<double>(features);\n#ifdef _OPENMP\n#pragma omp for\n#endif\n                for (j = 0; j < features; j++) {\n                    // preallocate with random initial weights\n                    W[i][k][j] = _random(-10, 10);\n                }\n            }\n        }\n    }\n\n    test_3d_classes1(&X);  // create test data around circumference of a circle\n    save_2d_data(\"test2.csv\", X);  // save test data points\n    save_u_matrix(\"w21.csv\", W);   // save initial random weights\n    kohonen_som(X, &W, 1e-4);      // train the SOM\n    save_u_matrix(\"w22.csv\", W);   // save the resultant weights\n}\n\n/** Creates a random set of points distributed in four clusters in\n * 3D space with centroids at the points\n * * \\f$(0,5, 0.5, 0.5)\\f$\n * * \\f$(0,5,-0.5, -0.5)\\f$\n * * \\f$(-0,5, 0.5, 0.5)\\f$\n * * \\f$(-0,5,-0.5, -0.5)\\f$\n *\n * \\param[out] data matrix to store data in\n */\nvoid test_3d_classes2(std::vector<std::valarray<double>> *data) {\n    const size_t N = data->size();\n    const double R = 0.2;  // radius of cluster\n    int i = 0;\n    const int num_classes = 8;\n    const std::array<std::array<double, 3>, num_classes> centres = {\n        // centres of each class cluster\n        std::array<double, 3>({.5, .5, .5}),    // centre of class 1\n        std::array<double, 3>({.5, .5, -.5}),   // centre of class 2\n        std::array<double, 3>({.5, -.5, .5}),   // centre of class 3\n        std::array<double, 3>({.5, -.5, -.5}),  // centre of class 4\n        std::array<double, 3>({-.5, .5, .5}),   // centre of class 5\n        std::array<double, 3>({-.5, .5, -.5}),  // centre of class 6\n        std::array<double, 3>({-.5, -.5, .5}),  // centre of class 7\n        std::array<double, 3>({-.5, -.5, -.5})  // centre of class 8\n    };\n\n#ifdef _OPENMP\n#pragma omp for\n#endif\n    for (i = 0; i < N; i++) {\n        // select a random class for the point\n        int cls = std::rand() % num_classes;\n\n        // create random coordinates (x,y,z) around the centre of the class\n        data[0][i][0] = _random(centres[cls][0] - R, centres[cls][0] + R);\n        data[0][i][1] = _random(centres[cls][1] - R, centres[cls][1] + R);\n        data[0][i][2] = _random(centres[cls][2] - R, centres[cls][2] + R);\n\n        /* The follosing can also be used\n        for (int j = 0; j < 3; j++)\n            data[i][j] = _random(centres[class][j] - R, centres[class][j] + R);\n        */\n    }\n}\n\n/** Test that creates a random set of points distributed in eight clusters in\n * 3D space and trains an SOM that finds the topological pattern. The following\n * [CSV](https://en.wikipedia.org/wiki/Comma-separated_values) files are created\n * to validate the execution:\n * * `test3.csv`: random test samples points with a circular pattern\n * * `w31.csv`: initial random map\n * * `w32.csv`: trained SOM map\n */\nvoid test3() {\n    int j = 0, N = 500;\n    int features = 3;\n    int num_out = 30;\n    std::vector<std::valarray<double>> X(N);\n    std::vector<std::vector<std::valarray<double>>> W(num_out);\n    for (int i = 0; i < std::max(num_out, N); i++) {\n        // loop till max(N, num_out)\n        if (i < N) {  // only add new arrays if i < N\n            X[i] = std::valarray<double>(features);\n        }\n        if (i < num_out) {  // only add new arrays if i < num_out\n            W[i] = std::vector<std::valarray<double>>(num_out);\n            for (int k = 0; k < num_out; k++) {\n                W[i][k] = std::valarray<double>(features);\n#ifdef _OPENMP\n#pragma omp for\n#endif\n                for (j = 0; j < features; j++) {\n                    // preallocate with random initial weights\n                    W[i][k][j] = _random(-10, 10);\n                }\n            }\n        }\n    }\n\n    test_3d_classes2(&X);  // create test data around circumference of a circle\n    save_2d_data(\"test3.csv\", X);  // save test data points\n    save_u_matrix(\"w31.csv\", W);   // save initial random weights\n    kohonen_som(X, &W, 1e-4);      // train the SOM\n    save_u_matrix(\"w32.csv\", W);   // save the resultant weights\n}\n\n/**\n * Convert clock cycle difference to time in seconds\n *\n * \\param[in] start_t start clock\n * \\param[in] end_t end clock\n * \\returns time difference in seconds\n */\ndouble get_clock_diff(clock_t start_t, clock_t end_t) {\n    return static_cast<double>(end_t - start_t) / CLOCKS_PER_SEC;\n}\n\n/** Main function */\nint main(int argc, char **argv) {\n#ifdef _OPENMP\n    std::cout << \"Using OpenMP based parallelization\\n\";\n#else\n    std::cout << \"NOT using OpenMP based parallelization\\n\";\n#endif\n\n    std::srand(std::time(nullptr));\n\n    std::clock_t start_clk = std::clock();\n    test1();\n    auto end_clk = std::clock();\n    std::cout << \"Test 1 completed in \" << get_clock_diff(start_clk, end_clk)\n              << \" sec\\n\";\n\n    start_clk = std::clock();\n    test2();\n    end_clk = std::clock();\n    std::cout << \"Test 2 completed in \" << get_clock_diff(start_clk, end_clk)\n              << \" sec\\n\";\n\n    start_clk = std::clock();\n    test3();\n    end_clk = std::clock();\n    std::cout << \"Test 3 completed in \" << get_clock_diff(start_clk, end_clk)\n              << \" sec\\n\";\n\n    std::cout\n        << \"(Note: Calculated times include: creating test sets, training \"\n           \"model and writing files to disk.)\\n\\n\";\n    return 0;\n}\n","index":102},{"title":"Kohonen Som Trace","category":"machine_learning","id":"kohonen_som_trace_machine_learning","algorithm":"/**\n * \\addtogroup machine_learning Machine Learning Algorithms\n * @{\n * \\file\n * \\brief [Kohonen self organizing\n * map](https://en.wikipedia.org/wiki/Self-organizing_map) (data tracing)\n *\n * This example implements a powerful self organizing map algorithm.\n * The algorithm creates a connected network of weights that closely\n * follows the given data points. This this creates a chain of nodes that\n * resembles the given input shape.\n *\n * \\author [Krishna Vedala](https://github.com/kvedala)\n *\n * \\note This C++ version of the program is considerable slower than its [C\n * counterpart](https://github.com/kvedala/C/blob/master/machine_learning/kohonen_som_trace.c)\n * \\note The compiled code is much slower when compiled with MS Visual C++ 2019\n * than with GCC on windows\n * \\see kohonen_som_topology.cpp\n */\n#define _USE_MATH_DEFINES  // required for MS Visual C++\n#include <algorithm>\n#include <array>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <fstream>\n#include <iostream>\n#include <valarray>\n#include <vector>\n#ifdef _OPENMP  // check if OpenMP based parallellization is available\n#include <omp.h>\n#endif\n\n/**\n * Helper function to generate a random number in a given interval.\n * \\n Steps:\n * 1. `r1 = rand() % 100` gets a random number between 0 and 99\n * 2. `r2 = r1 / 100` converts random number to be between 0 and 0.99\n * 3. scale and offset the random number to given range of \\f$[a,b]\\f$\n *\n * \\param[in] a lower limit\n * \\param[in] b upper limit\n * \\returns random number in the range \\f$[a,b]\\f$\n */\ndouble _random(double a, double b) {\n    return ((b - a) * (std::rand() % 100) / 100.f) + a;\n}\n\n/**\n * Save a given n-dimensional data martix to file.\n *\n * \\param[in] fname filename to save in (gets overwriten without confirmation)\n * \\param[in] X matrix to save\n * \\returns 0 if all ok\n * \\returns -1 if file creation failed\n */\nint save_nd_data(const char *fname,\n                 const std::vector<std::valarray<double>> &X) {\n    size_t num_points = X.size();       // number of rows\n    size_t num_features = X[0].size();  // number of columns\n\n    std::ofstream fp;\n    fp.open(fname);\n    if (!fp.is_open()) {\n        // error with opening file to write\n        std::cerr << \"Error opening file \" << fname << \"\\n\";\n        return -1;\n    }\n\n    // for each point in the array\n    for (int i = 0; i < num_points; i++) {\n        // for each feature in the array\n        for (int j = 0; j < num_features; j++) {\n            fp << X[i][j];               // print the feature value\n            if (j < num_features - 1) {  // if not the last feature\n                fp << \",\";               // suffix comma\n            }\n        }\n        if (i < num_points - 1) {  // if not the last row\n            fp << \"\\n\";            // start a new line\n        }\n    }\n\n    fp.close();\n    return 0;\n}\n\n/** \\namespace machine_learning\n * \\brief Machine learning algorithms\n */\nnamespace machine_learning {\n\n/**\n * Update weights of the SOM using Kohonen algorithm\n *\n * \\param[in] X data point\n * \\param[in,out] W weights matrix\n * \\param[in,out] D temporary vector to store distances\n * \\param[in] alpha learning rate \\f$0<\\alpha\\le1\\f$\n * \\param[in] R neighborhood range\n */\nvoid update_weights(const std::valarray<double> &x,\n                    std::vector<std::valarray<double>> *W,\n                    std::valarray<double> *D, double alpha, int R) {\n    int j = 0, k = 0;\n    int num_out = W->size();  // number of SOM output nodes\n    // int num_features = x.size();  // number of data features\n\n#ifdef _OPENMP\n#pragma omp for\n#endif\n    // step 1: for each output point\n    for (j = 0; j < num_out; j++) {\n        // compute Euclidian distance of each output\n        // point from the current sample\n        (*D)[j] = (((*W)[j] - x) * ((*W)[j] - x)).sum();\n    }\n\n    // step 2:  get closest node i.e., node with snallest Euclidian distance to\n    // the current pattern\n    auto result = std::min_element(std::begin(*D), std::end(*D));\n    // double d_min = *result;\n    int d_min_idx = std::distance(std::begin(*D), result);\n\n    // step 3a: get the neighborhood range\n    int from_node = std::max(0, d_min_idx - R);\n    int to_node = std::min(num_out, d_min_idx + R + 1);\n\n    // step 3b: update the weights of nodes in the\n    // neighborhood\n#ifdef _OPENMP\n#pragma omp for\n#endif\n    for (j = from_node; j < to_node; j++) {\n        // update weights of nodes in the neighborhood\n        (*W)[j] += alpha * (x - (*W)[j]);\n    }\n}\n\n/**\n * Apply incremental algorithm with updating neighborhood and learning rates\n * on all samples in the given datset.\n *\n * \\param[in] X data set\n * \\param[in,out] W weights matrix\n * \\param[in] alpha_min terminal value of alpha\n */\nvoid kohonen_som_tracer(const std::vector<std::valarray<double>> &X,\n                        std::vector<std::valarray<double>> *W,\n                        double alpha_min) {\n    int num_samples = X.size();  // number of rows\n    // int num_features = X[0].size();  // number of columns\n    int num_out = W->size();  // number of rows\n    int R = num_out >> 2, iter = 0;\n    double alpha = 1.f;\n\n    std::valarray<double> D(num_out);\n\n    // Loop alpha from 1 to slpha_min\n    do {\n        // Loop for each sample pattern in the data set\n        for (int sample = 0; sample < num_samples; sample++) {\n            // update weights for the current input pattern sample\n            update_weights(X[sample], W, &D, alpha, R);\n        }\n\n        // every 10th iteration, reduce the neighborhood range\n        if (iter % 10 == 0 && R > 1) {\n            R--;\n        }\n\n        alpha -= 0.01;\n        iter++;\n    } while (alpha > alpha_min);\n}\n\n}  // namespace machine_learning\n\n/** @} */\n\nusing machine_learning::kohonen_som_tracer;\n\n/** Creates a random set of points distributed *near* the circumference\n * of a circle and trains an SOM that finds that circular pattern. The\n * generating function is\n * \\f{eqnarray*}{\n * r &\\in& [1-\\delta r, 1+\\delta r)\\\\\n * \\theta &\\in& [0, 2\\pi)\\\\\n * x &=& r\\cos\\theta\\\\\n * y &=& r\\sin\\theta\n * \\f}\n *\n * \\param[out] data matrix to store data in\n */\nvoid test_circle(std::vector<std::valarray<double>> *data) {\n    const int N = data->size();\n    const double R = 0.75, dr = 0.3;\n    double a_t = 0., b_t = 2.f * M_PI;  // theta random between 0 and 2*pi\n    double a_r = R - dr, b_r = R + dr;  // radius random between R-dr and R+dr\n    int i = 0;\n\n#ifdef _OPENMP\n#pragma omp for\n#endif\n    for (i = 0; i < N; i++) {\n        double r = _random(a_r, b_r);      // random radius\n        double theta = _random(a_t, b_t);  // random theta\n        data[0][i][0] = r * cos(theta);    // convert from polar to cartesian\n        data[0][i][1] = r * sin(theta);\n    }\n}\n\n/** Test that creates a random set of points distributed *near* the\n * circumference of a circle and trains an SOM that finds that circular pattern.\n * The following [CSV](https://en.wikipedia.org/wiki/Comma-separated_values)\n * files are created to validate the execution:\n * * `test1.csv`: random test samples points with a circular pattern\n * * `w11.csv`: initial random map\n * * `w12.csv`: trained SOM map\n *\n * The outputs can be readily plotted in [gnuplot](https:://gnuplot.info) using\n * the following snippet\n * ```gnuplot\n * set datafile separator ','\n * plot \"test1.csv\" title \"original\", \\\n *      \"w11.csv\" title \"w1\", \\\n *      \"w12.csv\" title \"w2\"\n * ```\n * ![Sample execution\n * output](https://raw.githubusercontent.com/TheAlgorithms/C-Plus-Plus/docs/images/machine_learning/kohonen/test1.svg)\n */\nvoid test1() {\n    int j = 0, N = 500;\n    int features = 2;\n    int num_out = 50;\n    std::vector<std::valarray<double>> X(N);\n    std::vector<std::valarray<double>> W(num_out);\n    for (int i = 0; i < std::max(num_out, N); i++) {\n        // loop till max(N, num_out)\n        if (i < N) {  // only add new arrays if i < N\n            X[i] = std::valarray<double>(features);\n        }\n        if (i < num_out) {  // only add new arrays if i < num_out\n            W[i] = std::valarray<double>(features);\n\n#ifdef _OPENMP\n#pragma omp for\n#endif\n            for (j = 0; j < features; j++) {\n                // preallocate with random initial weights\n                W[i][j] = _random(-1, 1);\n            }\n        }\n    }\n\n    test_circle(&X);  // create test data around circumference of a circle\n    save_nd_data(\"test1.csv\", X);    // save test data points\n    save_nd_data(\"w11.csv\", W);      // save initial random weights\n    kohonen_som_tracer(X, &W, 0.1);  // train the SOM\n    save_nd_data(\"w12.csv\", W);      // save the resultant weights\n}\n\n/** Creates a random set of points distributed *near* the locus\n * of the [Lamniscate of\n * Gerono](https://en.wikipedia.org/wiki/Lemniscate_of_Gerono).\n * \\f{eqnarray*}{\n * \\delta r &=& 0.2\\\\\n * \\delta x &\\in& [-\\delta r, \\delta r)\\\\\n * \\delta y &\\in& [-\\delta r, \\delta r)\\\\\n * \\theta &\\in& [0, \\pi)\\\\\n * x &=& \\delta x + \\cos\\theta\\\\\n * y &=& \\delta y + \\frac{\\sin(2\\theta)}{2}\n * \\f}\n * \\param[out] data matrix to store data in\n */\nvoid test_lamniscate(std::vector<std::valarray<double>> *data) {\n    const int N = data->size();\n    const double dr = 0.2;\n    int i = 0;\n\n#ifdef _OPENMP\n#pragma omp for\n#endif\n    for (i = 0; i < N; i++) {\n        double dx = _random(-dr, dr);     // random change in x\n        double dy = _random(-dr, dr);     // random change in y\n        double theta = _random(0, M_PI);  // random theta\n        data[0][i][0] = dx + cos(theta);  // convert from polar to cartesian\n        data[0][i][1] = dy + sin(2. * theta) / 2.f;\n    }\n}\n\n/** Test that creates a random set of points distributed *near* the locus\n * of the [Lamniscate of\n * Gerono](https://en.wikipedia.org/wiki/Lemniscate_of_Gerono) and trains an SOM\n * that finds that circular pattern. The following\n * [CSV](https://en.wikipedia.org/wiki/Comma-separated_values) files are created\n * to validate the execution:\n * * `test2.csv`: random test samples points with a lamniscate pattern\n * * `w21.csv`: initial random map\n * * `w22.csv`: trained SOM map\n *\n * The outputs can be readily plotted in [gnuplot](https:://gnuplot.info) using\n * the following snippet\n * ```gnuplot\n * set datafile separator ','\n * plot \"test2.csv\" title \"original\", \\\n *      \"w21.csv\" title \"w1\", \\\n *      \"w22.csv\" title \"w2\"\n * ```\n * ![Sample execution\n * output](https://raw.githubusercontent.com/TheAlgorithms/C-Plus-Plus/docs/images/machine_learning/kohonen/test2.svg)\n */\nvoid test2() {\n    int j = 0, N = 500;\n    int features = 2;\n    int num_out = 20;\n    std::vector<std::valarray<double>> X(N);\n    std::vector<std::valarray<double>> W(num_out);\n    for (int i = 0; i < std::max(num_out, N); i++) {\n        // loop till max(N, num_out)\n        if (i < N) {  // only add new arrays if i < N\n            X[i] = std::valarray<double>(features);\n        }\n        if (i < num_out) {  // only add new arrays if i < num_out\n            W[i] = std::valarray<double>(features);\n\n#ifdef _OPENMP\n#pragma omp for\n#endif\n            for (j = 0; j < features; j++) {\n                // preallocate with random initial weights\n                W[i][j] = _random(-1, 1);\n            }\n        }\n    }\n\n    test_lamniscate(&X);              // create test data around the lamniscate\n    save_nd_data(\"test2.csv\", X);     // save test data points\n    save_nd_data(\"w21.csv\", W);       // save initial random weights\n    kohonen_som_tracer(X, &W, 0.01);  // train the SOM\n    save_nd_data(\"w22.csv\", W);       // save the resultant weights\n}\n\n/** Creates a random set of points distributed in six clusters in\n * 3D space with centroids at the points\n * * \\f${0.5, 0.5, 0.5}\\f$\n * * \\f${0.5, 0.5, -0.5}\\f$\n * * \\f${0.5, -0.5, 0.5}\\f$\n * * \\f${0.5, -0.5, -0.5}\\f$\n * * \\f${-0.5, 0.5, 0.5}\\f$\n * * \\f${-0.5, 0.5, -0.5}\\f$\n * * \\f${-0.5, -0.5, 0.5}\\f$\n * * \\f${-0.5, -0.5, -0.5}\\f$\n *\n * \\param[out] data matrix to store data in\n */\nvoid test_3d_classes(std::vector<std::valarray<double>> *data) {\n    const int N = data->size();\n    const double R = 0.1;  // radius of cluster\n    int i = 0;\n    const int num_classes = 8;\n    const std::array<const std::array<double, 3>, num_classes> centres = {\n        // centres of each class cluster\n        std::array<double, 3>({.5, .5, .5}),    // centre of class 0\n        std::array<double, 3>({.5, .5, -.5}),   // centre of class 1\n        std::array<double, 3>({.5, -.5, .5}),   // centre of class 2\n        std::array<double, 3>({.5, -.5, -.5}),  // centre of class 3\n        std::array<double, 3>({-.5, .5, .5}),   // centre of class 4\n        std::array<double, 3>({-.5, .5, -.5}),  // centre of class 5\n        std::array<double, 3>({-.5, -.5, .5}),  // centre of class 6\n        std::array<double, 3>({-.5, -.5, -.5})  // centre of class 7\n    };\n\n#ifdef _OPENMP\n#pragma omp for\n#endif\n    for (i = 0; i < N; i++) {\n        int cls =\n            std::rand() % num_classes;  // select a random class for the point\n\n        // create random coordinates (x,y,z) around the centre of the class\n        data[0][i][0] = _random(centres[cls][0] - R, centres[cls][0] + R);\n        data[0][i][1] = _random(centres[cls][1] - R, centres[cls][1] + R);\n        data[0][i][2] = _random(centres[cls][2] - R, centres[cls][2] + R);\n\n        /* The follosing can also be used\n        for (int j = 0; j < 3; j++)\n            data[0][i][j] = _random(centres[cls][j] - R, centres[cls][j] + R);\n        */\n    }\n}\n\n/** Test that creates a random set of points distributed in six clusters in\n * 3D space. The following\n * [CSV](https://en.wikipedia.org/wiki/Comma-separated_values) files are created\n * to validate the execution:\n * * `test3.csv`: random test samples points with a circular pattern\n * * `w31.csv`: initial random map\n * * `w32.csv`: trained SOM map\n *\n * The outputs can be readily plotted in [gnuplot](https:://gnuplot.info) using\n * the following snippet\n * ```gnuplot\n * set datafile separator ','\n * plot \"test3.csv\" title \"original\", \\\n *      \"w31.csv\" title \"w1\", \\\n *      \"w32.csv\" title \"w2\"\n * ```\n * ![Sample execution\n * output](https://raw.githubusercontent.com/TheAlgorithms/C-Plus-Plus/docs/images/machine_learning/kohonen/test3.svg)\n */\nvoid test3() {\n    int j = 0, N = 200;\n    int features = 3;\n    int num_out = 20;\n    std::vector<std::valarray<double>> X(N);\n    std::vector<std::valarray<double>> W(num_out);\n    for (int i = 0; i < std::max(num_out, N); i++) {\n        // loop till max(N, num_out)\n        if (i < N) {  // only add new arrays if i < N\n            X[i] = std::valarray<double>(features);\n        }\n        if (i < num_out) {  // only add new arrays if i < num_out\n            W[i] = std::valarray<double>(features);\n\n#ifdef _OPENMP\n#pragma omp for\n#endif\n            for (j = 0; j < features; j++) {\n                // preallocate with random initial weights\n                W[i][j] = _random(-1, 1);\n            }\n        }\n    }\n\n    test_3d_classes(&X);              // create test data around the lamniscate\n    save_nd_data(\"test3.csv\", X);     // save test data points\n    save_nd_data(\"w31.csv\", W);       // save initial random weights\n    kohonen_som_tracer(X, &W, 0.01);  // train the SOM\n    save_nd_data(\"w32.csv\", W);       // save the resultant weights\n}\n\n/**\n * Convert clock cycle difference to time in seconds\n *\n * \\param[in] start_t start clock\n * \\param[in] end_t end clock\n * \\returns time difference in seconds\n */\ndouble get_clock_diff(clock_t start_t, clock_t end_t) {\n    return static_cast<double>(end_t - start_t) / CLOCKS_PER_SEC;\n}\n\n/** Main function */\nint main(int argc, char **argv) {\n#ifdef _OPENMP\n    std::cout << \"Using OpenMP based parallelization\\n\";\n#else\n    std::cout << \"NOT using OpenMP based parallelization\\n\";\n#endif\n\n    std::srand(std::time(nullptr));\n\n    std::clock_t start_clk = std::clock();\n    test1();\n    auto end_clk = std::clock();\n    std::cout << \"Test 1 completed in \" << get_clock_diff(start_clk, end_clk)\n              << \" sec\\n\";\n\n    start_clk = std::clock();\n    test2();\n    end_clk = std::clock();\n    std::cout << \"Test 2 completed in \" << get_clock_diff(start_clk, end_clk)\n              << \" sec\\n\";\n\n    start_clk = std::clock();\n    test3();\n    end_clk = std::clock();\n    std::cout << \"Test 3 completed in \" << get_clock_diff(start_clk, end_clk)\n              << \" sec\\n\";\n\n    std::cout\n        << \"(Note: Calculated times include: creating test sets, training \"\n           \"model and writing files to disk.)\\n\\n\";\n    return 0;\n}\n","index":103},{"title":"Neural Network","category":"machine_learning","id":"neural_network_machine_learning","algorithm":"/**\n * @file\n * @author [Deep Raval](https://github.com/imdeep2905)\n *\n * @brief Implementation of [Multilayer Perceptron]\n * (https://en.wikipedia.org/wiki/Multilayer_perceptron).\n *\n * @details\n * A multilayer perceptron (MLP) is a class of feedforward artificial neural\n * network (ANN). The term MLP is used ambiguously, sometimes loosely to any\n * feedforward ANN, sometimes strictly to refer to networks composed of multiple\n * layers of perceptrons (with threshold activation). Multilayer perceptrons are\n * sometimes colloquially referred to as \"vanilla\" neural networks, especially\n * when they have a single hidden layer.\n *\n * An MLP consists of at least three layers of nodes: an input layer, a hidden\n * layer and an output layer. Except for the input nodes, each node is a neuron\n * that uses a nonlinear activation function. MLP utilizes a supervised learning\n * technique called backpropagation for training. Its multiple layers and\n * non-linear activation distinguish MLP from a linear perceptron. It can\n * distinguish data that is not linearly separable.\n *\n * See [Backpropagation](https://en.wikipedia.org/wiki/Backpropagation) for\n * training algorithm.\n *\n * \\note This implementation uses mini-batch gradient descent as optimizer and\n * MSE as loss function. Bias is also not included.\n */\n\n#include <algorithm>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <valarray>\n#include <vector>\n\n#include \"vector_ops.hpp\"  // Custom header file for vector operations\n\n/** \\namespace machine_learning\n * \\brief Machine learning algorithms\n */\nnamespace machine_learning {\n/** \\namespace neural_network\n * \\brief Neural Network or Multilayer Perceptron\n */\nnamespace neural_network {\n/** \\namespace activations\n * \\brief Various activation functions used in Neural network\n */\nnamespace activations {\n/**\n * Sigmoid function\n * @param X Value\n * @return Returns sigmoid(x)\n */\ndouble sigmoid(const double &x) { return 1.0 / (1.0 + std::exp(-x)); }\n\n/**\n * Derivative of sigmoid function\n * @param X Value\n * @return Returns derivative of sigmoid(x)\n */\ndouble dsigmoid(const double &x) { return x * (1 - x); }\n\n/**\n * Relu function\n * @param X Value\n * @returns relu(x)\n */\ndouble relu(const double &x) { return std::max(0.0, x); }\n\n/**\n * Derivative of relu function\n * @param X Value\n * @returns derivative of relu(x)\n */\ndouble drelu(const double &x) { return x >= 0.0 ? 1.0 : 0.0; }\n\n/**\n * Tanh function\n * @param X Value\n * @return Returns tanh(x)\n */\ndouble tanh(const double &x) { return 2 / (1 + std::exp(-2 * x)) - 1; }\n\n/**\n * Derivative of Sigmoid function\n * @param X Value\n * @return Returns derivative of tanh(x)\n */\ndouble dtanh(const double &x) { return 1 - x * x; }\n}  // namespace activations\n/** \\namespace util_functions\n * \\brief Various utility functions used in Neural network\n */\nnamespace util_functions {\n/**\n * Square function\n * @param X Value\n * @return Returns x * x\n */\ndouble square(const double &x) { return x * x; }\n/**\n * Identity function\n * @param X Value\n * @return Returns x\n */\ndouble identity_function(const double &x) { return x; }\n}  // namespace util_functions\n/** \\namespace layers\n * \\brief This namespace contains layers used\n * in MLP.\n */\nnamespace layers {\n/**\n * neural_network::layers::DenseLayer class is used to store all necessary\n * information about the layers (i.e. neurons, activation and kernal). This\n * class is used by NeuralNetwork class to store layers.\n *\n */\nclass DenseLayer {\n public:\n    // To store activation function and it's derivative\n    double (*activation_function)(const double &);\n    double (*dactivation_function)(const double &);\n    int neurons;             // To store number of neurons (used in summary)\n    std::string activation;  // To store activation name (used in summary)\n    std::vector<std::valarray<double>> kernal;  // To store kernal (aka weights)\n\n    /**\n     * Constructor for neural_network::layers::DenseLayer class\n     * @param neurons number of neurons\n     * @param activation activation function for layer\n     * @param kernal_shape shape of kernal\n     * @param random_kernal flag for whether to intialize kernal randomly\n     */\n    DenseLayer(const int &neurons, const std::string &activation,\n               const std::pair<size_t, size_t> &kernal_shape,\n               const bool &random_kernal) {\n        // Choosing activation (and it's derivative)\n        if (activation == \"sigmoid\") {\n            activation_function = neural_network::activations::sigmoid;\n            dactivation_function = neural_network::activations::sigmoid;\n        } else if (activation == \"relu\") {\n            activation_function = neural_network::activations::relu;\n            dactivation_function = neural_network::activations::drelu;\n        } else if (activation == \"tanh\") {\n            activation_function = neural_network::activations::tanh;\n            dactivation_function = neural_network::activations::dtanh;\n        } else if (activation == \"none\") {\n            // Set identity function in casse of none is supplied\n            activation_function =\n                neural_network::util_functions::identity_function;\n            dactivation_function =\n                neural_network::util_functions::identity_function;\n        } else {\n            // If supplied activation is invalid\n            std::cerr << \"ERROR (\" << __func__ << \") : \";\n            std::cerr << \"Invalid argument. Expected {none, sigmoid, relu, \"\n                         \"tanh} got \";\n            std::cerr << activation << std::endl;\n            std::exit(EXIT_FAILURE);\n        }\n        this->activation = activation;  // Setting activation name\n        this->neurons = neurons;        // Setting number of neurons\n        // Initialize kernal according to flag\n        if (random_kernal) {\n            uniform_random_initialization(kernal, kernal_shape, -1.0, 1.0);\n        } else {\n            unit_matrix_initialization(kernal, kernal_shape);\n        }\n    }\n    /**\n     * Constructor for neural_network::layers::DenseLayer class\n     * @param neurons number of neurons\n     * @param activation activation function for layer\n     * @param kernal values of kernal (useful in loading model)\n     */\n    DenseLayer(const int &neurons, const std::string &activation,\n               const std::vector<std::valarray<double>> &kernal) {\n        // Choosing activation (and it's derivative)\n        if (activation == \"sigmoid\") {\n            activation_function = neural_network::activations::sigmoid;\n            dactivation_function = neural_network::activations::sigmoid;\n        } else if (activation == \"relu\") {\n            activation_function = neural_network::activations::relu;\n            dactivation_function = neural_network::activations::drelu;\n        } else if (activation == \"tanh\") {\n            activation_function = neural_network::activations::tanh;\n            dactivation_function = neural_network::activations::dtanh;\n        } else if (activation == \"none\") {\n            // Set identity function in casse of none is supplied\n            activation_function =\n                neural_network::util_functions::identity_function;\n            dactivation_function =\n                neural_network::util_functions::identity_function;\n        } else {\n            // If supplied activation is invalid\n            std::cerr << \"ERROR (\" << __func__ << \") : \";\n            std::cerr << \"Invalid argument. Expected {none, sigmoid, relu, \"\n                         \"tanh} got \";\n            std::cerr << activation << std::endl;\n            std::exit(EXIT_FAILURE);\n        }\n        this->activation = activation;  // Setting activation name\n        this->neurons = neurons;        // Setting number of neurons\n        this->kernal = kernal;          // Setting supplied kernal values\n    }\n\n    /**\n     * Copy Constructor for class DenseLayer.\n     *\n     * @param model instance of class to be copied.\n     */\n    DenseLayer(const DenseLayer &layer) = default;\n\n    /**\n     * Destructor for class DenseLayer.\n     */\n    ~DenseLayer() = default;\n\n    /**\n     * Copy assignment operator for class DenseLayer\n     */\n    DenseLayer &operator=(const DenseLayer &layer) = default;\n\n    /**\n     * Move constructor for class DenseLayer\n     */\n    DenseLayer(DenseLayer &&) = default;\n\n    /**\n     * Move assignment operator for class DenseLayer\n     */\n    DenseLayer &operator=(DenseLayer &&) = default;\n};\n}  // namespace layers\n/**\n * NeuralNetwork class is implements MLP. This class is\n * used by actual user to create and train networks.\n *\n */\nclass NeuralNetwork {\n private:\n    std::vector<neural_network::layers::DenseLayer> layers;  // To store layers\n    /**\n     * Private Constructor for class NeuralNetwork. This constructor\n     * is used internally to load model.\n     * @param config vector containing pair (neurons, activation)\n     * @param kernals vector containing all pretrained kernals\n     */\n    NeuralNetwork(\n        const std::vector<std::pair<int, std::string>> &config,\n        const std::vector<std::vector<std::valarray<double>>> &kernals) {\n        // First layer should not have activation\n        if (config.begin()->second != \"none\") {\n            std::cerr << \"ERROR (\" << __func__ << \") : \";\n            std::cerr\n                << \"First layer can't have activation other than none got \"\n                << config.begin()->second;\n            std::cerr << std::endl;\n            std::exit(EXIT_FAILURE);\n        }\n        // Network should have atleast two layers\n        if (config.size() <= 1) {\n            std::cerr << \"ERROR (\" << __func__ << \") : \";\n            std::cerr << \"Invalid size of network, \";\n            std::cerr << \"Atleast two layers are required\";\n            std::exit(EXIT_FAILURE);\n        }\n        // Reconstructing all pretrained layers\n        for (size_t i = 0; i < config.size(); i++) {\n            layers.emplace_back(neural_network::layers::DenseLayer(\n                config[i].first, config[i].second, kernals[i]));\n        }\n        std::cout << \"INFO: Network constructed successfully\" << std::endl;\n    }\n    /**\n     * Private function to get detailed predictions (i.e.\n     * activated neuron values). This function is used in\n     * backpropagation, single predict and batch predict.\n     * @param X input vector\n     */\n    std::vector<std::vector<std::valarray<double>>>\n    __detailed_single_prediction(const std::vector<std::valarray<double>> &X) {\n        std::vector<std::vector<std::valarray<double>>> details;\n        std::vector<std::valarray<double>> current_pass = X;\n        details.emplace_back(X);\n        for (const auto &l : layers) {\n            current_pass = multiply(current_pass, l.kernal);\n            current_pass = apply_function(current_pass, l.activation_function);\n            details.emplace_back(current_pass);\n        }\n        return details;\n    }\n\n public:\n    /**\n     * Default Constructor for class NeuralNetwork. This constructor\n     * is used to create empty variable of type NeuralNetwork class.\n     */\n    NeuralNetwork() = default;\n\n    /**\n     * Constructor for class NeuralNetwork. This constructor\n     * is used by user.\n     * @param config vector containing pair (neurons, activation)\n     */\n    explicit NeuralNetwork(\n        const std::vector<std::pair<int, std::string>> &config) {\n        // First layer should not have activation\n        if (config.begin()->second != \"none\") {\n            std::cerr << \"ERROR (\" << __func__ << \") : \";\n            std::cerr\n                << \"First layer can't have activation other than none got \"\n                << config.begin()->second;\n            std::cerr << std::endl;\n            std::exit(EXIT_FAILURE);\n        }\n        // Network should have atleast two layers\n        if (config.size() <= 1) {\n            std::cerr << \"ERROR (\" << __func__ << \") : \";\n            std::cerr << \"Invalid size of network, \";\n            std::cerr << \"Atleast two layers are required\";\n            std::exit(EXIT_FAILURE);\n        }\n        // Separately creating first layer so it can have unit matrix\n        // as kernal.\n        layers.push_back(neural_network::layers::DenseLayer(\n            config[0].first, config[0].second,\n            {config[0].first, config[0].first}, false));\n        // Creating remaining layers\n        for (size_t i = 1; i < config.size(); i++) {\n            layers.push_back(neural_network::layers::DenseLayer(\n                config[i].first, config[i].second,\n                {config[i - 1].first, config[i].first}, true));\n        }\n        std::cout << \"INFO: Network constructed successfully\" << std::endl;\n    }\n\n    /**\n     * Copy Constructor for class NeuralNetwork.\n     *\n     * @param model instance of class to be copied.\n     */\n    NeuralNetwork(const NeuralNetwork &model) = default;\n\n    /**\n     * Destructor for class NeuralNetwork.\n     */\n    ~NeuralNetwork() = default;\n\n    /**\n     * Copy assignment operator for class NeuralNetwork\n     */\n    NeuralNetwork &operator=(const NeuralNetwork &model) = default;\n\n    /**\n     * Move constructor for class NeuralNetwork\n     */\n    NeuralNetwork(NeuralNetwork &&) = default;\n\n    /**\n     * Move assignment operator for class NeuralNetwork\n     */\n    NeuralNetwork &operator=(NeuralNetwork &&) = default;\n\n    /**\n     * Function to get X and Y from csv file (where X = data, Y = label)\n     * @param file_name csv file name\n     * @param last_label flag for whether label is in first or last column\n     * @param normalize flag for whether to normalize data\n     * @param slip_lines number of lines to skip\n     * @return returns pair of X and Y\n     */\n    std::pair<std::vector<std::vector<std::valarray<double>>>,\n              std::vector<std::vector<std::valarray<double>>>>\n    get_XY_from_csv(const std::string &file_name, const bool &last_label,\n                    const bool &normalize, const int &slip_lines = 1) {\n        std::ifstream in_file;                          // Ifstream to read file\n        in_file.open(file_name.c_str(), std::ios::in);  // Open file\n        // If there is any problem in opening file\n        if (!in_file.is_open()) {\n            std::cerr << \"ERROR (\" << __func__ << \") : \";\n            std::cerr << \"Unable to open file: \" << file_name << std::endl;\n            std::exit(EXIT_FAILURE);\n        }\n        std::vector<std::vector<std::valarray<double>>> X,\n            Y;             // To store X and Y\n        std::string line;  // To store each line\n        // Skip lines\n        for (int i = 0; i < slip_lines; i++) {\n            std::getline(in_file, line, '\\n');  // Ignore line\n        }\n        // While file has information\n        while (!in_file.eof() && std::getline(in_file, line, '\\n')) {\n            std::valarray<double> x_data,\n                y_data;                  // To store single sample and label\n            std::stringstream ss(line);  // Constructing stringstream from line\n            std::string token;  // To store each token in line (seprated by ',')\n            while (std::getline(ss, token, ',')) {  // For each token\n                // Insert numerical value of token in x_data\n                x_data = insert_element(x_data, std::stod(token));\n            }\n            // If label is in last column\n            if (last_label) {\n                y_data.resize(this->layers.back().neurons);\n                // If task is classification\n                if (y_data.size() > 1) {\n                    y_data[x_data[x_data.size() - 1]] = 1;\n                }\n                // If task is regrssion (of single value)\n                else {\n                    y_data[0] = x_data[x_data.size() - 1];\n                }\n                x_data = pop_back(x_data);  // Remove label from x_data\n            } else {\n                y_data.resize(this->layers.back().neurons);\n                // If task is classification\n                if (y_data.size() > 1) {\n                    y_data[x_data[x_data.size() - 1]] = 1;\n                }\n                // If task is regrssion (of single value)\n                else {\n                    y_data[0] = x_data[x_data.size() - 1];\n                }\n                x_data = pop_front(x_data);  // Remove label from x_data\n            }\n            // Push collected X_data and y_data in X and Y\n            X.push_back({x_data});\n            Y.push_back({y_data});\n        }\n        // Normalize training data if flag is set\n        if (normalize) {\n            // Scale data between 0 and 1 using min-max scaler\n            X = minmax_scaler(X, 0.01, 1.0);\n        }\n        in_file.close();         // Closing file\n        return make_pair(X, Y);  // Return pair of X and Y\n    }\n\n    /**\n     * Function to get prediction of model on single sample.\n     * @param X array of feature vectors\n     * @return returns predictions as vector\n     */\n    std::vector<std::valarray<double>> single_predict(\n        const std::vector<std::valarray<double>> &X) {\n        // Get activations of all layers\n        auto activations = this->__detailed_single_prediction(X);\n        // Return activations of last layer (actual predicted values)\n        return activations.back();\n    }\n\n    /**\n     * Function to get prediction of model on batch\n     * @param X array of feature vectors\n     * @return returns predicted values as vector\n     */\n    std::vector<std::vector<std::valarray<double>>> batch_predict(\n        const std::vector<std::vector<std::valarray<double>>> &X) {\n        // Store predicted values\n        std::vector<std::vector<std::valarray<double>>> predicted_batch(\n            X.size());\n        for (size_t i = 0; i < X.size(); i++) {  // For every sample\n            // Push predicted values\n            predicted_batch[i] = this->single_predict(X[i]);\n        }\n        return predicted_batch;  // Return predicted values\n    }\n\n    /**\n     * Function to fit model on supplied data\n     * @param X array of feature vectors\n     * @param Y array of target values\n     * @param epochs number of epochs (default = 100)\n     * @param learning_rate learning rate (default = 0.01)\n     * @param batch_size batch size for gradient descent (default = 32)\n     * @param shuffle flag for whether to shuffle data (default = true)\n     */\n    void fit(const std::vector<std::vector<std::valarray<double>>> &X_,\n             const std::vector<std::vector<std::valarray<double>>> &Y_,\n             const int &epochs = 100, const double &learning_rate = 0.01,\n             const size_t &batch_size = 32, const bool &shuffle = true) {\n        std::vector<std::vector<std::valarray<double>>> X = X_, Y = Y_;\n        // Both label and input data should have same size\n        if (X.size() != Y.size()) {\n            std::cerr << \"ERROR (\" << __func__ << \") : \";\n            std::cerr << \"X and Y in fit have different sizes\" << std::endl;\n            std::exit(EXIT_FAILURE);\n        }\n        std::cout << \"INFO: Training Started\" << std::endl;\n        for (int epoch = 1; epoch <= epochs; epoch++) {  // For every epoch\n            // Shuffle X and Y if flag is set\n            if (shuffle) {\n                equal_shuffle(X, Y);\n            }\n            auto start =\n                std::chrono::high_resolution_clock::now();  // Start clock\n            double loss = 0,\n                   acc = 0;  // Intialize performance metrics with zero\n            // For each starting index of batch\n            for (size_t batch_start = 0; batch_start < X.size();\n                 batch_start += batch_size) {\n                for (size_t i = batch_start;\n                     i < std::min(X.size(), batch_start + batch_size); i++) {\n                    std::vector<std::valarray<double>> grad, cur_error,\n                        predicted;\n                    auto activations = this->__detailed_single_prediction(X[i]);\n                    // Gradients vector to store gradients for all layers\n                    // They will be averaged and applied to kernal\n                    std::vector<std::vector<std::valarray<double>>> gradients;\n                    gradients.resize(this->layers.size());\n                    // First intialize gradients to zero\n                    for (size_t i = 0; i < gradients.size(); i++) {\n                        zeroes_initialization(\n                            gradients[i], get_shape(this->layers[i].kernal));\n                    }\n                    predicted = activations.back();  // Predicted vector\n                    cur_error = predicted - Y[i];    // Absoulute error\n                    // Calculating loss with MSE\n                    loss += sum(apply_function(\n                        cur_error, neural_network::util_functions::square));\n                    // If prediction is correct\n                    if (argmax(predicted) == argmax(Y[i])) {\n                        acc += 1;\n                    }\n                    // For every layer (except first) starting from last one\n                    for (size_t j = this->layers.size() - 1; j >= 1; j--) {\n                        // Backpropogating errors\n                        cur_error = hadamard_product(\n                            cur_error,\n                            apply_function(\n                                activations[j + 1],\n                                this->layers[j].dactivation_function));\n                        // Calculating gradient for current layer\n                        grad = multiply(transpose(activations[j]), cur_error);\n                        // Change error according to current kernal values\n                        cur_error = multiply(cur_error,\n                                             transpose(this->layers[j].kernal));\n                        // Adding gradient values to collection of gradients\n                        gradients[j] = gradients[j] + grad / double(batch_size);\n                    }\n                    // Applying gradients\n                    for (size_t j = this->layers.size() - 1; j >= 1; j--) {\n                        // Updating kernal (aka weights)\n                        this->layers[j].kernal = this->layers[j].kernal -\n                                                 gradients[j] * learning_rate;\n                    }\n                }\n            }\n            auto stop =\n                std::chrono::high_resolution_clock::now();  // Stoping the clock\n            // Calculate time taken by epoch\n            auto duration =\n                std::chrono::duration_cast<std::chrono::microseconds>(stop -\n                                                                      start);\n            loss /= X.size();        // Averaging loss\n            acc /= X.size();         // Averaging accuracy\n            std::cout.precision(4);  // set output precision to 4\n            // Printing training stats\n            std::cout << \"Training: Epoch \" << epoch << '/' << epochs;\n            std::cout << \", Loss: \" << loss;\n            std::cout << \", Accuracy: \" << acc;\n            std::cout << \", Taken time: \" << duration.count() / 1e6\n                      << \" seconds\";\n            std::cout << std::endl;\n        }\n        return;\n    }\n\n    /**\n     * Function to fit model on data stored in csv file\n     * @param file_name csv file name\n     * @param last_label flag for whether label is in first or last column\n     * @param epochs number of epochs\n     * @param learning_rate learning rate\n     * @param normalize flag for whether to normalize data\n     * @param slip_lines number of lines to skip\n     * @param batch_size batch size for gradient descent (default = 32)\n     * @param shuffle flag for whether to shuffle data (default = true)\n     */\n    void fit_from_csv(const std::string &file_name, const bool &last_label,\n                      const int &epochs, const double &learning_rate,\n                      const bool &normalize, const int &slip_lines = 1,\n                      const size_t &batch_size = 32,\n                      const bool &shuffle = true) {\n        // Getting training data from csv file\n        auto data =\n            this->get_XY_from_csv(file_name, last_label, normalize, slip_lines);\n        // Fit the model on training data\n        this->fit(data.first, data.second, epochs, learning_rate, batch_size,\n                  shuffle);\n        return;\n    }\n\n    /**\n     * Function to evaluate model on supplied data\n     * @param X array of feature vectors (input data)\n     * @param Y array of target values (label)\n     */\n    void evaluate(const std::vector<std::vector<std::valarray<double>>> &X,\n                  const std::vector<std::vector<std::valarray<double>>> &Y) {\n        std::cout << \"INFO: Evaluation Started\" << std::endl;\n        double acc = 0, loss = 0;  // intialize performance metrics with zero\n        for (size_t i = 0; i < X.size(); i++) {  // For every sample in input\n            // Get predictions\n            std::vector<std::valarray<double>> pred =\n                this->single_predict(X[i]);\n            // If predicted class is correct\n            if (argmax(pred) == argmax(Y[i])) {\n                acc += 1;  // Increment accuracy\n            }\n            // Calculating loss - Mean Squared Error\n            loss += sum(apply_function((Y[i] - pred),\n                                       neural_network::util_functions::square) *\n                        0.5);\n        }\n        acc /= X.size();   // Averaging accuracy\n        loss /= X.size();  // Averaging loss\n        // Prinitng performance of the model\n        std::cout << \"Evaluation: Loss: \" << loss;\n        std::cout << \", Accuracy: \" << acc << std::endl;\n        return;\n    }\n\n    /**\n     * Function to evaluate model on data stored in csv file\n     * @param file_name csv file name\n     * @param last_label flag for whether label is in first or last column\n     * @param normalize flag for whether to normalize data\n     * @param slip_lines number of lines to skip\n     */\n    void evaluate_from_csv(const std::string &file_name, const bool &last_label,\n                           const bool &normalize, const int &slip_lines = 1) {\n        // Getting training data from csv file\n        auto data =\n            this->get_XY_from_csv(file_name, last_label, normalize, slip_lines);\n        // Evaluating model\n        this->evaluate(data.first, data.second);\n        return;\n    }\n\n    /**\n     * Function to save current model.\n     * @param file_name file name to save model (*.model)\n     */\n    void save_model(const std::string &_file_name) {\n        std::string file_name = _file_name;\n        // Adding \".model\" extension if it is not already there in name\n        if (file_name.find(\".model\") == file_name.npos) {\n            file_name += \".model\";\n        }\n        std::ofstream out_file;  // Ofstream to write in file\n        // Open file in out|trunc mode\n        out_file.open(file_name.c_str(),\n                      std::ofstream::out | std::ofstream::trunc);\n        // If there is any problem in opening file\n        if (!out_file.is_open()) {\n            std::cerr << \"ERROR (\" << __func__ << \") : \";\n            std::cerr << \"Unable to open file: \" << file_name << std::endl;\n            std::exit(EXIT_FAILURE);\n        }\n        /**\n            Format in which model is saved:\n\n            total_layers\n            neurons(1st neural_network::layers::DenseLayer) activation_name(1st\n           neural_network::layers::DenseLayer) kernal_shape(1st\n           neural_network::layers::DenseLayer) kernal_values\n            .\n            .\n            .\n            neurons(Nth neural_network::layers::DenseLayer) activation_name(Nth\n           neural_network::layers::DenseLayer) kernal_shape(Nth\n           neural_network::layers::DenseLayer) kernal_value\n\n            For Example, pretrained model with 3 layers:\n            <pre>\n            3\n            4 none\n            4 4\n            1 0 0 0\n            0 1 0 0\n            0 0 1 0\n            0 0 0 1\n            6 relu\n            4 6\n            -1.88963 -3.61165 1.30757 -0.443906 -2.41039 -2.69653\n            -0.684753 0.0891452 0.795294 -2.39619 2.73377 0.318202\n            -2.91451 -4.43249 -0.804187 2.51995 -6.97524 -1.07049\n            -0.571531 -1.81689 -1.24485 1.92264 -2.81322 1.01741\n            3 sigmoid\n            6 3\n            0.390267 -0.391703 -0.0989607\n            0.499234 -0.564539 -0.28097\n            0.553386 -0.153974 -1.92493\n            -2.01336 -0.0219682 1.44145\n            1.72853 -0.465264 -0.705373\n            -0.908409 -0.740547 0.376416\n            </pre>\n        */\n        // Saving model in the same format\n        out_file << layers.size();\n        out_file << std::endl;\n        for (const auto &layer : this->layers) {\n            out_file << layer.neurons << ' ' << layer.activation << std::endl;\n            const auto shape = get_shape(layer.kernal);\n            out_file << shape.first << ' ' << shape.second << std::endl;\n            for (const auto &row : layer.kernal) {\n                for (const auto &val : row) {\n                    out_file << val << ' ';\n                }\n                out_file << std::endl;\n            }\n        }\n        std::cout << \"INFO: Model saved successfully with name : \";\n        std::cout << file_name << std::endl;\n        out_file.close();  // Closing file\n        return;\n    }\n\n    /**\n     * Function to load earlier saved model.\n     * @param file_name file from which model will be loaded (*.model)\n     * @return instance of NeuralNetwork class with pretrained weights\n     */\n    NeuralNetwork load_model(const std::string &file_name) {\n        std::ifstream in_file;            // Ifstream to read file\n        in_file.open(file_name.c_str());  // Openinig file\n        // If there is any problem in opening file\n        if (!in_file.is_open()) {\n            std::cerr << \"ERROR (\" << __func__ << \") : \";\n            std::cerr << \"Unable to open file: \" << file_name << std::endl;\n            std::exit(EXIT_FAILURE);\n        }\n        std::vector<std::pair<int, std::string>> config;  // To store config\n        std::vector<std::vector<std::valarray<double>>>\n            kernals;  // To store pretrained kernals\n        // Loading model from saved file format\n        size_t total_layers = 0;\n        in_file >> total_layers;\n        for (size_t i = 0; i < total_layers; i++) {\n            int neurons = 0;\n            std::string activation;\n            size_t shape_a = 0, shape_b = 0;\n            std::vector<std::valarray<double>> kernal;\n            in_file >> neurons >> activation >> shape_a >> shape_b;\n            for (size_t r = 0; r < shape_a; r++) {\n                std::valarray<double> row(shape_b);\n                for (size_t c = 0; c < shape_b; c++) {\n                    in_file >> row[c];\n                }\n                kernal.push_back(row);\n            }\n            config.emplace_back(make_pair(neurons, activation));\n            ;\n            kernals.emplace_back(kernal);\n        }\n        std::cout << \"INFO: Model loaded successfully\" << std::endl;\n        in_file.close();  // Closing file\n        return NeuralNetwork(\n            config, kernals);  // Return instance of NeuralNetwork class\n    }\n\n    /**\n     * Function to print summary of the network.\n     */\n    void summary() {\n        // Printing Summary\n        std::cout\n            << \"===============================================================\"\n            << std::endl;\n        std::cout << \"\\t\\t+ MODEL SUMMARY +\\t\\t\\n\";\n        std::cout\n            << \"===============================================================\"\n            << std::endl;\n        for (size_t i = 1; i <= layers.size(); i++) {  // For every layer\n            std::cout << i << \")\";\n            std::cout << \" Neurons : \"\n                      << layers[i - 1].neurons;  // number of neurons\n            std::cout << \", Activation : \"\n                      << layers[i - 1].activation;  // activation\n            std::cout << \", Kernal Shape : \"\n                      << get_shape(layers[i - 1].kernal);  // kernal shape\n            std::cout << std::endl;\n        }\n        std::cout\n            << \"===============================================================\"\n            << std::endl;\n        return;\n    }\n};\n}  // namespace neural_network\n}  // namespace machine_learning\n\n/**\n * Function to test neural network\n * @returns none\n */\nstatic void test() {\n    // Creating network with 3 layers for \"iris.csv\"\n    machine_learning::neural_network::NeuralNetwork myNN =\n        machine_learning::neural_network::NeuralNetwork({\n            {4, \"none\"},  // First layer with 3 neurons and \"none\" as activation\n            {6,\n             \"relu\"},  // Second layer with 6 neurons and \"relu\" as activation\n            {3, \"sigmoid\"}  // Third layer with 3 neurons and \"sigmoid\" as\n                            // activation\n        });\n    // Printing summary of model\n    myNN.summary();\n    // Training Model\n    myNN.fit_from_csv(\"iris.csv\", true, 100, 0.3, false, 2, 32, true);\n    // Testing predictions of model\n    assert(machine_learning::argmax(\n               myNN.single_predict({{5, 3.4, 1.6, 0.4}})) == 0);\n    assert(machine_learning::argmax(\n               myNN.single_predict({{6.4, 2.9, 4.3, 1.3}})) == 1);\n    assert(machine_learning::argmax(\n               myNN.single_predict({{6.2, 3.4, 5.4, 2.3}})) == 2);\n    return;\n}\n\n/** Driver Code */\nint main() {\n    // Testing\n    test();\n    return 0;\n}\n","index":104},{"title":"Ordinary Least Squares Regressor","category":"machine_learning","id":"ordinary_least_squares_regressor_machine_learning","algorithm":"/**\n * @file\n * \\brief Linear regression example using [Ordinary least\n * squares](https://en.wikipedia.org/wiki/Ordinary_least_squares)\n *\n * Program that gets the number of data samples and number of features per\n * sample along with output per sample. It applies OLS regression to compute\n * the regression output for additional test data samples.\n *\n * \\author [Krishna Vedala](https://github.com/kvedala)\n */\n#include <cassert>\n#include <cmath>    // for std::abs\n#include <iomanip>  // for print formatting\n#include <iostream>\n#include <vector>\n\n/**\n * operator to print a matrix\n */\ntemplate <typename T>\nstd::ostream &operator<<(std::ostream &out,\n                         std::vector<std::vector<T>> const &v) {\n    const int width = 10;\n    const char separator = ' ';\n\n    for (size_t row = 0; row < v.size(); row++) {\n        for (size_t col = 0; col < v[row].size(); col++) {\n            out << std::left << std::setw(width) << std::setfill(separator)\n                << v[row][col];\n        }\n        out << std::endl;\n    }\n\n    return out;\n}\n\n/**\n * operator to print a vector\n */\ntemplate <typename T>\nstd::ostream &operator<<(std::ostream &out, std::vector<T> const &v) {\n    const int width = 15;\n    const char separator = ' ';\n\n    for (size_t row = 0; row < v.size(); row++) {\n        out << std::left << std::setw(width) << std::setfill(separator)\n            << v[row];\n    }\n\n    return out;\n}\n\n/**\n * function to check if given matrix is a square matrix\n * \\returns 1 if true, 0 if false\n */\ntemplate <typename T>\ninline bool is_square(std::vector<std::vector<T>> const &A) {\n    // Assuming A is square matrix\n    size_t N = A.size();\n    for (size_t i = 0; i < N; i++) {\n        if (A[i].size() != N) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n * Matrix multiplication such that if A is size (mxn) and\n * B is of size (pxq) then the multiplication is defined\n * only when n = p and the resultant matrix is of size (mxq)\n *\n * \\returns resultant matrix\n **/\ntemplate <typename T>\nstd::vector<std::vector<T>> operator*(std::vector<std::vector<T>> const &A,\n                                      std::vector<std::vector<T>> const &B) {\n    // Number of rows in A\n    size_t N_A = A.size();\n    // Number of columns in B\n    size_t N_B = B[0].size();\n\n    std::vector<std::vector<T>> result(N_A);\n\n    if (A[0].size() != B.size()) {\n        std::cerr << \"Number of columns in A != Number of rows in B (\"\n                  << A[0].size() << \", \" << B.size() << \")\" << std::endl;\n        return result;\n    }\n\n    for (size_t row = 0; row < N_A; row++) {\n        std::vector<T> v(N_B);\n        for (size_t col = 0; col < N_B; col++) {\n            v[col] = static_cast<T>(0);\n            for (size_t j = 0; j < B.size(); j++) {\n                v[col] += A[row][j] * B[j][col];\n            }\n        }\n        result[row] = v;\n    }\n\n    return result;\n}\n\n/**\n * multiplication of a matrix with a column vector\n * \\returns resultant vector\n */\ntemplate <typename T>\nstd::vector<T> operator*(std::vector<std::vector<T>> const &A,\n                         std::vector<T> const &B) {\n    // Number of rows in A\n    size_t N_A = A.size();\n\n    std::vector<T> result(N_A);\n\n    if (A[0].size() != B.size()) {\n        std::cerr << \"Number of columns in A != Number of rows in B (\"\n                  << A[0].size() << \", \" << B.size() << \")\" << std::endl;\n        return result;\n    }\n\n    for (size_t row = 0; row < N_A; row++) {\n        result[row] = static_cast<T>(0);\n        for (size_t j = 0; j < B.size(); j++) result[row] += A[row][j] * B[j];\n    }\n\n    return result;\n}\n\n/**\n * pre-multiplication of a vector by a scalar\n * \\returns resultant vector\n */\ntemplate <typename T>\nstd::vector<float> operator*(float const scalar, std::vector<T> const &A) {\n    // Number of rows in A\n    size_t N_A = A.size();\n\n    std::vector<float> result(N_A);\n\n    for (size_t row = 0; row < N_A; row++) {\n        result[row] += A[row] * static_cast<float>(scalar);\n    }\n\n    return result;\n}\n\n/**\n * post-multiplication of a vector by a scalar\n * \\returns resultant vector\n */\ntemplate <typename T>\nstd::vector<float> operator*(std::vector<T> const &A, float const scalar) {\n    // Number of rows in A\n    size_t N_A = A.size();\n\n    std::vector<float> result(N_A);\n\n    for (size_t row = 0; row < N_A; row++) {\n        result[row] = A[row] * static_cast<float>(scalar);\n    }\n\n    return result;\n}\n\n/**\n * division of a vector by a scalar\n * \\returns resultant vector\n */\ntemplate <typename T>\nstd::vector<float> operator/(std::vector<T> const &A, float const scalar) {\n    return (1.f / scalar) * A;\n}\n\n/**\n * subtraction of two vectors of identical lengths\n * \\returns resultant vector\n */\ntemplate <typename T>\nstd::vector<T> operator-(std::vector<T> const &A, std::vector<T> const &B) {\n    // Number of rows in A\n    size_t N = A.size();\n\n    std::vector<T> result(N);\n\n    if (B.size() != N) {\n        std::cerr << \"Vector dimensions shouldbe identical!\" << std::endl;\n        return A;\n    }\n\n    for (size_t row = 0; row < N; row++) result[row] = A[row] - B[row];\n\n    return result;\n}\n\n/**\n * addition of two vectors of identical lengths\n * \\returns resultant vector\n */\ntemplate <typename T>\nstd::vector<T> operator+(std::vector<T> const &A, std::vector<T> const &B) {\n    // Number of rows in A\n    size_t N = A.size();\n\n    std::vector<T> result(N);\n\n    if (B.size() != N) {\n        std::cerr << \"Vector dimensions shouldbe identical!\" << std::endl;\n        return A;\n    }\n\n    for (size_t row = 0; row < N; row++) result[row] = A[row] + B[row];\n\n    return result;\n}\n\n/**\n * Get matrix inverse using Row-trasnformations. Given matrix must\n * be a square and non-singular.\n * \\returns inverse matrix\n **/\ntemplate <typename T>\nstd::vector<std::vector<float>> get_inverse(\n    std::vector<std::vector<T>> const &A) {\n    // Assuming A is square matrix\n    size_t N = A.size();\n\n    std::vector<std::vector<float>> inverse(N);\n    for (size_t row = 0; row < N; row++) {\n        // preallocatae a resultant identity matrix\n        inverse[row] = std::vector<float>(N);\n        for (size_t col = 0; col < N; col++) {\n            inverse[row][col] = (row == col) ? 1.f : 0.f;\n        }\n    }\n\n    if (!is_square(A)) {\n        std::cerr << \"A must be a square matrix!\" << std::endl;\n        return inverse;\n    }\n\n    // preallocatae a temporary matrix identical to A\n    std::vector<std::vector<float>> temp(N);\n    for (size_t row = 0; row < N; row++) {\n        std::vector<float> v(N);\n        for (size_t col = 0; col < N; col++) {\n            v[col] = static_cast<float>(A[row][col]);\n        }\n        temp[row] = v;\n    }\n\n    // start transformations\n    for (size_t row = 0; row < N; row++) {\n        for (size_t row2 = row; row2 < N && temp[row][row] == 0; row2++) {\n            // this to ensure diagonal elements are not 0\n            temp[row] = temp[row] + temp[row2];\n            inverse[row] = inverse[row] + inverse[row2];\n        }\n\n        for (size_t col2 = row; col2 < N && temp[row][row] == 0; col2++) {\n            // this to further ensure diagonal elements are not 0\n            for (size_t row2 = 0; row2 < N; row2++) {\n                temp[row2][row] = temp[row2][row] + temp[row2][col2];\n                inverse[row2][row] = inverse[row2][row] + inverse[row2][col2];\n            }\n        }\n\n        if (temp[row][row] == 0) {\n            // Probably a low-rank matrix and hence singular\n            std::cerr << \"Low-rank matrix, no inverse!\" << std::endl;\n            return inverse;\n        }\n\n        // set diagonal to 1\n        auto divisor = static_cast<float>(temp[row][row]);\n        temp[row] = temp[row] / divisor;\n        inverse[row] = inverse[row] / divisor;\n        // Row transformations\n        for (size_t row2 = 0; row2 < N; row2++) {\n            if (row2 == row) {\n                continue;\n            }\n            float factor = temp[row2][row];\n            temp[row2] = temp[row2] - factor * temp[row];\n            inverse[row2] = inverse[row2] - factor * inverse[row];\n        }\n    }\n\n    return inverse;\n}\n\n/**\n * matrix transpose\n * \\returns resultant matrix\n **/\ntemplate <typename T>\nstd::vector<std::vector<T>> get_transpose(\n    std::vector<std::vector<T>> const &A) {\n    std::vector<std::vector<T>> result(A[0].size());\n\n    for (size_t row = 0; row < A[0].size(); row++) {\n        std::vector<T> v(A.size());\n        for (size_t col = 0; col < A.size(); col++) v[col] = A[col][row];\n\n        result[row] = v;\n    }\n    return result;\n}\n\n/**\n * Perform Ordinary Least Squares curve fit. This operation is defined as\n * \\f[\\beta = \\left(X^TXX^T\\right)Y\\f]\n * \\param X feature matrix with rows representing sample vector of features\n * \\param Y known regression value for each sample\n * \\returns fitted regression model polynomial coefficients\n */\ntemplate <typename T>\nstd::vector<float> fit_OLS_regressor(std::vector<std::vector<T>> const &X,\n                                     std::vector<T> const &Y) {\n    // NxF\n    std::vector<std::vector<T>> X2 = X;\n    for (size_t i = 0; i < X2.size(); i++) {\n        // add Y-intercept -> Nx(F+1)\n        X2[i].push_back(1);\n    }\n    // (F+1)xN\n    std::vector<std::vector<T>> Xt = get_transpose(X2);\n    // (F+1)x(F+1)\n    std::vector<std::vector<T>> tmp = get_inverse(Xt * X2);\n    // (F+1)xN\n    std::vector<std::vector<float>> out = tmp * Xt;\n    // cout << endl\n    //      << \"Projection matrix: \" << X2 * out << endl;\n\n    // Fx1,1    -> (F+1)^th element is the independent constant\n    return out * Y;\n}\n\n/**\n * Given data and OLS model coeffficients, predict\n * regression estimates. This operation is defined as\n * \\f[y_{\\text{row}=i} = \\sum_{j=\\text{columns}}\\beta_j\\cdot X_{i,j}\\f]\n *\n * \\param X feature matrix with rows representing sample vector of features\n * \\param beta fitted regression model\n * \\return vector with regression values for each sample\n **/\ntemplate <typename T>\nstd::vector<float> predict_OLS_regressor(std::vector<std::vector<T>> const &X,\n                                         std::vector<float> const &beta /**< */\n) {\n    std::vector<float> result(X.size());\n\n    for (size_t rows = 0; rows < X.size(); rows++) {\n        // -> start with constant term\n        result[rows] = beta[X[0].size()];\n        for (size_t cols = 0; cols < X[0].size(); cols++) {\n            result[rows] += beta[cols] * X[rows][cols];\n        }\n    }\n    // Nx1\n    return result;\n}\n\n/** Self test checks */\nvoid ols_test() {\n    int F = 3, N = 5;\n\n    /* test function = x^2 -5 */\n    std::cout << \"Test 1 (quadratic function)....\";\n    // create training data set with features = x, x^2, x^3\n    std::vector<std::vector<float>> data1(\n        {{-5, 25, -125}, {-1, 1, -1}, {0, 0, 0}, {1, 1, 1}, {6, 36, 216}});\n    // create corresponding outputs\n    std::vector<float> Y1({20, -4, -5, -4, 31});\n    // perform regression modelling\n    std::vector<float> beta1 = fit_OLS_regressor(data1, Y1);\n    // create test data set with same features = x, x^2, x^3\n    std::vector<std::vector<float>> test_data1(\n        {{-2, 4, -8}, {2, 4, 8}, {-10, 100, -1000}, {10, 100, 1000}});\n    // expected regression outputs\n    std::vector<float> expected1({-1, -1, 95, 95});\n    // predicted regression outputs\n    std::vector<float> out1 = predict_OLS_regressor(test_data1, beta1);\n    // compare predicted results are within +-0.01 limit of expected\n    for (size_t rows = 0; rows < out1.size(); rows++) {\n        assert(std::abs(out1[rows] - expected1[rows]) < 0.01);\n    }\n    std::cout << \"passed\\n\";\n\n    /* test function = x^3 + x^2 - 100 */\n    std::cout << \"Test 2 (cubic function)....\";\n    // create training data set with features = x, x^2, x^3\n    std::vector<std::vector<float>> data2(\n        {{-5, 25, -125}, {-1, 1, -1}, {0, 0, 0}, {1, 1, 1}, {6, 36, 216}});\n    // create corresponding outputs\n    std::vector<float> Y2({-200, -100, -100, 98, 152});\n    // perform regression modelling\n    std::vector<float> beta2 = fit_OLS_regressor(data2, Y2);\n    // create test data set with same features = x, x^2, x^3\n    std::vector<std::vector<float>> test_data2(\n        {{-2, 4, -8}, {2, 4, 8}, {-10, 100, -1000}, {10, 100, 1000}});\n    // expected regression outputs\n    std::vector<float> expected2({-104, -88, -1000, 1000});\n    // predicted regression outputs\n    std::vector<float> out2 = predict_OLS_regressor(test_data2, beta2);\n    // compare predicted results are within +-0.01 limit of expected\n    for (size_t rows = 0; rows < out2.size(); rows++) {\n        assert(std::abs(out2[rows] - expected2[rows]) < 0.01);\n    }\n    std::cout << \"passed\\n\";\n\n    std::cout << std::endl;  // ensure test results are displayed on screen\n                             // (flush stdout)\n}\n\n/**\n * main function\n */\nint main() {\n    ols_test();\n\n    size_t N = 0, F = 0;\n\n    std::cout << \"Enter number of features: \";\n    // number of features = columns\n    std::cin >> F;\n    std::cout << \"Enter number of samples: \";\n    // number of samples = rows\n    std::cin >> N;\n\n    std::vector<std::vector<float>> data(N);\n    std::vector<float> Y(N);\n\n    std::cout\n        << \"Enter training data. Per sample, provide features and one output.\"\n        << std::endl;\n\n    for (size_t rows = 0; rows < N; rows++) {\n        std::vector<float> v(F);\n        std::cout << \"Sample# \" << rows + 1 << \": \";\n        for (size_t cols = 0; cols < F; cols++) {\n            // get the F features\n            std::cin >> v[cols];\n        }\n        data[rows] = v;\n        // get the corresponding output\n        std::cin >> Y[rows];\n    }\n\n    std::vector<float> beta = fit_OLS_regressor(data, Y);\n    std::cout << std::endl << std::endl << \"beta:\" << beta << std::endl;\n\n    size_t T = 0;\n    std::cout << \"Enter number of test samples: \";\n    // number of test sample inputs\n    std::cin >> T;\n    std::vector<std::vector<float>> data2(T);\n    // vector<float> Y2(T);\n\n    for (size_t rows = 0; rows < T; rows++) {\n        std::cout << \"Sample# \" << rows + 1 << \": \";\n        std::vector<float> v(F);\n        for (size_t cols = 0; cols < F; cols++) std::cin >> v[cols];\n        data2[rows] = v;\n    }\n\n    std::vector<float> out = predict_OLS_regressor(data2, beta);\n    for (size_t rows = 0; rows < T; rows++) std::cout << out[rows] << std::endl;\n\n    return 0;\n}\n","index":105},{"title":"Math","category":null,"id":"math","index":106},{"title":"Armstrong Number","category":"math","id":"armstrong_number_math","algorithm":"/**\n * @file\n * \\brief Program to check if a number is an [Armstrong/Narcissistic\n * number](https://en.wikipedia.org/wiki/Narcissistic_number) in decimal system.\n *\n * \\details\n * Armstrong number or [Narcissistic\n * number](https://en.wikipedia.org/wiki/Narcissistic_number) is a number that\n * is the sum of its own digits raised to the power of the number of digits.\n * @author iamnambiar\n */\n#include <cassert>\n#include <cmath>\n#include <iostream>\n\n/**\n * Function to calculate the total number of digits in the number.\n * @param num Number\n * @return Total number of digits.\n */\nint number_of_digits(int num) {\n    int total_digits = 0;\n    while (num > 0) {\n        num = num / 10;\n        ++total_digits;\n    }\n    return total_digits;\n}\n\n/**\n * Function to check whether the number is armstrong number or not.\n * @param num Number\n * @return `true` if the number is armstrong.\n * @return `false` if the number is not armstrong.\n */\nbool is_armstrong(int number) {\n    // If the number is less than 0, then it is not a armstrong number.\n    if (number < 0) {\n        return false;\n    }\n    int sum = 0;\n    int temp = number;\n    // Finding the total number of digits in the number\n    int total_digits = number_of_digits(number);\n    while (temp > 0) {\n        int rem = temp % 10;\n        // Finding each digit raised to the power total digit and add it to the\n        // total sum\n        sum = sum + std::pow(rem, total_digits);\n        temp = temp / 10;\n    }\n    return number == sum;\n}\n\n/**\n * Function for testing the is_armstrong() function\n * with all the test cases.\n */\nvoid test() {\n    // is_armstrong(370) returns true.\n    assert(is_armstrong(370) == true);\n    // is_armstrong(225) returns false.\n    assert(is_armstrong(225) == false);\n    // is_armstrong(-23) returns false.\n    assert(is_armstrong(-23) == false);\n    // is_armstrong(153) returns true.\n    assert(is_armstrong(153) == true);\n    // is_armstrong(0) returns true.\n    assert(is_armstrong(0) == true);\n    // is_armstrong(12) returns false.\n    assert(is_armstrong(12) == false);\n}\n\n/**\n * Main Function\n */\nint main() {\n    test();\n    return 0;\n}\n","index":107},{"title":"Binary Exponent","category":"math","id":"binary_exponent_math","algorithm":"/**\n * @file\n * @brief C++ Program to find Binary Exponent Iteratively and Recursively.\n *\n * Calculate \\f$a^b\\f$ in \\f$O(\\log(b))\\f$ by converting \\f$b\\f$ to a\n * binary number. Binary exponentiation is also known as exponentiation by\n * squaring.\n * @note This is a far better approach compared to naive method which\n * provide \\f$O(b)\\f$ operations.\n *\n * Example:\n * </br>10 in base 2 is 1010.\n * \\f{eqnarray*}{\n * 2^{10_d} &=& 2^{1010_b} = 2^8 * 2^2\\\\\n * 2^1 &=& 2\\\\\n * 2^2 &=& (2^1)^2 = 2^2 = 4\\\\\n * 2^4 &=& (2^2)^2 = 4^2 = 16\\\\\n * 2^8 &=& (2^4)^2 = 16^2 = 256\\\\\n * \\f}\n * Hence to calculate 2^10 we only need to multiply \\f$2^8\\f$ and \\f$2^2\\f$\n * skipping \\f$2^1\\f$ and \\f$2^4\\f$.\n */\n\n#include <iostream>\n\n/// Recursive function to calculate exponent in \\f$O(\\log(n))\\f$ using binary\n/// exponent.\nint binExpo(int a, int b) {\n    if (b == 0) {\n        return 1;\n    }\n    int res = binExpo(a, b / 2);\n    if (b % 2) {\n        return res * res * a;\n    } else {\n        return res * res;\n    }\n}\n\n/// Iterative function to calculate exponent in \\f$O(\\log(n))\\f$ using binary\n/// exponent.\nint binExpo_alt(int a, int b) {\n    int res = 1;\n    while (b > 0) {\n        if (b % 2) {\n            res = res * a;\n        }\n        a = a * a;\n        b /= 2;\n    }\n    return res;\n}\n\n/// Main function\nint main() {\n    int a, b;\n    /// Give two numbers a, b\n    std::cin >> a >> b;\n    if (a == 0 && b == 0) {\n        std::cout << \"Math error\" << std::endl;\n    } else if (b < 0) {\n        std::cout << \"Exponent must be positive !!\" << std::endl;\n    } else {\n        int resRecurse = binExpo(a, b);\n        /// int resIterate = binExpo_alt(a, b);\n\n        /// Result of a^b (where '^' denotes exponentiation)\n        std::cout << resRecurse << std::endl;\n        /// std::cout << resIterate << std::endl;\n    }\n}\n","index":108},{"title":"Check Amicable Pair","category":"math","id":"check_amicable_pair_math","algorithm":"/**\n *\n * @file\n * \\brief A C++ Program to check whether a pair of number is [amicable\n * pair](https://en.wikipedia.org/wiki/Amicable_numbers) or not.\n *\n * \\details\n * Amicable Pair are two positive integers such that sum of the proper divisor\n * of each number is equal to the other number.\n * @author iamnambiar\n */\n#include <cassert>\n#include <iostream>\n\n/**\n * Function to calculate the sum of all the proper divisor\n * of an integer.\n * @param num First number.\n * @return Sum of the proper divisor of the number.\n */\nint sum_of_divisor(int num) {\n    // Variable to store the sum of all proper divisors.\n    int sum = 0;\n    // Below loop condition helps to reduce Time complexity by a factor of\n    // square root of the number.\n    for (int div = 2; div * div <= num; ++div) {\n        // Check 'div' is divisor of 'num'.\n        if (num % div == 0) {\n            // If both divisor are same, add once to 'sum'\n            if (div == (num / div)) {\n                sum += div;\n            } else {\n                // If both divisor are not the same, add both to 'sum'.\n                sum += (div + (num / div));\n            }\n        }\n    }\n    return sum + 1;\n}\n\n/**\n * Function to check whether the pair is amicable or not.\n * @param x First number.\n * @param y Second number.\n * @return `true` if the pair is amicable\n * @return `false` if the pair is not amicable\n */\nbool are_amicable(int x, int y) {\n    return (sum_of_divisor(x) == y) && (sum_of_divisor(y) == x);\n}\n\n/**\n * Function for testing the is_amicable() with\n * all the test cases.\n */\nvoid test() {\n    // are_amicable(220, 284) returns true.\n    assert(are_amicable(220, 284) == true);\n    // are_amicable(6232, 6368) returns true.\n    assert(are_amicable(6368, 6232) == true);\n    // are_amicable(458, 232) returns false.\n    assert(are_amicable(458, 232) == false);\n}\n\n/**\n * Main Function\n */\nint main() {\n    test();\n    std::cout << \"Assertion Success.\" << std::endl;\n    return 0;\n}\n","index":109},{"title":"Check Prime","category":"math","id":"check_prime_math","algorithm":"/**\n * Copyright 2020 @author omkarlanghe\n *\n * @file\n * A simple program to check if the given number if prime or not.\n *\n * @brief\n * Reduced all possibilities of a number which cannot be prime.\n * Eg: No even number, except 2 can be a prime number, hence we will increment\n * our loop with i+2 jumping on all odd numbers only. If number is <= 1 or if it\n * is even except 2, break the loop and return false telling number is not\n * prime.\n */\n#include <cassert>\n#include <iostream>\n/**\n * Function to check if the given number is prime or not.\n * @param num number to be checked.\n * @return if number is prime, it returns @ true, else it returns @ false.\n */\ntemplate <typename T>\nbool is_prime(T num) {\n    bool result = true;\n    if (num <= 1) {\n        return 0;\n    } else if (num == 2) {\n        return 1;\n    } else if ((num & 1) == 0) {\n        return 0;\n    }\n    if (num >= 3) {\n        for (T i = 3; (i * i) < (num); i = (i + 2)) {\n            if ((num % i) == 0) {\n                result = false;\n                break;\n            }\n        }\n    }\n    return (result);\n}\n\n/**\n * Main function\n */\nint main() {\n    // perform self-test\n    assert(is_prime(50) == false);\n    assert(is_prime(115249) == true);\n\n    int num;\n    std::cout << \"Enter the number to check if it is prime or not\" << std::endl;\n    std::cin >> num;\n    bool result = is_prime(num);\n    if (result) {\n        std::cout << num << \" is a prime number\" << std::endl;\n    } else {\n        std::cout << num << \" is not a prime number\" << std::endl;\n    }\n\n    return 0;\n}\n","index":110},{"title":"Complex Numbers","category":"math","id":"complex_numbers_math","algorithm":"/**\n * @author tjgurwara99\n * @file\n *\n * \\brief An implementation of Complex Number as Objects\n * \\details A basic implementation of Complex Number field as a class with\n * operators overloaded to accommodate (mathematical) field operations.\n */\n\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <ctime>\n#include <iostream>\n#include <stdexcept>\n\n/**\n * \\brief Class Complex to represent complex numbers as a field.\n */\nclass Complex {\n    // The real value of the complex number\n    double re;\n    // The imaginary value of the complex number\n    double im;\n\n public:\n    /**\n     * \\brief Complex Constructor which initialises our complex number.\n     * \\details\n     * Complex Constructor which initialises the complex number which takes\n     * three arguments.\n     * @param x If the third parameter is 'true' then this x is the absolute\n     * value of the complex number, if the third parameter is 'false' then this\n     * x is the real value of the complex number (optional).\n     * @param y If the third parameter is 'true' then this y is the argument of\n     * the complex number, if the third parameter is 'false' then this y is the\n     * imaginary value of the complex number (optional).\n     * @param is_polar 'false' by default. If we want to initialise our complex\n     * number using polar form then set this to true, otherwise set it to false\n     * to use initialiser which initialises real and imaginary values using the\n     * first two parameters (optional).\n     */\n    explicit Complex(double x = 0.f, double y = 0.f, bool is_polar = false) {\n        if (!is_polar) {\n            re = x;\n            im = y;\n            return;\n        }\n\n        re = x * std::cos(y);\n        im = x * std::sin(y);\n    }\n\n    /**\n     * \\brief Copy Constructor\n     * @param other The other number to equate our number to.\n     */\n    Complex(const Complex &other) : re(other.real()), im(other.imag()) {}\n\n    /**\n     * \\brief Member function to get real value of our complex number.\n     * Member function (getter) to access the class' re value.\n     */\n    double real() const { return this->re; }\n\n    /**\n     * \\brief Member function to get imaginary value of our complex number.\n     * Member function (getter) to access the class' im value.\n     */\n    double imag() const { return this->im; }\n\n    /**\n     * \\brief Member function to give the modulus of our complex number.\n     * Member function to which gives the absolute value (modulus) of our\n     * complex number\n     * @return \\f$ \\sqrt{z \\bar{z}} \\f$ where \\f$ z \\f$ is our complex\n     * number.\n     */\n    double abs() const {\n        return std::sqrt(this->re * this->re + this->im * this->im);\n    }\n\n    /**\n     * \\brief Member function to give the argument of our complex number.\n     * @return Argument of our Complex number in radians.\n     */\n    double arg() const { return std::atan2(this->im, this->re); }\n\n    /**\n     * \\brief Operator overload of '+' on Complex class.\n     * Operator overload to be able to add two complex numbers.\n     * @param other The other number that is added to the current number.\n     * @return result current number plus other number\n     */\n    Complex operator+(const Complex &other) {\n        Complex result(this->re + other.re, this->im + other.im);\n        return result;\n    }\n\n    /**\n     * \\brief Operator overload of '-' on Complex class.\n     * Operator overload to be able to subtract two complex numbers.\n     * @param other The other number being subtracted from the current number.\n     * @return result current number subtract other number\n     */\n    Complex operator-(const Complex &other) {\n        Complex result(this->re - other.re, this->im - other.im);\n        return result;\n    }\n\n    /**\n     * \\brief Operator overload of '*' on Complex class.\n     * Operator overload to be able to multiple two complex numbers.\n     * @param other The other number to multiply the current number to.\n     * @return result current number times other number.\n     */\n    Complex operator*(const Complex &other) {\n        Complex result(this->re * other.re - this->im * other.im,\n                       this->re * other.im + this->im * other.re);\n        return result;\n    }\n\n    /**\n     * \\brief Operator overload of '~' on Complex class.\n     * Operator overload of the BITWISE NOT which gives us the conjugate of our\n     * complex number. NOTE: This is overloading the BITWISE operator but its\n     * not a BITWISE operation in this definition.\n     * @return result The conjugate of our complex number.\n     */\n    Complex operator~() const {\n        Complex result(this->re, -(this->im));\n        return result;\n    }\n\n    /**\n     * \\brief Operator overload of '/' on Complex class.\n     * Operator overload to be able to divide two complex numbers. This function\n     * would throw an exception if the other number is zero.\n     * @param other The other number we divide our number by.\n     * @return result Current number divided by other number.\n     */\n    Complex operator/(const Complex &other) {\n        Complex result = *this * ~other;\n        double denominator =\n            other.real() * other.real() + other.imag() * other.imag();\n        if (denominator != 0) {\n            result = Complex(result.real() / denominator,\n                             result.imag() / denominator);\n            return result;\n        } else {\n            throw std::invalid_argument(\"Undefined Value\");\n        }\n    }\n\n    /**\n     * \\brief Operator overload of '=' on Complex class.\n     * Operator overload to be able to copy RHS instance of Complex to LHS\n     * instance of Complex\n     */\n    const Complex &operator=(const Complex &other) {\n        this->re = other.real();\n        this->im = other.imag();\n        return *this;\n    }\n};\n\n/**\n * \\brief Operator overload of '==' on Complex class.\n * Logical Equal overload for our Complex class.\n * @param a Left hand side of our expression\n * @param b Right hand side of our expression\n * @return 'True' If real and imaginary parts of a and b are same\n * @return 'False' Otherwise.\n */\nbool operator==(const Complex &a, const Complex &b) {\n    return a.real() == b.real() && a.imag() == b.imag();\n}\n\n/**\n * \\brief Operator overload of '<<' of ostream for Complex class.\n * Overloaded insersion operator to accommodate the printing of our complex\n * number in their standard form.\n * @param os The console stream\n * @param num The complex number.\n */\nstd::ostream &operator<<(std::ostream &os, const Complex &num) {\n    os << \"(\" << num.real();\n    if (num.imag() < 0) {\n        os << \" - \" << -num.imag();\n    } else {\n        os << \" + \" << num.imag();\n    }\n    os << \"i)\";\n    return os;\n}\n\n/**\n * \\brief Function to get random numbers to generate our complex numbers for\n * test\n */\ndouble get_rand() { return (std::rand() % 100 - 50) / 100.f; }\n\n/**\n * Tests Function\n */\nvoid tests() {\n    std::srand(std::time(nullptr));\n    double x1 = get_rand(), y1 = get_rand(), x2 = get_rand(), y2 = get_rand();\n    Complex num1(x1, y1), num2(x2, y2);\n    std::complex<double> cnum1(x1, y1), cnum2(x2, y2);\n    Complex result;\n    std::complex<double> expected;\n    // Test for addition\n    result = num1 + num2;\n    expected = cnum1 + cnum2;\n    assert(((void)\"1 + 1i + 1 + 1i is equal to 2 + 2i but the addition doesn't \"\n                  \"add up \\n\",\n            (result.real() == expected.real() &&\n             result.imag() == expected.imag())));\n    std::cout << \"First test passes.\" << std::endl;\n    // Test for subtraction\n    result = num1 - num2;\n    expected = cnum1 - cnum2;\n    assert(((void)\"1 + 1i - 1 - 1i is equal to 0 but the program says \"\n                  \"otherwise. \\n\",\n            (result.real() == expected.real() &&\n             result.imag() == expected.imag())));\n    std::cout << \"Second test passes.\" << std::endl;\n    // Test for multiplication\n    result = num1 * num2;\n    expected = cnum1 * cnum2;\n    assert(((void)\"(1 + 1i) * (1 + 1i) is equal to 2i but the program says \"\n                  \"otherwise. \\n\",\n            (result.real() == expected.real() &&\n             result.imag() == expected.imag())));\n    std::cout << \"Third test passes.\" << std::endl;\n    // Test for division\n    result = num1 / num2;\n    expected = cnum1 / cnum2;\n    assert(((void)\"(1 + 1i) / (1 + 1i) is equal to 1 but the program says \"\n                  \"otherwise.\\n\",\n            (result.real() == expected.real() &&\n             result.imag() == expected.imag())));\n    std::cout << \"Fourth test passes.\" << std::endl;\n    // Test for conjugates\n    result = ~num1;\n    expected = std::conj(cnum1);\n    assert(((void)\"(1 + 1i) has a conjugate which is equal to (1 - 1i) but the \"\n                  \"program says otherwise.\\n\",\n            (result.real() == expected.real() &&\n             result.imag() == expected.imag())));\n    std::cout << \"Fifth test passes.\\n\";\n    // Test for Argument of our complex number\n    assert(((void)\"(1 + 1i) has argument PI / 4 but the program differs from \"\n                  \"the std::complex result.\\n\",\n            (num1.arg() == std::arg(cnum1))));\n    std::cout << \"Sixth test passes.\\n\";\n    // Test for absolute value of our complex number\n    assert(((void)\"(1 + 1i) has absolute value sqrt(2) but the program differs \"\n                  \"from the std::complex result. \\n\",\n            (num1.abs() == std::abs(cnum1))));\n    std::cout << \"Seventh test passes.\\n\";\n}\n\n/**\n * Main function\n */\nint main() {\n    tests();\n    return 0;\n}\n","index":111},{"title":"Double Factorial","category":"math","id":"double_factorial_math","algorithm":"/**\n * @file\n * @brief Compute [double\n * factorial](https://en.wikipedia.org/wiki/Double_factorial): \\f$n!!\\f$\n *\n * Double factorial of a non-negative integer `n`, is defined as the product of\n * all the integers from 1 to n that have the same parity (odd or even) as n.\n * <br/>It is also called as semifactorial of a number and is denoted by\n * \\f$n!!\\f$\n */\n\n#include <cassert>\n#include <iostream>\n\n/** Compute double factorial using iterative method\n */\nuint64_t double_factorial_iterative(uint64_t n) {\n    uint64_t res = 1;\n    for (uint64_t i = n;; i -= 2) {\n        if (i == 0 || i == 1)\n            return res;\n        res *= i;\n    }\n    return res;\n}\n\n/** Compute double factorial using resursive method.\n * <br/>Recursion can be costly for large numbers.\n */\nuint64_t double_factorial_recursive(uint64_t n) {\n    if (n <= 1)\n        return 1;\n    return n * double_factorial_recursive(n - 2);\n}\n\n/** Wrapper to run tests using both recursive and iterative implementations.\n * The checks are only valid in debug builds due to the use of `assert()`\n * statements.\n * \\param [in] n number to check double factorial for\n * \\param [in] expected expected result\n */\nvoid test(uint64_t n, uint64_t expected) {\n    assert(double_factorial_iterative(n) == expected);\n    assert(double_factorial_recursive(n) == expected);\n}\n\n/**\n * Test implementations\n */\nvoid tests() {\n    std::cout << \"Test 1:\\t n=5\\t...\";\n    test(5, 15);\n    std::cout << \"passed\\n\";\n\n    std::cout << \"Test 2:\\t n=15\\t...\";\n    test(15, 2027025);\n    std::cout << \"passed\\n\";\n\n    std::cout << \"Test 3:\\t n=0\\t...\";\n    test(0, 1);\n    std::cout << \"passed\\n\";\n}\n\n/**\n * Main function\n */\nint main() {\n    tests();\n    return 0;\n}\n","index":112},{"title":"Eulers Totient Function","category":"math","id":"eulers_totient_function_math","algorithm":"/**\n * @file\n * @brief C++ Program to find\n * [Euler's Totient](https://en.wikipedia.org/wiki/Euler%27s_totient_function)\n * function\n *\n * Euler Totient Function is also known as phi function.\n * \\f[\\phi(n) =\n * \\phi\\left({p_1}^{a_1}\\right)\\cdot\\phi\\left({p_2}^{a_2}\\right)\\ldots\\f] where\n * \\f$p_1\\f$, \\f$p_2\\f$, \\f$\\ldots\\f$ are prime factors of n.\n * <br/>3 Euler's properties:\n * 1. \\f$\\phi(n) = n-1\\f$\n * 2. \\f$\\phi(n^k) = n^k - n^{k-1}\\f$\n * 3. \\f$\\phi(a,b) = \\phi(a)\\cdot\\phi(b)\\f$ where a and b are relative primes.\n *\n * Applying this 3 properties on the first equation.\n * \\f[\\phi(n) =\n * n\\cdot\\left(1-\\frac{1}{p_1}\\right)\\cdot\\left(1-\\frac{1}{p_2}\\right)\\cdots\\f]\n * where \\f$p_1\\f$,\\f$p_2\\f$... are prime factors.\n * Hence Implementation in \\f$O\\left(\\sqrt{n}\\right)\\f$.\n * <br/>Some known values are:\n * * \\f$\\phi(100) = 40\\f$\n * * \\f$\\phi(1) = 1\\f$\n * * \\f$\\phi(17501) = 15120\\f$\n * * \\f$\\phi(1420) = 560\\f$\n */\n#include <cstdlib>\n#include <iostream>\n\n/** Function to caculate Euler's totient phi\n */\nuint64_t phiFunction(uint64_t n) {\n    uint64_t result = n;\n    for (uint64_t i = 2; i * i <= n; i++) {\n        if (n % i == 0) {\n            while (n % i == 0) {\n                n /= i;\n            }\n            result -= result / i;\n        }\n    }\n    if (n > 1)\n        result -= result / n;\n    return result;\n}\n\n/// Main function\nint main(int argc, char *argv[]) {\n    uint64_t n;\n    if (argc < 2) {\n        std::cout << \"Enter the number: \";\n    } else {\n        n = strtoull(argv[1], nullptr, 10);\n    }\n    std::cin >> n;\n    std::cout << phiFunction(n);\n    return 0;\n}\n","index":113},{"title":"Extended Euclid Algorithm","category":"math","id":"extended_euclid_algorithm_math","algorithm":"/**\n * @file\n * @brief GCD using [extended Euclid's algorithm]\n * (https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm)\n *\n * Finding coefficients of a and b ie x and y in  Bézout's identity\n * \\f[\\text{gcd}(a, b) = a \\times x + b \\times y \\f]\n * This is also used in finding Modular\n * multiplicative inverse of a number. (A * B)%M == 1 Here B is the MMI of A for\n * given M, so extendedEuclid (A, M) gives B.\n */\n#include <algorithm>  // for swap function\n#include <iostream>\n\n/**\n * function to update the coefficients per iteration\n * \\f[r_0,\\,r = r,\\, r_0 - \\text{quotient}\\times r\\f]\n *\n * @param[in,out] r signed or unsigned\n * @param[in,out] r0 signed or unsigned\n * @param[in] quotient  unsigned\n */\ntemplate <typename T, typename T2>\ninline void update_step(T *r, T *r0, const T2 quotient) {\n    T temp = *r;\n    *r = *r0 - (quotient * temp);\n    *r0 = temp;\n}\n\n/**\n * Implementation using iterative algorithm from\n * [Wikipedia](https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Pseudocode)\n *\n * @param[in] A unsigned\n * @param[in] B unsigned\n * @param[out] GCD unsigned\n * @param[out] x signed\n * @param[out] y signed\n */\ntemplate <typename T1, typename T2>\nvoid extendedEuclid_1(T1 A, T1 B, T1 *GCD, T2 *x, T2 *y) {\n    if (B > A)\n        std::swap(A, B);  // Ensure that A >= B\n\n    T2 s = 0, s0 = 1;\n    T2 t = 1, t0 = 0;\n    T1 r = B, r0 = A;\n\n    while (r != 0) {\n        T1 quotient = r0 / r;\n        update_step(&r, &r0, quotient);\n        update_step(&s, &s0, quotient);\n        update_step(&t, &t0, quotient);\n    }\n    *GCD = r0;\n    *x = s0;\n    *y = t0;\n}\n\n/**\n * Implementation using recursive algorithm\n *\n * @param[in] A unsigned\n * @param[in] B unsigned\n * @param[out] GCD unsigned\n * @param[in,out] x signed\n * @param[in,out] y signed\n */\ntemplate <typename T, typename T2>\nvoid extendedEuclid(T A, T B, T *GCD, T2 *x, T2 *y) {\n    if (B > A)\n        std::swap(A, B);  // Ensure that A >= B\n\n    if (B == 0) {\n        *GCD = A;\n        *x = 1;\n        *y = 0;\n    } else {\n        extendedEuclid(B, A % B, GCD, x, y);\n        T2 temp = *x;\n        *x = *y;\n        *y = temp - (A / B) * (*y);\n    }\n}\n\n/// Main function\nint main() {\n    uint32_t a, b, gcd;\n    int32_t x, y;\n    std::cin >> a >> b;\n    extendedEuclid(a, b, &gcd, &x, &y);\n    std::cout << gcd << \" \" << x << \" \" << y << std::endl;\n    extendedEuclid_1(a, b, &gcd, &x, &y);\n    std::cout << gcd << \" \" << x << \" \" << y << std::endl;\n    return 0;\n}\n","index":114},{"title":"Factorial","category":"math","id":"factorial_math","algorithm":"/**\n * @file\n * @brief C++ program to find factorial of given number\n */\n#include <iostream>\n\n/** function to find factorial of given number */\nunsigned int factorial(unsigned int n) {\n    if (n == 0)\n        return 1;\n    return n * factorial(n - 1);\n}\n\n/** Main function */\nint main() {\n    int num = 5;\n    std::cout << \"Factorial of \" << num << \" is \" << factorial(num)\n              << std::endl;\n    return 0;\n}\n","index":115},{"title":"Fast Power","category":"math","id":"fast_power_math","algorithm":"/**\n * @file\n * @brief Faster computation for \\f$a^b\\f$\n *\n * Program that computes \\f$a^b\\f$ in \\f$O(logN)\\f$ time.\n * It is based on formula that:\n * 1. if \\f$b\\f$ is even:\n *  \\f$a^b = a^\\frac{b}{2} \\cdot a^\\frac{b}{2} = {a^\\frac{b}{2}}^2\\f$\n * 2. if \\f$b\\f$ is odd: \\f$a^b = a^\\frac{b-1}{2}\n *  \\cdot a^\\frac{b-1}{2} \\cdot a = {a^\\frac{b-1}{2}}^2 \\cdot a\\f$\n *\n * We can compute \\f$a^b\\f$ recursively using above algorithm.\n */\n\n#include <cassert>\n#include <cmath>\n#include <cstdint>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n\n/**\n * algorithm implementation for \\f$a^b\\f$\n */\ntemplate <typename T>\ndouble fast_power_recursive(T a, T b) {\n    // negative power. a^b = 1 / (a^-b)\n    if (b < 0)\n        return 1.0 / fast_power_recursive(a, -b);\n\n    if (b == 0)\n        return 1;\n    T bottom = fast_power_recursive(a, b >> 1);\n    // Since it is integer division b/2 = (b-1)/2 where b is odd.\n    // Therefore, case2 is easily solved by integer division.\n\n    double result;\n    if ((b & 1) == 0)  // case1\n        result = bottom * bottom;\n    else  // case2\n        result = bottom * bottom * a;\n    return result;\n}\n\n/**\n    Same algorithm with little different formula.\n    It still calculates in \\f$O(\\log N)\\f$\n*/\ntemplate <typename T>\ndouble fast_power_linear(T a, T b) {\n    // negative power. a^b = 1 / (a^-b)\n    if (b < 0)\n        return 1.0 / fast_power_linear(a, -b);\n\n    double result = 1;\n    while (b) {\n        if (b & 1)\n            result = result * a;\n        a = a * a;\n        b = b >> 1;\n    }\n    return result;\n}\n\n/**\n * Main function\n */\nint main() {\n    std::srand(std::time(nullptr));\n    std::ios_base::sync_with_stdio(false);\n\n    std::cout << \"Testing...\" << std::endl;\n    for (int i = 0; i < 20; i++) {\n        int a = std::rand() % 20 - 10;\n        int b = std::rand() % 20 - 10;\n        std::cout << std::endl << \"Calculating \" << a << \"^\" << b << std::endl;\n        assert(fast_power_recursive(a, b) == std::pow(a, b));\n        assert(fast_power_linear(a, b) == std::pow(a, b));\n\n        std::cout << \"------ \" << a << \"^\" << b << \" = \"\n                  << fast_power_recursive(a, b) << std::endl;\n    }\n\n    int64_t a, b;\n    std::cin >> a >> b;\n\n    std::cout << a << \"^\" << b << \" = \" << fast_power_recursive(a, b)\n              << std::endl;\n\n    std::cout << a << \"^\" << b << \" = \" << fast_power_linear(a, b) << std::endl;\n\n    return 0;\n}\n","index":116},{"title":"Fibonacci","category":"math","id":"fibonacci_math","algorithm":"/**\n * @file\n * @brief Generate fibonacci sequence\n *\n * Calculate the the value on Fibonacci's sequence given an\n * integer as input.\n * \\f[\\text{fib}(n) = \\text{fib}(n-1) + \\text{fib}(n-2)\\f]\n *\n * @see fibonacci_large.cpp, fibonacci_fast.cpp, string_fibonacci.cpp\n */\n#include <cassert>\n#include <iostream>\n\n/**\n * Recursively compute sequences\n * @param n input\n * @returns n-th element of the Fbinacci's sequence\n */\nuint64_t fibonacci(uint64_t n) {\n    /* If the input is 0 or 1 just return the same\n       This will set the first 2 values of the sequence */\n    if (n <= 1) {\n        return n;\n    }\n\n    /* Add the last 2 values of the sequence to get next */\n    return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\n/**\n * Function for testing the fibonacci() function with a few\n * test cases and assert statement.\n * @returns `void`\n*/\nstatic void test() {\n    uint64_t test_case_1 = fibonacci(0);\n    assert(test_case_1 == 0);\n    std::cout << \"Passed Test 1!\" << std::endl;\n\n    uint64_t test_case_2 = fibonacci(1);\n    assert(test_case_2 == 1);\n    std::cout << \"Passed Test 2!\" << std::endl;\n\n    uint64_t test_case_3 = fibonacci(2);\n    assert(test_case_3 == 1);\n    std::cout << \"Passed Test 3!\" << std::endl;\n\n    uint64_t test_case_4 = fibonacci(3);\n    assert(test_case_4 == 2);\n    std::cout << \"Passed Test 4!\" << std::endl;\n\n    uint64_t test_case_5 = fibonacci(4);\n    assert(test_case_5 == 3);\n    std::cout << \"Passed Test 5!\" << std::endl;\n\n    uint64_t test_case_6 = fibonacci(15);\n    assert(test_case_6 == 610);\n    std::cout << \"Passed Test 6!\" << std::endl << std::endl;\n}\n\n/// Main function\nint main() {\n    test();\n    int n = 0;\n    std::cin >> n;\n    assert(n >= 0);\n    std::cout << \"F(\" << n << \")= \" << fibonacci(n) << std::endl;\n}\n","index":117},{"title":"Fibonacci Fast","category":"math","id":"fibonacci_fast_math","algorithm":"/**\n * @file\n * @brief Faster computation of Fibonacci series\n *\n * An efficient way to calculate nth fibonacci number faster and simpler than\n * \\f$O(n\\log n)\\f$ method of matrix exponentiation This works by using both\n * recursion and dynamic programming. as 93rd fibonacci exceeds 19 digits, which\n * cannot be stored in a single long long variable, we can only use it till 92nd\n * fibonacci we can use it for 10000th fibonacci etc, if we implement\n * bigintegers. This algorithm works with the fact that nth fibonacci can easily\n * found if we have already found n/2th or (n+1)/2th fibonacci It is a property\n * of fibonacci similar to matrix exponentiation.\n *\n * \\author [Krishna Vedala](https://github.com/kvedala)\n * @see fibonacci_large.cpp, fibonacci.cpp, string_fibonacci.cpp\n */\n\n#include <cinttypes>\n#include <cstdio>\n#include <iostream>\n\n/**\n * maximum number that can be computed - The result after 93 cannot be stored\n * in a `uint64_t` data type.\n */\n\n#define MAX 93\n\n/** Algorithm */\nuint64_t fib(uint64_t n) {\n    static uint64_t f1 = 1,\n                    f2 = 1;  // using static keyword will retain the values of\n                             // f1 and f2 for the next function call.\n\n    if (n <= 2)\n        return f2;\n    if (n >= 93) {\n        std::cerr\n            << \"Cannot compute for n>93 due to limit of 64-bit integers\\n\";\n        return 0;\n    }\n\n    uint64_t temp = f2;  // we do not need temp to be static\n    f2 += f1;\n    f1 = temp;\n\n    return f2;\n}\n\n/** Main function */\nint main() {\n    // Main Function\n    for (uint64_t i = 1; i < 93; i++) {\n        std::cout << i << \" th fibonacci number is \" << fib(i) << std::endl;\n    }\n    return 0;\n}\n","index":118},{"title":"Fibonacci Large","category":"math","id":"fibonacci_large_math","algorithm":"/**\n * @file\n * @brief Computes N^th Fibonacci number given as\n * input argument. Uses custom build arbitrary integers library\n * to perform additions and other operations.\n *\n * Took 0.608246 seconds to compute 50,000^th Fibonacci\n * number that contains 10450 digits!\n *\n * \\author [Krishna Vedala](https://github.com/kvedala)\n * @see fibonacci.cpp, fibonacci_fast.cpp, string_fibonacci.cpp\n */\n\n#include <cinttypes>\n#include <ctime>\n#include <iostream>\n\n#include \"./large_number.h\"\n\n/** Compute fibonacci numbers using the relation\n * \\f[f(n)=f(n-1)+f(n-2)\\f]\n * and returns the result as a large_number type.\n */\nlarge_number fib(uint64_t n) {\n    large_number f0(1);\n    large_number f1(1);\n\n    do {\n        large_number f2 = f1;\n        f1 += f0;\n        f0 = f2;\n        n--;\n    } while (n > 2);  // since we start from 2\n\n    return f1;\n}\n\nint main(int argc, char *argv[]) {\n    uint64_t N;\n    if (argc == 2) {\n        N = strtoull(argv[1], NULL, 10);\n    } else {\n        std::cout << \"Enter N: \";\n        std::cin >> N;\n    }\n\n    clock_t start_time = std::clock();\n    large_number result = fib(N);\n    clock_t end_time = std::clock();\n    double time_taken = static_cast<double>(end_time - start_time) /\n                        static_cast<double>(CLOCKS_PER_SEC);\n\n    std::cout << std::endl\n              << N << \"^th Fibonacci number: \" << result << std::endl\n              << \"Number of digits: \" << result.num_digits() << std::endl\n              << \"Time taken: \" << std::scientific << time_taken << \" s\"\n              << std::endl;\n\n    N = 5000;\n    if (fib(N) ==\n        large_number(\n            \"387896845438832563370191630832590531208212771464624510616059721489\"\n            \"555013904403709701082291646221066947929345285888297381348310200895\"\n            \"498294036143015691147893836421656394410691021450563413370655865623\"\n            \"825465670071252592990385493381392883637834751890876297071203333705\"\n            \"292310769300851809384980180384781399674888176555465378829164426891\"\n            \"298038461377896902150229308247566634622492307188332480328037503913\"\n            \"035290330450584270114763524227021093463769910400671417488329842289\"\n            \"149127310405432875329804427367682297724498774987455569190770388063\"\n            \"704683279481135897373999311010621930814901857081539785437919530561\"\n            \"751076105307568878376603366735544525884488624161921055345749367589\"\n            \"784902798823435102359984466393485325641195222185956306047536464547\"\n            \"076033090242080638258492915645287629157575914234380914230291749108\"\n            \"898415520985443248659407979357131684169286803954530954538869811466\"\n            \"508206686289742063932343848846524098874239587380197699382031717420\"\n            \"893226546887936400263079778005875912967138963421425257911687275560\"\n            \"0360311370547754724604639987588046985178408674382863125\"))\n        std::cout << \"Test for \" << N << \"^th Fibonacci number passed!\"\n                  << std::endl;\n    else\n        std::cerr << \"Test for \" << N << \"^th Fibonacci number failed!\"\n                  << std::endl;\n\n    return 0;\n}\n","index":119},{"title":"Gcd Iterative Euclidean","category":"math","id":"gcd_iterative_euclidean_math","algorithm":"/**\n * @file\n * @brief Compute the greatest common denominator of two integers using\n * *iterative form* of\n * [Euclidean algorithm](https://en.wikipedia.org/wiki/Euclidean_algorithm)\n *\n * @see gcd_recursive_euclidean.cpp, gcd_of_n_numbers.cpp\n */\n#include <iostream>\n#include <stdexcept>\n\n/**\n * algorithm\n */\nint gcd(int num1, int num2) {\n    if (num1 <= 0 | num2 <= 0) {\n        throw std::domain_error(\"Euclidean algorithm domain is for ints > 0\");\n    }\n\n    if (num1 == num2) {\n        return num1;\n    }\n\n    int base_num = 0;\n    int previous_remainder = 1;\n\n    if (num1 > num2) {\n        base_num = num1;\n        previous_remainder = num2;\n    } else {\n        base_num = num2;\n        previous_remainder = num1;\n    }\n\n    while ((base_num % previous_remainder) != 0) {\n        int old_base = base_num;\n        base_num = previous_remainder;\n        previous_remainder = old_base % previous_remainder;\n    }\n\n    return previous_remainder;\n}\n\n/**\n * Main function\n */\nint main() {\n    std::cout << \"gcd of 120,7 is \" << (gcd(120, 7)) << std::endl;\n    try {\n        std::cout << \"gcd of -120,10 is \" << gcd(-120, 10) << std::endl;\n    } catch (const std::domain_error &e) {\n        std::cout << \"Error handling was successful\" << std::endl;\n    }\n    std::cout << \"gcd of 312,221 is \" << (gcd(312, 221)) << std::endl;\n    std::cout << \"gcd of 289,204 is \" << (gcd(289, 204)) << std::endl;\n\n    return 0;\n}\n","index":120},{"title":"Gcd Of N Numbers","category":"math","id":"gcd_of_n_numbers_math","algorithm":"/**\n * @file\n * @brief This program aims at calculating the GCD of n numbers by division\n * method\n *\n * @see gcd_iterative_euclidean.cpp, gcd_recursive_euclidean.cpp\n */\n#include <iostream>\n\n/** Compute GCD using division algorithm\n *\n * @param[in] a array of integers to compute GCD for\n * @param[in] n number of integers in array `a`\n */\nint gcd(int *a, int n) {\n    int j = 1;  // to access all elements of the array starting from 1\n    int gcd = a[0];\n    while (j < n) {\n        if (a[j] % gcd == 0)  // value of gcd is as needed so far\n            j++;              // so we check for next element\n        else\n            gcd = a[j] % gcd;  // calculating GCD by division method\n    }\n    return gcd;\n}\n\n/** Main function */\nint main() {\n    int n;\n    std::cout << \"Enter value of n:\" << std::endl;\n    std::cin >> n;\n    int *a = new int[n];\n    int i;\n    std::cout << \"Enter the n numbers:\" << std::endl;\n    for (i = 0; i < n; i++) std::cin >> a[i];\n\n    std::cout << \"GCD of entered n numbers:\" << gcd(a, n) << std::endl;\n\n    delete[] a;\n    return 0;\n}\n","index":121},{"title":"Gcd Recursive Euclidean","category":"math","id":"gcd_recursive_euclidean_math","algorithm":"/**\n * @file\n * @brief Compute the greatest common denominator of two integers using\n * *recursive form* of\n * [Euclidean algorithm](https://en.wikipedia.org/wiki/Euclidean_algorithm)\n *\n * @see gcd_iterative_euclidean.cpp, gcd_of_n_numbers.cpp\n */\n#include <iostream>\n\n/**\n * algorithm\n */\nint gcd(int num1, int num2) {\n    if (num1 <= 0 | num2 <= 0) {\n        throw std::domain_error(\"Euclidean algorithm domain is for ints > 0\");\n    }\n\n    if (num1 == num2) {\n        return num1;\n    }\n\n    // Everything divides 0\n    if (num1 == 0)\n        return num2;\n    if (num2 == 0)\n        return num1;\n\n    // base case\n    if (num1 == num2)\n        return num1;\n\n    // a is greater\n    if (num1 > num2)\n        return gcd(num1 - num2, num2);\n    return gcd(num1, num2 - num1);\n}\n\n/**\n * Main function\n */\nint main() {\n    std::cout << \"gcd of 120,7 is \" << (gcd(120, 7)) << std::endl;\n    try {\n        std::cout << \"gcd of -120,10 is \" << gcd(-120, 10) << std::endl;\n    } catch (const std::domain_error &e) {\n        std::cout << \"Error handling was successful\" << std::endl;\n    }\n    std::cout << \"gcd of 312,221 is \" << (gcd(312, 221)) << std::endl;\n    std::cout << \"gcd of 289,204 is \" << (gcd(289, 204)) << std::endl;\n    return 0;\n}\n","index":122},{"title":"Large Factorial","category":"math","id":"large_factorial_math","algorithm":"/**\n * @file\n * @brief Compute factorial of any arbitratily large number/\n *\n * \\author [Krishna Vedala](https://github.com/kvedala)\n * @see factorial.cpp\n */\n#include <cstring>\n#include <ctime>\n#include <iostream>\n\n#include \"./large_number.h\"\n\n/** Test implementation for 10! Result must be 3628800.\n * @returns True if test pass else False\n */\nbool test1() {\n    std::cout << \"---- Check 1\\t\";\n    unsigned int i, number = 10;\n    large_number result;\n    for (i = 2; i <= number; i++) /* Multiply every number from 2 thru N */\n        result *= i;\n\n    const char *known_reslt = \"3628800\";\n\n    /* check 1 */\n    if (strlen(known_reslt) != result.num_digits()) {\n        std::cerr << \"Result lengths dont match! \" << strlen(known_reslt)\n                  << \" != \" << result.num_digits() << std::endl;\n        return false;\n    }\n\n    const size_t N = result.num_digits();\n    for (i = 0; i < N; i++) {\n        if (known_reslt[i] != result.digit_char(i)) {\n            std::cerr << i << \"^th digit mismatch! \" << known_reslt[i]\n                      << \" != \" << result.digit_char(i) << std::endl;\n            return false;\n        }\n    }\n\n    std::cout << \"Passed!\" << std::endl;\n    return true;\n}\n\n/** Test implementation for 100! The result is the 156 digit number:\n * ```\n * 9332621544394415268169923885626670049071596826438162146859296389521759\n * 9993229915608941463976156518286253697920827223758251185210916864000000\n * 000000000000000000\n * ```\n * @returns True if test pass else False\n */\nbool test2() {\n    std::cout << \"---- Check 2\\t\";\n    unsigned int i, number = 100;\n    large_number result;\n    for (i = 2; i <= number; i++) /* Multiply every number from 2 thru N */\n        result *= i;\n\n    const char *known_reslt =\n        \"9332621544394415268169923885626670049071596826438162146859296389521759\"\n        \"9993229915608941463976156518286253697920827223758251185210916864000000\"\n        \"000000000000000000\";\n\n    /* check 1 */\n    if (strlen(known_reslt) != result.num_digits()) {\n        std::cerr << \"Result lengths dont match! \" << strlen(known_reslt)\n                  << \" != \" << result.num_digits() << std::endl;\n        return false;\n    }\n\n    const size_t N = result.num_digits();\n    for (i = 0; i < N; i++) {\n        if (known_reslt[i] != result.digit_char(i)) {\n            std::cerr << i << \"^th digit mismatch! \" << known_reslt[i]\n                      << \" != \" << result.digit_char(i) << std::endl;\n            return false;\n        }\n    }\n\n    std::cout << \"Passed!\" << std::endl;\n    return true;\n}\n\n/**\n * Main program\n **/\nint main(int argc, char *argv[]) {\n    int number, i;\n\n    if (argc == 2) {\n        number = atoi(argv[1]);\n    } else {\n        std::cout << \"Enter the value of n(n starts from 0 ): \";\n        std::cin >> number;\n    }\n\n    large_number result;\n\n    std::clock_t start_time = std::clock();\n    for (i = 2; i <= number; i++) /* Multiply every number from 2 thru N */\n        result *= i;\n    std::clock_t end_time = std::clock();\n    double time_taken =\n        static_cast<double>(end_time - start_time) / CLOCKS_PER_SEC;\n\n    std::cout << number << \"! = \" << result << std::endl\n              << \"Number of digits: \" << result.num_digits() << std::endl\n              << \"Time taken: \" << std::scientific << time_taken << \" s\"\n              << std::endl;\n\n    test1();\n    test2();\n    result.test();\n\n    return 0;\n}\n","index":123},{"title":"Large Number.h","category":"math","id":"large_number.h_math","algorithm":"/**\n * @file\n * @brief Library to perform arithmatic operations on arbitrarily large\n * numbers.\n * \\author [Krishna Vedala](https://github.com/kvedala)\n */\n\n#ifndef MATH_LARGE_NUMBER_H_\n#define MATH_LARGE_NUMBER_H_\n#include <algorithm>\n#include <cassert>\n#include <cinttypes>\n#include <cstring>\n#include <iostream>\n#include <type_traits>\n#include <vector>\n\n/**\n * Store large unsigned numbers as a C++ vector\n * The class provides convenience functions to add a\n * digit to the number, perform multiplication of\n * large number with long unsigned integers.\n **/\nclass large_number {\n public:\n    /**< initializer with value = 1 */\n    large_number() { _digits.push_back(1); }\n\n    // /**< initializer from an integer */\n    // explicit large_number(uint64_t n) {\n    //     uint64_t carry = n;\n    //     do {\n    //         add_digit(carry % 10);\n    //         carry /= 10;\n    //     } while (carry != 0);\n    // }\n\n    /**< initializer from an integer */\n    explicit large_number(int n) {\n        int carry = n;\n        do {\n            add_digit(carry % 10);\n            carry /= 10;\n        } while (carry != 0);\n    }\n\n    /**< initializer from another large_number */\n    large_number(const large_number &a) : _digits(a._digits) {}\n\n    /**< initializer from a vector */\n    explicit large_number(std::vector<unsigned char> &vec) : _digits(vec) {}\n\n    /**< initializer from a string */\n    explicit large_number(char const *number_str) {\n        for (size_t i = strlen(number_str); i > 0; i--) {\n            char a = number_str[i - 1] - '0';\n            if (a >= 0 && a <= 9)\n                _digits.push_back(a);\n        }\n    }\n\n    /**\n     * Function to check implementation\n     **/\n    static bool test() {\n        std::cout << \"------ Checking `large_number` class implementations\\t\"\n                  << std::endl;\n        large_number a(40);\n        // 1. test multiplication\n        a *= 10;\n        if (a != large_number(400)) {\n            std::cerr << \"\\tFailed 1/6 (\" << a << \"!=400)\" << std::endl;\n            return false;\n        }\n        std::cout << \"\\tPassed 1/6...\";\n        // 2. test compound addition with integer\n        a += 120;\n        if (a != large_number(520)) {\n            std::cerr << \"\\tFailed 2/6 (\" << a << \"!=520)\" << std::endl;\n            return false;\n        }\n        std::cout << \"\\tPassed 2/6...\";\n        // 3. test compound multiplication again\n        a *= 10;\n        if (a != large_number(5200)) {\n            std::cerr << \"\\tFailed 3/6 (\" << a << \"!=5200)\" << std::endl;\n            return false;\n        }\n        std::cout << \"\\tPassed 3/6...\";\n        // 4. test increment (prefix)\n        ++a;\n        if (a != large_number(5201)) {\n            std::cerr << \"\\tFailed 4/6 (\" << a << \"!=5201)\" << std::endl;\n            return false;\n        }\n        std::cout << \"\\tPassed 4/6...\";\n        // 5. test increment (postfix)\n        a++;\n        if (a != large_number(5202)) {\n            std::cerr << \"\\tFailed 5/6 (\" << a << \"!=5202)\" << std::endl;\n            return false;\n        }\n        std::cout << \"\\tPassed 5/6...\";\n        // 6. test addition with another large number\n        a = a + large_number(\"7000000000000000000000000000000\");\n        if (a != large_number(\"7000000000000000000000000005202\")) {\n            std::cerr << \"\\tFailed 6/6 (\" << a\n                      << \"!=7000000000000000000000000005202)\" << std::endl;\n            return false;\n        }\n        std::cout << \"\\tPassed 6/6...\" << std::endl;\n        return true;\n    }\n\n    /**\n     * add a digit at MSB to the large number\n     **/\n    void add_digit(unsigned int value) {\n        if (value > 9) {\n            std::cerr << \"digit > 9!!\\n\";\n            exit(EXIT_FAILURE);\n        }\n\n        _digits.push_back(value);\n    }\n\n    /**\n     * Get number of digits in the number\n     **/\n    size_t num_digits() const { return _digits.size(); }\n\n    /**\n     * operator over load to access the\n     * i^th digit conveniently and also\n     * assign value to it\n     **/\n    inline unsigned char &operator[](size_t n) { return this->_digits[n]; }\n\n    inline const unsigned char &operator[](size_t n) const {\n        return this->_digits[n];\n    }\n\n    /**\n     * operator overload to compare two numbers\n     **/\n    friend std::ostream &operator<<(std::ostream &out, const large_number &a) {\n        for (size_t i = a.num_digits(); i > 0; i--)\n            out << static_cast<int>(a[i - 1]);\n        return out;\n    }\n\n    /**\n     * operator overload to compare two numbers\n     **/\n    friend bool operator==(large_number const &a, large_number const &b) {\n        size_t N = a.num_digits();\n        if (N != b.num_digits())\n            return false;\n        for (size_t i = 0; i < N; i++)\n            if (a[i] != b[i])\n                return false;\n        return true;\n    }\n\n    /**\n     * operator overload to compare two numbers\n     **/\n    friend bool operator!=(large_number const &a, large_number const &b) {\n        return !(a == b);\n    }\n\n    /**\n     * operator overload to increment (prefix)\n     **/\n    large_number &operator++() {\n        (*this) += 1;\n        return *this;\n    }\n\n    /**\n     * operator overload to increment (postfix)\n     **/\n    large_number &operator++(int) {\n        static large_number tmp(_digits);\n        ++(*this);\n        return tmp;\n    }\n\n    /**\n     * operator overload to add\n     **/\n    large_number &operator+=(large_number n) {\n        // if adding with another large_number\n        large_number *b = reinterpret_cast<large_number *>(&n);\n        const size_t max_L = std::max(this->num_digits(), b->num_digits());\n        unsigned int carry = 0;\n        size_t i;\n        for (i = 0; i < max_L || carry != 0; i++) {\n            if (i < b->num_digits())\n                carry += (*b)[i];\n            if (i < this->num_digits())\n                carry += (*this)[i];\n            if (i < this->num_digits())\n                (*this)[i] = carry % 10;\n            else\n                this->add_digit(carry % 10);\n            carry /= 10;\n        }\n        return *this;\n    }\n\n    large_number &operator+=(int n) { return (*this) += large_number(n); }\n    // large_number &operator+=(uint64_t n) { return (*this) += large_number(n);\n    // }\n\n    /**\n     * operator overload to perform addition\n     **/\n    template <class T>\n    friend large_number &operator+(const large_number &a, const T &b) {\n        static large_number c = a;\n        c += b;\n        return c;\n    }\n\n    /**\n     * assignment operator\n     **/\n    large_number &operator=(const large_number &b) {\n        this->_digits = b._digits;\n        return *this;\n    }\n\n    /**\n     * operator overload to increment\n     **/\n    template <class T>\n    large_number &operator*=(const T n) {\n        static_assert(std::is_integral<T>::value,\n                      \"Must be integer addition unsigned integer types.\");\n        this->multiply(n);\n        return *this;\n    }\n\n    /**\n     * returns i^th digit as an ASCII character\n     **/\n    char digit_char(size_t i) const {\n        return _digits[num_digits() - i - 1] + '0';\n    }\n\n private:\n    /**\n     * multiply large number with another integer and\n     * store the result in the same large number\n     **/\n    template <class T>\n    void multiply(const T n) {\n        static_assert(std::is_integral<T>::value,\n                      \"Can only have integer types.\");\n        // assert(!(std::is_signed<T>::value)); //, \"Implemented only for\n        // unsigned integer types.\");\n\n        size_t i;\n        uint64_t carry = 0, temp;\n        for (i = 0; i < this->num_digits(); i++) {\n            temp = static_cast<uint64_t>((*this)[i]) * n;\n            temp += carry;\n            if (temp < 10) {\n                carry = 0;\n            } else {\n                carry = temp / 10;\n                temp = temp % 10;\n            }\n            (*this)[i] = temp;\n        }\n\n        while (carry != 0) {\n            this->add_digit(carry % 10);\n            carry /= 10;\n        }\n    }\n\n    std::vector<unsigned char>\n        _digits; /**< where individual digits are stored */\n};\n\n#endif  // MATH_LARGE_NUMBER_H_\n","index":124},{"title":"Least Common Multiple","category":"math","id":"least_common_multiple_math","algorithm":"/**\n * Copyright 2020 @author tjgurwara99\n * @file\n *\n * A basic implementation of LCM function\n */\n\n#include <cassert>\n#include <iostream>\n\n/**\n * Function for finding greatest common divisor of two numbers.\n * @params two integers x and y whose gcd we want to find.\n * @return greatest common divisor of x and y.\n */\nunsigned int gcd(unsigned int x, unsigned int y) {\n    if (x == 0) {\n        return y;\n    }\n    if (y == 0) {\n        return x;\n    }\n    if (x == y) {\n        return x;\n    }\n    if (x > y) {\n        // The following is valid because we have checked whether y == 0\n\n        unsigned int temp = x / y;\n        return gcd(y, x - temp * y);\n    }\n    // Again the following is valid because we have checked whether x == 0\n\n    unsigned int temp = y / x;\n    return gcd(x, y - temp * x);\n}\n\n/**\n * Function for finding the least common multiple of two numbers.\n * @params integer x and y whose lcm we want to find.\n * @return lcm of x and y using the relation x * y = gcd(x, y) * lcm(x, y)\n */\nunsigned int lcm(unsigned int x, unsigned int y) {\n  return x / gcd(x, y) * y;\n}\n\n/**\n * Function for testing the lcm() functions with some assert statements.\n */\nvoid tests() {\n    // First test on lcm(5,10) == 10\n    assert(((void)\"LCM of 5 and 10 is 10 but lcm function gives a different \"\n                  \"result.\\n\",\n            lcm(5, 10) == 10));\n    std::cout << \"First assertion passes: LCM of 5 and 10 is \" << lcm(5, 10)\n              << std::endl;\n\n    // Second test on lcm(2,3) == 6 as 2 and 3 are coprime (prime in fact)\n    assert(((void)\"LCM of 2 and 3 is 6 but lcm function gives a different \"\n                  \"result.\\n\",\n            lcm(2, 3) == 6));\n    std::cout << \"Second assertion passes: LCM of 2 and 3 is \" << lcm(2, 3)\n              << std::endl;\n\n    // Testing an integer overflow.\n    // The algorithm should work as long as the result fits into integer.\n    assert(((void)\"LCM of 987654321 and 987654321 is 987654321 but lcm function\"\n                  \" gives a different result.\\n\",\n            lcm(987654321, 987654321) == 987654321));\n    std::cout << \"Third assertion passes: LCM of 987654321 and 987654321 is \"\n              << lcm(987654321, 987654321)\n              << std::endl;\n}\n\n/**\n * Main function\n */\nint main() {\n    tests();\n    return 0;\n}\n","index":125},{"title":"Miller Rabin","category":"math","id":"miller_rabin_math","algorithm":"/**\n * Copyright 2020 @author tjgurwara99\n * @file\n *\n * A basic implementation of Miller-Rabin primality test.\n */\n\n#include <cassert>\n#include <iostream>\n#include <random>\n#include <vector>\n\n/**\n * Function to give a binary representation of a number in reverse order\n * @param num integer number that we want to convert\n * @return result vector of the number input in reverse binary\n */\ntemplate <typename T>\nstd::vector<T> reverse_binary(T num) {\n    std::vector<T> result;\n    T temp = num;\n    while (temp > 0) {\n        result.push_back(temp % 2);\n        temp = temp / 2;\n    }\n    return result;\n}\n\n/**\n * Function for modular exponentiation.\n * This function is an efficient modular exponentiation function.\n * It can be used with any big integer library such as Boost multiprecision\n * to give result any modular exponentiation problem relatively quickly.\n * @param base number being raised to a power as integer\n * @param rev_binary_exponent reverse binary of the power the base is being\n * raised to\n * @param mod modulo\n * @return r the modular exponentiation of \\f$a^{n} \\equiv r \\mod{m}\\f$ where\n * \\f$n\\f$ is the base 10 representation of rev_binary_exponent and \\f$m = mod\n * \\f$ parameter.\n */\ntemplate <typename T>\nT modular_exponentiation(T base, const std::vector<T> &rev_binary_exponent,\n                         T mod) {\n    if (mod == 1)\n        return 0;\n    T b = 1;\n    if (rev_binary_exponent.size() == 0)\n        return b;\n    T A = base;\n    if (rev_binary_exponent[0] == 1)\n        b = base;\n\n    for (typename std::vector<T>::const_iterator it =\n             rev_binary_exponent.cbegin() + 1;\n         it != rev_binary_exponent.cend(); ++it) {\n        A = A * A % mod;\n        if (*it == 1)\n            b = A * b % mod;\n    }\n    return b;\n}\n\n/** Function for testing the conditions that are satisfied when a number is\n * prime.\n * \t@param d number such that \\f$d \\cdot 2^r = n - 1\\f$ where \\f$n = num\\f$\n * parameter and \\f$r \\geq 1\\f$\n * \t@param num number being tested for primality.\n * \t@return 'false' if n is composite\n * \t@return 'true' if n is (probably) prime.\n */\ntemplate <typename T>\nbool miller_test(T d, T num) {\n    // random number seed\n    std::random_device rd_seed;\n    // random number generator\n    std::mt19937 gen(rd_seed());\n    // Uniformly distributed range [2, num - 2] for random numbers\n    std::uniform_int_distribution<> distribution(2, num - 2);\n    // Random number generated in the range [2, num -2].\n    T random = distribution(gen);\n    // vector for reverse binary of the power\n    std::vector<T> power = reverse_binary(d);\n    // x = random ^ d % num\n    T x = modular_exponentiation(random, power, num);\n    // miller conditions\n    if (x == 1 || x == num - 1) {\n        return true;\n    }\n\n    while (d != num - 1) {\n        x = (x * x) % num;\n        d *= 2;\n        if (x == 1) {\n            return false;\n        }\n        if (x == num - 1) {\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * Function that test (probabilistically) whether a given number is a prime\n * based on the Miller-Rabin Primality Test.\n * @param num number to be tested for primality.\n * @param repeats number of repetitions for the test to increase probability of\n * correct result.\n * @return 'false' if num is composite\n * @return 'true' if num is (probably) prime\n *\n * \\detail\n * First we check whether the num input is less than 4, if so we can determine\n * whether this is a prime or composite by checking for 2 and 3.\n * Next we check whether this num is odd (as all primes greater than 2 are odd).\n * Next we write our num in the following format \\f$num = 2^r \\cdot d + 1\\f$.\n * After finding r and d for our input num, we use for loop repeat number of\n * times inside which we check the miller conditions using the function\n * miller_test. If miller_test returns false then the number is composite After\n * the loop finishes completely without issuing a false return call, we can\n * conclude that this number is probably prime.\n */\ntemplate <typename T>\nbool miller_rabin_primality_test(T num, T repeats) {\n    if (num <= 4) {\n        // If num == 2 or num == 3 then prime\n        if (num == 2 || num == 3) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    // If num is even then not prime\n    if (num % 2 == 0) {\n        return false;\n    }\n    // Finding d and r in num = 2^r * d + 1\n    T d = num - 1, r = 0;\n    while (d % 2 == 0) {\n        d = d / 2;\n        r++;\n    }\n\n    for (T i = 0; i < repeats; ++i) {\n        if (!miller_test(d, num)) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n * Functions for testing the miller_rabin_primality_test() function with some\n * assert statements.\n */\nvoid tests() {\n    // First test on 2\n    assert(((void)\"2 is prime but function says otherwise.\\n\",\n            miller_rabin_primality_test(2, 1) == true));\n    std::cout << \"First test passes.\" << std::endl;\n    // Second test on 5\n    assert(((void)\"5 should be prime but the function says otherwise.\\n\",\n            miller_rabin_primality_test(5, 3) == true));\n    std::cout << \"Second test passes.\" << std::endl;\n    // Third test on 23\n    assert(((void)\"23 should be prime but the function says otherwise.\\n\",\n            miller_rabin_primality_test(23, 3) == true));\n    std::cout << \"Third test passes.\" << std::endl;\n    // Fourth test on 16\n    assert(((void)\"16 is not a prime but the function says otherwise.\\n\",\n            miller_rabin_primality_test(16, 3) == false));\n    std::cout << \"Fourth test passes.\" << std::endl;\n    // Fifth test on 27\n    assert(((void)\"27 is not a prime but the function says otherwise.\\n\",\n            miller_rabin_primality_test(27, 3) == false));\n    std::cout << \"Fifth test passes.\" << std::endl;\n}\n\n/**\n * Main function\n */\nint main() {\n    tests();\n    return 0;\n}\n","index":126},{"title":"Modular Inverse Fermat Little Theorem","category":"math","id":"modular_inverse_fermat_little_theorem_math","algorithm":"/**\n * @file\n * @brief C++ Program to find the modular inverse using [Fermat's Little\n * Theorem](https://en.wikipedia.org/wiki/Fermat%27s_little_theorem)\n *\n * Fermat's Little Theorem state that \\f[ϕ(m) = m-1\\f]\n * where \\f$m\\f$ is a prime number.\n * \\f{eqnarray*}{\n *  a \\cdot x &≡& 1 \\;\\text{mod}\\; m\\\\\n *  x &≡& a^{-1} \\;\\text{mod}\\; m\n * \\f}\n * Using Euler's theorem we can modify the equation.\n *\\f[\n * a^{ϕ(m)} ≡ 1 \\;\\text{mod}\\; m\n * \\f]\n * (Where '^' denotes the exponent operator)\n *\n * Here 'ϕ' is Euler's Totient Function. For modular inverse existence 'a' and\n * 'm' must be relatively primes numbers. To apply Fermat's Little Theorem is\n * necessary that 'm' must be a prime number. Generally in many competitive\n * programming competitions 'm' is either 1000000007 (1e9+7) or 998244353.\n *\n * We considered m as large prime (1e9+7).\n * \\f$a^{ϕ(m)} ≡ 1 \\;\\text{mod}\\; m\\f$ (Using Euler's Theorem)\n * \\f$ϕ(m) = m-1\\f$ using Fermat's Little Theorem.\n * \\f$a^{m-1} ≡ 1 \\;\\text{mod}\\; m\\f$\n * Now multiplying both side by \\f$a^{-1}\\f$.\n * \\f{eqnarray*}{\n * a^{m-1} \\cdot a^{-1} &≡& a^{-1} \\;\\text{mod}\\; m\\\\\n * a^{m-2} &≡&  a^{-1} \\;\\text{mod}\\; m\n * \\f}\n *\n * We will find the exponent using binary exponentiation. Such that the\n * algorithm works in \\f$O(\\log m)\\f$ time.\n *\n * Examples: -\n * * a = 3 and m = 7\n * * \\f$a^{-1} \\;\\text{mod}\\; m\\f$ is equivalent to\n * \\f$a^{m-2} \\;\\text{mod}\\; m\\f$\n * * \\f$3^5 \\;\\text{mod}\\; 7 = 243 \\;\\text{mod}\\; 7 = 5\\f$\n * <br/>Hence, \\f$3^{-1} \\;\\text{mod}\\; 7 = 5\\f$\n * or \\f$3 \\times 5  \\;\\text{mod}\\; 7 = 1 \\;\\text{mod}\\; 7\\f$\n * (as \\f$a\\times a^{-1} = 1\\f$)\n */\n\n#include <iostream>\n#include <vector>\n\n/** Recursive function to calculate exponent in \\f$O(\\log n)\\f$ using binary\n * exponent.\n */\nint64_t binExpo(int64_t a, int64_t b, int64_t m) {\n    a %= m;\n    int64_t res = 1;\n    while (b > 0) {\n        if (b % 2) {\n            res = res * a % m;\n        }\n        a = a * a % m;\n        // Dividing b by 2 is similar to right shift.\n        b >>= 1;\n    }\n    return res;\n}\n\n/** Prime check in \\f$O(\\sqrt{m})\\f$ time.\n */\nbool isPrime(int64_t m) {\n    if (m <= 1) {\n        return false;\n    } else {\n        for (int64_t i = 2; i * i <= m; i++) {\n            if (m % i == 0) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\n/**\n * Main function\n */\nint main() {\n    int64_t a, m;\n    // Take input of  a and m.\n    std::cout << \"Computing ((a^(-1))%(m)) using Fermat's Little Theorem\";\n    std::cout << std::endl << std::endl;\n    std::cout << \"Give input 'a' and 'm' space separated : \";\n    std::cin >> a >> m;\n    if (isPrime(m)) {\n        std::cout << \"The modular inverse of a with mod m is (a^(m-2)) : \";\n        std::cout << binExpo(a, m - 2, m) << std::endl;\n    } else {\n        std::cout << \"m must be a prime number.\";\n        std::cout << std::endl;\n    }\n}\n","index":127},{"title":"Number Of Positive Divisors","category":"math","id":"number_of_positive_divisors_math","algorithm":"/**\n * @file\n * @brief C++ Program to calculate the number of positive divisors\n *\n * This algorithm uses the prime factorization approach.\n * Any positive integer can be written as a product of its prime factors.\n * <br/>Let \\f$N = p_1^{e_1} \\times p_2^{e_2} \\times\\cdots\\times p_k^{e_k}\\f$\n * where \\f$p_1,\\, p_2,\\, \\dots,\\, p_k\\f$ are distinct prime factors of \\f$N\\f$ and\n * \\f$e_1,\\, e_2,\\, \\dots,\\, e_k\\f$ are respective positive integer exponents.\n * <br/>Each positive divisor of \\f$N\\f$ is in the form\n * \\f$p_1^{g_1}\\times p_2^{g_2}\\times\\cdots\\times p_k^{g_k}\\f$\n * where \\f$0\\le g_i\\le e_i\\f$ are integers for all \\f$1\\le i\\le k\\f$.\n * <br/>Finally, there are \\f$(e_1+1) \\times (e_2+1)\\times\\cdots\\times (e_k+1)\\f$\n * positive divisors of \\f$N\\f$ since we can choose every \\f$g_i\\f$\n * independently.\n *\n * Example:\n * <br/>\\f$N = 36 = (3^2 \\cdot 2^2)\\f$\n * <br/>\\f$\\mbox{number_of_positive_divisors}(36) = (2+1) \\cdot (2+1) = 9\\f$.\n * <br/>list of positive divisors of 36 = 1, 2, 3, 4, 6, 9, 12, 18, 36.\n *\n * Similarly, for N = -36 the number of positive divisors remain same.\n**/\n\n#include <cassert>\n#include <iostream>\n\n/**\n * Function to compute the number of positive divisors.\n * @param n number to compute divisors for\n * @returns number of positive divisors of n (or 1 if n = 0)\n */\nint number_of_positive_divisors(int n) {\n    if (n < 0) {\n        n = -n; // take the absolute value of n\n    }\n\n    int number_of_divisors = 1;\n\n    for (int i = 2; i * i <= n; i++) {\n        // This part is doing the prime factorization.\n        // Note that we cannot find a composite divisor of n unless we would\n        // already previously find the corresponding prime divisor and dvided\n        // n by that prime. Therefore, all the divisors found here will\n        // actually be primes.\n        // The loop terminates early when it is left with a number n which\n        // does not have a divisor smaller or equal to sqrt(n) - that means\n        // the remaining number is a prime itself.\n        int prime_exponent = 0;\n        while (n % i == 0) {\n            // Repeatedly divide n by the prime divisor n to compute\n            // the exponent (e_i in the algorithm description).\n            prime_exponent++;\n            n /= i;\n        }\n        number_of_divisors *= prime_exponent + 1;\n    }\n    if (n > 1) {\n        // In case the remaining number n is a prime number itself\n        // (essentially p_k^1) the final answer is also multiplied by (e_k+1).\n        number_of_divisors *= 2;\n    }\n\n    return number_of_divisors;\n}\n\n/**\n * Test implementations\n */\nvoid tests() {\n    assert(number_of_positive_divisors(36) == 9);\n    assert(number_of_positive_divisors(-36) == 9);\n    assert(number_of_positive_divisors(1) == 1);\n    assert(number_of_positive_divisors(2011) == 2); // 2011 is a prime\n    assert(number_of_positive_divisors(756) == 24); // 756 = 2^2 * 3^3 * 7\n}\n\n/**\n * Main function\n */\nint main() {\n    tests();\n    int n;\n    std::cin >> n;\n    if (n == 0) {\n        std::cout << \"All non-zero numbers are divisors of 0 !\" << std::endl;\n    } else {\n        std::cout << \"Number of positive divisors is : \";\n        std::cout << number_of_positive_divisors(n) << std::endl;\n    }\n    return 0;\n}\n","index":128},{"title":"Power For Huge Numbers","category":"math","id":"power_for_huge_numbers_math","algorithm":"/**\n * @file\n * @brief Compute powers of large numbers\n */\n#include <iostream>\n\n/** Maximum number of digits in output\n *  \\f$x^n\\f$ where \\f$1 <= x,\\; n <= 10000\\f$ and overflow may happen\n */\n#define MAX 100000\n\n/** This function multiplies x\n * with the number represented by res[].\n * res_size is size of res[] or\n * number of digits in the number\n * represented by res[]. This function\n * uses simple school mathematics\n * for multiplication.\n * This function may value of res_size\n * and returns the new value of res_size\n * @param x multiplicand\n * @param res large number representation using array\n * @param res_size number of digits in `res`\n */\nint multiply(int x, int res[], int res_size) {\n    // Initialize carry\n    int carry = 0;\n\n    // One by one multiply n with\n    // individual digits of res[]\n    for (int i = 0; i < res_size; i++) {\n        int prod = res[i] * x + carry;\n\n        // Store last digit of\n        // 'prod' in res[]\n        res[i] = prod % 10;\n\n        // Put rest in carry\n        carry = prod / 10;\n    }\n\n    // Put carry in res and\n    // increase result size\n    while (carry) {\n        res[res_size] = carry % 10;\n        carry = carry / 10;\n        res_size++;\n    }\n    return res_size;\n}\n\n/** This function finds power of a number x and print \\f$x^n\\f$\n * @param x base\n * @param n exponent\n */\nvoid power(int x, int n) {\n    // printing value \"1\" for power = 0\n    if (n == 0) {\n        std::cout << \"1\";\n        return;\n    }\n\n    int res[MAX];\n    int res_size = 0;\n    int temp = x;\n\n    // Initialize result\n    while (temp != 0) {\n        res[res_size++] = temp % 10;\n        temp = temp / 10;\n    }\n\n    // Multiply x n times\n    // (x^n = x*x*x....n times)\n    for (int i = 2; i <= n; i++) res_size = multiply(x, res, res_size);\n\n    std::cout << x << \"^\" << n << \" = \";\n    for (int i = res_size - 1; i >= 0; i--) std::cout << res[i];\n}\n\n/** Main function */\nint main() {\n    int exponent, base;\n    std::cout << \"Enter base \";\n    std::cin >> base;\n    std::cout << \"Enter exponent \";\n    std::cin >> exponent;\n    power(base, exponent);\n    return 0;\n}\n","index":129},{"title":"Primes Up To Billion","category":"math","id":"primes_up_to_billion_math","algorithm":"/**\n * @file\n * @brief Compute prime numbers upto 1 billion\n * @see prime_numbers.cpp sieve_of_eratosthenes.cpp\n */\n#include <cstring>\n#include <iostream>\n\n/** array to store the primes */\nchar prime[100000000];\n\n/** Perform Sieve algorithm */\nvoid Sieve(int64_t n) {\n    memset(prime, '1', sizeof(prime));  // intitize '1' to every index\n    prime[0] = '0';                     // 0 is not prime\n    prime[1] = '0';                     // 1 is not prime\n    for (int64_t p = 2; p * p <= n; p++) {\n        if (prime[p] == '1') {\n            for (int64_t i = p * p; i <= n; i += p)\n                prime[i] = '0';  // set all multiples of p to false\n        }\n    }\n}\n\n/** Main function */\nint main() {\n    Sieve(100000000);\n    int64_t n;\n    std::cin >> n;  // 10006187\n    if (prime[n] == '1')\n        std::cout << \"YES\\n\";\n    else\n        std::cout << \"NO\\n\";\n\n    return 0;\n}\n","index":130},{"title":"Prime Factorization","category":"math","id":"prime_factorization_math","algorithm":"/**\n * @file\n * @brief Prime factorization of positive integers\n */\n#include <algorithm>\n#include <cstring>\n#include <iostream>\n#include <vector>\n\n/** Declaring variables for maintaing prime numbers and to check whether a\n * number is prime or not\n */\nbool isprime[1000006];\n\n/** list of prime numbers */\nstd::vector<int> prime_numbers;\n\n/** list of prime factor-pairs */\nstd::vector<std::pair<int, int>> factors;\n\n/** Calculating prime number upto a given range\n */\nvoid SieveOfEratosthenes(int N) {\n    // initializes the array isprime\n    memset(isprime, true, sizeof isprime);\n\n    for (int i = 2; i <= N; i++) {\n        if (isprime[i]) {\n            for (int j = 2 * i; j <= N; j += i) isprime[j] = false;\n        }\n    }\n\n    for (int i = 2; i <= N; i++) {\n        if (isprime[i])\n            prime_numbers.push_back(i);\n    }\n}\n\n/** Prime factorization of a number */\nvoid prime_factorization(int num) {\n    int number = num;\n\n    for (int i = 0; prime_numbers[i] <= num; i++) {\n        int count = 0;\n\n        // termination condition\n        if (number == 1) {\n            break;\n        }\n\n        while (number % prime_numbers[i] == 0) {\n            count++;\n            number = number / prime_numbers[i];\n        }\n\n        if (count)\n            factors.push_back(std::make_pair(prime_numbers[i], count));\n    }\n}\n\n/** Main program */\nint main() {\n    int num;\n    std::cout << \"\\t\\tComputes the prime factorization\\n\\n\";\n    std::cout << \"Type in a number: \";\n    std::cin >> num;\n\n    SieveOfEratosthenes(num);\n\n    prime_factorization(num);\n\n    // Prime factors with their powers in the given number in new line\n    for (auto it : factors) {\n        std::cout << it.first << \" \" << it.second << std::endl;\n    }\n\n    return 0;\n}\n","index":131},{"title":"Prime Numbers","category":"math","id":"prime_numbers_math","algorithm":"/**\n * @file\n * @brief Get list of prime numbers\n * @see primes_up_to_billion.cpp sieve_of_eratosthenes.cpp\n */\n#include <iostream>\n#include <vector>\n\n/** Generate an increasingly large number of primes\n * and store in a list\n */\nstd::vector<int> primes(int max) {\n    max++;\n    std::vector<int> res;\n    std::vector<bool> numbers(max, false);\n    for (int i = 2; i < max; i++) {\n        if (!numbers[i]) {\n            for (int j = i; j < max; j += i) numbers[j] = true;\n            res.push_back(i);\n        }\n    }\n    return res;\n}\n\n/** main function */\nint main() {\n    std::cout << \"Calculate primes up to:\\n>> \";\n    int n;\n    std::cin >> n;\n    std::vector<int> ans = primes(n);\n    for (int i = 0; i < ans.size(); i++) std::cout << ans[i] << ' ';\n    std::cout << std::endl;\n}\n","index":132},{"title":"Realtime Stats","category":"math","id":"realtime_stats_math","algorithm":"/**\n * \\file\n * \\brief Compute statistics for data entered in rreal-time\n *\n * This algorithm is really beneficial to compute statistics on data read in\n * realtime. For example, devices reading biometrics data. The algorithm is\n * simple enough to be easily implemented in an embedded system.\n * \\author [Krishna Vedala](https://github.com/kvedala)\n */\n#include <cassert>\n#include <cmath>\n#include <iostream>\n\n/**\n * \\namespace statistics\n * \\brief Statistical algorithms\n */\nnamespace statistics {\n\n/**\n * continuous mean and variance computance using\n * first value as an approximation for the mean.\n * If the first number is much far form the mean, the algorithm becomes very\n * inaccurate to compute variance and standard deviation.\n */\ntemplate <typename T>\nclass stats_computer1 {\n public:\n    /** Constructor\n     * \\param[in] x new data sample\n     */\n    void new_val(T x) {\n        if (n == 0)\n            K = x;\n        n++;\n        T tmp = x - K;\n        Ex += tmp;\n        Ex2 += static_cast<double>(tmp) * tmp;\n    }\n\n    /** return sample mean computed till last sample */\n    double mean() const { return K + Ex / n; }\n\n    /** return data variance computed till last sample */\n    double variance() const { return (Ex2 - (Ex * Ex) / n) / (n - 1); }\n\n    /** return sample standard deviation computed till last sample */\n    double std() const { return std::sqrt(this->variance()); }\n\n    /** short-hand operator to read new sample from input stream\n     * \\n e.g.: `std::cin >> stats1;`\n     */\n    friend std::istream &operator>>(std::istream &input,\n                                    stats_computer1 &stat) {\n        T val;\n        input >> val;\n        stat.new_val(val);\n        return input;\n    }\n\n private:\n    unsigned int n = 0;\n    double Ex, Ex2;\n    T K;\n};\n\n/**\n * continuous mean and variance computance using\n * Welford's algorithm  (very accurate)\n */\ntemplate <typename T>\nclass stats_computer2 {\n public:\n    /** Constructor\n     * \\param[in] x new data sample\n     */\n    void new_val(T x) {\n        n++;\n        double delta = x - mu;\n        mu += delta / n;\n        double delta2 = x - mu;\n        M += delta * delta2;\n    }\n\n    /** return sample mean computed till last sample */\n    double mean() const { return mu; }\n\n    /** return data variance computed till last sample */\n    double variance() const { return M / n; }\n\n    /** return sample standard deviation computed till last sample */\n    double std() const { return std::sqrt(this->variance()); }\n\n    /** short-hand operator to read new sample from input stream\n     * \\n e.g.: `std::cin >> stats1;`\n     */\n    friend std::istream &operator>>(std::istream &input,\n                                    stats_computer2 &stat) {\n        T val;\n        input >> val;\n        stat.new_val(val);\n        return input;\n    }\n\n private:\n    unsigned int n = 0;\n    double mu = 0, var = 0, M = 0;\n};\n\n}  // namespace statistics\n\nusing statistics::stats_computer1;\nusing statistics::stats_computer2;\n\n/** Test the algorithm implementation\n * \\param[in] test_data array of data to test the algorithms\n */\nvoid test_function(const float *test_data, const int number_of_samples) {\n    float mean = 0.f, variance = 0.f;\n\n    stats_computer1<float> stats01;\n    stats_computer2<float> stats02;\n\n    for (int i = 0; i < number_of_samples; i++) {\n        stats01.new_val(test_data[i]);\n        stats02.new_val(test_data[i]);\n        mean += test_data[i];\n    }\n\n    mean /= number_of_samples;\n\n    for (int i = 0; i < number_of_samples; i++) {\n        float temp = test_data[i] - mean;\n        variance += temp * temp;\n    }\n    variance /= number_of_samples;\n\n    std::cout << \"<<<<<<<< Test Function >>>>>>>>\" << std::endl\n              << \"Expected: Mean: \" << mean << \"\\t Variance: \" << variance\n              << std::endl;\n    std::cout << \"\\tMethod 1:\"\n              << \"\\tMean: \" << stats01.mean()\n              << \"\\t Variance: \" << stats01.variance()\n              << \"\\t Std: \" << stats01.std() << std::endl;\n    std::cout << \"\\tMethod 2:\"\n              << \"\\tMean: \" << stats02.mean()\n              << \"\\t Variance: \" << stats02.variance()\n              << \"\\t Std: \" << stats02.std() << std::endl;\n\n    assert(std::abs(stats01.mean() - mean) < 0.01);\n    assert(std::abs(stats02.mean() - mean) < 0.01);\n    assert(std::abs(stats02.variance() - variance) < 0.01);\n\n    std::cout << \"(Tests passed)\" << std::endl;\n}\n\n/** Main function */\nint main(int argc, char **argv) {\n    const float test_data1[] = {3, 4, 5, -1.4, -3.6, 1.9, 1.};\n    test_function(test_data1, sizeof(test_data1) / sizeof(test_data1[0]));\n\n    std::cout\n        << \"Enter data. Any non-numeric data will terminate the data input.\"\n        << std::endl;\n\n    stats_computer1<float> stats1;\n    stats_computer2<float> stats2;\n\n    while (1) {\n        double val;\n        std::cout << \"Enter number: \";\n        std::cin >> val;\n\n        // check for failure to read input. Happens for\n        // non-numeric data\n        if (std::cin.fail())\n            break;\n\n        stats1.new_val(val);\n        stats2.new_val(val);\n\n        std::cout << \"\\tMethod 1:\"\n                  << \"\\tMean: \" << stats1.mean()\n                  << \"\\t Variance: \" << stats1.variance()\n                  << \"\\t Std: \" << stats1.std() << std::endl;\n        std::cout << \"\\tMethod 2:\"\n                  << \"\\tMean: \" << stats2.mean()\n                  << \"\\t Variance: \" << stats2.variance()\n                  << \"\\t Std: \" << stats2.std() << std::endl;\n    }\n\n    return 0;\n}\n","index":133},{"title":"Sieve Of Eratosthenes","category":"math","id":"sieve_of_eratosthenes_math","algorithm":"/**\n * @file\n * @brief Get list of prime numbers using Sieve of Eratosthenes\n * @details\n * Sieve of Eratosthenes is an algorithm that finds all the primes\n * between 2 and N.\n *\n * Time Complexity  : \\f$O(N \\cdot\\log \\log N)\\f$\n * <br/>Space Complexity : \\f$O(N)\\f$\n *\n * @see primes_up_to_billion.cpp prime_numbers.cpp\n */\n\n#include <cassert>\n#include <iostream>\n#include <vector>\n\n/**\n * This is the function that finds the primes and eliminates the multiples.\n * Contains a common optimization to start eliminating multiples of\n * a prime p starting from p * p since all of the lower multiples\n * have been already eliminated.\n * @param N number of primes to check\n * @return is_prime a vector of `N + 1` booleans identifying if `i`^th number is a prime or not\n */\nstd::vector<bool> sieve(uint32_t N) {\n    std::vector<bool> is_prime(N + 1, true);\n    is_prime[0] = is_prime[1] = false;\n    for (uint32_t i = 2; i * i <= N; i++) {\n        if (is_prime[i]) {\n            for (uint32_t j = i * i; j <= N; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n    return is_prime;\n}\n\n/**\n * This function prints out the primes to STDOUT\n * @param N number of primes to check\n * @param is_prime a vector of `N + 1` booleans identifying if `i`^th number is a prime or not\n */\nvoid print(uint32_t N, const std::vector<bool> &is_prime) {\n    for (uint32_t i = 2; i <= N; i++) {\n        if (is_prime[i]) {\n            std::cout << i << ' ';\n        }\n    }\n    std::cout << std::endl;\n}\n\n/**\n * Test implementations\n */\nvoid tests() {\n  //                    0      1      2     3     4      5     6      7     8      9      10\n  std::vector<bool> ans{false, false, true, true, false, true, false, true, false, false, false};\n  assert(sieve(10) == ans);\n}\n\n/**\n * Main function\n */\nint main() {\n    tests();\n\n    uint32_t N = 100;\n    std::vector<bool> is_prime = sieve(N);\n    print(N, is_prime);\n    return 0;\n}\n","index":134},{"title":"Sqrt Double","category":"math","id":"sqrt_double_math","algorithm":"/**\n * @file\n * @brief Calculate the square root of any positive real number in \\f$O(\\log\n * N)\\f$ time, with precision fixed using [bisection\n * method](https://en.wikipedia.org/wiki/Bisection_method) of root-finding.\n *\n * @see Can be implemented using faster and better algorithms like\n * newton_raphson_method.cpp and false_position.cpp\n */\n#include <cassert>\n#include <iostream>\n\n/** Bisection method implemented for the function \\f$x^2-a=0\\f$\n * whose roots are \\f$\\pm\\sqrt{a}\\f$ and only the positive root is returned.\n */\ndouble Sqrt(double a) {\n    if (a > 0 && a < 1) {\n        return 1 / Sqrt(1 / a);\n    }\n    double l = 0, r = a;\n    /* Epsilon is the precision.\n    A great precision is\n    between 1e-7 and 1e-12.\n    double epsilon = 1e-12;\n    */\n    double epsilon = 1e-12;\n    while (l <= r) {\n        double mid = (l + r) / 2;\n        if (mid * mid > a) {\n            r = mid;\n        } else {\n            if (a - mid * mid < epsilon) {\n                return mid;\n            }\n            l = mid;\n        }\n    }\n    return -1;\n}\n\n/** main function */\nint main() {\n    double n{};\n    std::cin >> n;\n    assert(n >= 0);\n    // Change this line for a better precision\n    std::cout.precision(12);\n    std::cout << std::fixed << Sqrt(n);\n}\n","index":135},{"title":"String Fibonacci","category":"math","id":"string_fibonacci_math","algorithm":"/**\n * @file\n * @brief This Programme returns the Nth fibonacci as a string.\n *\n * The method used is manual addition with carry and placing it in a string\n * which is called string addition This makes it have no bounds or limits\n *\n * @see fibonacci_large.cpp, fibonacci_fast.cpp, fibonacci.cpp\n */\n\n#include <iostream>\n#ifdef _MSC_VER\n#include <string>  // use this for MS Visual C\n#else\n#include <cstring>  // otherwise\n#endif\n\n/**\n * function to add two string numbers\n * \\param [in] a first number in string to add\n * \\param [in] b second number in string to add\n * \\returns sum as a std::string\n */\nstd::string add(std::string a, std::string b) {\n    std::string temp = \"\";\n\n    // carry flag\n    int carry = 0;\n\n    // fills up with zeros\n    while (a.length() < b.length()) {\n        a = \"0\" + a;\n    }\n\n    // fills up with zeros\n    while (b.length() < a.length()) {\n        b = \"0\" + b;\n    }\n\n    // adds the numbers a and b\n    for (int i = a.length() - 1; i >= 0; i--) {\n        char val = static_cast<char>(((a[i] - 48) + (b[i] - 48)) + 48 + carry);\n        if (val > 57) {\n            carry = 1;\n            val -= 10;\n        } else {\n            carry = 0;\n        }\n        temp = val + temp;\n    }\n\n    // processes the carry flag\n    if (carry == 1) {\n        temp = \"1\" + temp;\n    }\n\n    // removes leading zeros.\n    while (temp[0] == '0' && temp.length() > 1) {\n        temp = temp.substr(1);\n    }\n\n    return temp;\n}\n\n/** Fibonacci iterator\n * \\param [in] n n^th Fibonacci number\n */\nvoid fib_Accurate(uint64_t n) {\n    std::string tmp = \"\";\n    std::string fibMinus1 = \"1\";\n    std::string fibMinus2 = \"0\";\n    for (uint64_t i = 0; i < n; i++) {\n        tmp = add(fibMinus1, fibMinus2);\n        fibMinus2 = fibMinus1;\n        fibMinus1 = tmp;\n    }\n    std::cout << fibMinus2;\n}\n\n/** main function */\nint main() {\n    int n;\n    std::cout << \"Enter whatever number N you want to find the fibonacci of\\n\";\n    std::cin >> n;\n    std::cout << n << \" th Fibonacci is \\n\";\n    fib_Accurate(n);\n\n    return 0;\n}\n","index":136},{"title":"Sum Of Digits","category":"math","id":"sum_of_digits_math","algorithm":"/**\n * Copyright 2020 @author iamnambiar\n *\n * @file\n * \\brief A C++ Program to find the Sum of Digits of input integer.\n */\n#include <cassert>\n#include <iostream>\n\n/**\n * Function to find the sum of the digits of an integer.\n * @param num The integer.\n * @return Sum of the digits of the integer.\n *\n * \\detail\n * First the algorithm check whether the num is negative or positive,\n * if it is negative, then we neglect the negative sign.\n * Next, the algorithm extract the last digit of num by dividing by 10\n * and extracting the remainder and this is added to the sum.\n * The number is then divided by 10 to remove the last digit.\n * This loop continues until num becomes 0.\n */\nint sum_of_digits(int num) {\n    // If num is negative then negative sign is neglected.\n    if (num < 0) {\n        num = -1 * num;\n    }\n    int sum = 0;\n    while (num > 0) {\n        sum = sum + (num % 10);\n        num = num / 10;\n    }\n    return sum;\n}\n\n/**\n * Function for testing the sum_of_digits() function with a\n * first test case of 119765 and assert statement.\n */\nvoid test1() {\n    int test_case_1 = sum_of_digits(119765);\n    assert(test_case_1 == 29);\n}\n\n/**\n * Function for testing the sum_of_digits() function with a\n * second test case of -12256 and assert statement.\n */\nvoid test2() {\n    int test_case_2 = sum_of_digits(-12256);\n    assert(test_case_2 == 16);\n}\n\n/**\n * Function for testing the sum_of_digits() with\n * all the test cases.\n */\nvoid test() {\n    // First test.\n    test1();\n    // Second test.\n    test2();\n}\n\n/**\n * Main Function\n */\nint main() {\n    test();\n    std::cout << \"Success.\" << std::endl;\n    return 0;\n}\n","index":137},{"title":"Numerical Methods","category":null,"id":"numerical_methods","index":138},{"title":"Bisection Method","category":"numerical_methods","id":"bisection_method_numerical_methods","algorithm":"/**\n * \\file\n * \\brief Solve the equation \\f$f(x)=0\\f$ using [bisection\n * method](https://en.wikipedia.org/wiki/Bisection_method)\n *\n * Given two points \\f$a\\f$ and \\f$b\\f$ such that \\f$f(a)<0\\f$ and\n * \\f$f(b)>0\\f$, then the \\f$(i+1)^\\text{th}\\f$ approximation is given by: \\f[\n * x_{i+1} = \\frac{a_i+b_i}{2}\n * \\f]\n * For the next iteration, the interval is selected\n * as: \\f$[a,x]\\f$ if \\f$x>0\\f$ or \\f$[x,b]\\f$ if \\f$x<0\\f$. The Process is\n * continued till a close enough approximation is achieved.\n *\n * \\see newton_raphson_method.cpp, false_position.cpp, secant_method.cpp\n */\n#include <cmath>\n#include <iostream>\n#include <limits>\n\n#define EPSILON \\\n    1e-6  // std::numeric_limits<double>::epsilon()  ///< system accuracy limit\n#define MAX_ITERATIONS 50000  ///< Maximum number of iterations to check\n\n/** define \\f$f(x)\\f$ to find root for\n */\nstatic double eq(double i) {\n    return (std::pow(i, 3) - (4 * i) - 9);  // original equation\n}\n\n/** get the sign of any given number */\ntemplate <typename T>\nint sgn(T val) {\n    return (T(0) < val) - (val < T(0));\n}\n\n/** main function */\nint main() {\n    double a = -1, b = 1, x, z;\n    int i;\n\n    // loop to find initial intervals a, b\n    for (int i = 0; i < MAX_ITERATIONS; i++) {\n        z = eq(a);\n        x = eq(b);\n        if (sgn(z) == sgn(x)) {  // same signs, increase interval\n            b++;\n            a--;\n        } else {  // if opposite signs, we got our interval\n            break;\n        }\n    }\n\n    std::cout << \"\\nFirst initial: \" << a;\n    std::cout << \"\\nSecond initial: \" << b;\n\n    // start iterations\n    for (i = 0; i < MAX_ITERATIONS; i++) {\n        x = (a + b) / 2;\n        z = eq(x);\n        std::cout << \"\\n\\nz: \" << z << \"\\t[\" << a << \" , \" << b\n                  << \" | Bisect: \" << x << \"]\";\n\n        if (z < 0) {\n            a = x;\n        } else {\n            b = x;\n        }\n\n        if (std::abs(z) < EPSILON)  // stoping criteria\n            break;\n    }\n\n    std::cout << \"\\n\\nRoot: \" << x << \"\\t\\tSteps: \" << i << std::endl;\n    return 0;\n}\n","index":139},{"title":"Brent Method Extrema","category":"numerical_methods","id":"brent_method_extrema_numerical_methods","algorithm":"/**\n * \\file\n * \\brief Find real extrema of a univariate real function in a given interval\n * using [Brent's method](https://en.wikipedia.org/wiki/Brent%27s_method).\n *\n * Refer the algorithm discoverer's publication\n * [online](https://maths-people.anu.edu.au/~brent/pd/rpb011i.pdf) and also\n * associated book:\n * > R. P. Brent, Algorithms for Minimization without\n * > Derivatives, Prentice-Hall, Englewood Cliffs, New Jersey, 1973\n *\n * \\see golden_search_extrema.cpp\n *\n * \\author [Krishna Vedala](https://github.com/kvedala)\n */\n#define _USE_MATH_DEFINES  ///< required for MS Visual C++\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iostream>\n#include <limits>\n\n#define EPSILON \\\n    std::sqrt(  \\\n        std::numeric_limits<double>::epsilon())  ///< system accuracy limit\n\n/**\n * @brief Get the real root of a function in the given interval.\n *\n * @param f function to get root for\n * @param lim_a lower limit of search window\n * @param lim_b upper limit of search window\n * @return root found in the interval\n */\ndouble get_minima(const std::function<double(double)> &f, double lim_a,\n                  double lim_b) {\n    uint32_t iters = 0;\n\n    if (lim_a > lim_b) {\n        std::swap(lim_a, lim_b);\n    } else if (std::abs(lim_a - lim_b) <= EPSILON) {\n        std::cerr << \"Search range must be greater than \" << EPSILON << \"\\n\";\n        return lim_a;\n    }\n\n    // golden ratio value\n    const double M_GOLDEN_RATIO = (3.f - std::sqrt(5.f)) / 2.f;\n\n    double v = lim_a + M_GOLDEN_RATIO * (lim_b - lim_a);\n    double u, w = v, x = v;\n    double fu, fv = f(v);\n    double fw = fv, fx = fv;\n\n    double mid_point = (lim_a + lim_b) / 2.f;\n    double p = 0, q = 0, r = 0;\n\n    double d, e = 0;\n    double tolerance, tolerance2;\n\n    do {\n        mid_point = (lim_a + lim_b) / 2.f;\n        tolerance = EPSILON * std::abs(x);\n        tolerance2 = 2 * tolerance;\n\n        if (std::abs(e) > tolerance2) {\n            // fit parabola\n            r = (x - w) * (fx - fv);\n            q = (x - v) * (fx - fw);\n            p = (x - v) * q - (x - w) * r;\n            q = 2.f * (q - r);\n            if (q > 0)\n                p = -p;\n            else\n                q = -q;\n            r = e;\n            e = d;\n        }\n\n        if (std::abs(p) < std::abs(0.5 * q * r) && p < q * (lim_b - x)) {\n            // parabolic interpolation step\n            d = p / q;\n            u = x + d;\n            if (u - lim_a < tolerance2 || lim_b - u < tolerance2)\n                d = x < mid_point ? tolerance : -tolerance;\n        } else {\n            // golden section interpolation step\n            e = (x < mid_point ? lim_b : lim_a) - x;\n            d = M_GOLDEN_RATIO * e;\n        }\n\n        // evaluate not too close to x\n        if (std::abs(d) >= tolerance)\n            u = d;\n        else if (d > 0)\n            u = tolerance;\n        else\n            u = -tolerance;\n        u += x;\n        fu = f(u);\n\n        // update variables\n        if (fu <= fx) {\n            if (u < x)\n                lim_b = x;\n            else\n                lim_a = x;\n            v = w;\n            fv = fw;\n            w = x;\n            fw = fx;\n            x = u;\n            fx = fu;\n        } else {\n            if (u < x)\n                lim_a = u;\n            else\n                lim_b = u;\n            if (fu <= fw || x == w) {\n                v = w;\n                fv = fw;\n                w = u;\n                fw = fu;\n            } else if (fu <= fv || v == x || v == w) {\n                v = u;\n                fv = fu;\n            }\n        }\n\n        iters++;\n    } while (std::abs(x - mid_point) > (tolerance - (lim_b - lim_a) / 2.f));\n\n    std::cout << \" (iters: \" << iters << \") \";\n\n    return x;\n}\n\n/**\n * @brief Test function to find root for the function\n * \\f$f(x)= (x-2)^2\\f$\n * in the interval \\f$[1,5]\\f$\n * \\n Expected result = 2\n */\nvoid test1() {\n    // define the function to minimize as a lambda function\n    std::function<double(double)> f1 = [](double x) {\n        return (x - 2) * (x - 2);\n    };\n\n    std::cout << \"Test 1.... \";\n\n    double minima = get_minima(f1, -1, 5);\n\n    std::cout << minima << \"...\";\n\n    assert(std::abs(minima - 2) < EPSILON);\n    std::cout << \"passed\\n\";\n}\n\n/**\n * @brief Test function to find root for the function\n * \\f$f(x)= x^{\\frac{1}{x}}\\f$\n * in the interval \\f$[-2,10]\\f$\n * \\n Expected result: \\f$e\\approx 2.71828182845904509\\f$\n */\nvoid test2() {\n    // define the function to maximize as a lambda function\n    // since we are maximixing, we negated the function return value\n    std::function<double(double)> func = [](double x) {\n        return -std::pow(x, 1.f / x);\n    };\n\n    std::cout << \"Test 2.... \";\n\n    double minima = get_minima(func, -2, 5);\n\n    std::cout << minima << \" (\" << M_E << \")...\";\n\n    assert(std::abs(minima - M_E) < EPSILON);\n    std::cout << \"passed\\n\";\n}\n\n/**\n * @brief Test function to find *maxima* for the function\n * \\f$f(x)= \\cos x\\f$\n * in the interval \\f$[0,12]\\f$\n * \\n Expected result: \\f$\\pi\\approx 3.14159265358979312\\f$\n */\nvoid test3() {\n    // define the function to maximize as a lambda function\n    // since we are maximixing, we negated the function return value\n    std::function<double(double)> func = [](double x) { return std::cos(x); };\n\n    std::cout << \"Test 3.... \";\n\n    double minima = get_minima(func, -4, 12);\n\n    std::cout << minima << \" (\" << M_PI << \")...\";\n\n    assert(std::abs(minima - M_PI) < EPSILON);\n    std::cout << \"passed\\n\";\n}\n\n/** Main function */\nint main() {\n    std::cout.precision(18);\n\n    std::cout << \"Computations performed with machine epsilon: \" << EPSILON\n              << \"\\n\";\n\n    test1();\n    test2();\n    test3();\n\n    return 0;\n}\n","index":140},{"title":"Durand Kerner Roots","category":"numerical_methods","id":"durand_kerner_roots_numerical_methods","algorithm":"/**\n * @file\n * \\brief Compute all possible approximate roots of any given polynomial using\n * [Durand Kerner\n * algorithm](https://en.wikipedia.org/wiki/Durand%E2%80%93Kerner_method)\n * \\author [Krishna Vedala](https://github.com/kvedala)\n *\n * Test the algorithm online:\n * https://gist.github.com/kvedala/27f1b0b6502af935f6917673ec43bcd7\n *\n * Try the highly unstable Wilkinson's polynomial:\n * ```\n * ./numerical_methods/durand_kerner_roots 1 -210 20615 -1256850 53327946\n * -1672280820 40171771630 -756111184500 11310276995381 -135585182899530\n * 1307535010540395 -10142299865511450 63030812099294896 -311333643161390640\n * 1206647803780373360 -3599979517947607200 8037811822645051776\n * -12870931245150988800 13803759753640704000 -8752948036761600000\n * 2432902008176640000\n * ```\n * Sample implementation results to compute approximate roots of the equation\n * \\f$x^4-1=0\\f$:\\n\n * <img\n * src=\"https://raw.githubusercontent.com/TheAlgorithms/C-Plus-Plus/docs/images/numerical_methods/durand_kerner_error.svg\"\n * width=\"400\" alt=\"Error evolution during root approximations computed every\n * iteration.\"/> <img\n * src=\"https://raw.githubusercontent.com/TheAlgorithms/C-Plus-Plus/docs/images/numerical_methods/durand_kerner_roots.svg\"\n * width=\"400\" alt=\"Roots evolution - shows the initial approximation of the\n * roots and their convergence to a final approximation along with the iterative\n * approximations\" />\n */\n\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdlib>\n#include <ctime>\n#include <fstream>\n#include <iostream>\n#include <valarray>\n#ifdef _OPENMP\n#include <omp.h>\n#endif\n\n#define ACCURACY 1e-10 /**< maximum accuracy limit */\n\n/**\n * Evaluate the value of a polynomial with given coefficients\n * \\param[in] coeffs coefficients of the polynomial\n * \\param[in] x point at which to evaluate the polynomial\n * \\returns \\f$f(x)\\f$\n **/\nstd::complex<double> poly_function(const std::valarray<double> &coeffs,\n                                   std::complex<double> x) {\n    double real = 0.f, imag = 0.f;\n    int n;\n\n    // #ifdef _OPENMP\n    // #pragma omp target teams distribute reduction(+ : real, imag)\n    // #endif\n    for (n = 0; n < coeffs.size(); n++) {\n        std::complex<double> tmp =\n            coeffs[n] * std::pow(x, coeffs.size() - n - 1);\n        real += tmp.real();\n        imag += tmp.imag();\n    }\n\n    return std::complex<double>(real, imag);\n}\n\n/**\n * create a textual form of complex number\n * \\param[in] x point at which to evaluate the polynomial\n * \\returns pointer to converted string\n */\nconst char *complex_str(const std::complex<double> &x) {\n#define MAX_BUFF_SIZE 50\n    static char msg[MAX_BUFF_SIZE];\n\n    std::snprintf(msg, MAX_BUFF_SIZE, \"% 7.04g%+7.04gj\", x.real(), x.imag());\n\n    return msg;\n}\n\n/**\n * check for termination condition\n * \\param[in] delta point at which to evaluate the polynomial\n * \\returns `false` if termination not reached\n * \\returns `true` if termination reached\n */\nbool check_termination(long double delta) {\n    static long double past_delta = INFINITY;\n    if (std::abs(past_delta - delta) <= ACCURACY || delta < ACCURACY)\n        return true;\n    past_delta = delta;\n    return false;\n}\n\n/**\n * Implements Durand Kerner iterative algorithm to compute all roots of a\n * polynomial.\n *\n * \\param[in] coeffs coefficients of the polynomial\n * \\param[out] roots the computed roots of the polynomial\n * \\param[in] write_log flag whether to save the log file (default = `false`)\n * \\returns pair of values - number of iterations taken and final accuracy\n * achieved\n */\nstd::pair<uint32_t, double> durand_kerner_algo(\n    const std::valarray<double> &coeffs,\n    std::valarray<std::complex<double>> *roots, bool write_log = false) {\n    long double tol_condition = 1;\n    uint32_t iter = 0;\n    int n;\n    std::ofstream log_file;\n\n    if (write_log) {\n        /*\n         * store intermediate values to a CSV file\n         */\n        log_file.open(\"durand_kerner.log.csv\");\n        if (!log_file.is_open()) {\n            perror(\"Unable to create a storage log file!\");\n            std::exit(EXIT_FAILURE);\n        }\n        log_file << \"iter#,\";\n\n        for (n = 0; n < roots->size(); n++) log_file << \"root_\" << n << \",\";\n\n        log_file << \"avg. correction\";\n        log_file << \"\\n0,\";\n        for (n = 0; n < roots->size(); n++)\n            log_file << complex_str((*roots)[n]) << \",\";\n    }\n\n    bool break_loop = false;\n    while (!check_termination(tol_condition) && iter < INT16_MAX &&\n           !break_loop) {\n        tol_condition = 0;\n        iter++;\n        break_loop = false;\n\n        if (log_file.is_open())\n            log_file << \"\\n\" << iter << \",\";\n\n#ifdef _OPENMP\n#pragma omp parallel for shared(break_loop, tol_condition)\n#endif\n        for (n = 0; n < roots->size(); n++) {\n            if (break_loop)\n                continue;\n\n            std::complex<double> numerator, denominator;\n            numerator = poly_function(coeffs, (*roots)[n]);\n            denominator = 1.0;\n            for (int i = 0; i < roots->size(); i++)\n                if (i != n)\n                    denominator *= (*roots)[n] - (*roots)[i];\n\n            std::complex<long double> delta = numerator / denominator;\n\n            if (std::isnan(std::abs(delta)) || std::isinf(std::abs(delta))) {\n                std::cerr << \"\\n\\nOverflow/underrun error - got value = \"\n                          << std::abs(delta) << \"\\n\";\n                // return std::pair<uint32_t, double>(iter, tol_condition);\n                break_loop = true;\n            }\n\n            (*roots)[n] -= delta;\n\n#ifdef _OPENMP\n#pragma omp critical\n#endif\n            tol_condition = std::max(tol_condition, std::abs(std::abs(delta)));\n        }\n        // tol_condition /= (degree - 1);\n\n        if (break_loop)\n            break;\n\n        if (log_file.is_open()) {\n            for (n = 0; n < roots->size(); n++)\n                log_file << complex_str((*roots)[n]) << \",\";\n        }\n\n#if defined(DEBUG) || !defined(NDEBUG)\n        if (iter % 500 == 0) {\n            std::cout << \"Iter: \" << iter << \"\\t\";\n            for (n = 0; n < roots->size(); n++)\n                std::cout << \"\\t\" << complex_str((*roots)[n]);\n            std::cout << \"\\t\\tabsolute average change: \" << tol_condition\n                      << \"\\n\";\n        }\n#endif\n\n        if (log_file.is_open())\n            log_file << tol_condition;\n    }\n\n    return std::pair<uint32_t, long double>(iter, tol_condition);\n}\n\n/**\n * Self test the algorithm by checking the roots for \\f$x^2+4=0\\f$ to which the\n * roots are \\f$0 \\pm 2i\\f$\n */\nvoid test1() {\n    const std::valarray<double> coeffs = {1, 0, 4};  // x^2 - 2 = 0\n    std::valarray<std::complex<double>> roots(2);\n    std::valarray<std::complex<double>> expected = {\n        std::complex<double>(0., 2.),\n        std::complex<double>(0., -2.)  // known expected roots\n    };\n\n    /* initialize root approximations with random values */\n    for (int n = 0; n < roots.size(); n++) {\n        roots[n] = std::complex<double>(std::rand() % 100, std::rand() % 100);\n        roots[n] -= 50.f;\n        roots[n] /= 25.f;\n    }\n\n    auto result = durand_kerner_algo(coeffs, &roots, false);\n\n    for (int i = 0; i < roots.size(); i++) {\n        // check if approximations are have < 0.1% error with one of the\n        // expected roots\n        bool err1 = false;\n        for (int j = 0; j < roots.size(); j++)\n            err1 |= std::abs(std::abs(roots[i] - expected[j])) < 1e-3;\n        assert(err1);\n    }\n\n    std::cout << \"Test 1 passed! - \" << result.first << \" iterations, \"\n              << result.second << \" accuracy\"\n              << \"\\n\";\n}\n\n/**\n * Self test the algorithm by checking the roots for \\f$0.015625x^3-1=0\\f$ to\n * which the roots are \\f$(4+0i),\\,(-2\\pm3.464i)\\f$\n */\nvoid test2() {\n    const std::valarray<double> coeffs = {// 0.015625 x^3 - 1 = 0\n                                          1. / 64., 0., 0., -1.};\n    std::valarray<std::complex<double>> roots(3);\n    const std::valarray<std::complex<double>> expected = {\n        std::complex<double>(4., 0.), std::complex<double>(-2., 3.46410162),\n        std::complex<double>(-2., -3.46410162)  // known expected roots\n    };\n\n    /* initialize root approximations with random values */\n    for (int n = 0; n < roots.size(); n++) {\n        roots[n] = std::complex<double>(std::rand() % 100, std::rand() % 100);\n        roots[n] -= 50.f;\n        roots[n] /= 25.f;\n    }\n\n    auto result = durand_kerner_algo(coeffs, &roots, false);\n\n    for (int i = 0; i < roots.size(); i++) {\n        // check if approximations are have < 0.1% error with one of the\n        // expected roots\n        bool err1 = false;\n        for (int j = 0; j < roots.size(); j++)\n            err1 |= std::abs(std::abs(roots[i] - expected[j])) < 1e-3;\n        assert(err1);\n    }\n\n    std::cout << \"Test 2 passed! - \" << result.first << \" iterations, \"\n              << result.second << \" accuracy\"\n              << \"\\n\";\n}\n\n/***\n * Main function.\n * The comandline input arguments are taken as coeffiecients of a\n *polynomial. For example, this command\n * ```sh\n * ./durand_kerner_roots 1 0 -4\n * ```\n * will find roots of the polynomial \\f$1\\cdot x^2 + 0\\cdot x^1 + (-4)=0\\f$\n **/\nint main(int argc, char **argv) {\n    /* initialize random seed: */\n    std::srand(std::time(nullptr));\n\n    if (argc < 2) {\n        test1();  // run tests when no input is provided\n        test2();  // and skip tests when input polynomial is provided\n        std::cout << \"Please pass the coefficients of the polynomial as \"\n                     \"commandline \"\n                     \"arguments.\\n\";\n        return 0;\n    }\n\n    int n, degree = argc - 1;              // detected polynomial degree\n    std::valarray<double> coeffs(degree);  // create coefficiencts array\n\n    // number of roots = degree - 1\n    std::valarray<std::complex<double>> s0(degree - 1);\n\n    std::cout << \"Computing the roots for:\\n\\t\";\n    for (n = 0; n < degree; n++) {\n        coeffs[n] = strtod(argv[n + 1], nullptr);\n        if (n < degree - 1 && coeffs[n] != 0)\n            std::cout << \"(\" << coeffs[n] << \") x^\" << degree - n - 1 << \" + \";\n        else if (coeffs[n] != 0)\n            std::cout << \"(\" << coeffs[n] << \") x^\" << degree - n - 1\n                      << \" = 0\\n\";\n\n        /* initialize root approximations with random values */\n        if (n < degree - 1) {\n            s0[n] = std::complex<double>(std::rand() % 100, std::rand() % 100);\n            s0[n] -= 50.f;\n            s0[n] /= 50.f;\n        }\n    }\n\n    // numerical errors less when the first coefficient is \"1\"\n    // hence, we normalize the first coefficient\n    {\n        double tmp = coeffs[0];\n        coeffs /= tmp;\n    }\n\n    clock_t end_time, start_time = clock();\n    auto result = durand_kerner_algo(coeffs, &s0, true);\n    end_time = clock();\n\n    std::cout << \"\\nIterations: \" << result.first << \"\\n\";\n    for (n = 0; n < degree - 1; n++)\n        std::cout << \"\\t\" << complex_str(s0[n]) << \"\\n\";\n    std::cout << \"absolute average change: \" << result.second << \"\\n\";\n    std::cout << \"Time taken: \"\n              << static_cast<double>(end_time - start_time) / CLOCKS_PER_SEC\n              << \" sec\\n\";\n\n    return 0;\n}\n","index":141},{"title":"False Position","category":"numerical_methods","id":"false_position_numerical_methods","algorithm":"/**\n * \\file\n * \\brief Solve the equation \\f$f(x)=0\\f$ using [false position\n * method](https://en.wikipedia.org/wiki/Regula_falsi), also known as the Secant\n * method\n *\n * Given two points \\f$a\\f$ and \\f$b\\f$ such that \\f$f(a)<0\\f$ and\n * \\f$f(b)>0\\f$, then the \\f$(i+1)^\\text{th}\\f$ approximation is given by: \\f[\n * x_{i+1} = \\frac{a_i\\cdot f(b_i) - b_i\\cdot f(a_i)}{f(b_i) - f(a_i)}\n * \\f]\n * For the next iteration, the interval is selected\n * as: \\f$[a,x]\\f$ if \\f$x>0\\f$ or \\f$[x,b]\\f$ if \\f$x<0\\f$. The Process is\n * continued till a close enough approximation is achieved.\n *\n * \\see newton_raphson_method.cpp, bisection_method.cpp\n */\n#include <cmath>\n#include <cstdlib>\n#include <iostream>\n#include <limits>\n\n#define EPSILON \\\n    1e-6  // std::numeric_limits<double>::epsilon()  ///< system accuracy limit\n#define MAX_ITERATIONS 50000  ///< Maximum number of iterations to check\n\n/** define \\f$f(x)\\f$ to find root for\n */\nstatic double eq(double i) {\n    return (std::pow(i, 3) - (4 * i) - 9);  // origial equation\n}\n\n/** get the sign of any given number */\ntemplate <typename T>\nint sgn(T val) {\n    return (T(0) < val) - (val < T(0));\n}\n\n/** main function */\nint main() {\n    double a = -1, b = 1, x, z, m, n, c;\n    int i;\n\n    // loop to find initial intervals a, b\n    for (int i = 0; i < MAX_ITERATIONS; i++) {\n        z = eq(a);\n        x = eq(b);\n        if (sgn(z) == sgn(x)) {  // same signs, increase interval\n            b++;\n            a--;\n        } else {  // if opposite signs, we got our interval\n            break;\n        }\n    }\n\n    std::cout << \"\\nFirst initial: \" << a;\n    std::cout << \"\\nSecond initial: \" << b;\n\n    for (i = 0; i < MAX_ITERATIONS; i++) {\n        m = eq(a);\n        n = eq(b);\n\n        c = ((a * n) - (b * m)) / (n - m);\n\n        a = c;\n        z = eq(c);\n\n        if (std::abs(z) < EPSILON) {  // stoping criteria\n            break;\n        }\n    }\n\n    std::cout << \"\\n\\nRoot: \" << c << \"\\t\\tSteps: \" << i << std::endl;\n    return 0;\n}\n","index":142},{"title":"Gaussian Elimination","category":"numerical_methods","id":"gaussian_elimination_numerical_methods","algorithm":"/**\n * \\file\n * \\brief [Gaussian elimination\n * method](https://en.wikipedia.org/wiki/Gaussian_elimination)\n */\n#include <iostream>\n\n/** Main function */\nint main() {\n    int mat_size, i, j, step;\n\n    std::cout << \"Matrix size: \";\n    std::cin >> mat_size;\n\n    // create a 2D matrix by dynamic memory allocation\n    double **mat = new double *[mat_size + 1], **x = new double *[mat_size];\n    for (i = 0; i <= mat_size; i++) {\n        mat[i] = new double[mat_size + 1];\n        if (i < mat_size)\n            x[i] = new double[mat_size + 1];\n    }\n\n    // get the matrix elements from user\n    std::cout << std::endl << \"Enter value of the matrix: \" << std::endl;\n    for (i = 0; i < mat_size; i++) {\n        for (j = 0; j <= mat_size; j++) {\n            std::cin >>\n                mat[i][j];  // Enter (mat_size*mat_size) value of the matrix.\n        }\n    }\n\n    // perform Gaussian elimination\n    for (step = 0; step < mat_size - 1; step++) {\n        for (i = step; i < mat_size - 1; i++) {\n            double a = (mat[i + 1][step] / mat[step][step]);\n\n            for (j = step; j <= mat_size; j++)\n                mat[i + 1][j] = mat[i + 1][j] - (a * mat[step][j]);\n        }\n    }\n\n    std::cout << std::endl\n              << \"Matrix using Gaussian Elimination method: \" << std::endl;\n    for (i = 0; i < mat_size; i++) {\n        for (j = 0; j <= mat_size; j++) {\n            x[i][j] = mat[i][j];\n            std::cout << mat[i][j] << \" \";\n        }\n        std::cout << std::endl;\n    }\n    std::cout << std::endl\n              << \"Value of the Gaussian Elimination method: \" << std::endl;\n    for (i = mat_size - 1; i >= 0; i--) {\n        double sum = 0;\n        for (j = mat_size - 1; j > i; j--) {\n            x[i][j] = x[j][j] * x[i][j];\n            sum = x[i][j] + sum;\n        }\n        if (x[i][i] == 0)\n            x[i][i] = 0;\n        else\n            x[i][i] = (x[i][mat_size] - sum) / (x[i][i]);\n\n        std::cout << \"x\" << i << \"= \" << x[i][i] << std::endl;\n    }\n\n    for (i = 0; i <= mat_size; i++) {\n        delete[] mat[i];\n        if (i < mat_size)\n            delete[] x[i];\n    }\n    delete[] mat;\n    delete[] x;\n\n    return 0;\n}\n","index":143},{"title":"Golden Search Extrema","category":"numerical_methods","id":"golden_search_extrema_numerical_methods","algorithm":"/**\n * \\file\n * \\brief Find extrema of a univariate real function in a given interval using\n * [golden section search\n * algorithm](https://en.wikipedia.org/wiki/Golden-section_search).\n *\n * \\see brent_method_extrema.cpp\n * \\author [Krishna Vedala](https://github.com/kvedala)\n */\n#define _USE_MATH_DEFINES  //< required for MS Visual C++\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iostream>\n#include <limits>\n\n#define EPSILON 1e-7  ///< solution accuracy limit\n\n/**\n * @brief Get the minima of a function in the given interval. To get the maxima,\n * simply negate the function. The golden ratio used here is:\\f[\n * k=\\frac{3-\\sqrt{5}}{2} \\approx 0.381966\\ldots\\f]\n *\n * @param f function to get minima for\n * @param lim_a lower limit of search window\n * @param lim_b upper limit of search window\n * @return local minima found in the interval\n */\ndouble get_minima(const std::function<double(double)> &f, double lim_a,\n                  double lim_b) {\n    uint32_t iters = 0;\n    double c, d;\n    double prev_mean, mean = std::numeric_limits<double>::infinity();\n\n    // golden ratio value\n    const double M_GOLDEN_RATIO = (1.f + std::sqrt(5.f)) / 2.f;\n\n    // ensure that lim_a < lim_b\n    if (lim_a > lim_b) {\n        std::swap(lim_a, lim_b);\n    } else if (std::abs(lim_a - lim_b) <= EPSILON) {\n        std::cerr << \"Search range must be greater than \" << EPSILON << \"\\n\";\n        return lim_a;\n    }\n\n    do {\n        prev_mean = mean;\n\n        // compute the section ratio width\n        double ratio = (lim_b - lim_a) / M_GOLDEN_RATIO;\n        c = lim_b - ratio;  // right-side section start\n        d = lim_a + ratio;  // left-side section end\n\n        if (f(c) < f(d)) {\n            // select left section\n            lim_b = d;\n        } else {\n            // selct right section\n            lim_a = c;\n        }\n\n        mean = (lim_a + lim_b) / 2.f;\n        iters++;\n\n        // continue till the interval width is greater than sqrt(system epsilon)\n    } while (std::abs(lim_a - lim_b) > EPSILON);\n\n    std::cout << \" (iters: \" << iters << \") \";\n    return prev_mean;\n}\n\n/**\n * @brief Test function to find minima for the function\n * \\f$f(x)= (x-2)^2\\f$\n * in the interval \\f$[1,5]\\f$\n * \\n Expected result = 2\n */\nvoid test1() {\n    // define the function to minimize as a lambda function\n    std::function<double(double)> f1 = [](double x) {\n        return (x - 2) * (x - 2);\n    };\n\n    std::cout << \"Test 1.... \";\n\n    double minima = get_minima(f1, 1, 5);\n\n    std::cout << minima << \"...\";\n\n    assert(std::abs(minima - 2) < EPSILON);\n    std::cout << \"passed\\n\";\n}\n\n/**\n * @brief Test function to find *maxima* for the function\n * \\f$f(x)= x^{\\frac{1}{x}}\\f$\n * in the interval \\f$[-2,10]\\f$\n * \\n Expected result: \\f$e\\approx 2.71828182845904509\\f$\n */\nvoid test2() {\n    // define the function to maximize as a lambda function\n    // since we are maximixing, we negated the function return value\n    std::function<double(double)> func = [](double x) {\n        return -std::pow(x, 1.f / x);\n    };\n\n    std::cout << \"Test 2.... \";\n\n    double minima = get_minima(func, -2, 10);\n\n    std::cout << minima << \" (\" << M_E << \")...\";\n\n    assert(std::abs(minima - M_E) < EPSILON);\n    std::cout << \"passed\\n\";\n}\n\n/**\n * @brief Test function to find *maxima* for the function\n * \\f$f(x)= \\cos x\\f$\n * in the interval \\f$[0,12]\\f$\n * \\n Expected result: \\f$\\pi\\approx 3.14159265358979312\\f$\n */\nvoid test3() {\n    // define the function to maximize as a lambda function\n    // since we are maximixing, we negated the function return value\n    std::function<double(double)> func = [](double x) { return std::cos(x); };\n\n    std::cout << \"Test 3.... \";\n\n    double minima = get_minima(func, -4, 12);\n\n    std::cout << minima << \" (\" << M_PI << \")...\";\n\n    assert(std::abs(minima - M_PI) < EPSILON);\n    std::cout << \"passed\\n\";\n}\n\n/** Main function */\nint main() {\n    std::cout.precision(9);\n\n    std::cout << \"Computations performed with machine epsilon: \" << EPSILON\n              << \"\\n\";\n\n    test1();\n    test2();\n    test3();\n\n    return 0;\n}\n","index":144},{"title":"Lu Decompose","category":"numerical_methods","id":"lu_decompose_numerical_methods","algorithm":"/**\n * \\file\n * \\brief [LU decomposition](https://en.wikipedia.org/wiki/LU_decompositon) of a\n * square matrix\n * \\author [Krishna Vedala](https://github.com/kvedala)\n */\n#include <cassert>\n#include <ctime>\n#include <iomanip>\n#include <iostream>\n\n#include \"./lu_decomposition.h\"\n\n/**\n * operator to print a matrix\n */\ntemplate <typename T>\nstd::ostream &operator<<(std::ostream &out, matrix<T> const &v) {\n    const int width = 10;\n    const char separator = ' ';\n\n    for (size_t row = 0; row < v.size(); row++) {\n        for (size_t col = 0; col < v[row].size(); col++)\n            out << std::left << std::setw(width) << std::setfill(separator)\n                << v[row][col];\n        out << std::endl;\n    }\n\n    return out;\n}\n\n/**\n * Test LU decomposition\n * \\todo better ways to self-check a matrix output?\n */\nvoid test1() {\n    int mat_size = 3;  // default matrix size\n    const int range = 50;\n    const int range2 = range >> 1;\n\n    /* Create a square matrix with random values */\n    matrix<double> A(mat_size, std::valarray<double>(mat_size));\n    matrix<double> L(mat_size, std::valarray<double>(mat_size));  // output\n    matrix<double> U(mat_size, std::valarray<double>(mat_size));  // output\n    for (int i = 0; i < mat_size; i++) {\n        // calloc so that all valeus are '0' by default\n        for (int j = 0; j < mat_size; j++)\n            /* create random values in the limits [-range2, range-1] */\n            A[i][j] = static_cast<double>(std::rand() % range - range2);\n    }\n\n    std::clock_t start_t = std::clock();\n    lu_decomposition(A, &L, &U);\n    std::clock_t end_t = std::clock();\n    std::cout << \"Time taken: \"\n              << static_cast<double>(end_t - start_t) / CLOCKS_PER_SEC << \"\\n\";\n\n    std::cout << \"A = \\n\" << A << \"\\n\";\n    std::cout << \"L = \\n\" << L << \"\\n\";\n    std::cout << \"U = \\n\" << U << \"\\n\";\n}\n\n/**\n * Test determinant computation using LU decomposition\n */\nvoid test2() {\n    std::cout << \"Determinant test 1...\";\n    matrix<int> A1({{1, 2, 3}, {4, 9, 6}, {7, 8, 9}});\n    assert(determinant_lu(A1) == -48);\n    std::cout << \"passed\\n\";\n\n    std::cout << \"Determinant test 2...\";\n    matrix<int> A2({{1, 2, 3}, {4, 5, 6}, {7, 8, 9}});\n    assert(determinant_lu(A2) == 0);\n    std::cout << \"passed\\n\";\n\n    std::cout << \"Determinant test 3...\";\n    matrix<float> A3({{1.2, 2.3, 3.4}, {4.5, 5.6, 6.7}, {7.8, 8.9, 9.0}});\n    assert(determinant_lu(A3) == 3.63);\n    std::cout << \"passed\\n\";\n}\n\n/** Main function */\nint main(int argc, char **argv) {\n    std::srand(std::time(NULL));  // random number initializer\n\n    test1();\n    test2();\n    return 0;\n}\n","index":145},{"title":"Lu Decomposition.h","category":"numerical_methods","id":"lu_decomposition.h_numerical_methods","algorithm":"/**\n * @file lu_decomposition.h\n * @author [Krishna Vedala](https://github.com/kvedala)\n * @brief Functions associated with [LU\n * Decomposition](https://en.wikipedia.org/wiki/LU_decomposition)\n * of a square matrix.\n */\n#pragma once\n\n#include <iostream>\n#include <valarray>\n#include <vector>\n#ifdef _OPENMP\n#include <omp.h>\n#endif\n\n/** Define matrix type as a `std::vector` of `std::valarray` */\ntemplate <typename T>\nusing matrix = std::vector<std::valarray<T>>;\n\n/** Perform LU decomposition on matrix\n * \\param[in] A matrix to decompose\n * \\param[out] L output L matrix\n * \\param[out] U output U matrix\n * \\returns 0 if no errors\n * \\returns negative if error occurred\n */\ntemplate <typename T>\nint lu_decomposition(const matrix<T> &A, matrix<double> *L, matrix<double> *U) {\n    int row, col, j;\n    int mat_size = A.size();\n\n    if (mat_size != A[0].size()) {\n        // check matrix is a square matrix\n        std::cerr << \"Not a square matrix!\\n\";\n        return -1;\n    }\n\n    // regularize each row\n    for (row = 0; row < mat_size; row++) {\n        // Upper triangular matrix\n#ifdef _OPENMP\n#pragma omp for\n#endif\n        for (col = row; col < mat_size; col++) {\n            // Summation of L[i,j] * U[j,k]\n            double lu_sum = 0.;\n            for (j = 0; j < row; j++) {\n                lu_sum += L[0][row][j] * U[0][j][col];\n            }\n\n            // Evaluate U[i,k]\n            U[0][row][col] = A[row][col] - lu_sum;\n        }\n\n        // Lower triangular matrix\n#ifdef _OPENMP\n#pragma omp for\n#endif\n        for (col = row; col < mat_size; col++) {\n            if (row == col) {\n                L[0][row][col] = 1.;\n                continue;\n            }\n\n            // Summation of L[i,j] * U[j,k]\n            double lu_sum = 0.;\n            for (j = 0; j < row; j++) {\n                lu_sum += L[0][col][j] * U[0][j][row];\n            }\n\n            // Evaluate U[i,k]\n            L[0][col][row] = (A[col][row] - lu_sum) / U[0][row][row];\n        }\n    }\n\n    return 0;\n}\n\n/**\n * Compute determinant of an NxN square matrix using LU decomposition.\n * Using LU decomposition, the determinant is given by the product of diagonal\n * elements of matrices L and U.\n *\n * @tparam T datatype of input matrix - int, unsigned int, double, etc\n * @param A input square matrix\n * @return determinant of matrix A\n */\ntemplate <typename T>\ndouble determinant_lu(const matrix<T> &A) {\n    matrix<double> L(A.size(), std::valarray<double>(A.size()));\n    matrix<double> U(A.size(), std::valarray<double>(A.size()));\n\n    if (lu_decomposition(A, &L, &U) < 0)\n        return 0;\n\n    double result = 1.f;\n    for (size_t i = 0; i < A.size(); i++) {\n        result *= L[i][i] * U[i][i];\n    }\n    return result;\n}\n","index":146},{"title":"Newton Raphson Method","category":"numerical_methods","id":"newton_raphson_method_numerical_methods","algorithm":"/**\n * \\file\n * \\brief Solve the equation \\f$f(x)=0\\f$ using [Newton-Raphson\n * method](https://en.wikipedia.org/wiki/Newton%27s_method) for both real and\n * complex solutions\n *\n * The \\f$(i+1)^\\text{th}\\f$ approximation is given by:\n * \\f[\n * x_{i+1} = x_i - \\frac{f(x_i)}{f'(x_i)}\n * \\f]\n *\n * \\author [Krishna Vedala](https://github.com/kvedala)\n * \\see bisection_method.cpp, false_position.cpp\n */\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <limits>\n\nconstexpr double EPSILON = 1e-10;              ///< system accuracy limit\nconstexpr int16_t MAX_ITERATIONS = INT16_MAX;  ///< Maximum number of iterations\n\n/** define \\f$f(x)\\f$ to find root for.\n * Currently defined as:\n * \\f[\n * f(x) = x^3 - 4x - 9\n * \\f]\n */\nstatic double eq(double i) {\n    return (std::pow(i, 3) - (4 * i) - 9);  // original equation\n}\n\n/** define the derivative function \\f$f'(x)\\f$\n * For the current problem, it is:\n * \\f[\n * f'(x) = 3x^2 - 4\n * \\f]\n */\nstatic double eq_der(double i) {\n    return ((3 * std::pow(i, 2)) - 4);  // derivative of equation\n}\n\n/** Main function */\nint main() {\n    std::srand(std::time(nullptr));  // initialize randomizer\n\n    double z = NAN, c = std::rand() % 100, m = NAN, n = NAN;\n    int i = 0;\n\n    std::cout << \"\\nInitial approximation: \" << c;\n\n    // start iterations\n    for (i = 0; i < MAX_ITERATIONS; i++) {\n        m = eq(c);\n        n = eq_der(c);\n\n        z = c - (m / n);\n        c = z;\n\n        if (std::abs(m) < EPSILON) {  // stoping criteria\n            break;\n        }\n    }\n\n    std::cout << \"\\n\\nRoot: \" << z << \"\\t\\tSteps: \" << i << std::endl;\n    return 0;\n}\n","index":147},{"title":"Ode Forward Euler","category":"numerical_methods","id":"ode_forward_euler_numerical_methods","algorithm":"/**\n * \\file\n * \\authors [Krishna Vedala](https://github.com/kvedala)\n * \\brief Solve a multivariable first order [ordinary differential equation\n * (ODEs)](https://en.wikipedia.org/wiki/Ordinary_differential_equation) using\n * [forward Euler\n * method](https://en.wikipedia.org/wiki/Numerical_methods_for_ordinary_differential_equations#Euler_method)\n *\n * \\details\n * The ODE being solved is:\n * \\f{eqnarray*}{\n * \\dot{u} &=& v\\\\\n * \\dot{v} &=& -\\omega^2 u\\\\\n * \\omega &=& 1\\\\\n * [x_0, u_0, v_0] &=& [0,1,0]\\qquad\\ldots\\text{(initial values)}\n * \\f}\n * The exact solution for the above problem is:\n * \\f{eqnarray*}{\n * u(x) &=& \\cos(x)\\\\\n * v(x) &=& -\\sin(x)\\\\\n * \\f}\n * The computation results are stored to a text file `forward_euler.csv` and the\n * exact soltuion results in `exact.csv` for comparison.\n * <img\n * src=\"https://raw.githubusercontent.com/TheAlgorithms/C-Plus-Plus/docs/images/numerical_methods/ode_forward_euler.svg\"\n * alt=\"Implementation solution\"/>\n *\n * To implement [Van der Pol\n * oscillator](https://en.wikipedia.org/wiki/Van_der_Pol_oscillator), change the\n * ::problem function to:\n * ```cpp\n * const double mu = 2.0;\n * dy[0] = y[1];\n * dy[1] = mu * (1.f - y[0] * y[0]) * y[1] - y[0];\n * ```\n * \\see ode_midpoint_euler.cpp, ode_semi_implicit_euler.cpp\n */\n\n#include <cmath>\n#include <ctime>\n#include <fstream>\n#include <iostream>\n#include <valarray>\n\n/**\n * @brief Problem statement for a system with first-order differential\n * equations. Updates the system differential variables.\n * \\note This function can be updated to and ode of any order.\n *\n * @param[in] \t\tx \t\tindependent variable(s)\n * @param[in,out]\ty\t\tdependent variable(s)\n * @param[in,out]\tdy\t    first-derivative of dependent variable(s)\n */\nvoid problem(const double &x, std::valarray<double> *y,\n             std::valarray<double> *dy) {\n    const double omega = 1.F;             // some const for the problem\n    (*dy)[0] = (*y)[1];                   // x dot // NOLINT\n    (*dy)[1] = -omega * omega * (*y)[0];  // y dot // NOLINT\n}\n\n/**\n * @brief Exact solution of the problem. Used for solution comparison.\n *\n * @param[in] \t\tx \t\tindependent variable\n * @param[in,out]\ty\t\tdependent variable\n */\nvoid exact_solution(const double &x, std::valarray<double> *y) {\n    y[0][0] = std::cos(x);\n    y[0][1] = -std::sin(x);\n}\n\n/** \\addtogroup ode Ordinary Differential Equations\n * Integration functions for implementations with solving [ordinary differential\n * equations](https://en.wikipedia.org/wiki/Ordinary_differential_equation)\n * (ODEs) of any order and and any number of independent variables.\n * @{\n */\n/**\n * @brief Compute next step approximation using the forward-Euler\n * method. @f[y_{n+1}=y_n + dx\\cdot f\\left(x_n,y_n\\right)@f]\n * @param[in] \t\tdx\tstep size\n * @param[in] \t    x\ttake \\f$x_n\\f$ and compute \\f$x_{n+1}\\f$\n * @param[in,out] \ty\ttake \\f$y_n\\f$ and compute \\f$y_{n+1}\\f$\n * @param[in,out]\tdy\tcompute \\f$f\\left(x_n,y_n\\right)\\f$\n */\nvoid forward_euler_step(const double dx, const double x,\n                        std::valarray<double> *y, std::valarray<double> *dy) {\n    problem(x, y, dy);\n    *y += *dy * dx;\n}\n\n/**\n * @brief Compute approximation using the forward-Euler\n * method in the given limits.\n * @param[in] \t\tdx  \tstep size\n * @param[in]   \tx0  \tinitial value of independent variable\n * @param[in] \t    x_max\tfinal value of independent variable\n * @param[in,out] \ty\t    take \\f$y_n\\f$ and compute \\f$y_{n+1}\\f$\n * @param[in] save_to_file\tflag to save results to a CSV file (1) or not (0)\n * @returns time taken for computation in seconds\n */\ndouble forward_euler(double dx, double x0, double x_max,\n                     std::valarray<double> *y, bool save_to_file = false) {\n    std::valarray<double> dy = *y;\n\n    std::ofstream fp;\n    if (save_to_file) {\n        fp.open(\"forward_euler.csv\", std::ofstream::out);\n        if (!fp.is_open()) {\n            std::perror(\"Error! \");\n        }\n    }\n\n    std::size_t L = y->size();\n\n    /* start integration */\n    std::clock_t t1 = std::clock();\n    double x = x0;\n\n    do {  // iterate for each step of independent variable\n        if (save_to_file && fp.is_open()) {\n            // write to file\n            fp << x << \",\";\n            for (int i = 0; i < L - 1; i++) {\n                fp << y[0][i] << \",\";  // NOLINT\n            }\n            fp << y[0][L - 1] << \"\\n\";  // NOLINT\n        }\n\n        forward_euler_step(dx, x, y, &dy);  // perform integration\n        x += dx;                            // update step\n    } while (x <= x_max);  // till upper limit of independent variable\n    /* end of integration */\n    std::clock_t t2 = std::clock();\n\n    if (fp.is_open()) {\n        fp.close();\n    }\n\n    return static_cast<double>(t2 - t1) / CLOCKS_PER_SEC;\n}\n\n/** @} */\n\n/**\n * Function to compute and save exact solution for comparison\n *\n * \\param [in]    X0  \t    initial value of independent variable\n * \\param [in] \t  X_MAX\t    final value of independent variable\n * \\param [in] \t  step_size\tindependent variable step size\n * \\param [in]    Y0\t    initial values of dependent variables\n */\nvoid save_exact_solution(const double &X0, const double &X_MAX,\n                         const double &step_size,\n                         const std::valarray<double> &Y0) {\n    double x = X0;\n    std::valarray<double> y(Y0);\n\n    std::ofstream fp(\"exact.csv\", std::ostream::out);\n    if (!fp.is_open()) {\n        std::perror(\"Error! \");\n        return;\n    }\n    std::cout << \"Finding exact solution\\n\";\n\n    std::clock_t t1 = std::clock();\n    do {\n        fp << x << \",\";\n        for (int i = 0; i < y.size() - 1; i++) {\n            fp << y[i] << \",\";  // NOLINT\n        }\n        fp << y[y.size() - 1] << \"\\n\";  // NOLINT\n\n        exact_solution(x, &y);\n\n        x += step_size;\n    } while (x <= X_MAX);\n\n    std::clock_t t2 = std::clock();\n    double total_time = static_cast<double>(t2 - t1) / CLOCKS_PER_SEC;\n    std::cout << \"\\tTime = \" << total_time << \" ms\\n\";\n\n    fp.close();\n}\n\n/**\n * Main Function\n */\nint main(int argc, char *argv[]) {\n    double X0 = 0.f;                    /* initial value of x0 */\n    double X_MAX = 10.F;                /* upper limit of integration */\n    std::valarray<double> Y0{1.f, 0.f}; /* initial value Y = y(x = x_0) */\n    double step_size = NAN;\n\n    if (argc == 1) {\n        std::cout << \"\\nEnter the step size: \";\n        std::cin >> step_size;\n    } else {\n        // use commandline argument as independent variable step size\n        step_size = std::atof(argv[1]);\n    }\n\n    // get approximate solution\n    double total_time = forward_euler(step_size, X0, X_MAX, &Y0, true);\n    std::cout << \"\\tTime = \" << total_time << \" ms\\n\";\n\n    /* compute exact solution for comparion */\n    save_exact_solution(X0, X_MAX, step_size, Y0);\n\n    return 0;\n}\n","index":148},{"title":"Ode Midpoint Euler","category":"numerical_methods","id":"ode_midpoint_euler_numerical_methods","algorithm":"/**\n * \\file\n * \\authors [Krishna Vedala](https://github.com/kvedala)\n * \\brief Solve a multivariable first order [ordinary differential equation\n * (ODEs)](https://en.wikipedia.org/wiki/Ordinary_differential_equation) using\n * [midpoint Euler\n * method](https://en.wikipedia.org/wiki/Midpoint_method)\n *\n * \\details\n * The ODE being solved is:\n * \\f{eqnarray*}{\n * \\dot{u} &=& v\\\\\n * \\dot{v} &=& -\\omega^2 u\\\\\n * \\omega &=& 1\\\\\n * [x_0, u_0, v_0] &=& [0,1,0]\\qquad\\ldots\\text{(initial values)}\n * \\f}\n * The exact solution for the above problem is:\n * \\f{eqnarray*}{\n * u(x) &=& \\cos(x)\\\\\n * v(x) &=& -\\sin(x)\\\\\n * \\f}\n * The computation results are stored to a text file `midpoint_euler.csv` and\n * the exact soltuion results in `exact.csv` for comparison. <img\n * src=\"https://raw.githubusercontent.com/TheAlgorithms/C-Plus-Plus/docs/images/numerical_methods/ode_midpoint_euler.svg\"\n * alt=\"Implementation solution\"/>\n *\n * To implement [Van der Pol\n * oscillator](https://en.wikipedia.org/wiki/Van_der_Pol_oscillator), change the\n * ::problem function to:\n * ```cpp\n * const double mu = 2.0;\n * dy[0] = y[1];\n * dy[1] = mu * (1.f - y[0] * y[0]) * y[1] - y[0];\n * ```\n * \\see ode_forward_euler.cpp, ode_semi_implicit_euler.cpp\n */\n\n#include <cmath>\n#include <ctime>\n#include <fstream>\n#include <iostream>\n#include <valarray>\n\n/**\n * @brief Problem statement for a system with first-order differential\n * equations. Updates the system differential variables.\n * \\note This function can be updated to and ode of any order.\n *\n * @param[in] \t\tx \t\tindependent variable(s)\n * @param[in,out]\ty\t\tdependent variable(s)\n * @param[in,out]\tdy\t    first-derivative of dependent variable(s)\n */\nvoid problem(const double &x, std::valarray<double> *y,\n             std::valarray<double> *dy) {\n    const double omega = 1.F;             // some const for the problem\n    dy[0][0] = y[0][1];                   // x dot\n    dy[0][1] = -omega * omega * y[0][0];  // y dot\n}\n\n/**\n * @brief Exact solution of the problem. Used for solution comparison.\n *\n * @param[in] \t\tx \t\tindependent variable\n * @param[in,out]\ty\t\tdependent variable\n */\nvoid exact_solution(const double &x, std::valarray<double> *y) {\n    y[0][0] = std::cos(x);\n    y[0][1] = -std::sin(x);\n}\n\n/** \\addtogroup ode Ordinary Differential Equations\n * @{\n */\n/**\n * @brief Compute next step approximation using the midpoint-Euler\n * method.\n * @f[y_{n+1} = y_n + dx\\, f\\left(x_n+\\frac{1}{2}dx,\n * y_n + \\frac{1}{2}dx\\,f\\left(x_n,y_n\\right)\\right)@f]\n *\n * @param[in] \t\tdx\tstep size\n * @param[in] \t    x\ttake \\f$x_n\\f$ and compute \\f$x_{n+1}\\f$\n * @param[in,out] \ty\ttake \\f$y_n\\f$ and compute \\f$y_{n+1}\\f$\n * @param[in,out]\tdy\tcompute \\f$f\\left(x_n,y_n\\right)\\f$\n */\nvoid midpoint_euler_step(const double dx, const double &x,\n                         std::valarray<double> *y, std::valarray<double> *dy) {\n    problem(x, y, dy);\n    double tmp_x = x + 0.5 * dx;\n\n    std::valarray<double> tmp_y = y[0] + dy[0] * (0.5 * dx);\n\n    problem(tmp_x, &tmp_y, dy);\n\n    y[0] += dy[0] * dx;\n}\n\n/**\n * @brief Compute approximation using the midpoint-Euler\n * method in the given limits.\n * @param[in] \t\tdx  \tstep size\n * @param[in]   \tx0  \tinitial value of independent variable\n * @param[in] \t    x_max\tfinal value of independent variable\n * @param[in,out] \ty\t    take \\f$y_n\\f$ and compute \\f$y_{n+1}\\f$\n * @param[in] save_to_file\tflag to save results to a CSV file (1) or not (0)\n * @returns time taken for computation in seconds\n */\ndouble midpoint_euler(double dx, double x0, double x_max,\n                      std::valarray<double> *y, bool save_to_file = false) {\n    std::valarray<double> dy = y[0];\n\n    std::ofstream fp;\n    if (save_to_file) {\n        fp.open(\"midpoint_euler.csv\", std::ofstream::out);\n        if (!fp.is_open()) {\n            std::perror(\"Error! \");\n        }\n    }\n\n    std::size_t L = y->size();\n\n    /* start integration */\n    std::clock_t t1 = std::clock();\n    double x = x0;\n    do {  // iterate for each step of independent variable\n        if (save_to_file && fp.is_open()) {\n            // write to file\n            fp << x << \",\";\n            for (int i = 0; i < L - 1; i++) {\n                fp << y[0][i] << \",\";\n            }\n            fp << y[0][L - 1] << \"\\n\";\n        }\n\n        midpoint_euler_step(dx, x, y, &dy);  // perform integration\n        x += dx;                             // update step\n    } while (x <= x_max);  // till upper limit of independent variable\n    /* end of integration */\n    std::clock_t t2 = std::clock();\n\n    if (fp.is_open())\n        fp.close();\n\n    return static_cast<double>(t2 - t1) / CLOCKS_PER_SEC;\n}\n\n/** @} */\n\n/**\n * Function to compute and save exact solution for comparison\n *\n * \\param [in]    X0  \t    initial value of independent variable\n * \\param [in] \t  X_MAX\t    final value of independent variable\n * \\param [in] \t  step_size\tindependent variable step size\n * \\param [in]    Y0\t    initial values of dependent variables\n */\nvoid save_exact_solution(const double &X0, const double &X_MAX,\n                         const double &step_size,\n                         const std::valarray<double> &Y0) {\n    double x = X0;\n    std::valarray<double> y = Y0;\n\n    std::ofstream fp(\"exact.csv\", std::ostream::out);\n    if (!fp.is_open()) {\n        std::perror(\"Error! \");\n        return;\n    }\n    std::cout << \"Finding exact solution\\n\";\n\n    std::clock_t t1 = std::clock();\n    do {\n        fp << x << \",\";\n        for (int i = 0; i < y.size() - 1; i++) {\n            fp << y[i] << \",\";\n        }\n        fp << y[y.size() - 1] << \"\\n\";\n\n        exact_solution(x, &y);\n\n        x += step_size;\n    } while (x <= X_MAX);\n\n    std::clock_t t2 = std::clock();\n    double total_time = static_cast<double>(t2 - t1) / CLOCKS_PER_SEC;\n    std::cout << \"\\tTime = \" << total_time << \" ms\\n\";\n\n    fp.close();\n}\n\n/**\n * Main Function\n */\nint main(int argc, char *argv[]) {\n    double X0 = 0.f;                       /* initial value of x0 */\n    double X_MAX = 10.F;                   /* upper limit of integration */\n    std::valarray<double> Y0 = {1.f, 0.f}; /* initial value Y = y(x = x_0) */\n    double step_size;\n\n    if (argc == 1) {\n        std::cout << \"\\nEnter the step size: \";\n        std::cin >> step_size;\n    } else {\n        // use commandline argument as independent variable step size\n        step_size = std::atof(argv[1]);\n    }\n\n    // get approximate solution\n    double total_time = midpoint_euler(step_size, X0, X_MAX, &Y0, true);\n    std::cout << \"\\tTime = \" << total_time << \" ms\\n\";\n\n    /* compute exact solution for comparion */\n    save_exact_solution(X0, X_MAX, step_size, Y0);\n\n    return 0;\n}\n","index":149},{"title":"Ode Semi Implicit Euler","category":"numerical_methods","id":"ode_semi_implicit_euler_numerical_methods","algorithm":"/**\n * \\file\n * \\authors [Krishna Vedala](https://github.com/kvedala)\n * \\brief Solve a multivariable first order [ordinary differential equation\n * (ODEs)](https://en.wikipedia.org/wiki/Ordinary_differential_equation) using\n * [semi implicit Euler\n * method](https://en.wikipedia.org/wiki/Semi-implicit_Euler_method)\n *\n * \\details\n * The ODE being solved is:\n * \\f{eqnarray*}{\n * \\dot{u} &=& v\\\\\n * \\dot{v} &=& -\\omega^2 u\\\\\n * \\omega &=& 1\\\\\n * [x_0, u_0, v_0] &=& [0,1,0]\\qquad\\ldots\\text{(initial values)}\n * \\f}\n * The exact solution for the above problem is:\n * \\f{eqnarray*}{\n * u(x) &=& \\cos(x)\\\\\n * v(x) &=& -\\sin(x)\\\\\n * \\f}\n * The computation results are stored to a text file `semi_implicit_euler.csv`\n * and the exact soltuion results in `exact.csv` for comparison. <img\n * src=\"https://raw.githubusercontent.com/TheAlgorithms/C-Plus-Plus/docs/images/numerical_methods/ode_semi_implicit_euler.svg\"\n * alt=\"Implementation solution\"/>\n *\n * To implement [Van der Pol\n * oscillator](https://en.wikipedia.org/wiki/Van_der_Pol_oscillator), change the\n * ::problem function to:\n * ```cpp\n * const double mu = 2.0;\n * dy[0] = y[1];\n * dy[1] = mu * (1.f - y[0] * y[0]) * y[1] - y[0];\n * ```\n * \\see ode_midpoint_euler.cpp, ode_forward_euler.cpp\n */\n\n#include <cmath>\n#include <ctime>\n#include <fstream>\n#include <iostream>\n#include <valarray>\n\n/**\n * @brief Problem statement for a system with first-order differential\n * equations. Updates the system differential variables.\n * \\note This function can be updated to and ode of any order.\n *\n * @param[in] \t\tx \t\tindependent variable(s)\n * @param[in,out]\ty\t\tdependent variable(s)\n * @param[in,out]\tdy\t    first-derivative of dependent variable(s)\n */\nvoid problem(const double &x, std::valarray<double> *y,\n             std::valarray<double> *dy) {\n    const double omega = 1.F;             // some const for the problem\n    dy[0][0] = y[0][1];                   // x dot\n    dy[0][1] = -omega * omega * y[0][0];  // y dot\n}\n\n/**\n * @brief Exact solution of the problem. Used for solution comparison.\n *\n * @param[in] \t\tx \t\tindependent variable\n * @param[in,out]\ty\t\tdependent variable\n */\nvoid exact_solution(const double &x, std::valarray<double> *y) {\n    y[0][0] = std::cos(x);\n    y[0][1] = -std::sin(x);\n}\n\n/** \\addtogroup ode Ordinary Differential Equations\n * @{\n */\n/**\n * @brief Compute next step approximation using the semi-implicit-Euler\n * method. @f[y_{n+1}=y_n + dx\\cdot f\\left(x_n,y_n\\right)@f]\n * @param[in] \t\tdx\tstep size\n * @param[in] \t    x\ttake \\f$x_n\\f$ and compute \\f$x_{n+1}\\f$\n * @param[in,out] \ty\ttake \\f$y_n\\f$ and compute \\f$y_{n+1}\\f$\n * @param[in,out]\tdy\tcompute \\f$f\\left(x_n,y_n\\right)\\f$\n */\nvoid semi_implicit_euler_step(const double dx, const double &x,\n                              std::valarray<double> *y,\n                              std::valarray<double> *dy) {\n    problem(x, y, dy);         // update dy once\n    y[0][0] += dx * dy[0][0];  // update y0\n    problem(x, y, dy);         // update dy once more\n\n    dy[0][0] = 0.f;      // ignore y0\n    y[0] += dy[0] * dx;  // update remaining using new dy\n}\n\n/**\n * @brief Compute approximation using the semi-implicit-Euler\n * method in the given limits.\n * @param[in] \t\tdx  \tstep size\n * @param[in]   \tx0  \tinitial value of independent variable\n * @param[in] \t    x_max\tfinal value of independent variable\n * @param[in,out] \ty\t    take \\f$y_n\\f$ and compute \\f$y_{n+1}\\f$\n * @param[in] save_to_file\tflag to save results to a CSV file (1) or not (0)\n * @returns time taken for computation in seconds\n */\ndouble semi_implicit_euler(double dx, double x0, double x_max,\n                           std::valarray<double> *y,\n                           bool save_to_file = false) {\n    std::valarray<double> dy = y[0];\n\n    std::ofstream fp;\n    if (save_to_file) {\n        fp.open(\"semi_implicit_euler.csv\", std::ofstream::out);\n        if (!fp.is_open()) {\n            std::perror(\"Error! \");\n        }\n    }\n\n    std::size_t L = y->size();\n\n    /* start integration */\n    std::clock_t t1 = std::clock();\n    double x = x0;\n    do {  // iterate for each step of independent variable\n        if (save_to_file && fp.is_open()) {\n            // write to file\n            fp << x << \",\";\n            for (int i = 0; i < L - 1; i++) {\n                fp << y[0][i] << \",\";\n            }\n            fp << y[0][L - 1] << \"\\n\";\n        }\n\n        semi_implicit_euler_step(dx, x, y, &dy);  // perform integration\n        x += dx;                                  // update step\n    } while (x <= x_max);  // till upper limit of independent variable\n    /* end of integration */\n    std::clock_t t2 = std::clock();\n\n    if (fp.is_open())\n        fp.close();\n\n    return static_cast<double>(t2 - t1) / CLOCKS_PER_SEC;\n}\n\n/** @} */\n\n/**\n * Function to compute and save exact solution for comparison\n *\n * \\param [in]    X0  \t    initial value of independent variable\n * \\param [in] \t  X_MAX\t    final value of independent variable\n * \\param [in] \t  step_size\tindependent variable step size\n * \\param [in]    Y0\t    initial values of dependent variables\n */\nvoid save_exact_solution(const double &X0, const double &X_MAX,\n                         const double &step_size,\n                         const std::valarray<double> &Y0) {\n    double x = X0;\n    std::valarray<double> y = Y0;\n\n    std::ofstream fp(\"exact.csv\", std::ostream::out);\n    if (!fp.is_open()) {\n        std::perror(\"Error! \");\n        return;\n    }\n    std::cout << \"Finding exact solution\\n\";\n\n    std::clock_t t1 = std::clock();\n    do {\n        fp << x << \",\";\n        for (int i = 0; i < y.size() - 1; i++) {\n            fp << y[i] << \",\";\n        }\n        fp << y[y.size() - 1] << \"\\n\";\n\n        exact_solution(x, &y);\n\n        x += step_size;\n    } while (x <= X_MAX);\n\n    std::clock_t t2 = std::clock();\n    double total_time = static_cast<double>(t2 - t1) / CLOCKS_PER_SEC;\n    std::cout << \"\\tTime = \" << total_time << \" ms\\n\";\n\n    fp.close();\n}\n\n/**\n * Main Function\n */\nint main(int argc, char *argv[]) {\n    double X0 = 0.f;                       /* initial value of x0 */\n    double X_MAX = 10.F;                   /* upper limit of integration */\n    std::valarray<double> Y0 = {1.f, 0.f}; /* initial value Y = y(x = x_0) */\n    double step_size;\n\n    if (argc == 1) {\n        std::cout << \"\\nEnter the step size: \";\n        std::cin >> step_size;\n    } else {\n        // use commandline argument as independent variable step size\n        step_size = std::atof(argv[1]);\n    }\n\n    // get approximate solution\n    double total_time = semi_implicit_euler(step_size, X0, X_MAX, &Y0, true);\n    std::cout << \"\\tTime = \" << total_time << \" ms\\n\";\n\n    /* compute exact solution for comparion */\n    save_exact_solution(X0, X_MAX, step_size, Y0);\n\n    return 0;\n}\n","index":150},{"title":"Qr Decompose.h","category":"numerical_methods","id":"qr_decompose.h_numerical_methods","algorithm":"/**\n * @file\n * \\brief Library functions to compute [QR\n * decomposition](https://en.wikipedia.org/wiki/QR_decomposition) of a given\n * matrix.\n * \\author [Krishna Vedala](https://github.com/kvedala)\n */\n\n#ifndef NUMERICAL_METHODS_QR_DECOMPOSE_H_\n#define NUMERICAL_METHODS_QR_DECOMPOSE_H_\n\n#include <cmath>\n#include <cstdlib>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <numeric>\n#include <valarray>\n#ifdef _OPENMP\n#include <omp.h>\n#endif\n\n/** \\namespace qr_algorithm\n * \\brief Functions to compute [QR\n * decomposition](https://en.wikipedia.org/wiki/QR_decomposition) of any\n * rectangular matrix\n */\nnamespace qr_algorithm {\n/**\n * operator to print a matrix\n */\ntemplate <typename T>\nstd::ostream &operator<<(std::ostream &out,\n                         std::valarray<std::valarray<T>> const &v) {\n    const int width = 12;\n    const char separator = ' ';\n\n    out.precision(4);\n    for (size_t row = 0; row < v.size(); row++) {\n        for (size_t col = 0; col < v[row].size(); col++)\n            out << std::right << std::setw(width) << std::setfill(separator)\n                << v[row][col];\n        out << std::endl;\n    }\n\n    return out;\n}\n\n/**\n * operator to print a vector\n */\ntemplate <typename T>\nstd::ostream &operator<<(std::ostream &out, std::valarray<T> const &v) {\n    const int width = 10;\n    const char separator = ' ';\n\n    out.precision(4);\n    for (size_t row = 0; row < v.size(); row++) {\n        out << std::right << std::setw(width) << std::setfill(separator)\n            << v[row];\n    }\n\n    return out;\n}\n\n/**\n * Compute dot product of two vectors of equal lengths\n *\n * If \\f$\\vec{a}=\\left[a_0,a_1,a_2,...,a_L\\right]\\f$ and\n * \\f$\\vec{b}=\\left[b_0,b_1,b_1,...,b_L\\right]\\f$ then\n * \\f$\\vec{a}\\cdot\\vec{b}=\\displaystyle\\sum_{i=0}^L a_i\\times b_i\\f$\n *\n * \\returns \\f$\\vec{a}\\cdot\\vec{b}\\f$\n */\ntemplate <typename T>\ninline double vector_dot(const std::valarray<T> &a, const std::valarray<T> &b) {\n    return (a * b).sum();\n    // could also use following\n    // return std::inner_product(std::begin(a), std::end(a), std::begin(b),\n    // 0.f);\n}\n\n/**\n * Compute magnitude of vector.\n *\n * If \\f$\\vec{a}=\\left[a_0,a_1,a_2,...,a_L\\right]\\f$ then\n * \\f$\\left|\\vec{a}\\right|=\\sqrt{\\displaystyle\\sum_{i=0}^L a_i^2}\\f$\n *\n * \\returns \\f$\\left|\\vec{a}\\right|\\f$\n */\ntemplate <typename T>\ninline double vector_mag(const std::valarray<T> &a) {\n    double dot = vector_dot(a, a);\n    return std::sqrt(dot);\n}\n\n/**\n * Compute projection of vector \\f$\\vec{a}\\f$ on \\f$\\vec{b}\\f$ defined as\n * \\f[\\text{proj}_\\vec{b}\\vec{a}=\\frac{\\vec{a}\\cdot\\vec{b}}{\\left|\\vec{b}\\right|^2}\\vec{b}\\f]\n *\n * \\returns NULL if error, otherwise pointer to output\n */\ntemplate <typename T>\nstd::valarray<T> vector_proj(const std::valarray<T> &a,\n                             const std::valarray<T> &b) {\n    double num = vector_dot(a, b);\n    double deno = vector_dot(b, b);\n\n    /*! check for division by zero using machine epsilon */\n    if (deno <= std::numeric_limits<double>::epsilon()) {\n        std::cerr << \"[\" << __func__ << \"] Possible division by zero\\n\";\n        return a;  // return vector a back\n    }\n\n    double scalar = num / deno;\n\n    return b * scalar;\n}\n\n/**\n * Decompose matrix \\f$A\\f$ using [Gram-Schmidt\n *process](https://en.wikipedia.org/wiki/QR_decomposition).\n *\n * \\f{eqnarray*}{\n * \\text{given that}\\quad A &=&\n *\\left[\\mathbf{a}_1,\\mathbf{a}_2,\\ldots,\\mathbf{a}_{N-1},\\right]\\\\\n * \\text{where}\\quad\\mathbf{a}_i &=&\n * \\left[a_{0i},a_{1i},a_{2i},\\ldots,a_{(M-1)i}\\right]^T\\quad\\ldots\\mbox{(column\n * vectors)}\\\\\n * \\text{then}\\quad\\mathbf{u}_i &=& \\mathbf{a}_i\n *-\\sum_{j=0}^{i-1}\\text{proj}_{\\mathbf{u}_j}\\mathbf{a}_i\\\\\n * \\mathbf{e}_i &=&\\frac{\\mathbf{u}_i}{\\left|\\mathbf{u}_i\\right|}\\\\\n * Q &=& \\begin{bmatrix}\\mathbf{e}_0 & \\mathbf{e}_1 & \\mathbf{e}_2 & \\dots &\n * \\mathbf{e}_{N-1}\\end{bmatrix}\\\\\n * R &=& \\begin{bmatrix}\\langle\\mathbf{e}_0\\,,\\mathbf{a}_0\\rangle &\n * \\langle\\mathbf{e}_1\\,,\\mathbf{a}_1\\rangle &\n * \\langle\\mathbf{e}_2\\,,\\mathbf{a}_2\\rangle & \\dots \\\\\n *                  0 & \\langle\\mathbf{e}_1\\,,\\mathbf{a}_1\\rangle &\n * \\langle\\mathbf{e}_2\\,,\\mathbf{a}_2\\rangle & \\dots\\\\\n *                  0 & 0 & \\langle\\mathbf{e}_2\\,,\\mathbf{a}_2\\rangle &\n * \\dots\\\\ \\vdots & \\vdots & \\vdots & \\ddots\n *      \\end{bmatrix}\\\\\n * \\f}\n */\ntemplate <typename T>\nvoid qr_decompose(\n    const std::valarray<std::valarray<T>> &A, /**< input matrix to decompose */\n    std::valarray<std::valarray<T>> *Q,       /**< output decomposed matrix */\n    std::valarray<std::valarray<T>> *R        /**< output decomposed matrix */\n) {\n    std::size_t ROWS = A.size();        // number of rows of A\n    std::size_t COLUMNS = A[0].size();  // number of columns of A\n    std::valarray<T> col_vector(ROWS);\n    std::valarray<T> col_vector2(ROWS);\n    std::valarray<T> tmp_vector(ROWS);\n\n    for (int i = 0; i < COLUMNS; i++) {\n        /* for each column => R is a square matrix of NxN */\n        int j;\n        R[0][i] = 0.; /* make R upper triangular */\n\n        /* get corresponding Q vector */\n#ifdef _OPENMP\n// parallelize on threads\n#pragma omp for\n#endif\n        for (j = 0; j < ROWS; j++) {\n            tmp_vector[j] = A[j][i]; /* accumulator for uk */\n            col_vector[j] = A[j][i];\n        }\n        for (j = 0; j < i; j++) {\n            for (int k = 0; k < ROWS; k++) {\n                col_vector2[k] = Q[0][k][j];\n            }\n            col_vector2 = vector_proj(col_vector, col_vector2);\n            tmp_vector -= col_vector2;\n        }\n\n        double mag = vector_mag(tmp_vector);\n\n#ifdef _OPENMP\n// parallelize on threads\n#pragma omp for\n#endif\n        for (j = 0; j < ROWS; j++) Q[0][j][i] = tmp_vector[j] / mag;\n\n            /* compute upper triangular values of R */\n#ifdef _OPENMP\n// parallelize on threads\n#pragma omp for\n#endif\n        for (int kk = 0; kk < ROWS; kk++) {\n            col_vector[kk] = Q[0][kk][i];\n        }\n\n#ifdef _OPENMP\n// parallelize on threads\n#pragma omp for\n#endif\n        for (int k = i; k < COLUMNS; k++) {\n            for (int kk = 0; kk < ROWS; kk++) {\n                col_vector2[kk] = A[kk][k];\n            }\n            R[0][i][k] = (col_vector * col_vector2).sum();\n        }\n    }\n}\n}  // namespace qr_algorithm\n\n#endif  // NUMERICAL_METHODS_QR_DECOMPOSE_H_\n","index":151},{"title":"Qr Decomposition","category":"numerical_methods","id":"qr_decomposition_numerical_methods","algorithm":"/**\n * @file\n * \\brief Program to compute the [QR\n * decomposition](https://en.wikipedia.org/wiki/QR_decomposition) of a given\n * matrix.\n * \\author [Krishna Vedala](https://github.com/kvedala)\n */\n\n#include <array>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n\n#include \"./qr_decompose.h\"\n\nusing qr_algorithm::qr_decompose;\nusing qr_algorithm::operator<<;\n\n/**\n * main function\n */\nint main(void) {\n    unsigned int ROWS, COLUMNS;\n\n    std::cout << \"Enter the number of rows and columns: \";\n    std::cin >> ROWS >> COLUMNS;\n\n    std::cout << \"Enter matrix elements row-wise:\\n\";\n\n    std::valarray<std::valarray<double>> A(ROWS);\n    std::valarray<std::valarray<double>> Q(ROWS);\n    std::valarray<std::valarray<double>> R(COLUMNS);\n    for (int i = 0; i < std::max(ROWS, COLUMNS); i++) {\n        if (i < ROWS) {\n            A[i] = std::valarray<double>(COLUMNS);\n            Q[i] = std::valarray<double>(COLUMNS);\n        }\n        if (i < COLUMNS) {\n            R[i] = std::valarray<double>(COLUMNS);\n        }\n    }\n\n    for (int i = 0; i < ROWS; i++)\n        for (int j = 0; j < COLUMNS; j++) std::cin >> A[i][j];\n\n    std::cout << A << \"\\n\";\n\n    clock_t t1 = clock();\n    qr_decompose(A, &Q, &R);\n    double dtime = static_cast<double>(clock() - t1) / CLOCKS_PER_SEC;\n\n    std::cout << Q << \"\\n\";\n    std::cout << R << \"\\n\";\n    std::cout << \"Time taken to compute: \" << dtime << \" sec\\n \";\n\n    return 0;\n}\n","index":152},{"title":"Qr Eigen Values","category":"numerical_methods","id":"qr_eigen_values_numerical_methods","algorithm":"/**\n * @file\n * \\brief Compute real eigen values and eigen vectors of a symmetric matrix\n * using [QR decomposition](https://en.wikipedia.org/wiki/QR_decomposition)\n * method.\n * \\author [Krishna Vedala](https://github.com/kvedala)\n */\n#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#ifdef _OPENMP\n#include <omp.h>\n#endif\n\n#include \"./qr_decompose.h\"\nusing qr_algorithm::operator<<;\n\n#define LIMS 9 /**< limit of range of matrix values */\n\n/**\n * create a symmetric square matrix of given size with random elements. A\n * symmetric square matrix will *always* have real eigen values.\n *\n * \\param[out] A matrix to create (must be pre-allocated in memory)\n */\nvoid create_matrix(std::valarray<std::valarray<double>> *A) {\n    int i, j, tmp, lim2 = LIMS >> 1;\n    int N = A->size();\n\n#ifdef _OPENMP\n#pragma omp for\n#endif\n    for (i = 0; i < N; i++) {\n        A[0][i][i] = (std::rand() % LIMS) - lim2;\n        for (j = i + 1; j < N; j++) {\n            tmp = (std::rand() % LIMS) - lim2;\n            A[0][i][j] = tmp;  // summetrically distribute random values\n            A[0][j][i] = tmp;\n        }\n    }\n}\n\n/**\n * Perform multiplication of two matrices.\n * * R2 must be equal to C1\n * * Resultant matrix size should be R1xC2\n * \\param[in] A first matrix to multiply\n * \\param[in] B second matrix to multiply\n * \\param[out] OUT output matrix (must be pre-allocated)\n * \\returns pointer to resultant matrix\n */\nvoid mat_mul(const std::valarray<std::valarray<double>> &A,\n             const std::valarray<std::valarray<double>> &B,\n             std::valarray<std::valarray<double>> *OUT) {\n    int R1 = A.size();\n    int C1 = A[0].size();\n    int R2 = B.size();\n    int C2 = B[0].size();\n    if (C1 != R2) {\n        perror(\"Matrix dimensions mismatch!\");\n        return;\n    }\n\n    for (int i = 0; i < R1; i++) {\n        for (int j = 0; j < C2; j++) {\n            OUT[0][i][j] = 0.f;\n            for (int k = 0; k < C1; k++) {\n                OUT[0][i][j] += A[i][k] * B[k][j];\n            }\n        }\n    }\n}\n\nnamespace qr_algorithm {\n/** Compute eigen values using iterative shifted QR decomposition algorithm as\n * follows:\n * 1. Use last diagonal element of A as eigen value approximation \\f$c\\f$\n * 2. Shift diagonals of matrix \\f$A' = A - cI\\f$\n * 3. Decompose matrix \\f$A'=QR\\f$\n * 4. Compute next approximation \\f$A'_1 = RQ \\f$\n * 5. Shift diagonals back \\f$A_1 = A'_1 + cI\\f$\n * 6. Termination condition check: last element below diagonal is almost 0\n *   1. If not 0, go back to step 1 with the new approximation \\f$A_1\\f$\n *   2. If 0, continue to step 7\n * 7. Save last known \\f$c\\f$ as the eigen value.\n * 8. Are all eigen values found?\n *   1. If not, remove last row and column of \\f$A_1\\f$ and go back to step 1.\n *   2. If yes, stop.\n *\n * \\note The matrix \\f$A\\f$ gets modified\n *\n * \\param[in,out] A matrix to compute eigen values for\n * \\param[in] print_intermediates (optional) whether to print intermediate A, Q\n * and R matrices (default = `false`)\n */\nstd::valarray<double> eigen_values(std::valarray<std::valarray<double>> *A,\n                                   bool print_intermediates = false) {\n    int rows = A->size();\n    int columns = rows;\n    int counter = 0, num_eigs = rows - 1;\n    double last_eig = 0;\n\n    std::valarray<std::valarray<double>> Q(rows);\n    std::valarray<std::valarray<double>> R(columns);\n\n    /* number of eigen values = matrix size */\n    std::valarray<double> eigen_vals(rows);\n    for (int i = 0; i < rows; i++) {\n        Q[i] = std::valarray<double>(columns);\n        R[i] = std::valarray<double>(columns);\n    }\n\n    /* continue till all eigen values are found */\n    while (num_eigs > 0) {\n        /* iterate with QR decomposition */\n        while (std::abs(A[0][num_eigs][num_eigs - 1]) >\n               std::numeric_limits<double>::epsilon()) {\n            // initial approximation = last diagonal element\n            last_eig = A[0][num_eigs][num_eigs];\n            for (int i = 0; i < rows; i++) {\n                A[0][i][i] -= last_eig; /* A - cI */\n            }\n\n            qr_decompose(*A, &Q, &R);\n\n            if (print_intermediates) {\n                std::cout << *A << \"\\n\";\n                std::cout << Q << \"\\n\";\n                std::cout << R << \"\\n\";\n                printf(\"-------------------- %d ---------------------\\n\",\n                       ++counter);\n            }\n\n            // new approximation A' = R * Q\n            mat_mul(R, Q, A);\n\n            for (int i = 0; i < rows; i++) {\n                A[0][i][i] += last_eig; /* A + cI */\n            }\n        }\n\n        /* store the converged eigen value */\n        eigen_vals[num_eigs] = last_eig;\n        // A[0][num_eigs][num_eigs];\n        if (print_intermediates) {\n            std::cout << \"========================\\n\";\n            std::cout << \"Eigen value: \" << last_eig << \",\\n\";\n            std::cout << \"========================\\n\";\n        }\n\n        num_eigs--;\n        rows--;\n        columns--;\n    }\n    eigen_vals[0] = A[0][0][0];\n\n    if (print_intermediates) {\n        std::cout << Q << \"\\n\";\n        std::cout << R << \"\\n\";\n    }\n\n    return eigen_vals;\n}\n\n}  // namespace qr_algorithm\n\n/**\n * test function to compute eigen values of a 2x2 matrix\n * \\f[\\begin{bmatrix}\n * 5 & 7\\\\\n * 7 & 11\n * \\end{bmatrix}\\f]\n * which are approximately, {15.56158, 0.384227}\n */\nvoid test1() {\n    std::valarray<std::valarray<double>> X = {{5, 7}, {7, 11}};\n    double y[] = {15.56158, 0.384227};  // corresponding y-values\n\n    std::cout << \"------- Test 1 -------\" << std::endl;\n    std::valarray<double> eig_vals = qr_algorithm::eigen_values(&X);\n\n    for (int i = 0; i < 2; i++) {\n        std::cout << i + 1 << \"/2 Checking for \" << y[i] << \" --> \";\n        bool result = false;\n        for (int j = 0; j < 2 && !result; j++) {\n            if (std::abs(y[i] - eig_vals[j]) < 0.1) {\n                result = true;\n                std::cout << \"(\" << eig_vals[j] << \") \";\n            }\n        }\n        assert(result);  // ensure that i^th expected eigen value was computed\n        std::cout << \"found\\n\";\n    }\n    std::cout << \"Test 1 Passed\\n\\n\";\n}\n\n/**\n * test function to compute eigen values of a 2x2 matrix\n * \\f[\\begin{bmatrix}\n * -4& 4& 2& 0& -3\\\\\n * 4& -4& 4& -3& -1\\\\\n * 2& 4& 4& 3& -3\\\\\n * 0& -3& 3& -1&-1\\\\\n * -3& -1& -3& -3& 0\n * \\end{bmatrix}\\f]\n * which are approximately, {9.27648, -9.26948, 2.0181, -1.03516, -5.98994}\n */\nvoid test2() {\n    std::valarray<std::valarray<double>> X = {{-4, 4, 2, 0, -3},\n                                              {4, -4, 4, -3, -1},\n                                              {2, 4, 4, 3, -3},\n                                              {0, -3, 3, -1, -3},\n                                              {-3, -1, -3, -3, 0}};\n    double y[] = {9.27648, -9.26948, 2.0181, -1.03516,\n                  -5.98994};  // corresponding y-values\n\n    std::cout << \"------- Test 2 -------\" << std::endl;\n    std::valarray<double> eig_vals = qr_algorithm::eigen_values(&X);\n\n    std::cout << X << \"\\n\"\n              << \"Eigen values: \" << eig_vals << \"\\n\";\n\n    for (int i = 0; i < 5; i++) {\n        std::cout << i + 1 << \"/5 Checking for \" << y[i] << \" --> \";\n        bool result = false;\n        for (int j = 0; j < 5 && !result; j++) {\n            if (std::abs(y[i] - eig_vals[j]) < 0.1) {\n                result = true;\n                std::cout << \"(\" << eig_vals[j] << \") \";\n            }\n        }\n        assert(result);  // ensure that i^th expected eigen value was computed\n        std::cout << \"found\\n\";\n    }\n    std::cout << \"Test 2 Passed\\n\\n\";\n}\n\n/**\n * main function\n */\nint main(int argc, char **argv) {\n    int mat_size = 5;\n    if (argc == 2) {\n        mat_size = atoi(argv[1]);\n    } else {  // if invalid input argument is given run tests\n        test1();\n        test2();\n        std::cout << \"Usage: ./qr_eigen_values [mat_size]\\n\";\n        return 0;\n    }\n\n    if (mat_size < 2) {\n        fprintf(stderr, \"Matrix size should be > 2\\n\");\n        return -1;\n    }\n\n    // initialize random number generator\n    std::srand(std::time(nullptr));\n\n    int i, rows = mat_size, columns = mat_size;\n\n    std::valarray<std::valarray<double>> A(rows);\n\n    for (int i = 0; i < rows; i++) {\n        A[i] = std::valarray<double>(columns);\n    }\n\n    /* create a random matrix */\n    create_matrix(&A);\n\n    std::cout << A << \"\\n\";\n\n    clock_t t1 = clock();\n    std::valarray<double> eigen_vals = qr_algorithm::eigen_values(&A);\n    double dtime = static_cast<double>(clock() - t1) / CLOCKS_PER_SEC;\n\n    std::cout << \"Eigen vals: \";\n    for (i = 0; i < mat_size; i++) std::cout << eigen_vals[i] << \"\\t\";\n    std::cout << \"\\nTime taken to compute: \" << dtime << \" sec\\n\";\n\n    return 0;\n}\n","index":153},{"title":"Successive Approximation","category":"numerical_methods","id":"successive_approximation_numerical_methods","algorithm":"/**\n * \\file\n * \\brief Method of successive approximations using [fixed-point\n * iteration](https://en.wikipedia.org/wiki/Fixed-point_iteration) method\n */\n#include <cmath>\n#include <iostream>\n\n/** equation 1\n * \\f[f(y) = 3y - \\cos y -2\\f]\n */\nstatic float eq(float y) { return (3 * y) - cos(y) - 2; }\n\n/** equation 2\n * \\f[f(y) = \\frac{\\cos y+2}{2}\\f]\n */\nstatic float eqd(float y) { return 0.5 * (cos(y) + 2); }\n\n/** Main function */\nint main() {\n    float y, x1, x2, x3, sum, s, a, f1, f2, gd;\n    int i, n;\n\n    for (i = 0; i < 10; i++) {\n        sum = eq(y);\n        std::cout << \"value of equation at \" << i << \" \" << sum << \"\\n\";\n        y++;\n    }\n    std::cout << \"enter the x1->\";\n    std::cin >> x1;\n    std::cout << \"enter the no iteration to perform->\\n\";\n    std::cin >> n;\n\n    for (i = 0; i <= n; i++) {\n        x2 = eqd(x1);\n        std::cout << \"\\nenter the x2->\" << x2;\n        x1 = x2;\n    }\n    return 0;\n}\n","index":154},{"title":"Operations On Datastructures","category":null,"id":"operations_on_datastructures","index":155},{"title":"Array Left Rotation","category":"operations_on_datastructures","id":"array_left_rotation_operations_on_datastructures","algorithm":"#include <iostream>\nusing namespace std;\nint main() {\n    int n, k;\n    cout << \"Enter size of array=\\t\";\n    cin >> n;\n    cout << \"Enter Number of indeces u want to rotate the array to left=\\t\";\n    cin >> k;\n    int a[n];\n    cout << \"Enter  elements of array=\\t\";\n    for (int i = 0; i < n; i++) {\n        cin >> a[i];\n    }\n    int temp = 0;\n    for (int i = 0; i < k; i++) {\n        temp = a[0];\n        for (int j = 0; j < n; j++) {\n            if (j == n - 1) {\n                a[n - 1] = temp;\n            } else {\n                a[j] = a[j + 1];\n            }\n        }\n    }\n    cout << \"Your rotated array is=\\t\";\n    for (int j = 0; j < n; j++) {\n        cout << a[j] << \" \";\n    }\n    getchar();\n    return 0;\n}\n","index":156},{"title":"Array Right Rotation","category":"operations_on_datastructures","id":"array_right_rotation_operations_on_datastructures","algorithm":"#include <iostream>\nusing namespace std;\nint main() {\n    int n, k;\n    cout << \"Enter size of array=\\t\";\n    cin >> n;\n    cout << \"Enter Number of indices u want to rotate the array to right=\\t\";\n    cin >> k;\n    int a[n];\n    cout << \"Enter elements of array=\\t\";\n    for (int i = 0; i < n; i++) cin >> a[i];\n    int temp = 0;\n    for (int i = 0; i < k; i++) {\n        temp = a[n - 1];\n        for (int j = n - 1; j >= 0; j--) {\n            if (j == 0) {\n                a[j] = temp;\n            } else {\n                a[j] = a[j - 1];\n            }\n        }\n    }\n    cout << \"Your rotated array is=\\t\";\n    for (int i = 0; i < n; i++) {\n        cout << a[i] << \" \";\n    }\n}\n","index":157},{"title":"Circular Linked List","category":"operations_on_datastructures","id":"circular_linked_list_operations_on_datastructures","algorithm":"#include <iostream>\nusing namespace std;\n\nstruct node {\n    int val;\n    node *next;\n};\n\nnode *start;\n\nvoid insert(int x) {\n    node *t = start;\n\n    if (start != NULL) {\n        while (t->next != start) {\n            t = t->next;\n        }\n        node *n = new node;\n        t->next = n;\n        n->val = x;\n        n->next = start;\n    } else {\n        node *n = new node;\n        n->val = x;\n        start = n;\n        n->next = start;\n    }\n}\n\nvoid remove(int x) {\n    node *t = start;\n    node *p;\n    while (t->val != x) {\n        p = t;\n        t = t->next;\n    }\n    p->next = t->next;\n    delete t;\n}\n\nvoid search(int x) {\n    node *t = start;\n    int found = 0;\n    while (t->next != start) {\n        if (t->val == x) {\n            cout << \"\\nFound\";\n            found = 1;\n            break;\n        }\n        t = t->next;\n    }\n    if (found == 0) {\n        cout << \"\\nNot Found\";\n    }\n}\n\nvoid show() {\n    node *t = start;\n    do {\n        cout << t->val << \"\\t\";\n        t = t->next;\n    } while (t != start);\n}\n\nint main() {\n    int choice, x;\n    do {\n        cout << \"\\n1. Insert\";\n        cout << \"\\n2. Delete\";\n        cout << \"\\n3. Search\";\n        cout << \"\\n4. Print\";\n        cout << \"\\n\\nEnter you choice : \";\n        cin >> choice;\n        switch (choice) {\n        case 1:\n            cout << \"\\nEnter the element to be inserted : \";\n            cin >> x;\n            insert(x);\n            break;\n        case 2:\n            cout << \"\\nEnter the element to be removed : \";\n            cin >> x;\n            remove(x);\n            break;\n        case 3:\n            cout << \"\\nEnter the element to be searched : \";\n            cin >> x;\n            search(x);\n            break;\n        case 4:\n            show();\n            break;\n        }\n    } while (choice != 0);\n\n    return 0;\n}\n","index":158},{"title":"Circular Queue Using Array","category":"operations_on_datastructures","id":"circular_queue_using_array_operations_on_datastructures","algorithm":"#include <iostream>\nusing namespace std;\n\nint queue[10];\nint front = 0;\nint rear = 0;\nint count = 0;\n\nvoid Enque(int x) {\n    if (count == 10) {\n        cout << \"\\nOverflow\";\n    } else {\n        queue[rear] = x;\n        rear = (rear + 1) % 10;\n        count++;\n    }\n}\n\nvoid Deque() {\n    if (front == rear) {\n        cout << \"\\nUnderflow\";\n    }\n\n    else {\n        cout << \"\\n\" << queue[front] << \" deleted\";\n        front = (front + 1) % 10;\n        count--;\n    }\n}\n\nvoid show() {\n    for (int i = 0; i < count; i++) {\n        cout << queue[(i + front) % 10] << \"\\t\";\n    }\n}\n\nint main() {\n    int ch, x;\n    do {\n        cout << \"\\n1. Enque\";\n        cout << \"\\n2. Deque\";\n        cout << \"\\n3. Print\";\n        cout << \"\\nEnter Your Choice : \";\n        cin >> ch;\n        if (ch == 1) {\n            cout << \"\\nInsert : \";\n            cin >> x;\n            Enque(x);\n        } else if (ch == 2) {\n            Deque();\n        } else if (ch == 3) {\n            show();\n        }\n    } while (ch != 0);\n\n    return 0;\n}\n","index":159},{"title":"Get Size Of Linked List","category":"operations_on_datastructures","id":"get_size_of_linked_list_operations_on_datastructures","algorithm":"#include <iostream>\n\nclass Node {\n public:\n    int val;\n    Node *next;\n\n    Node(int v, Node *n) : val(v), next(n) {}  // Default constructor for Node\n};\n\nint getSize(Node *root) {\n    if (root == NULL) {\n        return 0;\n    }\n    // Each node will return 1 so the total adds up to be the size\n    return 1 + getSize(root->next);\n}\n\nint main() {\n    Node *myList = new Node(0, NULL);  // Initializes the LinkedList\n    Node *temp = myList;\n    // Creates a linked lists of total size 10, numbered 1 - 10\n    for (int i = 1; i < 10; i++) {\n        temp->next = new Node(i, NULL);\n        temp = temp->next;\n    }\n    // Creating other lists for checking purposes\n    Node *secondList = new Node(0, NULL);  // List of size 1\n    Node *thirdList = NULL;                // List of size 0\n\n    std::cout << getSize(myList) << std::endl\n              << getSize(secondList) << std::endl\n              << getSize(thirdList) << std::endl;\n\n    return 0;\n}\n","index":160},{"title":"Intersection Of 2 Arrays","category":"operations_on_datastructures","id":"intersection_of_2_arrays_operations_on_datastructures","algorithm":"#include <iostream>\nint main() {\n    int i, j, m, n;\n    cout << \"Enter size of array 1:\";\n    cin >> m;\n    cout << \"Enter size of array 2:\";\n    cin >> n;\n    int a[m];\n    int b[n];\n    cout << \"Enter elements of array 1:\";\n    for (i = 0; i < m; i++) cin >> a[i];\n    for (i = 0; i < n; i++) cin >> b[i];\n    i = 0;\n    j = 0;\n    while ((i < m) && (j < n)) {\n        if (a[i] < b[j])\n            i++;\n        else if (a[i] > b[j])\n            j++;\n        else {\n            cout << a[i++] << \" \";\n            j++;\n        }\n    }\n    return 0;\n}\n","index":161},{"title":"Reverse A Linked List Using Recusion","category":"operations_on_datastructures","id":"reverse_a_linked_list_using_recusion_operations_on_datastructures","algorithm":"#include <iostream>\nusing namespace std;\n\nstruct node {\n    int val;\n    node *next;\n};\n\nnode *start;\n\nvoid insert(int x) {\n    node *t = start;\n    if (start != NULL) {\n        while (t->next != NULL) {\n            t = t->next;\n        }\n        node *n = new node;\n        t->next = n;\n        n->val = x;\n        n->next = NULL;\n    } else {\n        node *n = new node;\n        n->val = x;\n        n->next = NULL;\n        start = n;\n    }\n}\n\nvoid reverse(node *p, node *q) {\n    if (q->next == NULL) {\n        q->next = p;\n        p->next = NULL;\n        start = q;\n        return;\n    } else {\n        reverse(q, q->next);\n        q->next = p;\n        p->next = NULL;\n    }\n}\n\nvoid show() {\n    node *t = start;\n    while (t != NULL) {\n        cout << t->val << \"\\t\";\n        t = t->next;\n    }\n}\n\nint main() {\n    insert(1);\n    insert(2);\n    insert(3);\n    insert(4);\n    insert(5);\n    insert(6);\n\n    reverse(start, start->next);\n\n    show();\n\n    return 0;\n}\n","index":162},{"title":"Selectionsortlinkedlist","category":"operations_on_datastructures","id":"selectionsortlinkedlist_operations_on_datastructures","algorithm":"#include <iostream>\nusing namespace std;\n\n// node defined\nclass node {\n public:\n    int data;\n    node *link;\n    node(int d) {\n        data = d;\n        link = NULL;\n    }\n};\n\n// printing the linked list\nvoid print(node *head) {\n    node *current = head;\n    while (current != NULL) {\n        cout << current->data << \" \";\n        current = current->link;\n    }\n    cout << endl;\n}\n\n// creating the linked list with 'n' nodes\nnode *createlist(int n) {\n    node *head = NULL;\n    node *t = NULL;\n    for (int i = 0; i < n; i++) {\n        node *temp = NULL;\n        int num;\n        cin >> num;\n        temp = new node(num);\n        if (head == NULL) {\n            head = temp;\n            t = temp;\n            continue;\n        }\n        if (t->link == NULL)\n            t->link = temp;\n        t = temp;\n    }\n    return head;\n}\n\n// performing selection sort on the linked list in an iterative manner\nvoid my_selection_sort_linked_list(node *&head) {\n    node *min = head;  // throughout the algorithm 'min' is used to denote the\n                       // node with min value out of all the nodes left for\n                       // scanning while scanning if we find a node 'X' with\n                       // value lesser than min, then we update the pointers in\n                       // such a way that 'X' becomes the predecessor of 'min'\n    node *current =\n        min->link;  // 'current' refers to the current node we are scanning\n    node *previous = min;  //'previous' refers to the node that is previous to\n                           // the current node\n    node *temp =\n        NULL;  // 'temp' in this algo is used to point to the last node of the\n               // sorted part of the linked list.\n               // eg. If at any time instance the state of the linked list is\n               // suppose 1->2->5->3->8->NULL then, we see that \"1->2\" is the\n               // sorted part of the LL, and therefore temp will be pointing to\n               // the last node of the sorted part,i.e,'2' We keep on arranging\n               // the Linked list in such a way that after each iteration the\n               // node with 'min' value is placed at its correct position. Eg.\n               // Let suppose initially we have 5->4->1->3->2->NULL After 1st\n               // iteration : 1->4->5->3->2->NULL and so on\n\n    while (\n        min->link !=\n        NULL)  // so that all the nodes are scanned or until there exists a node\n    {\n        // pick the first node from the unsorted part and assume that it is the\n        // minimum and then start scanning from the next node\n\n        while (current != NULL)  // suppose you choose the min node to be X,\n                                 // then scan starts from the (X+1)th node until\n                                 // its NULL. current = (X+1)th node and min = X\n        {\n            if (current->data < min->data)  // if the current node is smaller\n                                            // than the presumed node 'min'\n            {\n                if (temp == NULL)  // temp stays null for the first iteration,\n                                   // therefore it symbolizes that we are\n                                   // scanning for the first time\n                {\n                    if (previous ==\n                        min)  // if the 'previous' is pointing to the 'min' node\n                    {\n                        // Update the pointers\n                        head = current;  // update the head pointer with the\n                                         // current node\n                        min->link = current->link;\n                        current->link = previous;\n                        min = current;\n                        current = previous->link;\n                    } else  // if the 'previous' is not pointing to the 'min'\n                            // node\n                    {\n                        // Update the pointers\n                        head = current;  // update the head pointer with the\n                                         // current node\n                        previous->link = current->link;\n                        current->link = min;\n                        min = current;\n                        current = previous->link;\n                    }\n                } else  // if 'temp' is not NULL, i.e., its not the 1st\n                        // iteration\n                {\n                    temp->link = current;\n                    previous->link = current->link;\n                    current->link = min;\n                    min = current;\n                    current = previous->link;\n                }\n            } else  // if the current node is greater than min, just move the\n                    // previous and the current pointer a step further\n            {\n                previous = previous->link;\n                current = current->link;\n            }\n        }\n\n        // update the pointers. Set 'temp' to the last node in the sorted part.\n        // Make 'min' move a step further so that 'min' points to the 1st node\n        // of the unsorted part start the iteration again\n        temp = min;\n        min = min->link;\n        previous = min;\n        current = min->link;\n    }\n}\n\n// Test cases:\n\n// enter the no. of nodes : 5\n// 8 9 3 1 4\n// original list is : 8 9 3 1 4\n// sorted list is : 1 3 4 8 9\n\n// enter the no. of nodes : 3\n// -1 -2 -3\n// original list is : -1 -2 -3\n// sorted list is : -3 -2 -1\n\n// enter the no. of nodes : 8\n// 8 7 6 5 4 3 2 1\n// original list is : 8 7 6 5 4 3 2 1\n// sorted list is : 1 2 3 4 5 6 7 8\n\n// enter the no. of nodes : 6\n// 5 3 4 1 -2 -4\n// original list is : 5 3 4 1 -2 -4\n// sorted list is : -4 -2 1 3 4 5\n\nint main() {\n    node *head = NULL;\n    int n;\n    cout << \"enter the no. of nodes : \";  // taking input from user about the\n                                          // number of nodes in linked list\n    cin >> n;\n    if (n == 0)\n        return 0;\n    head = createlist(n);  // creating the list\n    cout << \"original list is : \";\n    print(head);                          // printing the original linked list\n    my_selection_sort_linked_list(head);  // applying selection sort\n    cout << \"sorted list is : \";\n    print(head);  // printing the sorted linked list\n    return 0;\n}","index":163},{"title":"Union Of 2 Arrays","category":"operations_on_datastructures","id":"union_of_2_arrays_operations_on_datastructures","algorithm":"#include <iostream>\nint main() {\n    int m, n, i = 0, j = 0;\n    cout << \"Enter size of both arrays:\";\n    cin >> m >> n;\n    int a[m];\n    int b[n];\n    cout << \"Enter elements of array 1:\";\n    for (i = 0; i < m; i++) cin >> a[i];\n    cout << \"Enter elements of array 2:\";\n    for (i = 0; i < n; i++) cin >> b[i];\n    i = 0;\n    j = 0;\n    while ((i < m) && (j < n)) {\n        if (a[i] < b[j])\n            cout << a[i++] << \" \";\n        else if (a[i] > b[j])\n            cout << b[j++] << \" \";\n        else {\n            cout << a[i++];\n            j++;\n        }\n    }\n    while (i < m) cout << a[i++] << \" \";\n    while (j < n) cout << b[j++] << \" \";\n    return 0;\n}\n","index":164},{"title":"Others","category":null,"id":"others","index":165},{"title":"Buzz Number","category":"others","id":"buzz_number_others","algorithm":"/**\n * @file\n * @brief A buzz number is a number that is either divisible by 7 or has last\n * digit as 7.\n */\n#include <iostream>\n\n/** main function */\nint main() {\n    int n, t;\n    std::cin >> t;\n    while (t--) {\n        std::cin >> n;\n        if ((n % 7 == 0) || (n % 10 == 7))\n            std::cout << n << \" is a buzz number\" << std::endl;\n        else\n            std::cout << n << \" is not a buzz number\" << std::endl;\n    }\n    return 0;\n}\n","index":166},{"title":"Decimal To Binary","category":"others","id":"decimal_to_binary_others","algorithm":"/**\n * @file\n * @brief Function to convert decimal number to binary representation\n */\n#include <iostream>\n\n/**\n * This method converts the bit representation and stores it as a decimal\n * number.\n */\nvoid method1(int number) {\n    int remainder, binary = 0, var = 1;\n\n    do {\n        remainder = number % 2;\n        number = number / 2;\n        binary = binary + (remainder * var);\n        var = var * 10;\n    } while (number > 0);\n    std::cout << \"Method 1 : \" << binary << std::endl;\n}\n\n/**\n * This method stores each bit value from LSB to MSB and then prints them back\n * from MSB to LSB\n */\nvoid method2(int number) {\n    int num_bits = 0;\n    char bit_string[50];\n\n    do {\n        bool bit = number & 0x01;  // get last bit\n        if (bit)\n            bit_string[num_bits++] = '1';\n        else\n            bit_string[num_bits++] = '0';\n        number >>= 1;  // right shift bit 1 bit\n    } while (number > 0);\n\n    std::cout << \"Method 2 : \";\n    while (num_bits >= 0)\n        std::cout << bit_string[num_bits--];  // print from MSB to LSB\n    std::cout << std::endl;\n}\n\nint main() {\n    int number;\n    std::cout << \"Enter a number:\";\n    std::cin >> number;\n\n    method1(number);\n    method2(number);\n\n    return 0;\n}\n","index":167},{"title":"Decimal To Hexadecimal","category":"others","id":"decimal_to_hexadecimal_others","algorithm":"/**\n * @file\n * @brief Convert decimal number to hexadecimal representation\n */\n\n#include <iostream>\n\n/**\n * Main program\n */\nint main(void) {\n    int valueToConvert = 0;  // Holds user input\n    int hexArray[8];         // Contains hex values backwards\n    int i = 0;               // counter\n    char HexValues[] = \"0123456789ABCDEF\";\n\n    std::cout << \"Enter a Decimal Value\"\n              << std::endl;  // Displays request to stdout\n    std::cin >>\n        valueToConvert;  // Stores value into valueToConvert via user input\n\n    while (valueToConvert > 15) {             // Dec to Hex Algorithm\n        hexArray[i++] = valueToConvert % 16;  // Gets remainder\n        valueToConvert /= 16;\n        // valueToConvert >>= 4;  // This will divide by 2^4=16 and is faster\n    }\n    hexArray[i] = valueToConvert;  // Gets last value\n\n    std::cout << \"Hex Value: \";\n    while (i >= 0) std::cout << HexValues[hexArray[i--]];\n\n    std::cout << std::endl;\n    return 0;\n}\n","index":168},{"title":"Decimal To Roman Numeral","category":"others","id":"decimal_to_roman_numeral_others","algorithm":"/**\n * @file\n * @brief This Programme Converts a given decimal number in the range [0,4000)\n * to both Lower case and Upper case Roman Numeral\n */\n\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n\n/** This functions fills a string with character c, n times and returns it\n * @note This can probably be replace by `memcpy` function.\n */\nstd::string fill(char c, int n) {\n    std::string s = \"\";\n    while (n--) s += c;\n    return s;\n}\n\n/** to convert to lowercase Roman Numeral\n * the function works recursively\n */\nstd::string tolowerRoman(int n) {\n    if (n < 4)\n        return fill('i', n);\n    if (n < 6)\n        return fill('i', 5 - n) + \"v\";\n    if (n < 9)\n        return std::string(\"v\") + fill('i', n - 5);\n    if (n < 11)\n        return fill('i', 10 - n) + \"x\";\n    if (n < 40)\n        return fill('x', n / 10) + tolowerRoman(n % 10);\n    if (n < 60)\n        return fill('x', 5 - n / 10) + 'l' + tolowerRoman(n % 10);\n    if (n < 90)\n        return std::string(\"l\") + fill('x', n / 10 - 5) + tolowerRoman(n % 10);\n    if (n < 110)\n        return fill('x', 10 - n / 10) + \"c\" + tolowerRoman(n % 10);\n    if (n < 400)\n        return fill('c', n / 100) + tolowerRoman(n % 100);\n    if (n < 600)\n        return fill('c', 5 - n / 100) + 'd' + tolowerRoman(n % 100);\n    if (n < 900)\n        return std::string(\"d\") + fill('c', n / 100 - 5) +\n               tolowerRoman(n % 100);\n    if (n < 1100)\n        return fill('c', 10 - n / 100) + \"m\" + tolowerRoman(n % 100);\n    if (n < 4000)\n        return fill('m', n / 1000) + tolowerRoman(n % 1000);\n    return \"?\";\n}\n\n/** to convert to uppercase Roman Numeral\n * the function works recursively\n */\nstd::string toupperRoman(int n) {\n    if (n < 4)\n        return fill('I', n);\n    if (n < 6)\n        return fill('I', 5 - n) + \"V\";\n    if (n < 9)\n        return std::string(\"V\") + fill('I', n - 5);\n    if (n < 11)\n        return fill('I', 10 - n) + \"X\";\n    if (n < 40)\n        return fill('X', n / 10) + toupperRoman(n % 10);\n    if (n < 60)\n        return fill('X', 5 - n / 10) + 'L' + toupperRoman(n % 10);\n    if (n < 90)\n        return std::string(\"L\") + fill('X', n / 10 - 5) + toupperRoman(n % 10);\n    if (n < 110)\n        return fill('X', 10 - n / 10) + \"C\" + toupperRoman(n % 10);\n    if (n < 400)\n        return fill('C', n / 100) + toupperRoman(n % 100);\n    if (n < 600)\n        return fill('C', 5 - n / 100) + 'D' + toupperRoman(n % 100);\n    if (n < 900)\n        return std::string(\"D\") + fill('C', n / 100 - 5) +\n               toupperRoman(n % 100);\n    if (n < 1100)\n        return fill('C', 10 - n / 100) + \"M\" + toupperRoman(n % 100);\n    if (n < 4000)\n        return fill('M', n / 1000) + toupperRoman(n % 1000);\n    return \"?\";\n}\n\n/** main function */\nint main() {\n    int n;\n    std::cout << \"\\t\\tRoman numbers converter\\n\\n\";\n    std::cout << \"Type in decimal number between 0 up to 4000 (exclusive): \";\n    std::cin >> n;\n    std::cout << n << \" in Upper Roman Numerals is \" << toupperRoman(n) << \"\\n\";\n    std::cout << n << \" in Lower Roman Numerals is \" << tolowerRoman(n) << \"\\n\";\n    return 0;\n}\n","index":169},{"title":"Fast Integer Input","category":"others","id":"fast_integer_input_others","algorithm":"/**\n * @file\n * @brief Read integers from stdin continuously as they are entered without\n * waiting for the `\\n` character\n */\n#include <iostream>\n\n/** Function to read the number from stdin. The function reads input until a non\n * numeric character is entered.\n */\nvoid fastinput(int *number) {\n    // variable to indicate sign of input integer\n    bool negative = false;\n    register int c;\n    *number = 0;\n\n    // extract current character from buffer\n    c = std::getchar();\n    if (c == '-') {\n        // number is negative\n        negative = true;\n\n        // extract the next character from the buffer\n        c = std::getchar();\n    }\n\n    // Keep on extracting characters if they are integers\n    // i.e ASCII Value lies from '0'(48) to '9' (57)\n    for (; (c > 47 && c < 58); c = std::getchar())\n        *number = *number * 10 + c - 48;\n\n    // if scanned input has a negative sign, negate the\n    // value of the input number\n    if (negative)\n        *(number) *= -1;\n}\n\n/** Main function */\nint main() {\n    int number;\n    fastinput(&number);\n    std::cout << number << std::endl;\n    return 0;\n}\n","index":170},{"title":"Happy Number","category":"others","id":"happy_number_others","algorithm":"/**\n * @file\n * @brief A happy number is a number whose sum of digits is calculated until the\n * sum is a single digit, and this sum turns out to be 1\n */\n\n#include <iostream>\n\n/**\n * Checks if a decimal number is a happy number\n * \\returns true if happy else false\n */\ntemplate <typename T>\nbool is_happy(T n) {\n    T s = 0;              // stores sum of digits\n    while (n > 9) {       // while number is > 9, there are more than 1 digit\n        while (n != 0) {  // get digit\n            T d = n % 10;\n            s += d;\n            n /= 10;\n        }\n        n = s;\n        s = 0;\n    }\n    return (n == 1) ? true : false;  // true if k == 1\n}\n\n/** Main function */\nint main() {\n    int n;\n    std::cout << \"Enter a number:\";\n    std::cin >> n;\n\n    if (is_happy(n))\n        std::cout << n << \" is a happy number\" << std::endl;\n    else\n        std::cout << n << \" is not a happy number\" << std::endl;\n    return 0;\n}\n","index":171},{"title":"Matrix Exponentiation","category":"others","id":"matrix_exponentiation_others","algorithm":"/**\n@file\n@brief Matrix Exponentiation.\n\nThe problem can be solved with DP but constraints are high.\n<br/>\\f$a_i = b_i\\f$ (for \\f$i <= k\\f$)\n<br/>\\f$a_i = c_1 a_{i-1} + c_2 a_{i-2} + ... + c_k a_{i-k}\\f$ (for \\f$i > k\\f$)\n<br/>Taking the example of Fibonacci series, \\f$k=2\\f$\n<br/>\\f$b_1 = 1,\\; b_2=1\\f$\n<br/>\\f$c_1 = 1,\\; c_2=1\\f$\n<br/>\\f$a = \\begin{bmatrix}0& 1& 1& 2& \\ldots\\end{bmatrix}\\f$\n<br/>This way you can find the \\f$10^{18}\\f$ fibonacci number%MOD.\nI have given a general way to use it. The program takes the input of B and C\nmatrix.\n\nSteps for Matrix Expo\n1. Create vector F1 : which is the copy of B.\n2. Create transpose matrix (Learn more about it on the internet)\n3. Perform \\f$T^{n-1}\\f$ [transpose matrix to the power n-1]\n4. Multiply with F to get the last matrix of size (1\\f$\\times\\f$k).\n\nThe first element of this matrix is the required result.\n*/\n\n#include <iostream>\n#include <vector>\n\nusing std::cin;\nusing std::cout;\nusing std::vector;\n\n/*! shorthand definition for `int64_t` */\n#define ll int64_t\n\n/*! shorthand definition for `std::endl` */\n#define endl std::endl\n\n/*! shorthand definition for `int64_t` */\n#define pb push_back\n#define MOD 1000000007\n\n/** global variable mat_size\n * @todo @stepfencurryxiao add documetnation\n */\nll mat_size;\n\n/** global vector variables used in the ::ans function.\n * @todo @stepfencurryxiao add documetnation\n */\nvector<ll> fib_b, fib_c;\n\n/** To multiply 2 matrices\n * \\param [in] A matrix 1 of size (m\\f$\\times\\f$n)\n * \\param [in] B \\p matrix 2 of size (p\\f$\\times\\f$q)\\n\\note \\f$p=n\\f$\n * \\result matrix of dimension (m\\f$\\times\\f$q)\n */\nvector<vector<ll>> multiply(const vector<vector<ll>> &A,\n                            const vector<vector<ll>> &B) {\n    vector<vector<ll>> C(mat_size + 1, vector<ll>(mat_size + 1));\n    for (ll i = 1; i <= mat_size; i++) {\n        for (ll j = 1; j <= mat_size; j++) {\n            for (ll z = 1; z <= mat_size; z++) {\n                C[i][j] = (C[i][j] + (A[i][z] * B[z][j]) % MOD) % MOD;\n            }\n        }\n    }\n    return C;\n}\n\n/** computing integer power of a matrix using recursive multiplication.\n * @note A must be a square matrix for this algorithm.\n * \\param [in] A base matrix\n * \\param [in] p exponent\n * \\return matrix of same dimension as A\n */\nvector<vector<ll>> power(const vector<vector<ll>> &A, ll p) {\n    if (p == 1)\n        return A;\n    if (p % 2 == 1) {\n        return multiply(A, power(A, p - 1));\n    } else {\n        vector<vector<ll>> X = power(A, p / 2);\n        return multiply(X, X);\n    }\n}\n\n/*! Wrapper for Fibonacci\n * \\param[in] n \\f$n^\\text{th}\\f$ Fibonacci number\n * \\return \\f$n^\\text{th}\\f$ Fibonacci number\n */\nll ans(ll n) {\n    if (n == 0)\n        return 0;\n    if (n <= mat_size)\n        return fib_b[n - 1];\n    // F1\n    vector<ll> F1(mat_size + 1);\n    for (ll i = 1; i <= mat_size; i++) F1[i] = fib_b[i - 1];\n\n    // Transpose matrix\n    vector<vector<ll>> T(mat_size + 1, vector<ll>(mat_size + 1));\n    for (ll i = 1; i <= mat_size; i++) {\n        for (ll j = 1; j <= mat_size; j++) {\n            if (i < mat_size) {\n                if (j == i + 1)\n                    T[i][j] = 1;\n                else\n                    T[i][j] = 0;\n                continue;\n            }\n            T[i][j] = fib_c[mat_size - j];\n        }\n    }\n    // T^n-1\n    T = power(T, n - 1);\n\n    // T*F1\n    ll res = 0;\n    for (ll i = 1; i <= mat_size; i++) {\n        res = (res + (T[1][i] * F1[i]) % MOD) % MOD;\n    }\n    return res;\n}\n\n/** Main function */\nint main() {\n    cin.tie(0);\n    cout.tie(0);\n    ll t;\n    cin >> t;\n    ll i, j, x;\n    while (t--) {\n        cin >> mat_size;\n        for (i = 0; i < mat_size; i++) {\n            cin >> x;\n            fib_b.pb(x);\n        }\n        for (i = 0; i < mat_size; i++) {\n            cin >> x;\n            fib_c.pb(x);\n        }\n        cin >> x;\n        cout << ans(x) << endl;\n        fib_b.clear();\n        fib_c.clear();\n    }\n    return 0;\n}\n","index":172},{"title":"Palindrome Of Number","category":"others","id":"palindrome_of_number_others","algorithm":"/**\n * @file\n * @brief Check if a number is\n * [palindrome](https://en.wikipedia.org/wiki/Palindrome) or not.\n *\n * This program cheats by using the STL library's std::reverse function.\n */\n#include <algorithm>\n#include <iostream>\n\n#ifdef _MSC_VER\n// Required to compile std::toString function using MSVC\n#include <string>\n#else\n#include <cstring>\n#endif\n\n/** Main function */\nint main() {\n    int num;\n    std::cout << \"Enter number = \";\n    std::cin >> num;\n\n    std::string s1 = std::to_string(num);  // convert number to string\n    std::string s2 = s1;\n\n    std::reverse(s1.begin(), s1.end());  // reverse the string\n\n    if (s1 == s2)  // check if reverse and original string are identical\n        std::cout << \"true\";\n    else\n        std::cout << \"false\";\n\n    return 0;\n}\n","index":173},{"title":"Paranthesis Matching","category":"others","id":"paranthesis_matching_others","algorithm":"/**\n * @file\n * @brief Perform paranthesis matching. \\note Do not know the application of\n * this, however.\n * @note Implementation is C-type and does not utilize the C++ constructs\n * @todo implement as a C++ class\n */\n#include <iostream>\n#ifdef _MSC_VER\n#include <string>  // Visual Studio C requires this include\n#else\n#include <cstring>\n#endif\n\n/** check number */\n#define MAX 100\n\n//! @{-------------- stack --------------\n//! global stack\nchar stack[MAX];\n\n//! pointer to track stack index\nint stack_idx = -1;\n\n//! push byte to stack variable\nvoid push(char ch) { stack[++stack_idx] = ch; }\n\n//! pop a byte out of stack variable\nchar pop() { return stack[stack_idx--]; }\n\n//! @}-------------- end stack -----------\n\n/** return opening paranthesis corresponding to the close paranthesis\n * @param[in] ch closed paranthesis character\n */\nchar opening(char ch) {\n    switch (ch) {\n    case '}':\n        return '{';\n    case ']':\n        return '[';\n    case ')':\n        return '(';\n    case '>':\n        return '<';\n    }\n    return '\\0';\n}\n\nint main() {\n    std::string exp;\n    int valid = 1, i = 0;\n    std::cout << \"Enter The Expression : \";\n    std::cin >> exp;\n\n    while (valid == 1 && i < exp.length()) {\n        if (exp[i] == '(' || exp[i] == '{' || exp[i] == '[' || exp[i] == '<') {\n            push(exp[i]);\n        } else if (stack_idx >= 0 && stack[stack_idx] == opening(exp[i])) {\n            pop();\n        } else {\n            valid = 0;\n        }\n        i++;\n    }\n\n    // makes sure the stack is empty after processsing (above)\n    if (valid == 1 && stack_idx == -1) {\n        std::cout << \"\\nCorrect Expression\";\n    } else {\n        std::cout << \"\\nWrong Expression\";\n    }\n\n    return 0;\n}\n","index":174},{"title":"Pascal Triangle","category":"others","id":"pascal_triangle_others","algorithm":"/**\n * @file\n * @brief Pascal's triangle implementation\n */\n#ifdef _MSC_VER\n#include <string>  // required for Visual C\n#else\n#include <cstring>\n#endif\n#include <iomanip>\n#include <iostream>\n\n/**\n * Print the triangle\n * \\param [in] arr  2D-array containing Pascal numbers\n * \\param [in] n    depth of Pascal triangle to print\n */\nvoid show_pascal(int **arr, int n) {\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n + i; ++j) {\n            if (arr[i][j] == 0)\n                std::cout << std::setw(4) << \" \";\n            else\n                std::cout << std::setw(4) << arr[i][j];\n        }\n        std::cout << std::endl;\n    }\n}\n\n/**\n * Print the triangle\n * \\param [in,out] arr  array containing Pascal numbers\n * \\param [in] n    depth of Pascal triangle to print\n * \\result arr pointer returned\n */\nint **pascal_triangle(int **arr, int n) {\n    for (int i = 0; i < n; ++i) {\n        for (int j = n - i - 1; j < n + i; ++j) {\n            if (j == n - i - 1 || j == n + i - 1)\n                arr[i][j] = 1;  // The edge of the Pascal triangle goes in 1\n            else\n                arr[i][j] = arr[i - 1][j - 1] + arr[i - 1][j + 1];\n        }\n    }\n\n    return arr;\n}\n\n/**\n * main function\n */\nint main() {\n    int n = 0;\n\n    std::cout << \"Set Pascal's Triangle Height\" << std::endl;\n    std::cin >> n;\n\n    // memory allocation (Assign two-dimensional array to store Pascal triangle)\n    int **arr = new int *[n];\n    for (int i = 0; i < n; ++i) {\n        arr[i] = new int[2 * n - 1];\n        memset(arr[i], 0, sizeof(int) * (2 * n - 1));\n    }\n\n    pascal_triangle(arr, n);\n    show_pascal(arr, n);\n\n    // deallocation\n    for (int i = 0; i < n; ++i) {\n        delete[] arr[i];\n    }\n    delete[] arr;\n\n    return 0;\n}\n","index":175},{"title":"Primality Test","category":"others","id":"primality_test_others","algorithm":"/**\n * @file\n * @brief [Primality test](https://en.wikipedia.org/wiki/Primality_test)\n * implementation.\n *\n * A simple and efficient implementation of a function to test if a number is\n * prime, based on the fact that\n * > Every Prime number, except 2 and 3, are of the form \\f$6k\\pm1\\f$ for\n * > integer values of k.\n * This gives a 3x speed improvement.\n */\n#include <iostream>\n\n/** Check if a number is prime\n * \\param[in] number number to check\n * \\returns true if prime else false\n */\nbool IsPrime(int number) {\n    if (((!(number & 1)) && number != 2) || (number < 2) ||\n        (number % 3 == 0 && number != 3))\n        return false;\n\n    for (int k = 1; 36 * k * k - 12 * k < number; ++k) {\n        if ((number % (6 * k + 1) == 0) || (number % (6 * k - 1) == 0))\n            return false;\n    }\n    return true;\n}\n\n/** main function */\nint main() {\n    // Main Function\n    std::cout << \"Enter the value of n to check if Prime\\n\";\n    int n;\n    std::cin >> n;\n    if (IsPrime(n))\n        std::cout << n << \" is Prime\" << std::endl;\n    else\n        std::cout << n << \" is not Prime\" << std::endl;\n\n    return 0;\n}\n","index":176},{"title":"Smallest Circle","category":"others","id":"smallest_circle_others","algorithm":"/**\n * @file\n * @brief Get centre and radius of the\n * [smallest circle](https://en.wikipedia.org/wiki/Smallest-circle_problem)\n * that circumscribes given set of points.\n *\n * @see [other\n * implementation](https://www.nayuki.io/page/smallest-enclosing-circle)\n */\n#include <cmath>\n#include <iostream>\n#include <vector>\n\n/** Define a point */\nstruct Point {\n    double x, /**< abscissa */\n        y;    /**< ordinate */\n\n    /** construct a point\n     * \\param [in] a absicca (default = 0.0)\n     * \\param [in] b ordinate (default = 0.0)\n     */\n    explicit Point(double a = 0.f, double b = 0.f) {\n        x = a;\n        y = b;\n    }\n};\n\n/** Compute the Euclidian distance between two points \\f$A\\equiv(x_1,y_1)\\f$ and\n * \\f$B\\equiv(x_2,y_2)\\f$ using the formula:\n * \\f[d=\\sqrt{\\left(x_1-x_2\\right)^2+\\left(y_1-y_2\\right)^2}\\f]\n *\n * \\param [in] A point A\n * \\param [in] B point B\n * \\return ditance\n */\ndouble LenghtLine(const Point &A, const Point &B) {\n    double dx = B.x - A.x;\n    double dy = B.y - A.y;\n    return std::sqrt((dx * dx) + (dy * dy));\n}\n\n/**\n * Compute the area of triangle formed by three points using [Heron's\n * formula](https://en.wikipedia.org/wiki/Heron%27s_formula).\n * If the lengths of the sides of the triangle are \\f$a,\\,b,\\,c\\f$ and\n * \\f$s=\\displaystyle\\frac{a+b+c}{2}\\f$ is the semi-perimeter then the area is\n * given by \\f[A=\\sqrt{s(s-a)(s-b)(s-c)}\\f]\n * \\param [in] A vertex A\n * \\param [in] B vertex B\n * \\param [in] C vertex C\n * \\returns area of triangle\n */\ndouble TriangleArea(const Point &A, const Point &B, const Point &C) {\n    double a = LenghtLine(A, B);\n    double b = LenghtLine(B, C);\n    double c = LenghtLine(C, A);\n    double p = (a + b + c) / 2;\n    return std::sqrt(p * (p - a) * (p - b) * (p - c));\n}\n\n/**\n * Check if a set of points lie within given circle. This is true if the\n * distance of all the points from the centre of the circle is less than the\n * radius of the circle\n * \\param [in] P set of points to check\n * \\param [in] Center coordinates to centre of the circle\n * \\param [in] R radius of the circle\n * \\returns True if P lies on or within the circle\n * \\returns False if P lies outside the circle\n */\nbool PointInCircle(const std::vector<Point> &P, const Point &Center, double R) {\n    for (size_t i = 0; i < P.size(); i++) {\n        if (LenghtLine(P[i], Center) > R)\n            return false;\n    }\n    return true;\n}\n\n/**\n * Find the centre and radius of a circle enclosing a set of points.\\n\n * The function returns the radius of the circle and prints the coordinated of\n * the centre of the circle.\n * \\param [in] P vector of points\n * \\returns radius of the circle\n */\ndouble circle(const std::vector<Point> &P) {\n    double minR = INFINITY;\n    double R;\n    Point C;\n    Point minC;\n\n    /* This code is invalid and does not give correct result for TEST 3 */\n    // for each point in the list\n    for (size_t i = 0; i < P.size() - 2; i++)\n        // for every subsequent point in the list\n        for (size_t j = i + 1; j < P.size(); j++)\n            // for every subsequent point in the list\n            for (size_t k = j + 1; k < P.size(); k++) {\n                // here, we now have picked three points from the given set of\n                // points that we can use\n                // viz., P[i], P[j] and P[k]\n                C.x = -0.5 * ((P[i].y * (P[j].x * P[j].x + P[j].y * P[j].y -\n                                         P[k].x * P[k].x - P[k].y * P[k].y) +\n                               P[j].y * (P[k].x * P[k].x + P[k].y * P[k].y -\n                                         P[i].x * P[i].x - P[i].y * P[i].y) +\n                               P[k].y * (P[i].x * P[i].x + P[i].y * P[i].y -\n                                         P[j].x * P[j].x - P[j].y * P[j].y)) /\n                              (P[i].x * (P[j].y - P[k].y) +\n                               P[j].x * (P[k].y - P[i].y) +\n                               P[k].x * (P[i].y - P[j].y)));\n                C.y = 0.5 * ((P[i].x * (P[j].x * P[j].x + P[j].y * P[j].y -\n                                        P[k].x * P[k].x - P[k].y * P[k].y) +\n                              P[j].x * (P[k].x * P[k].x + P[k].y * P[k].y -\n                                        P[i].x * P[i].x - P[i].y * P[i].y) +\n                              P[k].x * (P[i].x * P[i].x + P[i].y * P[i].y -\n                                        P[j].x * P[j].x - P[j].y * P[j].y)) /\n                             (P[i].x * (P[j].y - P[k].y) +\n                              P[j].x * (P[k].y - P[i].y) +\n                              P[k].x * (P[i].y - P[j].y)));\n                R = (LenghtLine(P[i], P[j]) * LenghtLine(P[j], P[k]) *\n                     LenghtLine(P[k], P[i])) /\n                    (4 * TriangleArea(P[i], P[j], P[k]));\n                if (!PointInCircle(P, C, R)) {\n                    continue;\n                }\n                if (R <= minR) {\n                    minR = R;\n                    minC = C;\n                }\n            }\n\n    // for each point in the list\n    for (size_t i = 0; i < P.size() - 1; i++)\n        // for every subsequent point in the list\n        for (size_t j = i + 1; j < P.size(); j++) {\n            // check for diameterically opposite points\n            C.x = (P[i].x + P[j].x) / 2;\n            C.y = (P[i].y + P[j].y) / 2;\n            R = LenghtLine(C, P[i]);\n            if (!PointInCircle(P, C, R)) {\n                continue;\n            }\n            if (R <= minR) {\n                minR = R;\n                minC = C;\n            }\n        }\n    std::cout << minC.x << \" \" << minC.y << std::endl;\n    return minR;\n}\n\n/** Test case: result should be:\n * \\n Circle with\n * \\n radius 3.318493136080724\n * \\n centre at (3.0454545454545454, 1.3181818181818181)\n */\nvoid test() {\n    std::vector<Point> Pv;\n    Pv.push_back(Point(0, 0));\n    Pv.push_back(Point(5, 4));\n    Pv.push_back(Point(1, 3));\n    Pv.push_back(Point(4, 1));\n    Pv.push_back(Point(3, -2));\n    std::cout << circle(Pv) << std::endl;\n}\n\n/** Test case: result should be:\n * \\n Circle with\n * \\n radius 1.4142135623730951\n * \\n centre at (1.0, 1.0)\n */\nvoid test2() {\n    std::vector<Point> Pv;\n    Pv.push_back(Point(0, 0));\n    Pv.push_back(Point(0, 2));\n    Pv.push_back(Point(2, 2));\n    Pv.push_back(Point(2, 0));\n    std::cout << circle(Pv) << std::endl;\n}\n\n/** Test case: result should be:\n * \\n Circle with\n * \\n radius 1.821078397711709\n * \\n centre at (2.142857142857143, 1.7857142857142856)\n * @todo This test fails\n */\nvoid test3() {\n    std::vector<Point> Pv;\n    Pv.push_back(Point(0.5, 1));\n    Pv.push_back(Point(3.5, 3));\n    Pv.push_back(Point(2.5, 0));\n    Pv.push_back(Point(2, 1.5));\n    std::cout << circle(Pv) << std::endl;\n}\n\n/** Main program */\nint main() {\n    test();\n    std::cout << std::endl;\n    test2();\n    std::cout << std::endl;\n    test3();\n    return 0;\n}\n","index":177},{"title":"Sparse Matrix","category":"others","id":"sparse_matrix_others","algorithm":"/** @file\n * A sparse matrix is a matrix which has number of zeroes greater than\n * \\f$\\frac{m\\times n}{2}\\f$, where m and n are the dimensions of the matrix.\n */\n\n#include <iostream>\n\n/** main function */\nint main() {\n    int m, n;\n    int counterZeros = 0;\n\n    std::cout << \"Enter dimensions of matrix (seperated with space): \";\n    std::cin >> m;\n    std::cin >> n;\n\n    int **a = new int *[m];\n    for (int i = 0; i < m; i++) a[i] = new int[n];\n\n    std::cout << \"Enter matrix elements:\";\n    std::cout << \"\\n\";\n\n    // reads the matrix from stdin\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            std::cout << \"element? \";\n            std::cin >> a[i][j];\n        }\n    }\n\n    // counts the zero's\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (a[i][j] == 0)\n                counterZeros++;  // Counting number of zeroes\n        }\n    }\n\n    // makes sure the matrix is a sparse matrix\n    if (counterZeros > ((m * n) / 2))  // Checking for sparse matrix\n        std::cout << \"Sparse matrix\";\n    else\n        std::cout << \"Not a sparse matrix\";\n\n    for (int i = 0; i < m; i++) delete[] a[i];\n    delete[] a;\n    return 0;\n}\n","index":178},{"title":"Spiral Print","category":"others","id":"spiral_print_others","algorithm":"/**\n * @file\n * @brief Print the elements of a matrix traversing it spirally\n */\n#include <iostream>\n\n/** Arrange sequence of numbers from '1' in a matrix form\n * \\param [out] a matrix to fill\n * \\param [in] r number of rows\n * \\param [in] c number of columns\n */\nvoid genArray(int **a, int r, int c) {\n    int value = 1;\n    for (int i = 0; i < r; i++) {\n        for (int j = 0; j < c; j++) {\n            a[i][j] = value;\n            std::cout << a[i][j] << \" \";\n            value++;\n        }\n        std::cout << std::endl;\n    }\n}\n\n/** Traverse the matrix spirally and print the sequence of elements\n * \\param [in] a matrix to read from\n * \\param [in] r number of rows\n * \\param [in] c number of columns\n */\nvoid spiralPrint(int **a, int r, int c) {\n    int startRow = 0, endRow = r - 1;\n    int startCol = 0, endCol = c - 1;\n    int cnt = 0;\n\n    while (startRow <= endRow && startCol <= endCol) {\n        /// Print start row\n        for (int i = startCol; i <= endCol; i++, cnt++) {\n            std::cout << a[startRow][i] << \" \";\n        }\n        startRow++;\n\n        /// Print the end col\n        for (int i = startRow; i <= endRow; i++, cnt++) {\n            std::cout << a[i][endCol] << \" \";\n        }\n        endCol--;\n\n        /// Print the end row\n        if (cnt == r * c) {\n            break;\n        }\n\n        for (int i = endCol; i >= startCol; i--, cnt++) {\n            std::cout << a[endRow][i] << \" \";\n        }\n        endRow--;\n\n        /// Print the start Col\n        if (cnt == r * c) {\n            break;\n        }\n        for (int i = endRow; i >= startRow; i--, cnt++) {\n            std::cout << a[i][startCol] << \" \";\n        }\n        startCol++;\n    }\n}\n\n/** main function */\nint main() {\n    int r, c;\n    std::cin >> r >> c;\n    int **a = new int *[r];\n    for (int i = 0; i < r; i++) a[i] = new int[c];\n\n    genArray(a, r, c);\n    spiralPrint(a, r, c);\n\n    for (int i = 0; i < r; i++) delete[] a[i];\n    delete[] a;\n    return 0;\n}\n","index":179},{"title":"Stairs Pattern","category":"others","id":"stairs_pattern_others","algorithm":"/**\n * @file\n@brief This program is use to print the following pattern<pre>\n   \\*\\*\n   \\*\\*\n  \\*\\*\\*\\*\n  \\*\\*\\*\\*\n \\*\\*\\*\\*\\*\\*\n \\*\\*\\*\\*\\*\\*\n\\*\\*\\*\\*\\*\\*\\*\\*\n********</pre>\nwhere number of pairs line is given by user\n*/\n#include <iostream>\n\n/** main function */\nint main() {\n    int l, st = 2, x, r, z, n, sp;\n    std::cout << \"enter Index \";\n    std::cin >> x;\n    z = x;\n    for (r = 1; r <= x; r++) {\n        z = z - 1;\n        for (n = 1; n <= 2; n++) {\n            for (sp = 1; sp <= z; sp++) {\n                std::cout << \" \";\n            }\n            for (l = 1; l <= st; l++) {\n                std::cout << \"*\";\n            }\n            std::cout << std::endl;\n        }\n        st = st + 2;\n    }\n}\n","index":180},{"title":"Tower Of Hanoi","category":"others","id":"tower_of_hanoi_others","algorithm":"/**\n * @file\n * @brief Solve the [Tower of\n * Hanoi](https://en.wikipedia.org/wiki/Tower_of_Hanoi) problem.\n */\n#include <iostream>\n\n/**\n * Define the state of tower\n */\nstruct tower {\n    //! Values in the tower\n    int values[10];\n    //! top tower ID\n    int top;\n};\n\n/** Display the towers */\nvoid show(const struct tower *const F, const struct tower *const T,\n          const struct tower *const U) {\n    std::cout << \"\\n\\n\\tF : \";\n    for (int i = 0; i < F->top; i++) {\n        std::cout << F->values[i] << \"\\t\";\n    }\n    std::cout << \"\\n\\tU : \";\n    for (int i = 0; i < U->top; i++) {\n        std::cout << U->values[i] << \"\\t\";\n    }\n    std::cout << \"\\n\\tT : \";\n    for (int i = 0; i < T->top; i++) {\n        std::cout << T->values[i] << \"\\t\";\n    }\n}\n\n/** Move one disc from one tower to another\n * \\param [in,out] From tower to move disk *from*\n * \\param [in,out] To  tower to move disk *to*\n */\nvoid mov(tower *From, tower *To) {\n    --From->top;\n    To->values[To->top] = From->values[From->top];\n    ++To->top;\n}\n\n/**\n * Recursive algorithm to solve the puzzle\n * \\param [in] n starting number of disks\n * \\param [in,out] From  tower to move disks from\n * \\param [in,out] Using temporary tower for the puzzle\n * \\param [in,out] To  tower to move disk to\n */\nvoid TH(int n, tower *From, tower *Using, tower *To) {\n    if (n == 1) {\n        mov(From, To);\n        show(From, To, Using);\n    } else {\n        TH(n - 1, From, To, Using);\n        mov(From, To);\n        show(From, To, Using);\n        TH(n - 1, Using, From, To);\n    }\n}\n\n/** Main function */\nint main() {\n    struct tower F, U, T;\n\n    F.top = 0;\n    U.top = 0;\n    T.top = 0;\n\n    int no;\n\n    std::cout << \"\\nEnter number of discs : \";\n    std::cin >> no;\n\n    for (int i = no; i > 0; i--) {\n        F.values[F.top++] = i;\n    }\n\n    show(&F, &T, &U);\n    TH(no, &F, &U, &T);\n\n    return 0;\n}\n","index":181},{"title":"Vector Important Functions","category":"others","id":"vector_important_functions_others","algorithm":"/**\n * @file\n * @brief A C++ program to demonstrate working of std::sort(), std::reverse()\n */\n#include <algorithm>\n#include <iostream>\n#include <numeric>  // For accumulate operation\n#include <vector>\n\n/** Main function */\nint main() {\n    // Initializing vector with array values\n    int arr[] = {10, 20, 5, 23, 42, 15};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    std::vector<int> vect(arr, arr + n);\n\n    std::cout << \"Vector is: \";\n    for (int i = 0; i < n; i++) std::cout << vect[i] << \" \";\n\n    // Sorting the Vector in Ascending order\n    std::sort(vect.begin(), vect.end());\n\n    std::cout << \"\\nVector after sorting is: \";\n    for (int i = 0; i < n; i++) std::cout << vect[i] << \" \";\n\n    // Reversing the Vector\n    std::reverse(vect.begin(), vect.end());\n\n    std::cout << \"\\nVector after reversing is: \";\n    for (int i = 0; i < 6; i++) std::cout << vect[i] << \" \";\n\n    std::cout << \"\\nMaximum element of vector is: \";\n    std::cout << *max_element(vect.begin(), vect.end());\n\n    std::cout << \"\\nMinimum element of vector is: \";\n    std::cout << *min_element(vect.begin(), vect.end());\n\n    // Starting the summation from 0\n    std::cout << \"\\nThe summation of vector elements is: \";\n    std::cout << accumulate(vect.begin(), vect.end(), 0);\n\n    return 0;\n}\n","index":182},{"title":"Probability","category":null,"id":"probability","index":183},{"title":"Addition Rule","category":"probability","id":"addition_rule_probability","algorithm":"/**\n * @file\n * @brief Addition rule of probabilities\n */\n#include <iostream>\n\n/**\n * calculates the probability of the independent events A or B for independent\n * events\n * \\parama [in] A probability of event A\n * \\parama [in] B probability of event B\n * \\returns probability of A and B\n */\ndouble addition_rule_independent(double A, double B) {\n    return (A + B) - (A * B);\n}\n\n/** Calculates the probability of the events A or B for dependent events\n * note that if value of B_given_A is unknown, use chainrule to find it\n * \\parama [in] A probability of event A\n * \\parama [in] B probability of event B\n * \\parama [in] B_given_A probability of event B condition A\n * \\returns probability of A and B\n */\ndouble addition_rule_dependent(double A, double B, double B_given_A) {\n    return (A + B) - (A * B_given_A);\n}\n\n/** Main function */\nint main() {\n    double A = 0.5;\n    double B = 0.25;\n    double B_given_A = 0.05;\n\n    std::cout << \"independent P(A or B) = \" << addition_rule_independent(A, B)\n              << std::endl;\n\n    std::cout << \"dependent P(A or B) = \"\n              << addition_rule_dependent(A, B, B_given_A) << std::endl;\n\n    return 0;\n}\n","index":184},{"title":"Bayes Theorem","category":"probability","id":"bayes_theorem_probability","algorithm":"/**\n * @file\n * @brief [Bayes' theorem](https://en.wikipedia.org/wiki/Bayes%27_theorem)\n *\n * Bayes' theorem allows one to find \\f$P(A|B)\\f$ given \\f$P(B|A)\\f$ or\n * \\f$P(B|A)\\f$ given \\f$P(A|B)\\f$ and \\f$P(A)\\f$ and \\f$P(B)\\f$.\\n\n * Note that \\f$P(A|B)\\f$ is read 'The probability of A given that the event B\n * has occured'.\n */\n#include <iostream>\n\n/** returns P(A|B)\n */\ndouble bayes_AgivenB(double BgivenA, double A, double B) {\n    return (BgivenA * A) / B;\n}\n\n/** returns P(B|A)\n */\ndouble bayes_BgivenA(double AgivenB, double A, double B) {\n    return (AgivenB * B) / A;\n}\n\n/** Main function\n */\nint main() {\n    double A = 0.01;\n    double B = 0.1;\n    double BgivenA = 0.9;\n    double AgivenB = bayes_AgivenB(BgivenA, A, B);\n    std::cout << \"A given B = \" << AgivenB << std::endl;\n    std::cout << \"B given A = \" << bayes_BgivenA(AgivenB, A, B) << std::endl;\n    return 0;\n}\n","index":185},{"title":"Binomial Dist","category":"probability","id":"binomial_dist_probability","algorithm":"/**\n * @file\n * @brief [Binomial\n * distribution](https://en.wikipedia.org/wiki/Binomial_distribution) example\n *\n * The binomial distribution models the number of\n * successes in a sequence of n independent events\n *\n * Summary of variables used:\n * * n : number of trials\n * * p : probability of success\n * * x : desired successes\n */\n#include <cmath>\n#include <iostream>\n\n/** finds the expected value of a binomial distribution\n * \\param [in] n\n * \\param [in] p\n * \\returns \\f$\\mu=np\\f$\n */\ndouble binomial_expected(double n, double p) { return n * p; }\n\n/** finds the variance of the binomial distribution\n * \\param [in] n\n * \\param [in] p\n * \\returns \\f$\\sigma^2 = n\\cdot p\\cdot (1-p)\\f$\n */\ndouble binomial_variance(double n, double p) { return n * p * (1 - p); }\n\n/** finds the standard deviation of the binomial distribution\n * \\param [in] n\n * \\param [in] p\n * \\returns \\f$\\sigma = \\sqrt{\\sigma^2} = \\sqrt{n\\cdot p\\cdot (1-p)}\\f$\n */\ndouble binomial_standard_deviation(double n, double p) {\n    return std::sqrt(binomial_variance(n, p));\n}\n\n/** Computes n choose r\n * \\param [in] n\n * \\param [in] r\n * \\returns \\f$\\displaystyle {n\\choose r} =\n * \\frac{n!}{r!(n-r)!} = \\frac{n\\times(n-1)\\times(n-2)\\times\\cdots(n-r)}{r!}\n * \\f$\n */\ndouble nCr(double n, double r) {\n    double numerator = n;\n    double denominator = r;\n\n    for (int i = n - 1; i >= ((n - r) + 1); i--) {\n        numerator *= i;\n    }\n\n    for (int i = 1; i < r; i++) {\n        denominator *= i;\n    }\n\n    return numerator / denominator;\n}\n\n/** calculates the probability of exactly x successes\n * \\returns \\f$\\displaystyle P(n,p,x) = {n\\choose x} p^x (1-p)^{n-x}\\f$\n */\ndouble binomial_x_successes(double n, double p, double x) {\n    return nCr(n, x) * std::pow(p, x) * std::pow(1 - p, n - x);\n}\n\n/** calculates the probability of a result within a range (inclusive, inclusive)\n * \\returns \\f$\\displaystyle \\left.P(n,p)\\right|_{x_0}^{x_1} =\n * \\sum_{i=x_0}^{x_1} P(i)\n * =\\sum_{i=x_0}^{x_1} {n\\choose i} p^i (1-p)^{n-i}\\f$\n */\ndouble binomial_range_successes(double n, double p, double lower_bound,\n                                double upper_bound) {\n    double probability = 0;\n    for (int i = lower_bound; i <= upper_bound; i++) {\n        probability += nCr(n, i) * std::pow(p, i) * std::pow(1 - p, n - i);\n    }\n    return probability;\n}\n\n/** main function */\nint main() {\n    std::cout << \"expected value : \" << binomial_expected(100, 0.5)\n              << std::endl;\n\n    std::cout << \"variance : \" << binomial_variance(100, 0.5) << std::endl;\n\n    std::cout << \"standard deviation : \"\n              << binomial_standard_deviation(100, 0.5) << std::endl;\n\n    std::cout << \"exactly 30 successes : \" << binomial_x_successes(100, 0.5, 30)\n              << std::endl;\n\n    std::cout << \"45 or more successes : \"\n              << binomial_range_successes(100, 0.5, 45, 100) << std::endl;\n\n    return 0;\n}\n","index":186},{"title":"Poisson Dist","category":"probability","id":"poisson_dist_probability","algorithm":"/**\n * @file\n * @brief [Poisson\n * statistics](https://en.wikipedia.org/wiki/Poisson_distribution)\n *\n * The Poisson distribution counts how many\n * events occur over a set time interval.\n */\n#include <cmath>\n#include <iostream>\n\n/**\n * poisson rate:\\n\n * calculate the events per unit time\\n\n * e.g 5 dollars every 2 mins = 5 / 2 = 2.5\n */\ndouble poisson_rate(double events, double timeframe) {\n    return events / timeframe;\n}\n\n/**\n *  calculate the expected value over a time\n * e.g rate of 2.5 over 10 mins = 2.5 x 10 = 25\n */\ndouble poisson_expected(double rate, double time) { return rate * time; }\n\n/**\n * Compute factorial of a given number\n */\ndouble fact(double x) {\n    double x_fact = x;\n    for (int i = x - 1; i > 0; i--) {\n        x_fact *= i;\n    }\n\n    if (x_fact <= 0) {\n        x_fact = 1;\n    }\n    return x_fact;\n}\n\n/**\n * Find the probability of x successes in a Poisson dist.\n * \\f[p(\\mu,x) = \\frac{\\mu^x e^{-\\mu}}{x!}\\f]\n */\ndouble poisson_x_successes(double expected, double x) {\n    return (std::pow(expected, x) * std::exp(-expected)) / fact(x);\n}\n\n/**\n * probability of a success in range for Poisson dist (inclusive, inclusive)\n * \\f[P = \\sum_i p(\\mu,i)\\f]\n */\ndouble poisson_range_successes(double expected, double lower, double upper) {\n    double probability = 0;\n    for (int i = lower; i <= upper; i++) {\n        probability += poisson_x_successes(expected, i);\n    }\n    return probability;\n}\n\n/**\n * main function\n */\nint main() {\n    double rate, expected;\n    rate = poisson_rate(3, 1);\n    std::cout << \"Poisson rate : \" << rate << std::endl;\n\n    expected = poisson_expected(rate, 2);\n    std::cout << \"Poisson expected : \" << expected << std::endl;\n\n    std::cout << \"Poisson 0 successes : \" << poisson_x_successes(expected, 0)\n              << std::endl;\n    std::cout << \"Poisson 0-8 successes : \"\n              << poisson_range_successes(expected, 0, 8) << std::endl;\n\n    return 0;\n}\n","index":187},{"title":"Range Queries","category":null,"id":"range_queries","index":188},{"title":"Fenwick Tree","category":"range_queries","id":"fenwick_tree_range_queries","algorithm":"/**\n * @file\n * @brief Fenwick tree\n *\n * A Fenwick tree or binary indexed tree is a data structure\n * that can efficiently update elements and calculate\n * prefix sums in a table of numbers.\n */\n#include <cassert>\n#include <iostream>\n#include <vector>\n\n/**\n * n --> No. of elements present in input array.\n * bit[0..n] --> Array that represents Binary Indexed Tree.\n */\nclass FenwickTree {\n    int n;\n    std::vector<int> bit;\n\n    /** Returns the highest power of two which is not more than x */\n    inline int offset(int x) { return (x & (-x)); }\n\n public:\n    /** Constructor\n     * \\param[in] arr --> Input array for which prefix sum is evaluated.\n     */\n    explicit FenwickTree(const std::vector<int>& arr) {\n        n = arr.size();\n        bit.assign(n + 1, 0);\n        for (int i = 0; i < n; ++i) {\n            update(i, arr[i]);\n        }\n    }\n\n    /** Constructor\n     * \\param[in] x --> Size of array that represents Binary Indexed Tree.\n     */\n    explicit FenwickTree(int x) {\n        n = x;\n        bit.assign(n + 1, 0);\n    }\n\n    /** Add val at id */\n    void update(int id, int val) {\n        id++;\n        while (id <= n) {\n            bit[id] += val;\n            id += offset(id);\n        }\n    }\n\n    /** Get prefix sum upto id */\n    int sum(int id) {\n        id++;\n        int res = 0;\n        while (id > 0) {\n            res += bit[id];\n            id -= offset(id);\n        }\n        return res;\n    }\n\n    /** Returns the prefix sum in range from l to r */\n    int sum_range(int l, int r) { return sum(r) - sum(l - 1); }\n};\n\n/** Main function */\nint main() {\n    int n = 5;\n    std::vector<int> arr = {1, 2, 3, 4, 5};\n    FenwickTree fenwick_tree(arr);\n\n    assert(fenwick_tree.sum_range(0, 0) == 1);\n    assert(fenwick_tree.sum_range(0, 1) == 3);\n    assert(fenwick_tree.sum_range(0, 2) == 6);\n    fenwick_tree.update(0, 6);\n    assert(fenwick_tree.sum_range(0, 0) == 6);\n    assert(fenwick_tree.sum_range(0, 1) == 8);\n    assert(fenwick_tree.sum_range(0, 2) == 11);\n    return 0;\n}\n","index":189},{"title":"Heavy Light Decomposition","category":"range_queries","id":"heavy_light_decomposition_range_queries","algorithm":"/**\n * @file\n * @brief [Heavy Light\n * Decomposition](https://en.wikipedia.org/wiki/Heavy_path_decomposition)\n * implementation\n * @author [Aniruthan R](https://github.com/aneee004)\n *\n * @details\n * Heavy-Light Decomposition is a technique on trees, that supports the\n * following:\n * 1. Update node s, with a value v\n * 2. Return the (sum) of all node values on the simple path from a to b\n * (sum) can also be replced with XOR, OR, AND, min, or max\n *\n * The update is done in O(log n) time, and\n * the query is done in O(log^2 n) time with HLD\n * where, n is the number of nodes\n *\n * The template type is the data type of the value stored in the nodes.\n * If a non-primitive data-type is used as a template,\n * the coressponding operators must be overloaded.\n *\n * An HLD object can only be created with a constant number of nodes, and\n * it cannot be changed later. Creaty an empty instance is not supported.\n *\n * To start answering updates and queries,\n * 1. Create an instance of HLD<X> object (obj), with the required data type.\n * 2. Read in the edge/parent information and update it with obj.add_edge().\n * Note: The edges addes must be 0 indexed.\n * 3. Create a vector with initial node values, and call set_node_val() with it.\n * 4. Call obj.init() to populate the required information for supporting\n * operations.\n * 5. Call obj.update(node, new_val), to update the value at index 'node' to the\n * new value. Note: node must be 0 indexed\n * 6. Call obj.query(a, b) to get the (sum) of node values in the simple path\n * from a to b. Note: a and b, must be 0 indexed.\n *\n * Sample I/O at the bottom.\n * @todo Support edge weight queries, by storing the edge weight value in it's\n * child algorithm verified by testing in CSES path queries:\n * https://cses.fi/problemset/task/1138\n */\n\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <list>\n#include <numeric>\n#include <string>\n#include <vector>\n\n/**\n * @namespace range_queries\n * @brief Algorithms and Data Structures that support range queries and updates.\n */\nnamespace range_queries {\n/**\n * @namespace heavy_light_decomposition\n * @brief Heavy light decomposition algorithm\n */\nnamespace heavy_light_decomposition {\n/**\n * @brief A Basic Tree, which supports binary lifting\n * @tparam the data type of the values stored in the tree nodes\n * @details Deleting the default constructor\n * An instance can only be created with the number of nodes\n * Defaults:\n * t_node indexing are zero based\n * t_root is 0\n * depth of root_node is 0\n * Supports:\n * lift :- lift a node k units up the tree\n * kth_ancestor :- returns the kth ancestor\n * lca :- returns the least common ancestor\n */\ntemplate <typename X> class Tree {\n  //\n\nprivate:\n  std::vector<std::list<int>>\n      t_adj;         ///< an adjacency list to stores the tree edges\n  const int t_nodes, ///< number of nodes\n      t_maxlift;     ///< maximum possible height of the tree\n  std::vector<std::vector<int>>\n      t_par;                ///< a matrix to store every node's 2^kth parent\n  std::vector<int> t_depth, ///< a vector to store the depth of a node,\n      t_size; ///< a vector to store the subtree size rooted at node\n\n  int t_root;           ///< the root of the tree\n  std::vector<X> t_val; ///< values of nodes\n  template <typename T> friend class HLD;\n\n  /**\n   * @brief Utility function to compute sub-tree sizes\n   * @param u current dfs node\n   * @param p the parent of node @param u\n   * @returns void\n   */\n  void dfs_size(int u, int p = -1) {\n    for (const int &v : t_adj[u]) {\n      if (v ^ p) {\n        dfs_size(v, u);\n        t_size[u] += t_size[v];\n      }\n    }\n  }\n\n  /**\n   * @brief Utility function to populate the t_par vector\n   * @param u current dfs node\n   * @param p the parent of node u\n   * @returns void\n   */\n  void dfs_lca(int u, int p = -1) {\n    t_par[u][0] = p;\n    if (p != -1) {\n      t_depth[u] = 1 + t_depth[p];\n    }\n    for (int k = 1; k < t_maxlift; k++) {\n      if (t_par[u][k - 1] != -1) {\n        t_par[u][k] = t_par[t_par[u][k - 1]][k - 1];\n      }\n    }\n\n    for (const int &v : t_adj[u]) {\n      if (v ^ p) {\n        dfs_lca(v, u);\n      }\n    }\n  }\n\npublic:\n  /**\n   * @brief Class parameterized constructor, resizes the and initializes the\n   * data members\n   * @param nodes the total number of nodes in the tree\n   */\n  explicit Tree(int nodes)\n      : t_nodes(nodes), t_maxlift(static_cast<int>(floor(log2(nodes))) + 1) {\n    /* Initialize and resize all the vectors */\n    t_root = 0; /* Default */\n    t_adj.resize(t_nodes);\n    t_par.assign(t_nodes, std::vector<int>(t_maxlift, -1));\n    t_depth.assign(t_nodes, 0);\n    t_size.assign(t_nodes, 1);\n    t_val.resize(t_nodes);\n  }\n\n  /**\n   * @brief Adds an undirected edge from node u to node v in the tree\n   * @param u the node where the edge is from\n   * @param v the node where the edge is to\n   * @returns void\n   */\n  void add_edge(const int u, const int v) {\n    t_adj[u].push_back(v);\n    t_adj[v].push_back(u);\n  }\n\n  /**\n   * @brief Set the root for the tree\n   * @param new_root the new root\n   * @returns void\n   */\n  void change_root(int new_root) { t_root = new_root; }\n\n  /**\n   * @brief Set the values for all the nodes\n   * @param node_val a vector of size n, with all the node values where, n is\n   * the number of nodes\n   * @returns void\n   */\n  void set_node_val(const std::vector<X> &node_val) {\n    assert(static_cast<int>(node_val.size()) == t_nodes);\n    t_val = node_val;\n  }\n\n  /**\n   * @brief This function must be called after the tree adjacency list and node\n   * values are populated The function initializes the required parameters, and\n   * populates the segment tree\n   * @returns void\n   */\n  void init() {\n    assert(t_nodes > 0);\n    dfs_size(t_root);\n    dfs_lca(t_root);\n  }\n\n  /**\n   * @brief The function lifts a node, k units up the tree.\n   * The lifting is done in place, and the result is stored in the address\n   * pointed by p.\n   * @param p a pointer to the variable that stores the node id\n   * @param dist the distance to move up the tree\n   * @returns void\n   */\n  void lift(int *const p, int dist) {\n    for (int k = 0; k < t_maxlift; k++) {\n      if (*p == -1) {\n        return;\n      }\n      if (dist & 1) {\n        *p = t_par[*p][k];\n      }\n      dist >>= 1;\n    }\n  }\n\n  /**\n   * @brief The function returns the kth ancestor of a node\n   * @param p the node id whose kth ancestor is to be found\n   * @param dist the distance to move up the tree\n   * @returns the kth ancestor of node\n   */\n  int kth_ancestor(int p, const int &dist) {\n    lift(&p, dist);\n    return p;\n  }\n\n  /**\n   * @brief The function returns the least common ancestor of two nodes\n   * @param a node id_1\n   * @param b node id_2\n   * @returns the least common ancestor of node a, and node b\n   */\n  int lca(int a, int b) {\n    assert(a >= 0 and b >= 0 and a < t_nodes and b < t_nodes);\n    if (t_depth[a] > t_depth[b]) {\n      lift(&a, t_depth[a] - t_depth[b]);\n    }\n    if (t_depth[b] > t_depth[a]) {\n      lift(&b, t_depth[b] - t_depth[a]);\n    }\n    if (a == b) {\n      return a;\n    }\n    for (int k = t_maxlift - 1; k >= 0; k--) {\n      if (t_par[a][k] != t_par[b][k]) {\n        a = t_par[a][k];\n        b = t_par[b][k];\n      }\n    }\n    return t_par[a][0];\n  }\n};\n\n/**\n * @brief Segment Tree, to store heavy chains\n * @tparam the data type of the values stored in the tree nodes\n */\ntemplate <typename X> class SG {\nprivate:\n  /**\n   * @brief Everything here is private,\n   * and can only be accessed through the methods,\n   * in the derived class (HLD)\n   */\n\n  std::vector<X> s_tree; ///< the segment tree, stored as a vector\n  int s_size;            ///< number of leaves in the segment tree\n  X sret_init = 0;       ///< inital query return value\n  template <typename T> friend class HLD;\n\n  /**\n   * @brief Function that specifies the type of operation involved when segments\n   * are combined\n   * @param lhs the left segment\n   * @param rhs the right segment\n   * @returns the combined result\n   */\n  X combine(X lhs, X rhs) { return lhs + rhs; }\n\n  /**\n   * @brief Class parameterized constructor. Resizes the and initilizes the data\n   * members.\n   * @param nodes the total number of nodes in the tree\n   * @returns void\n   */\n  explicit SG(int size) {\n    s_size = size;\n    s_tree.assign(2 * s_size, 0ll);\n  }\n\n  /**\n   * @brief Update the value at a node\n   * @param p the node to be udpated\n   * @param v the update value\n   * @returns void\n   */\n  void update(int p, X v) {\n    for (p += s_size; p > 0; p >>= 1) {\n      s_tree[p] += v;\n    }\n  }\n\n  /**\n   * @brief Make a range query from node label l to node label r\n   * @param l node label where the path starts\n   * @param r node label where the path ends\n   * @returns void\n   */\n  X query(int l, int r) {\n    X lhs = sret_init, rhs = sret_init;\n    for (l += s_size, r += s_size + 1; l < r; l >>= 1, r >>= 1) {\n      if (l & 1) {\n        lhs = combine(lhs, s_tree[l++]);\n      }\n      if (r & 1) {\n        rhs = combine(s_tree[--r], rhs);\n      }\n    }\n    return combine(lhs, rhs);\n  }\n\n  /**\n   * @brief Set the initialization for the query data type, based on requirement\n   *\n   * @details\n   * Change the sret_init, based on requirement:\n   * * Sum Query: 0 (Default)\n   * * XOR Query: 0 (Default)\n   * * Min Query: Infinity\n   * * Max Query: -Infinity\n   * @param new_sret_init the new init\n   */\n  void set_sret_init(X new_sret_init) { sret_init = new_sret_init; }\n};\n\n/**\n * @brief The Heavy-Light Decomposition class\n * @tparam the data type of the values stored in the tree nodes\n */\ntemplate <typename X> class HLD : public Tree<X>, public SG<X> {\nprivate:\n  int label;                ///< utility member to assign labels in dfs_labels()\n  std::vector<int> h_label, ///< stores the label of a node\n      h_heavychlid,         ///< stores the heavy child of a node\n      h_parent;             ///< stores the top of the heavy chain from a node\n\n  /**\n   * @brief Utility function to assign heavy child to each node (-1 for a leaf\n   * node)\n   * @param u current dfs node\n   * @param p the parent of node u\n   * @returns void\n   */\n  void dfs_hc(int u, int p = -1) {\n    int hc_size = -1, hc_id = -1;\n    for (const int &v : Tree<X>::t_adj[u]) {\n      if (v ^ p) {\n        dfs_hc(v, u);\n        if (Tree<X>::t_size[v] > hc_size) {\n          hc_size = Tree<X>::t_size[v];\n          hc_id = v;\n        }\n      }\n    }\n    h_heavychlid[u] = hc_id;\n  }\n\n  /**\n   * @brief Utility function to assign highest parent that can be reached though\n   * heavy chains\n   * @param u current dfs node\n   * @param p the parent of node u\n   * @returns void\n   */\n  void dfs_par(int u, int p = -1) {\n    if (h_heavychlid[u] != -1) {\n      h_parent[h_heavychlid[u]] = h_parent[u];\n      dfs_par(h_heavychlid[u], u);\n    }\n    for (const int &v : Tree<X>::t_adj[u]) {\n      if (v ^ p and v ^ h_heavychlid[u]) {\n        dfs_par(v, u);\n      }\n    }\n  }\n\n  /**\n   * @brief Utility function to lable the nodes so that heavy chains have a\n   * contigous lable\n   * @param u current dfs node\n   * @param p the parent of node u\n   * @returns void\n   */\n  void dfs_labels(int u, int p = -1) {\n    h_label[u] = label++;\n    if (h_heavychlid[u] != -1) {\n      dfs_labels(h_heavychlid[u], u);\n    }\n    for (const int &v : Tree<X>::t_adj[u]) {\n      if (v ^ p and v ^ h_heavychlid[u]) {\n        dfs_labels(v, u);\n      }\n    }\n  }\n\n  /**\n   * @brief Utility function to break down a path query into two chain queries\n   * @param a node where the path starts\n   * @param b node where the path ends\n   * a and b must belong to a single root to leaf chain\n   * @returns the sum of ndoe values in the simple path from a to b\n   */\n  X chain_query(int a, int b) {\n    X ret = SG<X>::sret_init;\n    if (Tree<X>::t_depth[a] < Tree<X>::t_depth[b]) {\n      std::swap(a, b);\n    }\n    while (Tree<X>::t_depth[a] >= Tree<X>::t_depth[b]) {\n      int l = h_label[h_parent[a]];\n      int r = h_label[a];\n      if (Tree<X>::t_depth[h_parent[a]] < Tree<X>::t_depth[b]) {\n        l += Tree<X>::t_depth[b] - Tree<X>::t_depth[h_parent[a]];\n      }\n      ret = SG<X>::combine(ret, SG<X>::query(l, r));\n      a = Tree<X>::t_par[h_parent[a]][0];\n      if (a == -1) {\n        break;\n      }\n    }\n    return ret;\n  }\n\npublic:\n  /**\n   * @brief Class parameterized constructor. Resizes the and initilizes the data\n   * members.\n   * @param nodes the total number of nodes in the tree\n   */\n  explicit HLD<X>(int nodes) : Tree<X>(nodes), SG<X>(nodes) {\n    /* Initialization and resize vectors */\n    label = 0;\n    h_label.assign(Tree<X>::t_nodes, -1);\n    h_heavychlid.assign(Tree<X>::t_nodes, -1);\n    h_parent.resize(Tree<X>::t_nodes);\n    iota(h_parent.begin(), h_parent.end(), 0);\n  }\n\n  /**\n   * @brief This function must be called after the tree adjacency list and node\n   * values are populated The function initializes the required parametes, and\n   * populates the segment tree\n   * @returns void\n   */\n  void init() {\n    Tree<X>::init();\n\n    // Fill the heavy child, greatest parent, and labels\n    label = 0;\n    dfs_hc(Tree<X>::t_root);\n    dfs_par(Tree<X>::t_root);\n    dfs_labels(Tree<X>::t_root);\n\n    // Segment Tree Initialization\n    for (int i = 0; i < Tree<X>::t_nodes; i++) {\n      SG<X>::s_tree[h_label[i] + Tree<X>::t_nodes] = Tree<X>::t_val[i];\n    }\n    for (int i = Tree<X>::t_nodes - 1; i > 0; i--) {\n      SG<X>::s_tree[i] =\n          SG<X>::combine(SG<X>::s_tree[i << 1], SG<X>::s_tree[i << 1 | 1]);\n    }\n  }\n\n  /**\n   * @brief This function updates the value at node with val\n   * @param node the node where the update is done\n   * @param val the value that is being updated\n   * @returns void\n   */\n  void update(int node, X val) {\n    X diff = val - Tree<X>::t_val[node];\n    SG<X>::update(h_label[node], diff);\n    Tree<X>::t_val[node] = val;\n  }\n\n  /**\n   * @brief This function returns the sum of node values in the simple path from\n   * from node_1 to node_2\n   * @param a the node where the simple path starts\n   * @param b the node where the simple path ends\n   * (parameters are interchangeable, i.e., the function is commutative)\n   * @returns the sum of node values in the simple path from a to b\n   */\n  X query(int a, int b) {\n    int lc = Tree<X>::lca(a, b);\n    X ret = SG<X>::sret_init;\n    assert(lc != -1);\n    ret += chain_query(a, lc);\n    ret += chain_query(b, lc);\n    return ret - Tree<X>::t_val[lc];\n  }\n};\n} // namespace heavy_light_decomposition\n} // namespace range_queries\n\n/**\n * Test implementations\n * @returns none\n */\nstatic void test_1() {\n  std::cout << \"Test 1:\\n\";\n\n  // Test details\n  int n = 5;\n  std::vector<int64_t> node_values = {4, 2, 5, 2, 1};\n  std::vector<std::vector<int>> edges = {{1, 2}, {1, 3}, {3, 4}, {3, 5}};\n  std::vector<std::vector<int>> queries = {\n      {2, 1, 4},\n      {1, 3, 2},\n      {2, 1, 4},\n  };\n  std::vector<int> expected_result = {11, 8};\n  std::vector<int> code_result;\n\n  range_queries::heavy_light_decomposition::HLD<int64_t> hld(n);\n  hld.set_node_val(node_values);\n  for (int i = 0; i < n - 1; i++) {\n    int u = edges[i][0], v = edges[i][1];\n    hld.add_edge(u - 1, v - 1);\n  }\n  hld.init();\n  for (const auto &q : queries) {\n    int type = q[0];\n    if (type == 1) {\n      int p = q[1], x = q[2];\n      hld.update(p - 1, x);\n    } else if (type == 2) {\n      int a = q[1], b = q[2];\n      code_result.push_back(hld.query(a - 1, b - 1));\n    } else {\n      continue;\n    }\n  }\n  for (int i = 0; i < static_cast<int>(expected_result.size()); i++) {\n    assert(expected_result[i] == code_result[i]);\n  }\n  std::cout << \"\\nTest 1 passed!\\n\";\n}\n\n/**\n * Second test implementations\n * @returns void\n */\nstatic void test_2() {\n  std::cout << \"Test 2:\\n\";\n\n  // Test details (Bamboo)\n  int n = 10;\n  std::vector<int64_t> node_values = {1, 8, 6, 8, 6, 2, 9, 2, 3, 2};\n  std::vector<std::vector<int>> edges = {\n      {10, 5}, {6, 2}, {10, 7}, {5, 2}, {3, 9}, {8, 3}, {1, 4}, {6, 4}, {8, 7}};\n  std::vector<std::vector<int>> queries = {\n      {2, 1, 10}, {2, 1, 6}, {1, 3, 4}, {2, 1, 9}, {1, 5, 3},\n      {1, 7, 8},  {2, 1, 4}, {2, 1, 8}, {1, 1, 4}, {1, 2, 7}};\n  std::vector<int> expected_result = {27, 11, 45, 9, 34};\n  std::vector<int> code_result;\n\n  range_queries::heavy_light_decomposition::HLD<int64_t> hld(n);\n  hld.set_node_val(node_values);\n  for (int i = 0; i < n - 1; i++) {\n    int u = edges[i][0], v = edges[i][1];\n    hld.add_edge(u - 1, v - 1);\n  }\n  hld.init();\n  for (const auto &q : queries) {\n    int type = q[0];\n    if (type == 1) {\n      int p = q[1], x = q[2];\n      hld.update(p - 1, x);\n    } else if (type == 2) {\n      int a = q[1], b = q[2];\n      code_result.push_back(hld.query(a - 1, b - 1));\n    } else {\n      continue;\n    }\n  }\n  for (int i = 0; i < static_cast<int>(expected_result.size()); i++) {\n    assert(expected_result[i] == code_result[i]);\n  }\n  std::cout << \"\\nTest2 passed!\\n\";\n}\n\n/**\n * Third test implementations\n * @returns void\n */\nstatic void test_3() {\n  std::cout << \"Test 3:\\n\";\n\n  // Test details\n  int n = 8;\n  std::vector<int64_t> node_values = {1, 8, 6, 8, 6, 2, 9, 2};\n  std::vector<std::vector<int>> edges = {{1, 2}, {2, 3}, {3, 4}, {1, 5},\n                                         {6, 3}, {7, 5}, {8, 7}};\n  std::vector<std::vector<int>> queries = {\n      {2, 6, 8}, {2, 3, 6}, {1, 3, 4}, {2, 7, 1}, {1, 5, 3},\n      {1, 7, 8}, {2, 6, 4}, {2, 7, 8}, {1, 1, 4}, {1, 2, 7}};\n  std::vector<int> expected_result = {34, 8, 16, 14, 10};\n  std::vector<int> code_result;\n\n  range_queries::heavy_light_decomposition::HLD<int64_t> hld(n);\n  hld.set_node_val(node_values);\n  for (int i = 0; i < n - 1; i++) {\n    int u = edges[i][0], v = edges[i][1];\n    hld.add_edge(u - 1, v - 1);\n  }\n  hld.init();\n  for (const auto &q : queries) {\n    int type = q[0];\n    if (type == 1) {\n      int p = q[1], x = q[2];\n      hld.update(p - 1, x);\n    } else if (type == 2) {\n      int a = q[1], b = q[2];\n      code_result.push_back(hld.query(a - 1, b - 1));\n    } else {\n      continue;\n    }\n  }\n  for (int i = 0; i < static_cast<int>(expected_result.size()); i++) {\n    assert(expected_result[i] == code_result[i]);\n  }\n  std::cout << \"\\nTest3 passed!\\n\";\n}\n\n/**\n * Main function\n */\nint main() {\n  test_1();\n  test_2();\n  test_3();\n  return 0;\n}\n","index":190},{"title":"Mo","category":"range_queries","id":"mo_range_queries","algorithm":"#include <iostream>\nusing namespace std;\nconst int N = 1e6 + 5;\nint a[N], bucket[N], cnt[N];\nint bucket_size;\nstruct query {\n    int l, r, i;\n} q[N];\nint ans = 0;\n\nvoid add(int index) {\n    cnt[a[index]]++;\n    if (cnt[a[index]] == 1)\n        ans++;\n}\nvoid remove(int index) {\n    cnt[a[index]]--;\n    if (cnt[a[index]] == 0)\n        ans--;\n}\n\nbool mycmp(query x, query y) {\n    if (x.l / bucket_size != y.l / bucket_size)\n        return x.l / bucket_size < y.l / bucket_size;\n    return x.r < y.r;\n}\n\nint main() {\n    int n, t, i, j, k = 0;\n    scanf(\"%d\", &n);\n    for (i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n    bucket_size = ceil(sqrt(n));\n    scanf(\"%d\", &t);\n    for (i = 0; i < t; i++) {\n        scanf(\"%d %d\", &q[i].l, &q[i].r);\n        q[i].l--;\n        q[i].r--;\n        q[i].i = i;\n    }\n    sort(q, q + t, mycmp);\n    int left = 0, right = 0;\n    for (i = 0; i < t; i++) {\n        int L = q[i].l, R = q[i].r;\n        while (left < L) {\n            remove(left);\n            left++;\n        }\n        while (left > L) {\n            add(left - 1);\n            left--;\n        }\n        while (right <= R) {\n            add(right);\n            right++;\n        }\n        while (right > R + 1) {\n            remove(right - 1);\n            right--;\n        }\n        bucket[q[i].i] = ans;\n    }\n    for (i = 0; i < t; i++) printf(\"%d\\n\", bucket[i]);\n    return 0;\n}\n","index":191},{"title":"Segtree","category":"range_queries","id":"segtree_range_queries","algorithm":"//#include <bits/stdc++.h>\n#incldue < iostream >\n#define MAX 4000000\nusing namespace std;\ntypedef long long ll;\nvoid ConsTree(ll arr[], ll segtree[], ll low, ll high, ll pos) {\n    if (low == high) {\n        segtree[pos] = arr[low];\n        return;\n    }\n    ll mid = (low + high) / 2;\n    ConsTree(arr, segtree, low, mid, 2 * pos + 1);\n    ConsTree(arr, segtree, mid + 1, high, 2 * pos + 2);\n    segtree[pos] = segtree[2 * pos + 1] + segtree[2 * pos + 2];\n}\nll query(ll segtree[], ll lazy[], ll qlow, ll qhigh, ll low, ll high, ll pos) {\n    if (low > high)\n        return 0;\n    if (qlow > high || qhigh < low)\n        return 0;\n    if (lazy[pos] != 0) {\n        segtree[pos] += lazy[pos] * (high - low + 1);\n        if (low != high) {\n            lazy[2 * pos + 1] += lazy[pos];\n            lazy[2 * pos + 2] += lazy[pos];\n        }\n        lazy[pos] = 0;\n    }\n    if (qlow <= low && qhigh >= high)\n        return segtree[pos];\n    ll mid = (low + high) / 2;\n    return query(segtree, lazy, qlow, qhigh, low, mid, 2 * pos + 1) +\n           query(segtree, lazy, qlow, qhigh, mid + 1, high, 2 * pos + 2);\n}\nvoid update(ll segtree[], ll lazy[], ll start, ll end, ll delta, ll low,\n            ll high, ll pos) {\n    if (low > high)\n        return;\n    if (lazy[pos] != 0) {\n        segtree[pos] += lazy[pos] * (high - low + 1);\n        if (low != high) {\n            lazy[2 * pos + 1] += lazy[pos];\n            lazy[2 * pos + 2] += lazy[pos];\n        }\n        lazy[pos] = 0;\n    }\n    if (start > high || end < low)\n        return;\n    if (start <= low && end >= high) {\n        segtree[pos] += delta * (high - low + 1);\n        if (low != high) {\n            lazy[2 * pos + 1] += delta;\n            lazy[2 * pos + 2] += delta;\n        }\n        return;\n    }\n    ll mid = (low + high) / 2;\n    update(segtree, lazy, start, end, delta, low, mid, 2 * pos + 1);\n    update(segtree, lazy, start, end, delta, mid + 1, high, 2 * pos + 2);\n    segtree[pos] = segtree[2 * pos + 1] + segtree[2 * pos + 2];\n}\nint main() {\n    ll n, c;\n    scanf(\"%lld %lld\", &n, &c);\n    ll arr[n] = {0}, p, q, v, choice;\n    ll segtree[MAX], lazy[MAX] = {0};\n    ConsTree(arr, segtree, 0, n - 1, 0);\n    while (c--) {\n        scanf(\"%lld\", &choice);\n        if (choice == 0) {\n            scanf(\"%lld %lld %lld\", &p, &q, &v);\n            update(segtree, lazy, p - 1, q - 1, v, 0, n - 1, 0);\n        } else {\n            scanf(\"%lld %lld\", &p, &q);\n            printf(\"%lld\\n\", query(segtree, lazy, p - 1, q - 1, 0, n - 1, 0));\n        }\n    }\n    return 0;\n}\n","index":192},{"title":"Search","category":null,"id":"search","index":193},{"title":"Binary Search","category":"search","id":"binary_search_search","algorithm":"/**\n * @file\n * @brief [Binary search\n * algorithm](https://en.wikipedia.org/wiki/Binary_search_algorithm)\n */\n#include <iostream>\n\n/** binary_search function\n * \\param [in] a array to sort\n * \\param [in] r right hand limit = \\f$n-1\\f$\n * \\param [in] key value to find\n * \\returns index if T is found\n * \\return -1 if T is not found\n */\nint binary_search(int a[], int r, int key) {\n    int l = 0;\n\n    while (l <= r) {\n        int m = l + (r - l) / 2;\n        if (key == a[m])\n            return m;\n        else if (key < a[m])\n            r = m - 1;\n        else\n            l = m + 1;\n    }\n    return -1;\n}\n\n/** main function */\nint main(int argc, char const* argv[]) {\n    int n, key;\n    std::cout << \"Enter size of array: \";\n    std::cin >> n;\n    std::cout << \"Enter array elements: \";\n\n    int* a = new int[n];\n\n    // this loop use for store value in Array\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n\n    std::cout << \"Enter search key: \";\n    std::cin >> key;\n\n    // this is use for find value in given array\n    int res = binary_search(a, n - 1, key);\n    if (res != -1)\n        std::cout << key << \" found at index \" << res << std::endl;\n    else\n        std::cout << key << \" not found\" << std::endl;\n\n    delete[] a;\n    return 0;\n}\n","index":194},{"title":"Exponential Search","category":"search","id":"exponential_search_search","algorithm":"/**\n * \\file\n * \\brief [Exponential search\n * algorithm](https://en.wikipedia.org/wiki/Exponential_search)\n * \\copyright 2020 Divide-et-impera-11\n *\n * The algorithm try to search the range where the key should be.\n * If it has been found we do a binary search there.\n * The range of the search grows by exponential every time.\n * If the key is larger than the last element of array, the start of\n * block(block_front) will be equal to the end of block(block_size) and the\n * algorithm return null ponter, every other cases the algoritm return fom the\n * loop.\n */\n#include <cassert>\n#include <cmath>\n#include <iostream>\n#ifdef _MSC_VER\n#include <string>  // use for MS Visual C++\n#else\n#include <cstring>  // for all other compilers\n#endif\n\n/** Binary Search Algorithm (used by ::struzik_search)\\n\n * * Time Complexity O(log n) where 'n' is the number of elements\n * * Worst Time Complexity O(log n)\n * * Best Time Complexity Ω(1)\n * * Space Complexity O(1)\n * * Auxiliary Space Complexity O(1)\n * \\returns pointer to value in the array\n * \\returns `nullptr` if value not found\n */\ntemplate <class Type>\ninline Type* binary_s(Type* array, size_t size, Type key) {\n    int32_t lower_index(0), upper_index(size - 1), middle_index;\n\n    while (lower_index <= upper_index) {\n        middle_index = std::floor((lower_index + upper_index) / 2);\n\n        if (*(array + middle_index) < key)\n            lower_index = (middle_index + 1);\n        else if (*(array + middle_index) > key)\n            upper_index = (middle_index - 1);\n        else\n            return (array + middle_index);\n    }\n\n    return nullptr;\n}\n\n/** Struzik Search Algorithm(Exponential)\n * * Time Complexity O(log i) where i is the position of search key in the list\n * * Worst Time Complexity O(log i)\n * * Best Time Complexity Ω(1)\n * * Space Complexity O(1)\n * * Auxiliary Space Complexity O(1)\n */\ntemplate <class Type>\nType* struzik_search(Type* array, size_t size, Type key) {\n    uint32_t block_front(0), block_size = size == 0 ? 0 : 1;\n    while (block_front != block_size) {\n        if (*(array + block_size - 1) < key) {\n            block_front = block_size;\n            (block_size * 2 - 1 < size) ? (block_size *= 2) : block_size = size;\n            continue;\n        }\n        return binary_s<Type>(array + block_front, (block_size - block_front),\n                              key);\n    }\n    return nullptr;\n}\n\n/** Main function */\nint main() {\n    // TEST CASES\n    int* sorted_array = new int[7]{7, 10, 15, 23, 70, 105, 203};\n    assert(struzik_search<int>(sorted_array, 7, 0) == nullptr);\n    assert(struzik_search<int>(sorted_array, 7, 1000) == nullptr);\n    assert(struzik_search<int>(sorted_array, 7, 50) == nullptr);\n    assert(struzik_search<int>(sorted_array, 7, 7) == sorted_array);\n    // TEST CASES\n    delete[] sorted_array;\n    return 0;\n}\n","index":195},{"title":"Fibonacci Search","category":"search","id":"fibonacci_search_search","algorithm":"/**\n * @author sprintyaf\n * @file fibonacci_search.cpp\n * @brief [Fibonacci search\n * algorithm](https://en.wikipedia.org/wiki/Fibonacci_search_technique)\n */\n\n#include <iostream>\n#include <vector> // for std::vector class\n#include <cassert> // for assert\n#include <cstdlib> // for random numbers\n#include <algorithm> // for sorting\n\n\n\n/**\n * @brief using fibonacci search algorithm finds an index of a given element in a sorted array\n * \n * @param arr sorted array\n * @param value value that we're looking for\n * @returns if the array contains the value, returns an index of the element. otherwise -1.\n */\nint fibonacci_search(const std::vector<int> &arr, int value){\n    // initialize last and current members of Fibonacci sequence \n    int last = 0, current = 1;\n    int length = arr.size(); // array size\n    // next member of Fibonacci sequence which is \"last\" + \"current\"\n    int next = last + current; \n\n    // \"next\" will store the smallest Fibonacci number greater or equal to \"length\"\n    while(next < length){\n        last = current;\n        current = next;\n        next = last + current;\n    }\n\n    // \"offset\" is the end of eliminated range from front\n    int offset = -1, index;\n    // while loop until there are elements left to consider.\n    // when \"next\" becomes 1, last is equal to 0, so search is done,\n    // because arr[offset] will already be eliminated\n    while(next > 1){\n        // check if \"last\" is valid location\n        index = std::min(offset + last, length-1);\n        // if value is greater than the value at \"index\", eliminate the subarray from offset to index\n        if(arr[index] < value){\n            next = current;\n            current = last;\n            last = next - current;\n            offset = index;\n        // if value is less than the value at \"index\", eliminate the subarray after index+1\n        } else if(arr[index] > value){\n            next = last;\n            current = current - last;\n            last = next - current;\n        // element is found\n        } else {\n            return index;\n        }\n    }\n    // comparing the last element\n    if(current && !arr.empty() && arr[offset+1] == value){\n        return offset+1;\n    }\n    // value was not found, return -1\n    return -1;\n}\n\n/**\n * @brief random tests for checking performance when an array doesn't contain an element\n*/\nbool no_occurence_tests(){\n    bool passed = true;\n    int rand_num, rand_value, index, num_tests = 1000;\n    std::vector<int> arr;\n    while(num_tests--){\n        arr.clear();\n        for(int i = 0; i < 100; i++){\n            rand_num = std::rand() % 1000;\n            arr.push_back(rand_num);\n        }\n        rand_value = std::rand() % 1000;\n        while(std::find(arr.begin(), arr.end(), rand_value) != arr.end()){\n            std::remove(arr.begin(), arr.end(), rand_value);\n        }\n        sort(arr.begin(), arr.end());\n        index = fibonacci_search(arr, rand_value);\n        passed = passed && (index == -1);\n    }\n    return passed;\n}\n\n/**\n * @brief random tests which cover cases when we have one, multiple or zero occurences of the value we're looking for\n*/\nbool random_tests(){\n    bool passed = true;\n    int rand_num, rand_value, index, real_value, num_tests = 10000;\n    std::vector<int> arr;\n    while(num_tests--){\n        arr.clear();\n        for(int i = 0; i < 100; i++){\n            rand_num = std::rand() % 1000;\n            arr.push_back(rand_num);\n        }\n        rand_value = std::rand() % 1000;\n        std::sort(arr.begin(), arr.end());\n        index = fibonacci_search(arr, rand_value);\n        if(index != -1){\n            real_value = arr[index];\n            passed = passed && (real_value == rand_value);\n        } else {\n            passed = passed && (std::find(arr.begin(), arr.end(), rand_value) == arr.end());\n        }\n    }\n    return passed;\n}\n\n/**\n * Main Function\n * testing the algorithm\n */\nint main() {\n    assert(no_occurence_tests());\n    assert(random_tests());\n    return 0;\n}\n","index":196},{"title":"Hash Search","category":"search","id":"hash_search_search","algorithm":"/**\n * \\file\n * \\brief Hash Search Algorithm - Best Time Complexity Ω(1)\n *\n * \\copyright 2020 Arctic2333\n *\n * In this algorithm, we use the method of division and reservation remainder to\n * construct the hash function, and use the method of chain address to solve the\n * conflict, that is, we link a chain list after the data, and store all the\n * records whose keywords are synonyms in the same linear chain list.\n *\n * @warning This program is only for educational purposes. It has serious flaws\n * in implementation with regards to memory management resulting in large\n * amounts of memory leaks.\n * @todo fix the program for memory leaks and better structure in C++ and not C\n * fashion\n */\n#include <cstdlib>\n#include <iostream>\n\n#define MAX 6      ///< Determines how much data\n#define HASHMAX 5  ///< Determines the length of the hash table\n\nint data[MAX] = {1, 10, 15, 5, 8, 7};  //!< test data\n\n/**\n * a one-way linked list\n */\ntypedef struct list {\n    int key;            //!< key value for node\n    struct list* next;  //!< pointer to next link in the chain\n} node,                 /**< define node as one item list */\n    *link;              ///< pointer to nodes\n\nnode hashtab[HASHMAX];  ///< array of nodes\n\n// int counter = 1;\n\n/**\n * Mode of hash detection :\n * Division method\n * \\param [in] key to hash\n * \\returns hash value for `key`\n */\nint h(int key) { return key % HASHMAX; }\n\n/**\n * The same after the remainder will be added after the same hash header\n * To avoid conflict, zipper method is used\n * Insert elements into the linked list in the header\n * \\param [in] key key to add to list\n * \\warning dynamic memory allocated to `n` never gets freed.\n * \\todo fix memory leak\n */\nvoid create_list(int key) {  // Construct hash table\n    link p, n;\n    int index;\n    n = (link)malloc(sizeof(node));\n    n->key = key;\n    n->next = NULL;\n    index = h(key);\n    p = hashtab[index].next;\n    if (p != NULL) {\n        n->next = p;\n        hashtab[index].next = n;\n    } else {\n        hashtab[index].next = n;\n    }\n}\n\n/**\n * Input the key to be searched, and get the hash header position through the H\n * (int key) function, then one-dimensional linear search. If found @return\n * element depth and number of searches If not found @return -1\n */\nint hash_search(int key, int* counter) {  // Hash lookup function\n    link pointer;\n    int index;\n\n    *counter = 0;\n    index = h(key);\n    pointer = hashtab[index].next;\n\n    std::cout << \"data[\" << index << \"]:\";\n\n    while (pointer != NULL) {\n        counter[0]++;\n        std::cout << \"data[\" << pointer->key << \"]:\";\n        if (pointer->key == key)\n            return 1;\n        else\n            pointer = pointer->next;\n    }\n\n    return 0;\n}\n\n/** main function */\nint main() {\n    link p;\n    int key, index, i, counter;  // Key is the value to be found\n    index = 0;\n\n    // You can write the input mode here\n    while (index < MAX) {  // Construct hash table\n        create_list(data[index]);\n        index++;\n    }\n\n    for (i = 0; i < HASHMAX; i++) {  // Output hash table\n        std::cout << \"hashtab [\" << i << \"]\\n\";\n\n        p = hashtab[i].next;\n\n        while (p != NULL) {\n            std::cout << \"please int key:\";\n            if (p->key > 0)\n                std::cout << \"[\" << p->key << \"]\";\n            p = p->next;\n        }\n        std::cout << std::endl;\n    }\n\n    while (key != -1) {\n        // You can write the input mode here\n        // test key = 10\n        key = 10;\n        if (hash_search(key, &counter))\n            std::cout << \"search time = \" << counter << std::endl;\n        else\n            std::cout << \"no found!\\n\";\n        key = -1;  // Exit test\n        /* The test sample is returned as:\n         * data[0]:data[5]:data[15]:data[10]:search time = 3 The search is\n         * successful. There are 10 in this set of data */\n    }\n\n    return 0;\n}\n","index":197},{"title":"Interpolation Search","category":"search","id":"interpolation_search_search","algorithm":"/**\n * \\file\n * \\brief [Interpolation\n * search](https://en.wikipedia.org/wiki/Interpolation_search) algorithm\n */\n#include <iostream>\n\n/** function to search the value in an array using interpolation search\n * \\param [in] arr array to search in\n * \\param [in] value value to search for\n * \\param [in] len length of array\n * \\returns index where the value is found\n * \\returns 0 if not found\n */\nint interpolation_search(int arr[], int value, int len) {\n    int low = 0, high, mid;\n    high = len - 1;\n\n    while (arr[low] <= value && arr[high] >= value) {\n        mid = (low +\n               ((value - arr[low]) * (high - low)) / (arr[high] - arr[low]));\n        if (arr[mid] > value)\n            high = mid - 1;\n        else if (arr[mid] < value)\n            low = mid + 1;\n        else\n            return mid;\n    }\n\n    if (arr[low] == value)\n        return low;\n\n    return -1;\n}\n\n/** main function */\nint main() {\n    int n, value, re;\n\n    std::cout << \"Enter the size of array(less than 100) : \";\n    std::cin >> n;\n\n    int *array = new int[n];\n\n    std::cout << \"array in ascending (increasing) order : \" << std::endl;\n\n    for (int i = 0; i < n; i++) std::cin >> array[i];\n\n    std::cout << \"Enter the value you want to search : \";\n    std::cin >> value;\n\n    re = interpolation_search(array, value, n);\n\n    if (re == -1)\n        std::cout << \"Entered value is not in the array\" << std::endl;\n    else\n        std::cout << \"The value is at the position \" << re << std::endl;\n\n    delete[] array;\n    return 0;\n}\n","index":198},{"title":"Interpolation Search2","category":"search","id":"interpolation_search2_search","algorithm":"/**\r\n * \\file\r\n * \\brief [Interpolation\r\n * search](https://en.wikipedia.org/wiki/Interpolation_search) algorithm\r\n */\r\n#include <iostream>\r\n\r\n/** function to search the value in an array using interpolation search\r\n * \\param [in] arr array to search in\r\n * \\param [in] value value to search for\r\n * \\param [in] len length of array\r\n * \\returns index where the value is found\r\n * \\returns -1 if not found\r\n */\r\nint InterpolationSearch(int A[], int n, int x) {\r\n    int low = 0;\r\n    int high = n - 1;\r\n    while (low <= high) {\r\n        int mid = low + (((high - 1) * (x - A[low])) / (A[high] - A[low]));\r\n        if (x == A[mid])\r\n            return mid;  // Found x, return (exit)\r\n        else if (x < A[mid])\r\n            high = mid - 1;  // X lies before mid\r\n        else\r\n            low = mid + 1;  // x lies after mid\r\n    }\r\n\r\n    return -1;\r\n}\r\n\r\n/** main function */\r\nint main() {\r\n    int A[] = {2, 4, 5, 7, 13, 14, 15, 23};\r\n    int x = 17;\r\n\r\n    ///< passed array A inside the InterpolationSearch function\r\n    int index = InterpolationSearch(A, 8, x);\r\n    if (index < 0)\r\n        std::cout << \"Number \" << x << \" not found\" << std::endl;\r\n    else\r\n        std::cout << \"Number \" << x << \" is at \" << index << std::endl;\r\n}\r\n\r\n// randomly set x bcoz array was defined by us , therefore not reasonable for\r\n// asking input. We could have asked for input if array elements were inputed by\r\n// the user.\r\n","index":199},{"title":"Jump Search","category":"search","id":"jump_search_search","algorithm":"/**\n * \\file\n * \\brief C++ program to implement [Jump\n * Search](https://en.wikipedia.org/wiki/Jump_search)\n */\n#include <algorithm>\n#include <cmath>\n#include <iostream>\n\n/** jump search implementation\n */\nint jumpSearch(int arr[], int x, int n) {\n    // Finding block size to be jumped\n    int step = std::sqrt(n);\n\n    // Finding the block where element is\n    // present (if it is present)\n    int prev = 0;\n    while (arr[std::min(step, n) - 1] < x) {\n        prev = step;\n        step += std::sqrt(n);\n        if (prev >= n)\n            return -1;\n    }\n\n    // Doing a linear search for x in block\n    // beginning with prev.\n    while (arr[prev] < x) {\n        prev++;\n\n        // If we reached next block or end of\n        // array, element is not present.\n        if (prev == std::min(step, n))\n            return -1;\n    }\n    // If element is found\n    if (arr[prev] == x)\n        return prev;\n\n    return -1;\n}\n\n// Driver program to test function\nint main() {\n    int arr[] = {0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610};\n    int x = 55;\n    int n = sizeof(arr) / sizeof(arr[0]);\n\n    // Find the index of 'x' using Jump Search\n    int index = jumpSearch(arr, x, n);\n\n    // Print the index where 'x' is located\n    std::cout << \"\\nNumber \" << x << \" is at index \" << index;\n    return 0;\n}\n","index":200},{"title":"Linear Search","category":"search","id":"linear_search_search","algorithm":"/**\n * \\file\n * \\brief [Linear search\n * algorithm](https://en.wikipedia.org/wiki/Linear_search)\n */\n#include <iostream>\n\n/**\n * Algorithm implementation\n * \\param [in] array array to search in\n * \\param [in] size length of array\n * \\param [in] key key value to search for\n * \\returns index where the key-value occurs in the array\n * \\returns -1 if key-value not found\n */\nint LinearSearch(int *array, int size, int key) {\n    for (int i = 0; i < size; ++i) {\n        if (array[i] == key) {\n            return i;\n        }\n    }\n\n    return -1;\n}\n\n/** main function */\nint main() {\n    int size;\n    std::cout << \"\\nEnter the size of the Array : \";\n    std::cin >> size;\n\n    int *array = new int[size];\n    int key;\n\n    // Input array\n    std::cout << \"\\nEnter the Array of \" << size << \" numbers : \";\n    for (int i = 0; i < size; i++) {\n        std::cin >> array[i];\n    }\n\n    std::cout << \"\\nEnter the number to be searched : \";\n    std::cin >> key;\n\n    int index = LinearSearch(array, size, key);\n    if (index != -1) {\n        std::cout << \"\\nNumber found at index : \" << index;\n    } else {\n        std::cout << \"\\nNot found\";\n    }\n\n    delete[] array;\n    return 0;\n}\n","index":201},{"title":"Median Search","category":"search","id":"median_search_search","algorithm":"/**\n * @file median_search.cpp\n * @brief Implementation of [Median search](https://en.wikipedia.org/wiki/Median_of_medians) algorithm.\n * @cases from [here](https://brilliant.org/wiki/median-finding-algorithm/)\n *\n * @details\n * Given an array A[1,...,n] of n numbers and an index i, where 1 ≤ i ≤ n, find the i-th smallest element of A.\n * median_of_medians(A, i):\n *  #divide A into sublists of len 5\n *  sublists = [A[j:j+5] for j in range(0, len(A), 5)]\n *  medians = [sorted(sublist)[len(sublist)/2] for sublist in sublists]\n *  if len(medians) <= 5:\n *\tpivot = sorted(medians)[len(medians)/2]\n *  else:\n *      #the pivot is the median of the medians\n *      pivot = median_of_medians(medians, len(medians)/2)\n *  #partitioning step\n *  low = [j for j in A if j < pivot]\n *  high = [j for j in A if j > pivot]\n *  k = len(low)\n *   if i < k:\n *      return median_of_medians(low,i)\n *   elif i > k:\n *      return median_of_medians(high,i-k-1)\n *  else: #pivot = k\n *       return pivot\n *\n * \\note this algorithm implements median search for only arrays which have distinct elements\n *\n * Here are some example lists you can use to see how the algorithm works\n * A = [1,2,3,4,5,1000,8,9,99] (Contain Unique Elements)\n * B = [1,2,3,4,5,6] (Contains Unique Elements)\n * print median_of_medians(A, 0) #should be 1\n * print median_of_medians(A,7) #should be 99\n * print median_of_medians(B,4) #should be 5\n *\n * @author Unknown author\n * @author [Sushil Kumar](https://github.com/Rp-sushil)\n */\n\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cassert>\n\n/**\n * @namespace search\n * @brief Search algorithms\n */\nnamespace search {\n/**\n * @namespace median_search\n * @brief Functions for [Median search](https://en.wikipedia.org/wiki/Median_search) algorithm\n */\nnamespace median_search {\n/**\n* This function search the element in an array for the given index.\n* @param A array where numbers are saved\n* @param idx current index in array\n* @returns corresponding element which we want to search.\n*/  \nint median_of_medians(const std::vector<int>& A,  const int& idx) {\n\tint pivot = 0;\t\t\t\t\t// initialized with zero\n\tstd::vector<int> a(A.begin(), A.end());\n\tstd::vector<int> m;\n\tint r = a.size();\n\tfor(int i = 0; i < r; i += 5){\n\t\tstd::sort(a.begin() + i, a.begin() + std::min(r, i + 5));\n\t\tint mid = (i + std::min(r, i + 5)) / 2;\n\t\tm.push_back(a[mid]);\n\t}\n\tint sz = int(m.size());\n\tif(sz <= 5){\n\t\tstd::sort(m.begin(), m.end());\n\t\tpivot = m[(sz- 1) / 2];\n\t}\n\telse{\n\t\tpivot = median_of_medians(m, idx);\n\t}\n\tstd::vector<int> low;\n\tstd::vector<int> high;\n\tfor(int i = 0; i < r; i++){\n\t\tif(a[i] < pivot){\n\t\t\tlow.push_back(a[i]);\n\t\t}\n\t\telse if(a[i] > pivot){\n\t\t\thigh.push_back(a[i]);\n\t\t}\n\t}\n\tint k = int(low.size());\n\tif(idx < k){\n\t\treturn median_of_medians(low, idx);\n\t}\n\telse if(idx > k){\n\t\treturn median_of_medians(high, idx-k-1);\n\t}\n\telse{\n\t\treturn pivot;\n\t}\n}\n}  // namespace median_search\n}  // namespace search\n\n/**\n * Function to test above algorithm\n */\nvoid test(){\n\tstd::vector<int> A{25,21,98,100,76,22,43,60,89,87};\n\tint i = 3;\n\tassert(A[6] == search::median_search::median_of_medians(A, i));\t\t// A[6]  = 43, is the fourth smallest element.\n\tstd::cout << \"test case:1 passed\\n\";\n\t\n\tstd::vector<int> B{1,2,3,4,5,6};\n\tint j = 4;\n\tassert(B[4] == search::median_search::median_of_medians(B, j));\t\t// B[4] = 5, is the fifth smallest element.\n\tstd::cout << \"test case:2 passed\\n\";\n\t\n\tstd::vector<int> C{1,2,3,4,5,1000,8,9,99};\n\tint k = 3;\n\tassert(C[3] == search::median_search::median_of_medians(C, k)); \t// C[3] = 4, is the fourth smallest element.\n\tstd::cout << \"test case:3 passed\\n\";\n\tstd::cout << \"--All tests passed--\\n\";\n}\n\n/**\n * Main function\n */\nint main()\n{\n\ttest();\n\tint n = 0;\n\tstd::cout << \"Enter Size of Array: \";\n\tstd::cin >> n;\n\tstd::vector<int> a(n);\n\tstd::cout << \"Enter Array: \";\n\tfor(int i = 0; i < n; i++){\n\t\tstd::cin >> a[i];\n\t}\n\tstd::cout << \"Median: \";\t\t\t// Median defination: https://en.wikipedia.org/wiki/Median\n\tint x = search::median_search::median_of_medians(a,  (n - 1) / 2);\n\tif(n % 2 == 0){\n\t\tint y = search::median_search::median_of_medians(a, n / 2);\n\t\tstd::cout << (float(x) + float(y))/2.0;\n\t}\n\telse{\n\t\tstd::cout << x;\n\t}\n\tstd::cout << \"\\nTo find i-th smallest element \";\n       \tstd::cout << \"\\nEnter i: \";\n\tint idx = 0;\n\tstd::cin >> idx;\n\tidx--;\n\tstd::cout << idx + 1<< \"-th smallest element: \" << search::median_search::median_of_medians(a, idx) << '\\n';\n\treturn 0;\n}\n\n","index":202},{"title":"Ternary Search","category":"search","id":"ternary_search_search","algorithm":"/**\n * \\file\n * \\brief [Ternary search](https://en.wikipedia.org/wiki/Ternary_search)\n * algorithm\n *\n * This is a divide and conquer algorithm.\n * It does this by dividing the search space by 3 parts and\n * using its property (usually monotonic property) to find\n * the desired index.\n *\n * * Time Complexity : O(log3 n)\n * * Space Complexity : O(1) (without the array)\n */\n\n#include <iostream>\n\n/**\n * The absolutePrecision can be modified to fit preference but\n * it is recommended to not go lower than 10 due to errors that\n * may occur.\n */\n#define absolutePrecision 10\n/**\n * The value of _target should be decided or can be decided later\n * by using the variable of the function.\n */\n#define _target 10\n\n#define MAX 10000000  ///< Maximum length of array\n\n/**\n * get_input function is to receive input from standard IO\n * @todo @christianbender Get input from STDIO or write input to memory as done\n * above.\n */\nvoid get_input() {}\n\n/**\n * This is the iterative method of the ternary search which returns the index of\n * the element.\n * \\param[in] left lower interval limit\n * \\param[in] right upper interval limit\n * \\param[in] A array to search in\n * \\param[in] target value to search for\n * \\returns index where the target value was found\n * \\returns -1 if target value not found\n */\nint it_ternary_search(int left, int right, int A[], int target) {\n    while (1) {\n        if (left < right) {\n            if (right - left < absolutePrecision) {\n                for (int i = left; i <= right; i++)\n                    if (A[i] == target)\n                        return i;\n\n                return -1;\n            }\n\n            int oneThird = (left + right) / 3 + 1;\n            int twoThird = (left + right) * 2 / 3 + 1;\n\n            if (A[oneThird] == target)\n                return oneThird;\n            else if (A[twoThird] == target)\n                return twoThird;\n\n            else if (target > A[twoThird])\n                left = twoThird + 1;\n            else if (target < A[oneThird])\n                right = oneThird - 1;\n\n            else\n                left = oneThird + 1, right = twoThird - 1;\n        } else {\n            return -1;\n        }\n    }\n}\n\n/**\n * This is the recursive method of the ternary search which returns the index of\n * the element.\n * \\param[in] left lower interval limit\n * \\param[in] right upper interval limit\n * \\param[in] A array to search in\n * \\param[in] target value to search for\n * \\returns index where the target value was found\n * \\returns -1 if target value not found\n */\nint rec_ternary_search(int left, int right, int A[], int target) {\n    if (left < right) {\n        if (right - left < absolutePrecision) {\n            for (int i = left; i <= right; i++)\n                if (A[i] == target)\n                    return i;\n\n            return -1;\n        }\n\n        int oneThird = (left + right) / 3 + 1;\n        int twoThird = (left + right) * 2 / 3 + 1;\n\n        if (A[oneThird] == target)\n            return oneThird;\n        if (A[twoThird] == target)\n            return twoThird;\n\n        if (target < A[oneThird])\n            return rec_ternary_search(left, oneThird - 1, A, target);\n        if (target > A[twoThird])\n            return rec_ternary_search(twoThird + 1, right, A, target);\n\n        return rec_ternary_search(oneThird + 1, twoThird - 1, A, target);\n    } else {\n        return -1;\n    }\n}\n\n/**\n * ternary_search is a template function\n * You could either use it_ternary_search or rec_ternary_search according to\n * preference.\n * \\param [in] N length of array\n * \\param[in] A array to search in\n * \\param[in] target value to search for\n */\nvoid ternary_search(int N, int A[], int target) {\n    std::cout << it_ternary_search(0, N - 1, A, target) << '\\t';\n    std::cout << rec_ternary_search(0, N - 1, A, target) << '\\t';\n    std::cout << std::endl;\n}\n\n/** Main function */\nint main() {\n    int N = 21;\n    int A[] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 4, 10};\n    get_input();\n    ternary_search(N, A, _target);\n    return 0;\n}\n","index":203},{"title":"Text Search","category":"search","id":"text_search_search","algorithm":"/**\r\n * \\file\r\n * \\brief Search for words in a long textual paragraph.\r\n */\r\n#include <cstdlib>\r\n#include <iostream>\r\n#ifdef _MSC_VER\r\n#include <string>  // required for MS Visual C++\r\n#else\r\n#include <cstring>\r\n#endif\r\n\r\n/** Main function\r\n */\r\nint main() {\r\n    std::string paragraph;\r\n    std::cout << \"Please enter your paragraph: \\n\";\r\n    std::getline(std::cin, paragraph);\r\n    std::cout << \"\\nHello, your paragraph is:\\n \" << paragraph << \"!\\n\";\r\n    std::cout << \"\\nThe size of your paragraph = \" << paragraph.size()\r\n              << \" characters. \\n\\n\";\r\n\r\n    if (paragraph.empty()) {\r\n        std::cout << \"\\nThe paragraph is empty\" << std::endl;\r\n    } else {\r\n        while (true) {\r\n            std::string word;\r\n            std::cout << \"Please enter the word you are searching for: \";\r\n            std::getline(std::cin, word);\r\n            std::cout << \"Hello, your word is \" << word << \"!\\n\";\r\n            if (paragraph.find(word) == std::string::npos) {\r\n                std::cout << word << \" does not exist in the sentence\"\r\n                          << std::endl;\r\n            } else {\r\n                std::cout << \"The word \" << word << \" is now found at location \"\r\n                          << paragraph.find(word) << std::endl\r\n                          << std::endl;\r\n            }\r\n            std::cin.get();\r\n        }\r\n    }\r\n}\r\n","index":204},{"title":"Sorting","category":null,"id":"sorting","index":205},{"title":"Bead Sort","category":"sorting","id":"bead_sort_sorting","algorithm":"// C++ program to implement gravity/bead sort\n#include <cstdio>\n#include <cstring>\n\n#define BEAD(i, j) beads[i * max + j]\n\n// function to perform the above algorithm\nvoid beadSort(int *a, int len) {\n    // Find the maximum element\n    int max = a[0];\n    for (int i = 1; i < len; i++)\n        if (a[i] > max)\n            max = a[i];\n\n    // allocating memory\n    unsigned char *beads = new unsigned char[max * len];\n    memset(beads, 0, static_cast<size_t>(max) * len);\n\n    // mark the beads\n    for (int i = 0; i < len; i++)\n        for (int j = 0; j < a[i]; j++) BEAD(i, j) = 1;\n\n    for (int j = 0; j < max; j++) {\n        // count how many beads are on each post\n        int sum = 0;\n        for (int i = 0; i < len; i++) {\n            sum += BEAD(i, j);\n            BEAD(i, j) = 0;\n        }\n\n        // Move beads down\n        for (int i = len - sum; i < len; i++) BEAD(i, j) = 1;\n    }\n\n    // Put sorted values in array using beads\n    for (int i = 0; i < len; i++) {\n        int j;\n        for (j = 0; j < max && BEAD(i, j); j++) {\n        }\n\n        a[i] = j;\n    }\n    delete[] beads;\n}\n\n// driver function to test the algorithm\nint main() {\n    int a[] = {5, 3, 1, 7, 4, 1, 1, 20};\n    int len = sizeof(a) / sizeof(a[0]);\n\n    beadSort(a, len);\n\n    for (int i = 0; i < len; i++) printf(\"%d \", a[i]);\n\n    return 0;\n}\n","index":206},{"title":"Bitonic Sort","category":"sorting","id":"bitonic_sort_sorting","algorithm":"// Source : https://www.geeksforgeeks.org/bitonic-sort/\n\n/* C++ Program for Bitonic Sort. Note that this program\n   works only when size of input is a power of 2. */\n\n#include <algorithm>\n#include <iostream>\n\n/*The parameter dir indicates the sorting direction, ASCENDING\n   or DESCENDING; if (a[i] > a[j]) agrees with the direction,\n   then a[i] and a[j] are interchanged.*/\nvoid compAndSwap(int a[], int i, int j, int dir) {\n    if (dir == (a[i] > a[j]))\n        std::swap(a[i], a[j]);\n}\n\n/*It recursively sorts a bitonic sequence in ascending order,\n  if dir = 1, and in descending order otherwise (means dir=0).\n  The sequence to be sorted starts at index position low,\n  the parameter cnt is the number of elements to be sorted.*/\nvoid bitonicMerge(int a[], int low, int cnt, int dir) {\n    if (cnt > 1) {\n        int k = cnt / 2;\n        for (int i = low; i < low + k; i++) compAndSwap(a, i, i + k, dir);\n        bitonicMerge(a, low, k, dir);\n        bitonicMerge(a, low + k, k, dir);\n    }\n}\n\n/* This function first produces a bitonic sequence by recursively\n    sorting its two halves in opposite sorting orders, and then\n    calls bitonicMerge to make them in the same order */\nvoid bitonicSort(int a[], int low, int cnt, int dir) {\n    if (cnt > 1) {\n        int k = cnt / 2;\n\n        // sort in ascending order since dir here is 1\n        bitonicSort(a, low, k, 1);\n\n        // sort in descending order since dir here is 0\n        bitonicSort(a, low + k, k, 0);\n\n        // Will merge wole sequence in ascending order\n        // since dir=1.\n        bitonicMerge(a, low, cnt, dir);\n    }\n}\n\n/* Caller of bitonicSort for sorting the entire array of\n   length N in ASCENDING order */\nvoid sort(int a[], int N, int up) { bitonicSort(a, 0, N, up); }\n\n// Driver code\nint main() {\n    int a[] = {3, 7, 4, 8, 6, 2, 1, 5};\n    int N = sizeof(a) / sizeof(a[0]);\n\n    int up = 1;  // means sort in ascending order\n    sort(a, N, up);\n\n    std::cout << \"Sorted array: \\n\";\n    for (int i = 0; i < N; i++) std::cout << a[i] << \" \";\n    return 0;\n}\n","index":207},{"title":"Bogo Sort","category":"sorting","id":"bogo_sort_sorting","algorithm":"/**\n * @file\n * @brief Implementation of [Bogosort algorithm](https://en.wikipedia.org/wiki/Bogosort)\n *\n * @details\n *      In computer science, bogosort (also known as permutation sort, stupid sort, slowsort, \n *      shotgun sort, random sort, monkey sort, bobosort or shuffle sort) is a highly inefficient \n *      sorting algorithm based on the generate and test paradigm. Two versions of this algorithm \n *      exist: a deterministic version that enumerates all permutations until it hits a sorted one,\n *      and a randomized version that randomly permutes its input.Randomized version is implemented here. \n *\n * ### Algorithm\n * Shuffle the array untill array is sorted.\n *\n * @author [Deep Raval](https://github.com/imdeep2905)\n */\n#include <iostream>\n#include <algorithm>\n#include <array>\n#include <cassert>\n\n\n/**\n * @namespace sorting\n * @brief Sorting algorithms\n */\nnamespace sorting {\n/**\n * Function to shuffle the elements of an array. (for reference)\n * @tparam T typename of the array\n * @tparam N length of array\n * @param arr array to shuffle\n * @returns new array with elements shuffled from a given array\n */\ntemplate <typename T, size_t N>\nstd::array <T, N> shuffle (std::array <T, N> arr) {\n    for (int i = 0; i < N; i++) {\n        // Swaps i'th  index with random index (less than array size)\n        std::swap(arr[i], arr[std::rand() % N]);\n    }\n    return arr;\n}\n/**\n * Implement randomized Bogosort algorithm and sort the elements of a given array.\n * @tparam T typename of the array\n * @tparam N length of array\n * @param arr array to sort\n * @returns new array with elements sorted from a given array\n */\ntemplate <typename T, size_t N>\nstd::array <T, N> randomized_bogosort (std::array <T, N> arr) {\n    // Untill array is not sorted\n    while (!std::is_sorted(arr.begin(), arr.end())) {\n        std::random_shuffle(arr.begin(), arr.end());// Shuffle the array\n    }\n    return arr;\n}\n\n}  // namespace sorting\n\n/**\n * Function to display array on screen \n * @tparam T typename of the array\n * @tparam N length of array\n * @param arr array to display\n */\ntemplate <typename T, size_t N>\nvoid show_array (const std::array <T, N> &arr) {\n    for (int x : arr) {\n        std::cout << x << ' ';\n    }\n    std::cout << '\\n';\n}\n\n/**\n * Function to test above algorithm\n */\nvoid test() {\n    // Test 1\n    std::array <int, 5> arr1;\n    for (int &x : arr1) {\n        x = std::rand() % 100;\n    }\n    std::cout << \"Original Array : \";\n    show_array(arr1);\n    arr1 = sorting::randomized_bogosort(arr1);\n    std::cout << \"Sorted Array : \";\n    show_array(arr1);\n    assert(std::is_sorted(arr1.begin(), arr1.end()));\n    // Test 2\n    std::array <int, 5> arr2;\n    for (int &x : arr2) {\n        x = std::rand() % 100;\n    }\n    std::cout << \"Original Array : \";\n    show_array(arr2);\n    arr2 = sorting::randomized_bogosort(arr2);\n    std::cout << \"Sorted Array : \";\n    show_array(arr2);\n    assert(std::is_sorted(arr2.begin(), arr2.end()));\n}\n\n/** Driver Code */\nint main() {\n    // Testing\n    test();\n    // Example Usage\n    std::array <int, 5> arr = {3, 7, 10, 4, 1}; // Defining array which we want to sort\n    std::cout << \"Original Array : \";\n    show_array(arr);\n    arr = sorting::randomized_bogosort(arr); // Callling bogo sort on it\n    std::cout << \"Sorted Array : \";\n    show_array(arr); // Printing sorted array\n    return 0;\n}\n","index":208},{"title":"Bubble Sort","category":"sorting","id":"bubble_sort_sorting","algorithm":"/**\n * @file\n * @brief Bubble sort algorithm\n *\n * The working principle of the Bubble sort algorithm:\n\nBubble sort algorithm is the bubble sorting algorithm. The most important reason\nfor calling the bubble is that the largest number is thrown at the end of this\nalgorithm. This is all about the logic. In each iteration, the largest number is\nexpired and when iterations are completed, the sorting takes place.\n\nWhat is Swap?\n\nSwap in the software means that two variables are displaced.\nAn additional variable is required for this operation. x = 5, y = 10.\nWe want x = 10, y = 5. Here we create the most variable to do it.\n\nint z;\nz = x;\nx = y;\ny = z;\n\nThe above process is a typical displacement process.\nWhen x assigns the value to x, the old value of x is lost.\nThat's why we created a variable z to create the first value of the value of x,\nand finally, we have assigned to y.\n\nBubble Sort Algorithm Analysis (Best Case - Worst Case - Average Case)\n\nBubble Sort Worst Case Performance is O (n²). Why is that? Because if you\nremember Big O Notation, we were calculating the complexity of the algorithms in\nthe nested loops. The n * (n - 1) product gives us O (n²) performance. In the\nworst case all the steps of the cycle will occur. Bubble Sort (Avarage Case)\nPerformance. Bubble Sort is not an optimal algorithm. in average, O (n²)\nperformance is taken. Bubble Sort Best Case Performance. O (n). However, you\ncan't get the best status in the code we shared above. This happens on the\noptimized bubble sort algorithm. It's right down there.\n*/\n\n#include <iostream>\n#include <vector>\n\nint main() {\n    int n;\n    bool swap_check = true;\n    std::cout << \"Enter the amount of numbers to sort: \";\n    std::cin >> n;\n    std::vector<int> numbers;\n    std::cout << \"Enter \" << n << \" numbers: \";\n    int num;\n\n    // Input\n    for (int i = 0; i < n; i++) {\n        std::cin >> num;\n        numbers.push_back(num);\n    }\n\n    // Bubble Sorting\n    for (int i = 0; (i < n) && (swap_check); i++) {\n        swap_check = false;\n        for (int j = 0; j < n - 1 - i; j++) {\n            if (numbers[j] > numbers[j + 1]) {\n                swap_check = true;\n                std::swap(numbers[j],\n                          numbers[j + 1]);  // by changing swap location.\n                                            // I mean, j. If the number is\n                                            // greater than j + 1, then it\n                                            // means the location.\n            }\n        }\n    }\n\n    // Output\n    std::cout << \"\\nSorted Array : \";\n    for (int i = 0; i < numbers.size(); i++) {\n        if (i != numbers.size() - 1) {\n            std::cout << numbers[i] << \", \";\n        } else {\n            std::cout << numbers[i] << std::endl;\n        }\n    }\n    return 0;\n}\n","index":209},{"title":"Bucket Sort","category":"sorting","id":"bucket_sort_sorting","algorithm":"// C++ program to sort an array using bucket sort\n#include <algorithm>\n#include <iostream>\n#include <vector>\n\n// Function to sort arr[] of size n using bucket sort\nvoid bucketSort(float arr[], int n) {\n    // 1) Create n empty buckets\n    std::vector<float> *b = new std::vector<float>[n];\n\n    // 2) Put array elements in different buckets\n    for (int i = 0; i < n; i++) {\n        int bi = n * arr[i];  // Index in bucket\n        b[bi].push_back(arr[i]);\n    }\n\n    // 3) Sort individual buckets\n    for (int i = 0; i < n; i++) std::sort(b[i].begin(), b[i].end());\n\n    // 4) Concatenate all buckets into arr[]\n    int index = 0;\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < b[i].size(); j++) arr[index++] = b[i][j];\n    delete[] b;\n}\n\n/* Driver program to test above funtion */\nint main() {\n    float arr[] = {0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    bucketSort(arr, n);\n\n    std::cout << \"Sorted array is \\n\";\n    for (int i = 0; i < n; i++) std::cout << arr[i] << \" \";\n    return 0;\n}\n","index":210},{"title":"Cocktail Selection Sort","category":"sorting","id":"cocktail_selection_sort_sorting","algorithm":"// Returns Sorted elements after performing Cocktail Selection Sort\n// It is a Sorting algorithm which chooses the minimum and maximum element in an\n// array simultaneously, and swaps it with the lowest and highest available\n// position iteratively or recursively\n\n#include <algorithm>\n#include <iostream>\n#include <vector>\n\n// Iterative Version\n\nvoid CocktailSelectionSort(std::vector<int> *vec, int low, int high) {\n    while (low <= high) {\n        int minimum = (*vec)[low];\n        int minimumindex = low;\n        int maximum = (*vec)[high];\n        int maximumindex = high;\n\n        for (int i = low; i <= high; i++) {\n            if ((*vec)[i] >= maximum) {\n                maximum = (*vec)[i];\n                maximumindex = i;\n            }\n            if ((*vec)[i] <= minimum) {\n                minimum = (*vec)[i];\n                minimumindex = i;\n            }\n        }\n        if (low != maximumindex || high != minimumindex) {\n            std::swap((*vec)[low], (*vec)[minimumindex]);\n            std::swap((*vec)[high], (*vec)[maximumindex]);\n        } else {\n            std::swap((*vec)[low], (*vec)[high]);\n        }\n\n        low++;\n        high--;\n    }\n}\n\n// Recursive Version\n\nvoid CocktailSelectionSort_v2(std::vector<int> *vec, int low, int high) {\n    if (low >= high)\n        return;\n\n    int minimum = (*vec)[low];\n    int minimumindex = low;\n    int maximum = (*vec)[high];\n    int maximumindex = high;\n\n    for (int i = low; i <= high; i++) {\n        if ((*vec)[i] >= maximum) {\n            maximum = (*vec)[i];\n            maximumindex = i;\n        }\n        if ((*vec)[i] <= minimum) {\n            minimum = (*vec)[i];\n            minimumindex = i;\n        }\n    }\n    if (low != maximumindex || high != minimumindex) {\n        std::swap((*vec)[low], (*vec)[minimumindex]);\n        std::swap((*vec)[high], (*vec)[maximumindex]);\n    } else {\n        std::swap((*vec)[low], (*vec)[high]);\n    }\n\n    CocktailSelectionSort(vec, low + 1, high - 1);\n}\n\n// main function, select any one of iterative or recursive version\n\nint main() {\n    int n;\n    std::cout << \"Enter number of elements\\n\";\n    std::cin >> n;\n    std::vector<int> v(n);\n    std::cout << \"Enter all the elements\\n\";\n    for (int i = 0; i < n; ++i) {\n        std::cin >> v[i];\n    }\n\n    int method;\n    std::cout << \"Enter method: \\n\\t0: iterative\\n\\t1: recursive:\\t\";\n    std::cin >> method;\n\n    if (method == 0) {\n        CocktailSelectionSort(&v, 0, n - 1);\n    } else if (method == 1) {\n        CocktailSelectionSort_v2(&v, 0, n - 1);\n    } else {\n        std::cerr << \"Unknown method\" << std::endl;\n        return -1;\n    }\n    std::cout << \"Sorted elements are\\n\";\n    for (int i = 0; i < n; ++i) {\n        std::cout << v[i] << \" \";\n    }\n\n    return 0;\n}\n","index":211},{"title":"Comb Sort","category":"sorting","id":"comb_sort_sorting","algorithm":"/**\n *\n * \\file\n * \\brief [Comb Sort Algorithm\n * (Comb Sort)](https://en.wikipedia.org/wiki/Comb_sort)\n *\n * \\author\n *\n * \\details\n * - A better version of bubble sort algorithm\n * - Bubble sort compares adjacent values whereas comb sort uses gap larger\n *   than 1\n * - Best case Time complexity O(n)\n *   Worst case Time complexity O(n^2)\n *\n */\n\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n\n/**\n *\n * Find the next gap by shrinking the current gap by shrink factor of 1.3\n * @param gap current gap\n * @return new gap\n *\n */\nint FindNextGap(int gap) {\n    gap = (gap * 10) / 13;\n\n    return std::max(1, gap);\n}\n\n/** Function to sort array\n *\n * @param arr array to be sorted\n * @param l start index of array\n * @param r end index of array\n *\n */\nvoid CombSort(int *arr, int l, int r) {\n    /**\n     *\n     * initial gap will be maximum and the maximum possible value is\n     * the size of the array that is n and which is equal to r in this\n     * case so to avoid passing an extra parameter n that is the size of\n     * the array we are using r to initialize the initial gap.\n     *\n     */\n    int gap = r;\n\n    /// Initialize swapped as true to make sure that loop runs\n    bool swapped = true;\n\n    /// Keep running until gap = 1 or none elements were swapped\n    while (gap != 1 || swapped) {\n        /// Find next gap\n        gap = FindNextGap(gap);\n\n        swapped = false;\n\n        /// Compare all elements with current gap\n        for (int i = l; i <= r - gap; ++i) {\n            if (arr[i] > arr[i + gap]) {\n                std::swap(arr[i], arr[i + gap]);\n                swapped = true;\n            }\n        }\n    }\n}\n\nvoid tests() {\n    /// Test 1\n    int arr1[10] = {34, 56, 6, 23, 76, 34, 76, 343, 4, 76};\n    CombSort(arr1, 0, 10);\n    assert(std::is_sorted(arr1, arr1 + 10));\n    std::cout << \"Test 1 passed\\n\";\n\n    /// Test 2\n    int arr2[8] = {-6, 56, -45, 56, 0, -1, 8, 8};\n    CombSort(arr2, 0, 8);\n    assert(std::is_sorted(arr2, arr2 + 8));\n    std::cout << \"Test 2 Passed\\n\";\n}\n\n/** Main function */\nint main() {\n    /// Running predefined tests\n    tests();\n\n    /// For user interaction\n    int n;\n    std::cin >> n;\n    int *arr = new int[n];\n    for (int i = 0; i < n; ++i) std::cin >> arr[i];\n    CombSort(arr, 0, n);\n    for (int i = 0; i < n; ++i) std::cout << arr[i] << ' ';\n    delete[] arr;\n    return 0;\n}\n","index":212},{"title":"Counting Sort","category":"sorting","id":"counting_sort_sorting","algorithm":"#include <iostream>\nusing namespace std;\n\nint Max(int Arr[], int N) {\n    int max = Arr[0];\n    for (int i = 1; i < N; i++)\n        if (Arr[i] > max)\n            max = Arr[i];\n    return max;\n}\n\nint Min(int Arr[], int N) {\n    int min = Arr[0];\n    for (int i = 1; i < N; i++)\n        if (Arr[i] < min)\n            min = Arr[i];\n    return min;\n}\n\nvoid Print(int Arr[], int N) {\n    for (int i = 0; i < N; i++) cout << Arr[i] << \", \";\n}\n\nint *Counting_Sort(int Arr[], int N) {\n    int max = Max(Arr, N);\n    int min = Min(Arr, N);\n    int *Sorted_Arr = new int[N];\n\n    int *Count = new int[max - min + 1];\n\n    for (int i = 0; i < N; i++) Count[Arr[i] - min]++;\n\n    for (int i = 1; i < (max - min + 1); i++) Count[i] += Count[i - 1];\n\n    for (int i = N - 1; i >= 0; i--) {\n        Sorted_Arr[Count[Arr[i] - min] - 1] = Arr[i];\n        Count[Arr[i] - min]--;\n    }\n\n    return Sorted_Arr;\n}\n\nint main() {\n    int Arr[] = {47, 65, 20, 66, 25, 53, 64, 69, 72, 22,\n                 74, 25, 53, 15, 42, 36, 4,  69, 86, 19},\n        N = 20;\n    int *Sorted_Arr;\n\n    cout << \"\\n\\tOrignal Array = \";\n    Print(Arr, N);\n    Sorted_Arr = Counting_Sort(Arr, N);\n    cout << \"\\n\\t Sorted Array = \";\n    Print(Sorted_Arr, N);\n    cout << endl;\n\n    return 0;\n}\n","index":213},{"title":"Counting Sort String","category":"sorting","id":"counting_sort_string_sorting","algorithm":"// C++ Program for counting sort\n#include <iostream>\n\nusing namespace std;\n\nvoid countSort(string arr) {\n    string output;\n\n    int count[256], i;\n    for (int i = 0; i < 256; i++) count[i] = 0;\n\n    for (i = 0; arr[i]; ++i) ++count[arr[i]];\n\n    for (i = 1; i < 256; ++i) count[i] += count[i - 1];\n\n    for (i = 0; arr[i]; ++i) {\n        output[count[arr[i]] - 1] = arr[i];\n        --count[arr[i]];\n    }\n\n    for (i = 0; arr[i]; ++i) arr[i] = output[i];\n\n    cout << \"Sorted character array is \" << arr;\n}\n\nint main() {\n    string arr;\n    cin >> arr;\n\n    countSort(arr);\n\n    return 0;\n}\n","index":214},{"title":"Gnome Sort","category":"sorting","id":"gnome_sort_sorting","algorithm":"/**\n * @file\n * @brief Implementation of [gnome\n * sort](https://en.wikipedia.org/wiki/Gnome_sort) algorithm.\n * @author [beqakd](https://github.com/beqakd)\n * @author [Krishna Vedala](https://github.com/kvedala)\n * @details\n * Gnome sort algorithm is not the best one but it is widely used.\n * The algorithm iteratively checks the order of pairs in the array. If they are\n * on right order it moves to the next successive pair, otherwise it swaps\n * elements. This operation is repeated until no more swaps are made thus\n * indicating the values to be in ascending order.\n *\n * The time Complexity of the algorithm is \\f$O(n^2)\\f$ and in some cases it\n * can be \\f$O(n)\\f$.\n */\n\n#include <algorithm>  // for std::swap\n#include <array>      // for std::array\n#include <cassert>    // for assertions\n#include <iostream>   // for io operations\n\n/**\n * @namespace sorting\n * Sorting algorithms\n */\nnamespace sorting {\n/**\n * This implementation is for a C-style array input that gets modified in place.\n * @param [in,out] arr our array of elements.\n * @param size size of given array\n */\ntemplate <typename T>\nvoid gnomeSort(T *arr, int size) {\n    // few easy cases\n    if (size <= 1) {\n        return;\n    }\n\n    int index = 0;  // initialize some variables.\n    while (index < size) {\n        // check for swap\n        if ((index == 0) || (arr[index] >= arr[index - 1])) {\n            index++;\n        } else {\n            std::swap(arr[index], arr[index - 1]);  // swap\n            index--;\n        }\n    }\n}\n\n/**\n * This implementation is for a C++-style array input. The function argument is\n * a pass-by-value and hence a copy of the array gets created which is then\n * modified by the function and returned.\n * @tparam T type of data variables in the array\n * @tparam size size of the array\n * @param [in] arr our array of elements.\n * @return array with elements sorted\n */\ntemplate <typename T, size_t size>\nstd::array<T, size> gnomeSort(std::array<T, size> arr) {\n    // few easy cases\n    if (size <= 1) {\n        return arr;\n    }\n\n    int index = 0;  // initialize loop index\n    while (index < size) {\n        // check for swap\n        if ((index == 0) || (arr[index] >= arr[index - 1])) {\n            index++;\n        } else {\n            std::swap(arr[index], arr[index - 1]);  // swap\n            index--;\n        }\n    }\n    return arr;\n}\n}  // namespace sorting\n\n/**\n * Test function\n */\nstatic void test() {\n    // Example 1. Creating array of int,\n    std::cout << \"Test 1 - as a C-array...\";\n    const int size = 6;\n    std::array<int, size> arr = {-22, 100, 150, 35, -10, 99};\n    sorting::gnomeSort(arr.data(),\n                       size);  // pass array data as a C-style array pointer\n    assert(std::is_sorted(std::begin(arr), std::end(arr)));\n    std::cout << \" Passed\\n\";\n    for (int i = 0; i < size; i++) {\n        std::cout << arr[i] << \", \";\n    }\n    std::cout << std::endl;\n\n    // Example 2. Creating array of doubles.\n    std::cout << \"\\nTest 2 - as a std::array...\";\n    std::array<double, size> double_arr = {-100.2, 10.2, 20.0, 9.0, 7.5, 7.2};\n    std::array<double, size> sorted_arr = sorting::gnomeSort(double_arr);\n    assert(std::is_sorted(std::begin(sorted_arr), std::end(sorted_arr)));\n    std::cout << \" Passed\\n\";\n    for (int i = 0; i < size; i++) {\n        std::cout << double_arr[i] << \", \";\n    }\n    std::cout << std::endl;\n\n    // Example 3. Creating random array of float.\n    std::cout << \"\\nTest 3 - 200 random numbers as a std::array...\";\n    const int size2 = 200;\n    std::array<float, size2> rand_arr{};\n\n    for (auto &a : rand_arr) {\n        // generate random numbers between -5.0 and 4.99\n        a = float(std::rand() % 1000 - 500) / 100.f;\n    }\n\n    std::array<float, size2> float_arr = sorting::gnomeSort(rand_arr);\n    assert(std::is_sorted(std::begin(float_arr), std::end(float_arr)));\n    std::cout << \" Passed\\n\";\n    // for (int i = 0; i < size; i++) std::cout << double_arr[i] << \", \";\n    std::cout << std::endl;\n}\n\n/**\n * Our main function with example of sort method.\n */\nint main() {\n    test();\n    return 0;\n}\n","index":215},{"title":"Heap Sort","category":"sorting","id":"heap_sort_sorting","algorithm":"/**\n * \\file\n * \\brief [Heap Sort Algorithm\n * (heap sort)](https://en.wikipedia.org/wiki/Heapsort) implementation\n *\n * \\author [Ayaan Khan](http://github.com/ayaankhan98)\n *\n * \\details\n *  Heap-sort is a comparison-based sorting algorithm.\n *  Heap-sort can be thought of as an improved selection sort:\n *  like selection sort, heap sort divides its input into a sorted\n *  and an unsorted region, and it iteratively shrinks the unsorted\n *  region by extracting the largest element from it and inserting\n *  it into the sorted region. Unlike selection sort,\n *  heap sort does not waste time with a linear-time scan of the\n *  unsorted region; rather, heap sort maintains the unsorted region\n *  in a heap data structure to more quickly find the largest element\n *  in each step.\n *\n *  Time Complexity - \\f$O(n \\log(n))\\f$\n *\n */\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n\n/**\n *\n * Utility function to print the array after\n * sorting.\n *\n * @param arr array to be printed\n * @param sz size of array\n *\n */\ntemplate <typename T>\nvoid printArray(T *arr, int sz) {\n    for (int i = 0; i < sz; i++) std::cout << arr[i] << \"  \";\n    std::cout << \"\\n\";\n}\n\n/**\n *\n * \\addtogroup sorting Sorting Algorithm\n * @{\n *\n * The heapify procedure can be thought of as building a heap from\n * the bottom up by successively sifting downward to establish the\n * heap property.\n *\n * @param arr array to be sorted\n * @param n size of array\n * @param i node position in Binary Tress or element position in\n *          Array to be compared with it's childern\n *\n */\ntemplate <typename T>\nvoid heapify(T *arr, int n, int i) {\n    int largest = i;\n    int l = 2 * i + 1;\n    int r = 2 * i + 2;\n\n    if (l < n && arr[l] > arr[largest])\n        largest = l;\n\n    if (r < n && arr[r] > arr[largest])\n        largest = r;\n\n    if (largest != i) {\n        std::swap(arr[i], arr[largest]);\n        heapify(arr, n, largest);\n    }\n}\n\n/**\n * Utilizes heapify procedure to sort\n * the array\n *\n * @param arr array to be sorted\n * @param n size of array\n *\n */\ntemplate <typename T>\nvoid heapSort(T *arr, int n) {\n    for (int i = n - 1; i >= 0; i--) heapify(arr, n, i);\n\n    for (int i = n - 1; i >= 0; i--) {\n        std::swap(arr[0], arr[i]);\n        heapify(arr, i, 0);\n    }\n}\n\n/**\n *\n * @}\n * Test cases to test the program\n *\n */\nvoid test() {\n    std::cout << \"Test 1\\n\";\n    int arr[] = {-10, 78, -1, -6, 7, 4, 94, 5, 99, 0};\n    int sz = sizeof(arr) / sizeof(arr[0]);  // sz - size of array\n    printArray(arr, sz);  // displaying the array before sorting\n    heapSort(arr, sz);    // calling heapsort to sort the array\n    printArray(arr, sz);  // display array after sorting\n    assert(std::is_sorted(arr, arr + sz));\n    std::cout << \"Test 1 Passed\\n========================\\n\";\n\n    std::cout << \"Test 2\\n\";\n    double arr2[] = {4.5, -3.6, 7.6, 0, 12.9};\n    sz = sizeof(arr2) / sizeof(arr2[0]);\n    printArray(arr2, sz);\n    heapSort(arr2, sz);\n    printArray(arr2, sz);\n    assert(std::is_sorted(arr2, arr2 + sz));\n    std::cout << \"Test 2 passed\\n\";\n}\n\n/** Main function */\nint main() {\n    test();\n    return 0;\n}\n","index":216},{"title":"Insertion Sort","category":"sorting","id":"insertion_sort_sorting","algorithm":"/**\n *\n * \\file\n * \\brief [Insertion Sort Algorithm\n * (Insertion Sort)](https://en.wikipedia.org/wiki/Insertion_sort)\n *\n * \\details\n * Insertion sort is a simple sorting algorithm that builds the final\n * sorted array one at a time. It is much less efficient compared to\n * other sorting algorithms like heap sort, merge sort or quick sort.\n * However it has several advantages such as\n * 1. Easy to implement\n * 2. For small set of data it is quite efficient\n * 3. More efficient that other Quadratic complexity algorithms like\n *    Selection sort or bubble sort.\n * 4. It's stable that is it does not change the relative order of\n *    elements with equal keys\n * 5. Works on hand means it can sort the array or list as it receives.\n *\n * It is based on the same idea that people use to sort the playing cards in\n * their hands.\n * the algorithms goes in the manner that we start iterating over the array\n * of elements as soon as we find a unsorted element that is a misplaced\n * element we place it at a sorted position.\n *\n * Example execution steps:\n * 1. Suppose initially we have\n * \\f{bmatrix}{4 &3 &2 &5 &1\\f}\n * 2. We start traversing from 4 till we reach 1\n * when we reach at 3 we find that it is misplaced so we take 3 and place\n * it at a correct position thus the array will become\n * \\f{bmatrix}{3 &4 &2 &5 &1\\f}\n * 3. In the next iteration we are at 2 we find that this is also misplaced so\n * we place it at the correct sorted position thus the array in this iteration\n * becomes\n * \\f{bmatrix}{2 &3 &4 &5 &1\\f}\n * 4. We do not do anything with 5 and move on to the next iteration and\n * select 1 which is misplaced and place it at correct position. Thus, we have\n * \\f{bmatrix}{1 &2 &3 &4 &5\\f}\n */\n\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <vector>\n\n/** \\namespace sorting\n * \\brief Sorting algorithms\n */\nnamespace sorting {\n/** \\brief\n * Insertion Sort Function\n *\n * @tparam T type of array\n * @param [in,out] arr Array to be sorted\n * @param n Size of Array\n */\ntemplate <typename T>\nvoid insertionSort(T *arr, int n) {\n    for (int i = 1; i < n; i++) {\n        T temp = arr[i];\n        int j = i - 1;\n        while (j >= 0 && temp < arr[j]) {\n            arr[j + 1] = arr[j];\n            j--;\n        }\n        arr[j + 1] = temp;\n    }\n}\n\n/** Insertion Sort Function\n *\n * @tparam T type of array\n * @param [in,out] arr pointer to array to be sorted\n */\ntemplate <typename T>\nvoid insertionSort(std::vector<T> *arr) {\n    size_t n = arr->size();\n\n    for (size_t i = 1; i < n; i++) {\n        T temp = arr[0][i];\n        int32_t j = i - 1;\n        while (j >= 0 && temp < arr[0][j]) {\n            arr[0][j + 1] = arr[0][j];\n            j--;\n        }\n        arr[0][j + 1] = temp;\n    }\n}\n\n}  // namespace sorting\n\n/**\n * @brief Create a random array objecthelper function to create a random array\n *\n * @tparam T type of array\n * @param arr array to fill (must be pre-allocated)\n * @param N number of array elements\n */\ntemplate <typename T>\nstatic void create_random_array(T *arr, int N) {\n    while (N--) {\n        double r = (std::rand() % 10000 - 5000) / 100.f;\n        arr[N] = static_cast<T>(r);\n    }\n}\n\n/** Test Cases to test algorithm */\nvoid tests() {\n    int arr1[10] = {78, 34, 35, 6, 34, 56, 3, 56, 2, 4};\n    std::cout << \"Test 1... \";\n    sorting::insertionSort(arr1, 10);\n    assert(std::is_sorted(arr1, arr1 + 10));\n    std::cout << \"passed\" << std::endl;\n\n    int arr2[5] = {5, -3, 7, -2, 1};\n    std::cout << \"Test 2... \";\n    sorting::insertionSort(arr2, 5);\n    assert(std::is_sorted(arr2, arr2 + 5));\n    std::cout << \"passed\" << std::endl;\n\n    float arr3[5] = {5.6, -3.1, -3.0, -2.1, 1.8};\n    std::cout << \"Test 3... \";\n    sorting::insertionSort(arr3, 5);\n    assert(std::is_sorted(arr3, arr3 + 5));\n    std::cout << \"passed\" << std::endl;\n\n    std::vector<float> arr4({5.6, -3.1, -3.0, -2.1, 1.8});\n    std::cout << \"Test 4... \";\n    sorting::insertionSort(&arr4);\n    assert(std::is_sorted(std::begin(arr4), std::end(arr4)));\n    std::cout << \"passed\" << std::endl;\n\n    int arr5[50];\n    std::cout << \"Test 5... \";\n    create_random_array(arr5, 50);\n    sorting::insertionSort(arr5, 50);\n    assert(std::is_sorted(arr5, arr5 + 50));\n    std::cout << \"passed\" << std::endl;\n\n    float arr6[50];\n    std::cout << \"Test 6... \";\n    create_random_array(arr6, 50);\n    sorting::insertionSort(arr6, 50);\n    assert(std::is_sorted(arr6, arr6 + 50));\n    std::cout << \"passed\" << std::endl;\n}\n\n/** Main Function */\nint main() {\n    /// Running predefined tests to test algorithm\n    tests();\n\n    /// For user insteraction\n    size_t n;\n    std::cout << \"Enter the length of your array (0 to exit): \";\n    std::cin >> n;\n    if (n == 0) {\n        return 0;\n    }\n\n    int *arr = new int[n];\n    std::cout << \"Enter any \" << n << \" Numbers for Unsorted Array : \";\n\n    for (int i = 0; i < n; i++) {\n        std::cin >> arr[i];\n    }\n\n    sorting::insertionSort(arr, n);\n\n    std::cout << \"\\nSorted Array : \";\n    for (int i = 0; i < n; i++) {\n        std::cout << arr[i] << \" \";\n    }\n\n    std::cout << std::endl;\n    delete[] arr;\n    return 0;\n}\n","index":217},{"title":"Library Sort","category":"sorting","id":"library_sort_sorting","algorithm":"#include <algorithm>\n#include <iostream>\n\nvoid librarySort(int *index, int n) {\n    int lib_size, index_pos,\n        *gaps,        // gaps\n        *library[2];  // libraries\n\n    bool target_lib, *numbered;\n\n    for (int i = 0; i < 2; i++) library[i] = new int[n];\n\n    gaps = new int[n + 1];\n    numbered = new bool[n + 1];\n\n    lib_size = 1;\n    index_pos = 1;\n    target_lib = 0;\n    library[target_lib][0] = index[0];\n\n    while (index_pos < n) {\n        // binary search\n        int insert = std::distance(\n            library[target_lib],\n            std::lower_bound(library[target_lib],\n                             library[target_lib] + lib_size, index[index_pos]));\n\n        // if there is no gap to insert a new index ...\n\n        if (numbered[insert] == true) {\n            int prov_size = 0, next_target_lib = !target_lib;\n\n            // update library and clear gaps\n\n            for (int i = 0; i <= n; i++) {\n                if (numbered[i] == true) {\n                    library[next_target_lib][prov_size] = gaps[i];\n                    prov_size++;\n                    numbered[i] = false;\n                }\n\n                if (i <= lib_size) {\n                    library[next_target_lib][prov_size] =\n                        library[target_lib][i];\n                    prov_size++;\n                }\n            }\n\n            target_lib = next_target_lib;\n            lib_size = prov_size - 1;\n        } else {\n            numbered[insert] = true;\n            gaps[insert] = index[index_pos];\n            index_pos++;\n        }\n    }\n\n    int index_pos_for_output = 0;\n    for (int i = 0; index_pos_for_output < n; i++) {\n        if (numbered[i] == true) {\n            // std::cout << gaps[i] << std::endl;\n            index[index_pos_for_output] = gaps[i];\n            index_pos_for_output++;\n        }\n\n        if (i < lib_size) {\n            // std::cout << library[target_lib][i] << std::endl;\n            index[index_pos_for_output] = library[target_lib][i];\n            index_pos_for_output++;\n        }\n    }\n}\n\nint main() {\n    // ---example--\n    int index_ex[] = {-6, 5, 9, 1, 9, 1, 0, 1, -8, 4, -12};\n    int n_ex = sizeof(index_ex) / sizeof(index_ex[0]);\n\n    librarySort(index_ex, n_ex);\n    std::cout << \"sorted array :\" << std::endl;\n    for (int i = 0; i < n_ex; i++) std::cout << index_ex[i] << \" \";\n    std::cout << std::endl;\n\n    /* --output--\n    sorted array :\n    -12 -8 -6 0 1 1 1 4 5 9 9\n    */\n}\n","index":218},{"title":"Merge Sort","category":"sorting","id":"merge_sort_sorting","algorithm":"/**\n *  \\addtogroup sorting Sorting Algorithms\n *  @{\n *  \\file\n *  \\brief [Merege Sort Algorithm\n *  (MEREGE SORT)](https://en.wikipedia.org/wiki/Merge_sort) implementation\n *\n *  \\author [Ayaan Khan](http://github.com/ayaankhan98)\n *\n *  \\details\n *  Merge Sort is an efficient, general purpose, comparison\n *  based sorting algorithm.\n *  Merge Sort is a divide and conquer algorithm\n *\n */\n#include <iostream>\n\n/**\n *\n * The merge() function is used for merging two halves.\n * The merge(arr, l, m, r) is key process that assumes that\n * arr[l..m] and arr[m+1..r] are sorted and merges the two\n * sorted sub-arrays into one.\n *\n * @param arr - array with two halves arr[l...m] and arr[m+1...l]\n * @param l - left index or start index of first half array\n * @param m - right index or end index of first half array\n *\n * (The second array starts form m+1 and goes till l)\n *\n * @param l - end index or right index of second half array\n */\nvoid merge(int *arr, int l, int m, int r) {\n    int i, j, k;\n    int n1 = m - l + 1;\n    int n2 = r - m;\n\n    int *L = new int[n1], *R = new int[n2];\n\n    for (i = 0; i < n1; i++) L[i] = arr[l + i];\n    for (j = 0; j < n2; j++) R[j] = arr[m + 1 + j];\n\n    i = 0;\n    j = 0;\n    k = l;\n    while (i < n1 && j < n2) {\n        if (L[i] <= R[j]) {\n            arr[k] = L[i];\n            i++;\n        } else {\n            arr[k] = R[j];\n            j++;\n        }\n        k++;\n    }\n\n    while (i < n1) {\n        arr[k] = L[i];\n        i++;\n        k++;\n    }\n\n    while (j < n2) {\n        arr[k] = R[j];\n        j++;\n        k++;\n    }\n\n    delete[] L;\n    delete[] R;\n}\n\n/**\n * Merge sort is a divide and conquer algorithm, it divides the\n * input array into two halves and calls itself for the two halves\n * and then calls merge() to merge the two halves\n *\n * @param arr - array to be sorted\n * @param l - left index or start index of array\n * @param r - right index or end index of array\n *\n */\nvoid mergeSort(int *arr, int l, int r) {\n    if (l < r) {\n        int m = l + (r - l) / 2;\n        mergeSort(arr, l, m);\n        mergeSort(arr, m + 1, r);\n        merge(arr, l, m, r);\n    }\n}\n\n/**\n * Utility function used to print the array after\n * sorting\n */\nvoid show(int *arr, int size) {\n    for (int i = 0; i < size; i++) std::cout << arr[i] << \" \";\n    std::cout << \"\\n\";\n}\n\n/** Main function */\nint main() {\n    int size;\n    std::cout << \"Enter the number of elements : \";\n    std::cin >> size;\n    int *arr = new int[size];\n    std::cout << \"Enter the unsorted elements : \";\n    for (int i = 0; i < size; ++i) {\n        std::cin >> arr[i];\n    }\n    mergeSort(arr, 0, size - 1);\n    std::cout << \"Sorted array : \";\n    show(arr, size - 1);\n    delete[] arr;\n    return 0;\n}\n/** @} */\n","index":219},{"title":"Non Recursive Merge Sort","category":"sorting","id":"non_recursive_merge_sort_sorting","algorithm":"/**\n * Copyright 2020 @author Albirair\n * @file\n *\n * A generic implementation of non-recursive merge sort.\n */\n#include <cstddef>  // for size_t\n#include <iostream>\n#include <utility>  // for std::move & std::remove_reference_t\n\nnamespace sorting {\ntemplate <class Iterator>\nvoid merge(Iterator, Iterator, const Iterator, char[]);\n/// bottom-up merge sort which sorts elements in a non-decreasing order\n/**\n * sorts elements non-recursively by breaking them into small segments,\n * merging adjacent segments into larger sorted segments, then increasing\n * the sizes of segments by factors of 2 and repeating the same process.\n * best-case = worst-case = O(n log(n))\n * @param first points to the first element\n * @param last points to 1-step past the last element\n * @param n the number of elements\n */\ntemplate <class Iterator>\nvoid non_recursive_merge_sort(const Iterator first, const Iterator last,\n                              const size_t n) {\n    // create a buffer large enough to store all elements\n    // dynamically allocated to comply with cpplint\n    char* buffer = new char[n * sizeof(*first)];\n    // buffer size can be optimized to largest power of 2 less than n\n    // elements divide the container into equally-sized segments whose\n    // length start at 1 and keeps increasing by factors of 2\n    for (size_t length(1); length < n; length <<= 1) {\n        // merge adjacent segments whose number is n / (length * 2)\n        Iterator left(first);\n        for (size_t counter(n / (length << 1)); counter; --counter) {\n            Iterator right(left + length), end(right + length);\n            merge(left, right, end, buffer);\n            left = end;\n        }\n        // if the number of remaining elements (n * 2 % length) is longer\n        // than a segment, merge the remaining elements\n        if ((n & ((length << 1) - 1)) > length)\n            merge(left, left + length, last, buffer);\n    }\n    delete[] buffer;\n}\n/// merges 2 sorted adjacent segments into a larger sorted segment\n/**\n * best-case = worst-case = O(n)\n * @param l points to the left part\n * @param r points to the right part, end of left part\n * @param e points to end of right part\n * @param b points at the buffer\n */\ntemplate <class Iterator>\nvoid merge(Iterator l, Iterator r, const Iterator e, char b[]) {\n    // create 2 pointers to point at the buffer\n    auto p(reinterpret_cast<std::remove_reference_t<decltype(*l)>*>(b)), c(p);\n    // move the left part of the segment\n    for (Iterator t(l); r != t; ++t) *p++ = std::move(*t);\n    // while neither the buffer nor the right part has been exhausted\n    // move the smallest element of the two back to the container\n    while (e != r && c != p) *l++ = std::move(*r < *c ? *r++ : *c++);\n    // notice only one of the two following loops will be executed\n    // while the right part hasn't bee exhausted, move it back\n    while (e != r) *l++ = std::move(*r++);\n    // while the buffer hasn't bee exhausted, move it back\n    while (c != p) *l++ = std::move(*c++);\n}\n/// bottom-up merge sort which sorts elements in a non-decreasing order\n/**\n * @param first points to the first element\n * @param n the number of elements\n */\ntemplate <class Iterator>\nvoid non_recursive_merge_sort(const Iterator first, const size_t n) {\n    non_recursive_merge_sort(first, first + n, n);\n}\n/// bottom-up merge sort which sorts elements in a non-decreasing order\n/**\n * @param first points to the first element\n * @param last points to 1-step past the last element\n */\ntemplate <class Iterator>\nvoid non_recursive_merge_sort(const Iterator first, const Iterator last) {\n    non_recursive_merge_sort(first, last, last - first);\n}\n\n}  // namespace sorting\n\nusing sorting::non_recursive_merge_sort;\n\nint main(int argc, char** argv) {\n    int size;\n    std::cout << \"Enter the number of elements : \";\n    std::cin >> size;\n    int* arr = new int[size];\n    for (int i = 0; i < size; ++i) {\n        std::cout << \"arr[\" << i << \"] = \";\n        std::cin >> arr[i];\n    }\n    non_recursive_merge_sort(arr, size);\n    std::cout << \"Sorted array\\n\";\n    for (int i = 0; i < size; ++i)\n        std::cout << \"arr[\" << i << \"] = \" << arr[i] << '\\n';\n    delete[] arr;\n    return 0;\n}\n","index":220},{"title":"Numeric String Sort","category":"sorting","id":"numeric_string_sort_sorting","algorithm":"// Using general algorithms to sort a collection of strings results in\n// alphanumeric sort. If it is a numeric string, it leads to unnatural sorting\n\n// eg, an array of strings 1,10,100,2,20,200,3,30,300\n// would be sorted in that same order by using conventional sorting,\n// even though we know the correct sorting order is 1,2,3,10,20,30,100,200,300\n\n// This Programme uses a comparator to sort the array in Numerical order instead\n// of Alphanumeric order\n\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <vector>\n\nbool NumericSort(std::string a, std::string b) {\n    while (a[0] == '0') {\n        a.erase(a.begin());\n    }\n    while (b[0] == '0') {\n        b.erase(b.begin());\n    }\n    int n = a.length();\n    int m = b.length();\n    if (n == m)\n        return a < b;\n    return n < m;\n}\n\nint main() {\n    int n;\n    std::cout << \"Enter number of elements to be sorted Numerically\\n\";\n    std::cin >> n;\n\n    std::vector<std::string> v(n);\n    std::cout << \"Enter the string of Numbers\\n\";\n    for (int i = 0; i < n; i++) {\n        std::cin >> v[i];\n    }\n\n    sort(v.begin(), v.end());\n    std::cout << \"Elements sorted normally \\n\";\n    for (int i = 0; i < n; i++) {\n        std::cout << v[i] << \" \";\n    }\n    std::cout << \"\\n\";\n\n    std::sort(v.begin(), v.end(), NumericSort);\n    std::cout << \"Elements sorted Numerically \\n\";\n    for (int i = 0; i < n; i++) {\n        std::cout << v[i] << \" \";\n    }\n\n    return 0;\n}\n","index":221},{"title":"Odd Even Sort","category":"sorting","id":"odd_even_sort_sorting","algorithm":"/* C++ implementation Odd Even Sort */\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvoid oddEven(vector<int> &arr, int size) {\n    bool sorted = false;\n    while (!sorted) {\n        sorted = true;\n        for (int i = 1; i < size - 1; i += 2)  // Odd\n        {\n            if (arr[i] > arr[i + 1]) {\n                swap(arr[i], arr[i + 1]);\n                sorted = false;\n            }\n        }\n\n        for (int i = 0; i < size - 1; i += 2)  // Even\n        {\n            if (arr[i] > arr[i + 1]) {\n                swap(arr[i], arr[i + 1]);\n                sorted = false;\n            }\n        }\n    }\n}\n\nvoid show(vector<int> A, int size) {\n    int i;\n    for (i = 0; i < size; i++) cout << A[i] << \"\\n\";\n}\n\nint main() {\n    int size, temp;\n    cout << \"\\nEnter the number of elements : \";\n    cin >> size;\n\n    vector<int> arr;\n\n    cout << \"\\nEnter the unsorted elements : \\n\";\n\n    for (int i = 0; i < size; ++i) {\n        cin >> temp;\n        arr.push_back(temp);\n    }\n\n    oddEven(arr, size);\n\n    cout << \"Sorted array\\n\";\n    show(arr, size);\n    return 0;\n}\n","index":222},{"title":"Pigeonhole Sort","category":"sorting","id":"pigeonhole_sort_sorting","algorithm":"/**\n * @file\n * @brief Implementation of [Pigeonhole Sort algorithm]\n * (https://en.wikipedia.org/wiki/Pigeonhole_sort)\n * @author [Lownish](https://github.com/Lownish)\n * @details\n * Pigeonhole sorting is a sorting algorithm that is suitable for sorting lists\n * of elements where the number of elements and the number of possible key\n * values are approximately the same. It requires O(n + Range) time where n is\n * number of elements in input array and ‘Range’ is number of possible values in\n * array.\n *\n * The time Complexity of the algorithm is \\f$O(n+N)\\f$.\n */\n\n#include <algorithm>  //for std::is_sorted\n#include <array>      //for std::array\n#include <cassert>    //for assert\n#include <iostream>   //for io operations\n\n/**\n * @namespace sorting\n * @brief Sorting algorithms\n */\nnamespace sorting {\n\n/**\n * Pigeonhole sorting of array of size n\n * The function will sort the array through Pigeonhole algorithm and print\n * @param arr unsorted array of elements\n * @returns sorted array of elements\n */\ntemplate <std::size_t N>\nstd::array<int, N> pigeonSort(std::array<int, N> arr) {\n    // Finding min and max*\n    auto min = std::min_element(std::begin(arr), std::end(arr));\n    auto max = std::max_element(std::begin(arr), std::end(arr));\n\n    // Range refers to the number of holes required\n    int range = *max - *min + 1;\n    int *hole = new int[range]();\n\n    // Copying all array values to pigeonhole\n    for (int i = 0; i < N; i++) {\n        hole[arr[i] - *min] = arr[i];\n    }\n\n    // Deleting elements from list and storing to original array\n    int count = 0;\n    for (int i = 0; i < range; i++) {\n        while (hole[i] != '\\0') {\n            arr[count] = hole[i];\n            hole[i] = {};\n            count++;\n        }\n    }\n    delete[] hole;\n\n    return arr;\n}\n}  // namespace sorting\n\n/**\n * Test function 1 with unsorted array\n * {8, 3, 2, 7, 4, 6, 8}\n * @returns none\n */\nstatic void test_1() {\n    const int n = 7;\n    std::array<int, n> test_array = {8, 3, 2, 7, 4, 6, 8};\n\n    test_array = sorting::pigeonSort<n>(test_array);\n\n    assert(std::is_sorted(std::begin(test_array), std::end(test_array)));\n\n    // Printing sorted array\n    for (int i = 0; i < n; i++) {\n        std::cout << test_array.at(i) << \" \";\n    }\n    std::cout << \"\\nPassed\\n\";\n}\n\n/**\n * Test function 2 with unsorted array\n * {802, 630, 20, 745, 52, 300, 612, 932, 78, 187}\n * @returns none\n */\nstatic void test_2() {\n    const int n = 10;\n    std::array<int, n> test_array = {802, 630, 20,  745, 52,\n                                     300, 612, 932, 78,  187};\n\n    test_array = sorting::pigeonSort<n>(test_array);\n\n    assert(std::is_sorted(std::begin(test_array), std::end(test_array)));\n\n    // Printing sorted array\n    for (int i = 0; i < n; i++) {\n        std::cout << test_array.at(i) << \" \";\n    }\n    std::cout << \"\\nPassed\\n\";\n}\n\n/**\n * Test function 1 with unsorted array\n * {11,13,12,14}\n * @returns none\n */\nstatic void test_3() {\n    const int n = 4;\n    std::array<int, n> test_array = {11, 13, 12, 14};\n\n    test_array = sorting::pigeonSort<n>(test_array);\n\n    assert(std::is_sorted(std::begin(test_array), std::end(test_array)));\n\n    // Printing sorted array\n    for (int i = 0; i < n; i++) {\n        std::cout << test_array.at(i) << \" \";\n    }\n    std::cout << \"\\nPassed\\n\";\n}\n\n/**\n * Main function\n */\nint main() {\n    test_1();\n    test_2();\n    test_3();\n\n    return 0;\n}\n","index":223},{"title":"Quick Sort","category":"sorting","id":"quick_sort_sorting","algorithm":"/**\n * @file\n * @brief Quick sort algorithm\n *\n * Implementation Details -\n *      Quick Sort is a divide and conquer algorithm. It picks and element as\n *      pivot and partition the given array around the picked pivot. There\n *      are many different versions of quickSort that pick pivot in different\n *      ways.\n *\n *      1. Always pick the first element as pivot\n *      2. Always pick the last element as pivot (implemented below)\n *      3. Pick a random element as pivot\n *      4. Pick median as pivot\n *\n *      The key process in quickSort is partition(). Target of partition is,\n *      given an array and an element x(say) of array as pivot, put x at it's\n *      correct position in sorted array and put all smaller elements (samller\n *      than x) before x, and put all greater elements (greater than x) after\n *      x. All this should be done in linear time\n *\n */\n\n#include <cstdlib>\n#include <iostream>\n\nnamespace sorting {\n/**\n *      This function takes last element as pivot, places\n *      the pivot element at its correct position in sorted\n *      array, and places all smaller (smaller than pivot)\n *      to left of pivot and all greater elements to right\n *      of pivot\n *\n */\n\nint partition(int arr[], int low, int high) {\n    int pivot = arr[high];  // taking the last element as pivot\n    int i = (low - 1);      // Index of smaller element\n\n    for (int j = low; j < high; j++) {\n        // If current element is smaller than or\n        // equal to pivot\n        if (arr[j] <= pivot) {\n            i++;  // increment index of smaller element\n            int temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n        }\n    }\n    int temp = arr[i + 1];\n    arr[i + 1] = arr[high];\n    arr[high] = temp;\n    return (i + 1);\n}\n\n/**\n *      The main function that implements QuickSort\n *      arr[] --> Array to be sorted,\n *      low --> Starting index,\n *      high --> Ending index\n */\nvoid quickSort(int arr[], int low, int high) {\n    if (low < high) {\n        int p = partition(arr, low, high);\n        quickSort(arr, low, p - 1);\n        quickSort(arr, p + 1, high);\n    }\n}\n\n}  // namespace sorting\n\nusing sorting::quickSort;\n\n// prints the array after sorting\nvoid show(int arr[], int size) {\n    for (int i = 0; i < size; i++) std::cout << arr[i] << \" \";\n    std::cout << \"\\n\";\n}\n\n/** Driver program to test above functions */\nint main() {\n    int size;\n    std::cout << \"\\nEnter the number of elements : \";\n\n    std::cin >> size;\n\n    int *arr = new int[size];\n\n    std::cout << \"\\nEnter the unsorted elements : \";\n\n    for (int i = 0; i < size; ++i) {\n        std::cout << \"\\n\";\n        std::cin >> arr[i];\n    }\n    quickSort(arr, 0, size);\n    std::cout << \"Sorted array\\n\";\n    show(arr, size);\n    delete[] arr;\n    return 0;\n}\n","index":224},{"title":"Quick Sort 3","category":"sorting","id":"quick_sort_3_sorting","algorithm":"/**\n * @file\n * @brief Implementation Details\n * @details Quick sort 3 works on Dutch National Flag Algorithm\n * The major difference between simple quicksort and quick sort 3 comes in the\n * function partition3 In quick_sort_partition3 we divide the vector/array into\n * 3 parts. quick sort 3 works faster in some cases as compared to simple\n * quicksort.\n * @author immortal-j\n * @author [Krishna Vedala](https://github/kvedala)\n */\n#include <algorithm>\n#include <cassert>\n#include <ctime>\n#include <iostream>\n#include <vector>\n\nnamespace {\n/**\n * Operator to print the array.\n * @param out std::ostream object to write to\n * @param arr array to write\n */\ntemplate <typename T>\nstd::ostream &operator<<(std::ostream &out, const std::vector<T> &arr) {\n    for (size_t i = 0; i < arr.size(); ++i) {\n        out << arr[i];\n        if (i < arr.size() - 1) {\n            out << \", \";\n        }\n    }\n    return out;\n}\n\n}  // namespace\n\n/**\n * @namespace sorting\n * @brief Sorting Algorithms\n */\nnamespace sorting {\nnamespace {  // using un-named namespace here to prevent partition function\n             // being visible to end-users\n/** This function partitions `arr[]` in three parts\n * 1. \\f$arr[l\\ldots i]\\f$ contains all elements smaller than pivot\n * 2. \\f$arr[(i+1)\\ldots (j-1)]\\f$ contains all occurrences of pivot\n * 3. \\f$arr[j\\ldots r]\\f$ contains all elements greater than pivot\n * @tparam T type of data in the vector array\n * @param [in,out] arr vector array being partitioned\n * @param [in] low lower limit of window to partition\n * @param [in] high upper limit of window to partition\n * @param [out] i updated lower limit of partition\n * @param [out] j updated upper limit of partition\n */\ntemplate <typename T>\nvoid partition3(std::vector<T> *arr, int32_t low, int32_t high, int32_t *i,\n                int32_t *j) {\n    // To handle 2 elements\n    if (high - low <= 1) {\n        if ((*arr)[high] < (*arr)[low]) {\n            std::swap((*arr)[high], (*arr)[low]);\n        }\n        *i = low;\n        *j = high;\n        return;\n    }\n\n    int32_t mid = low;\n    T pivot = (*arr)[high];\n    while (mid <= high) {\n        if ((*arr)[mid] < pivot) {\n            std::swap((*arr)[low++], (*arr)[mid++]);\n        } else if ((*arr)[mid] == pivot) {\n            mid++;\n        } else if ((*arr)[mid] > pivot) {\n            std::swap((*arr)[mid], (*arr)[high--]);\n        }\n    }\n\n    // update i and j\n    *i = low - 1;\n    *j = mid;  // or high-1\n}\n}  // namespace\n\n/** 3-way partition based quick sort. This function accepts array pointer and\n * modified the input array.\n * @tparam T type of data in the vector array\n * @param [in,out] arr vector array to sort\n * @param [in] low lower limit of window to partition\n * @param [in] high upper limit of window to partition\n */\ntemplate <typename T>\nvoid quicksort(std::vector<T> *arr, int32_t low, int32_t high) {\n    if (low >= high) {  // 1 or 0 elements\n        return;\n    }\n\n    int32_t i = 0, j = 0;\n\n    // i and j are passed as reference\n    partition3(arr, low, high, &i, &j);\n\n    // Recur two halves\n    quicksort(arr, low, i);\n    quicksort(arr, j, high);\n}\n\n/** 3-way partition based quick sort. This function accepts array by value and\n * creates a copy of it. The array copy gets sorted and returned by the\n * function.\n * @tparam T type of data in the vector array\n * @param [in] arr vector array to sort\n * @param [in] low lower limit of window to partition\n * @param [in] high upper limit of window to partition\n * @returns sorted array vector\n */\ntemplate <typename T>\nstd::vector<T> quicksort(std::vector<T> arr, int32_t low, int32_t high) {\n    if (low >= high) {  // 1 or 0 elements\n        return arr;\n    }\n\n    int32_t i = 0, j = 0;\n\n    // i and j are passed as reference\n    partition3(&arr, low, high, &i, &j);\n\n    // Recur two halves\n    quicksort(&arr, low, i);\n    quicksort(&arr, j, high);\n\n    return arr;\n}\n}  // namespace sorting\n\n/** Test function for integer type arrays */\nstatic void test_int() {\n    std::cout << \"\\nTesting integer type arrays\\n\";\n\n    for (int num_tests = 1; num_tests < 21; num_tests++) {\n        size_t size = std::rand() % 500;\n        std::vector<int> arr(size);\n        for (auto &a : arr) {\n            a = std::rand() % 500 - 250;  // random numbers between -250, 249\n        }\n\n        std::cout << \"Test \" << num_tests << \"\\t Array size:\" << size << \"\\t \";\n        std::vector<int> sorted = sorting::quicksort(arr, 0, size - 1);\n        if (size < 20) {\n            std::cout << \"\\t Sorted Array is:\\n\\t\";\n            std::cout << sorted << \"\\n\";\n        }\n        assert(std::is_sorted(std::begin(sorted), std::end(sorted)));\n        std::cout << \"\\t Passed\\n\";\n    }\n}\n\n/** Test function for double type arrays */\nstatic void test_double() {\n    std::cout << \"\\nTesting Double type arrays\\n\";\n    for (int num_tests = 1; num_tests < 21; num_tests++) {\n        size_t size = std::rand() % 500;\n        std::vector<double> arr(size);\n        for (auto &a : arr) {\n            a = double(std::rand() % 500) -\n                250.f;   // random numbers between -250, 249\n            a /= 100.f;  // convert to -2.5 to 2.49\n        }\n\n        std::cout << \"Test \" << num_tests << \"\\t Array size:\" << size << \"\\t \";\n        std::vector<double> sorted = sorting::quicksort(arr, 0, size - 1);\n        if (size < 20) {\n            std::cout << \"\\t Sorted Array is:\\n\\t\";\n            std::cout << sorted << \"\\n\";\n        }\n        assert(std::is_sorted(std::begin(sorted), std::end(sorted)));\n        std::cout << \"\\t Passed\\n\";\n    }\n}\n\n/** Driver program for above functions */\nint main() {\n    std::srand(std::time(nullptr));\n    test_int();\n    test_double();\n    return 0;\n}\n","index":225},{"title":"Radix Sort","category":"sorting","id":"radix_sort_sorting","algorithm":"#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n\nvoid radixsort(int a[], int n) {\n    int count[10];\n    int* output = new int[n];\n    memset(output, 0, n * sizeof(*output));\n    memset(count, 0, sizeof(count));\n    int max = 0;\n    for (int i = 0; i < n; ++i) {\n        if (a[i] > max) {\n            max = a[i];\n        }\n    }\n    int maxdigits = 0;\n    while (max) {\n        maxdigits++;\n        max /= 10;\n    }\n    for (int j = 0; j < maxdigits; j++) {\n        for (int i = 0; i < n; i++) {\n            int t = std::pow(10, j);\n            count[(a[i] % (10 * t)) / t]++;\n        }\n        int k = 0;\n        for (int p = 0; p < 10; p++) {\n            for (int i = 0; i < n; i++) {\n                int t = std::pow(10, j);\n                if ((a[i] % (10 * t)) / t == p) {\n                    output[k] = a[i];\n                    k++;\n                }\n            }\n        }\n        memset(count, 0, sizeof(count));\n        for (int i = 0; i < n; ++i) {\n            a[i] = output[i];\n        }\n    }\n    delete[] output;\n}\n\nvoid print(int a[], int n) {\n    for (int i = 0; i < n; ++i) {\n        std::cout << a[i] << \" \";\n    }\n    std::cout << std::endl;\n}\n\nint main(int argc, char const* argv[]) {\n    int a[] = {170, 45, 75, 90, 802, 24, 2, 66};\n    int n = sizeof(a) / sizeof(a[0]);\n    radixsort(a, n);\n    print(a, n);\n    return 0;\n}\n","index":226},{"title":"Selection Sort","category":"sorting","id":"selection_sort_sorting","algorithm":"// Selection Sort\n\n#include <iostream>\nusing namespace std;\n\nint main() {\n    int Array[6];\n    cout << \"\\nEnter any 6 Numbers for Unsorted Array : \";\n\n    // Input\n    for (int i = 0; i < 6; i++) {\n        cin >> Array[i];\n    }\n\n    // Selection Sorting\n    for (int i = 0; i < 6; i++) {\n        int min = i;\n        for (int j = i + 1; j < 6; j++) {\n            if (Array[j] < Array[min]) {\n                min = j;  // Finding the smallest number in Array\n            }\n        }\n        int temp = Array[i];\n        Array[i] = Array[min];\n        Array[min] = temp;\n    }\n\n    // Output\n    cout << \"\\nSorted Array : \";\n    for (int i = 0; i < 6; i++) {\n        cout << Array[i] << \"\\t\";\n    }\n}\n","index":227},{"title":"Shell Sort","category":"sorting","id":"shell_sort_sorting","algorithm":"#include <iostream>\n\nint main() {\n    int size = 10;\n    int* array = new int[size];\n    // Input\n    std::cout << \"\\nHow many numbers do want to enter in unsorted array : \";\n    std::cin >> size;\n    std::cout << \"\\nEnter the numbers for unsorted array : \";\n    for (int i = 0; i < size; i++) {\n        std::cin >> array[i];\n    }\n\n    // Sorting\n    for (int i = size / 2; i > 0; i = i / 2) {\n        for (int j = i; j < size; j++) {\n            for (int k = j - i; k >= 0; k = k - i) {\n                if (array[k] < array[k + i]) {\n                    break;\n                } else {\n                    int temp = array[k + i];\n                    array[k + i] = array[k];\n                    array[k] = temp;\n                }\n            }\n        }\n    }\n\n    // Output\n    std::cout << \"\\nSorted array : \";\n    for (int i = 0; i < size; ++i) {\n        std::cout << array[i] << \"\\t\";\n    }\n\n    delete[] array;\n    return 0;\n}\n","index":228},{"title":"Shell Sort2","category":"sorting","id":"shell_sort2_sorting","algorithm":"/**\r\n * \\file\r\n * \\brief [Shell sort](https://en.wikipedia.org/wiki/Shell_sort) algorithm\r\n * \\author [Krishna Vedala](https://github.com/kvedala)\r\n */\r\n#include <cassert>\r\n#include <cstdlib>\r\n#include <ctime>\r\n#include <iostream>\r\n#include <utility>  // for std::swap\r\n#include <vector>\r\n\r\n/** pretty print array\r\n * \\param[in] arr array to print\r\n * \\param[in] LEN length of array to print\r\n */\r\ntemplate <class T>\r\nvoid show_data(T *arr, size_t LEN) {\r\n    size_t i;\r\n\r\n    for (i = 0; i < LEN; i++) {\r\n        std::cout << arr[i] << \", \";\r\n    }\r\n    std::cout << std::endl;\r\n}\r\n\r\n/** pretty print array\r\n * \\param[in] arr array to print\r\n * \\param[in] N length of array to print\r\n */\r\ntemplate <typename T, size_t N>\r\nvoid show_data(T (&arr)[N]) {\r\n    show_data(arr, N);\r\n}\r\n\r\n/** \\namespace sorting\r\n * \\brief Sorting algorithms\r\n */\r\nnamespace sorting {\r\n/**\r\n * Optimized algorithm - takes half the time by utilizing\r\n * Mar\r\n **/\r\ntemplate <typename T>\r\nvoid shell_sort(T *arr, size_t LEN) {\r\n    const unsigned int gaps[] = {701, 301, 132, 57, 23, 10, 4, 1};\r\n    const unsigned int gap_len = 8;\r\n    size_t i, j, g;\r\n\r\n    for (g = 0; g < gap_len; g++) {\r\n        unsigned int gap = gaps[g];\r\n        for (i = gap; i < LEN; i++) {\r\n            T tmp = arr[i];\r\n\r\n            for (j = i; j >= gap && (arr[j - gap] - tmp) > 0; j -= gap) {\r\n                arr[j] = arr[j - gap];\r\n            }\r\n\r\n            arr[j] = tmp;\r\n        }\r\n    }\r\n}\r\n\r\n/** function overload - when input array is of a known length array type\r\n */\r\ntemplate <typename T, size_t N>\r\nvoid shell_sort(T (&arr)[N]) {\r\n    shell_sort(arr, N);\r\n}\r\n\r\n/** function overload - when input array is of type std::vector,\r\n * simply send the data content and the data length to the above function.\r\n */\r\ntemplate <typename T>\r\nvoid shell_sort(std::vector<T> *arr) {\r\n    shell_sort(arr->data(), arr->size());\r\n}\r\n\r\n}  // namespace sorting\r\n\r\nusing sorting::shell_sort;\r\n\r\n/**\r\n * function to compare sorting using cstdlib's qsort\r\n **/\r\ntemplate <typename T>\r\nint compare(const void *a, const void *b) {\r\n    T arg1 = *static_cast<const T *>(a);\r\n    T arg2 = *static_cast<const T *>(b);\r\n\r\n    if (arg1 < arg2)\r\n        return -1;\r\n    if (arg1 > arg2)\r\n        return 1;\r\n    return 0;\r\n\r\n    //  return (arg1 > arg2) - (arg1 < arg2); // possible shortcut\r\n    //  return arg1 - arg2; // erroneous shortcut (fails if INT_MIN is present)\r\n}\r\n\r\n/**\r\n * Test implementation of shell_sort on integer arrays by comparing results\r\n * against std::qsort.\r\n */\r\nvoid test_int(const int NUM_DATA) {\r\n    // int array = new int[NUM_DATA];\r\n    int *data = new int[NUM_DATA];\r\n    int *data2 = new int[NUM_DATA];\r\n    // int array2 = new int[NUM_DATA];\r\n    int range = 1800;\r\n\r\n    for (int i = 0; i < NUM_DATA; i++)\r\n        data[i] = data2[i] = (std::rand() % range) - (range >> 1);\r\n\r\n    /* sort using our implementation */\r\n    std::clock_t start = std::clock();\r\n    shell_sort(data, NUM_DATA);\r\n    std::clock_t end = std::clock();\r\n    double elapsed_time = static_cast<double>(end - start) / CLOCKS_PER_SEC;\r\n    std::cout << \"Time spent sorting using shell_sort2: \" << elapsed_time\r\n              << \"s\\n\";\r\n\r\n    /* sort using std::qsort */\r\n    start = std::clock();\r\n    std::qsort(data2, NUM_DATA, sizeof(data2[0]), compare<int>);\r\n    end = std::clock();\r\n\r\n    elapsed_time = static_cast<double>(end - start) / CLOCKS_PER_SEC;\r\n    std::cout << \"Time spent sorting using std::qsort: \" << elapsed_time\r\n              << \"s\\n\";\r\n\r\n    for (int i = 0; i < NUM_DATA; i++) {\r\n        assert(data[i] == data2[i]);  // ensure that our sorting results match\r\n                                      // the standard results\r\n    }\r\n\r\n    delete[] data;\r\n    delete[] data2;\r\n}\r\n\r\n/**\r\n * Test implementation of shell_sort on float arrays by comparing results\r\n * against std::qsort.\r\n */\r\nvoid test_f(const int NUM_DATA) {\r\n    // int array = new int[NUM_DATA];\r\n    float *data = new float[NUM_DATA];\r\n    float *data2 = new float[NUM_DATA];\r\n    // int array2 = new int[NUM_DATA];\r\n    int range = 1000;\r\n\r\n    for (int i = 0; i < NUM_DATA; i++) {\r\n        data[i] = data2[i] = ((std::rand() % range) - (range >> 1)) / 100.;\r\n    }\r\n\r\n    /* sort using our implementation */\r\n    std::clock_t start = std::clock();\r\n    shell_sort(data, NUM_DATA);\r\n    std::clock_t end = std::clock();\r\n    double elapsed_time = static_cast<double>(end - start) / CLOCKS_PER_SEC;\r\n    std::cout << \"Time spent sorting using shell_sort2: \" << elapsed_time\r\n              << \"s\\n\";\r\n\r\n    /* sort using std::qsort */\r\n    start = std::clock();\r\n    std::qsort(data2, NUM_DATA, sizeof(data2[0]), compare<float>);\r\n    end = std::clock();\r\n\r\n    elapsed_time = static_cast<double>(end - start) / CLOCKS_PER_SEC;\r\n    std::cout << \"Time spent sorting using std::qsort: \" << elapsed_time\r\n              << \"s\\n\";\r\n\r\n    for (int i = 0; i < NUM_DATA; i++) {\r\n        assert(data[i] == data2[i]);  // ensure that our sorting results match\r\n                                      // the standard results\r\n    }\r\n\r\n    delete[] data;\r\n    delete[] data2;\r\n}\r\n\r\n/** Main function */\r\nint main(int argc, char *argv[]) {\r\n    // initialize random number generator - once per program\r\n    std::srand(std::time(NULL));\r\n\r\n    test_int(100);  // test with sorting random array of 100 values\r\n    std::cout << \"Test 1 - 100 int values - passed. \\n\";\r\n    test_int(1000);  // test with sorting random array of 1000 values\r\n    std::cout << \"Test 2 - 1000 int values - passed.\\n\";\r\n    test_int(10000);  // test with sorting random array of 10000 values\r\n    std::cout << \"Test 3 - 10000 int values - passed.\\n\";\r\n\r\n    test_f(100);  // test with sorting random array of 100 values\r\n    std::cout << \"Test 1 - 100 float values - passed. \\n\";\r\n    test_f(1000);  // test with sorting random array of 1000 values\r\n    std::cout << \"Test 2 - 1000 float values - passed.\\n\";\r\n    test_f(10000);  // test with sorting random array of 10000 values\r\n    std::cout << \"Test 3 - 10000 float values - passed.\\n\";\r\n\r\n    int i, NUM_DATA;\r\n\r\n    if (argc == 2)\r\n        NUM_DATA = atoi(argv[1]);\r\n    else\r\n        NUM_DATA = 200;\r\n\r\n    // int array = new int[NUM_DATA];\r\n    int *data = new int[NUM_DATA];\r\n    // int array2 = new int[NUM_DATA];\r\n    int range = 1800;\r\n\r\n    std::srand(time(NULL));\r\n    for (i = 0; i < NUM_DATA; i++) {\r\n        // allocate random numbers in the given range\r\n        data[i] = (std::rand() % range) - (range >> 1);\r\n    }\r\n\r\n    std::cout << \"Unsorted original data: \" << std::endl;\r\n    show_data(data, NUM_DATA);\r\n    std::clock_t start = std::clock();\r\n    shell_sort(data, NUM_DATA);  // perform sorting\r\n    std::clock_t end = std::clock();\r\n\r\n    std::cout << std::endl\r\n              << \"Data Sorted using custom implementation: \" << std::endl;\r\n    show_data(data, NUM_DATA);\r\n\r\n    double elapsed_time = (end - start) * 1.f / CLOCKS_PER_SEC;\r\n    std::cout << \"Time spent sorting: \" << elapsed_time << \"s\\n\" << std::endl;\r\n\r\n    delete[] data;\r\n    return 0;\r\n}\r\n","index":229},{"title":"Slow Sort","category":"sorting","id":"slow_sort_sorting","algorithm":"// Returns the sorted vector after performing SlowSort\n// It is a sorting algorithm that is of humorous nature and not useful.\n// It's based on the principle of multiply and surrender, a tongue-in-cheek joke\n// of divide and conquer. It was published in 1986 by Andrei Broder and Jorge\n// Stolfi in their paper Pessimal Algorithms and Simplexity Analysis. This\n// algorithm multiplies a single problem into multiple subproblems It is\n// interesting because it is provably the least efficient sorting algorithm that\n// can be built asymptotically, and with the restriction that such an algorithm,\n// while being slow, must still all the time be working towards a result.\n\n#include <iostream>\n\nvoid SlowSort(int a[], int i, int j) {\n    if (i >= j)\n        return;\n    int m = i + (j - i) / 2;  // midpoint, implemented this way to avoid\n                              // overflow\n    int temp;\n    SlowSort(a, i, m);\n    SlowSort(a, m + 1, j);\n    if (a[j] < a[m]) {\n        temp = a[j];  // swapping a[j] & a[m]\n        a[j] = a[m];\n        a[m] = temp;\n    }\n    SlowSort(a, i, j - 1);\n}\n\n// Sample Main function\n\nint main() {\n    int size;\n    std::cout << \"\\nEnter the number of elements : \";\n\n    std::cin >> size;\n\n    int *arr = new int[size];\n\n    std::cout << \"\\nEnter the unsorted elements : \";\n\n    for (int i = 0; i < size; ++i) {\n        std::cout << \"\\n\";\n        std::cin >> arr[i];\n    }\n\n    SlowSort(arr, 0, size);\n\n    std::cout << \"Sorted array\\n\";\n\n    for (int i = 0; i < size; ++i) {\n        std::cout << arr[i] << \" \";\n    }\n\n    delete[] arr;\n    return 0;\n}\n","index":230},{"title":"Swap Sort","category":"sorting","id":"swap_sort_sorting","algorithm":"// C++ program to find minimum number of swaps required to sort an array\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <vector>\n\n// Function returns the minimum number of swaps\n// required to sort the array\nint minSwaps(int arr[], int n) {\n    // Create an array of pairs where first\n    // element is array element and second element\n    // is position of first element\n    std::pair<int, int> *arrPos = new std::pair<int, int>[n];\n    for (int i = 0; i < n; i++) {\n        arrPos[i].first = arr[i];\n        arrPos[i].second = i;\n    }\n\n    // Sort the array by array element values to\n    // get right position of every element as second\n    // element of pair.\n    std::sort(arrPos, arrPos + n);\n\n    // To keep track of visited elements. Initialize\n    // all elements as not visited or false.\n    std::vector<bool> vis(n, false);\n\n    // Initialize result\n    int ans = 0;\n\n    // Traverse array elements\n    for (int i = 0; i < n; i++) {\n        // already swapped and corrected or\n        // already present at correct pos\n        if (vis[i] || arrPos[i].second == i)\n            continue;\n\n        // find out the number of node in\n        // this cycle and add in ans\n        int cycle_size = 0;\n        int j = i;\n        while (!vis[j]) {\n            vis[j] = 1;\n\n            // move to next node\n            j = arrPos[j].second;\n            cycle_size++;\n        }\n\n        // Update answer by adding current cycle.\n        if (cycle_size > 0) {\n            ans += (cycle_size - 1);\n        }\n    }\n\n    delete[] arrPos;\n\n    // Return result\n    return ans;\n}\n\n// program to test\nint main() {\n    int arr[] = {6, 7, 8, 1, 2, 3, 9, 12};\n    int n = (sizeof(arr) / sizeof(int));\n    std::cout << minSwaps(arr, n);\n    return 0;\n}\n","index":231},{"title":"Tim Sort","category":"sorting","id":"tim_sort_sorting","algorithm":"// C++ program to perform TimSort.\n#include <algorithm>\n#include <iostream>\n\nconst int RUN = 32;\n\n// this function sorts array from left index to to right index which is of size\n// atmost RUN\nvoid insertionSort(int arr[], int left, int right) {\n    for (int i = left + 1; i <= right; i++) {\n        int temp = arr[i];\n        int j = i - 1;\n        while (arr[j] > temp && j >= left) {\n            arr[j + 1] = arr[j];\n            j--;\n        }\n        arr[j + 1] = temp;\n    }\n}\n\n// merge function merges the sorted runs\nvoid merge(int arr[], int l, int m, int r) {\n    // original array is broken in two parts, left and right array\n    int len1 = m - l + 1, len2 = r - m;\n    int *left = new int[len1], *right = new int[len2];\n    for (int i = 0; i < len1; i++) left[i] = arr[l + i];\n    for (int i = 0; i < len2; i++) right[i] = arr[m + 1 + i];\n\n    int i = 0;\n    int j = 0;\n    int k = l;\n\n    // after comparing, we merge those two array in larger sub array\n    while (i < len1 && j < len2) {\n        if (left[i] <= right[j]) {\n            arr[k] = left[i];\n            i++;\n        } else {\n            arr[k] = right[j];\n            j++;\n        }\n        k++;\n    }\n\n    // copy remaining elements of left, if any\n    while (i < len1) {\n        arr[k] = left[i];\n        k++;\n        i++;\n    }\n\n    // copy remaining element of right, if any\n    while (j < len2) {\n        arr[k] = right[j];\n        k++;\n        j++;\n    }\n    delete[] left;\n    delete[] right;\n}\n\n// iterative Timsort function to sort the array[0...n-1] (similar to merge sort)\nvoid timSort(int arr[], int n) {\n    // Sort individual subarrays of size RUN\n    for (int i = 0; i < n; i += RUN)\n        insertionSort(arr, i, std::min((i + 31), (n - 1)));\n\n    // start merging from size RUN (or 32). It will merge to form size 64, then\n    // 128, 256 and so on ....\n    for (int size = RUN; size < n; size = 2 * size) {\n        // pick starting point of left sub array. We are going to merge\n        // arr[left..left+size-1] and arr[left+size, left+2*size-1] After every\n        // merge, we increase left by 2*size\n        for (int left = 0; left < n; left += 2 * size) {\n            // find ending point of left sub array\n            // mid+1 is starting point of right sub array\n            int mid = left + size - 1;\n            int right = std::min((left + 2 * size - 1), (n - 1));\n\n            // merge sub array arr[left.....mid] & arr[mid+1....right]\n            merge(arr, left, mid, right);\n        }\n    }\n}\n\n// utility function to print the Array\nvoid printArray(int arr[], int n) {\n    for (int i = 0; i < n; i++) printf(\"%d  \", arr[i]);\n    std::cout << std::endl;\n}\n\n// Driver program to test above function\nint main() {\n    int arr[] = {5, 21, 7, 23, 19};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    printf(\"Given Array is\\n\");\n    printArray(arr, n);\n\n    timSort(arr, n);\n\n    printf(\"After Sorting Array is\\n\");\n    printArray(arr, n);\n    return 0;\n}\n","index":232},{"title":"Strings","category":null,"id":"strings","index":233},{"title":"Brute Force String Searching","category":"strings","id":"brute_force_string_searching_strings","algorithm":"/**\n * @file\n * @brief          String pattern search - brute force\n */\n#include <iostream>\n#ifdef _MSC_VER\n#include <string>  // use this for MS Visucal C++\n#else\n#include <cstring>\n#endif\n#include <vector>\n\nnamespace string_search {\n/**\n * Find a pattern in a string by comparing the pattern to every substring.\n * @param text     Any string that might contain the pattern.\n * @param pattern  String that we are searching for.\n * @return         Index where the pattern starts in the text\n * @return         -1 if the pattern was not found.\n */\nint brute_force(const std::string &text, const std::string &pattern) {\n    size_t pat_l = pattern.length();\n    size_t txt_l = text.length();\n    int index = -1;\n    if (pat_l <= txt_l) {\n        for (size_t i = 0; i < txt_l - pat_l + 1; i++) {\n            std::string s = text.substr(i, pat_l);\n            if (s == pattern) {\n                index = i;\n                break;\n            }\n        }\n    }\n    return index;\n}\n}  // namespace string_search\n\nusing string_search::brute_force;\n\n/** set of test cases */\nconst std::vector<std::vector<std::string>> test_set = {\n    // {text, pattern, expected output}\n    {\"a\", \"aa\", \"-1\"},  {\"a\", \"a\", \"0\"},    {\"ba\", \"b\", \"0\"},\n    {\"bba\", \"bb\", \"0\"}, {\"bbca\", \"c\", \"2\"}, {\"ab\", \"b\", \"1\"}};\n\n/** Main function */\nint main() {\n    for (size_t i = 0; i < test_set.size(); i++) {\n        int output = brute_force(test_set[i][0], test_set[i][1]);\n\n        if (std::to_string(output) == test_set[i][2])\n            std::cout << \"success\\n\";\n        else\n            std::cout << \"failure\\n\";\n    }\n    return 0;\n}\n","index":234},{"title":"Knuth Morris Pratt","category":"strings","id":"knuth_morris_pratt_strings","algorithm":"/**\n * \\file\n * \\brief The [Knuth-Morris-Pratt\n * Algorithm](https://en.wikipedia.org/wiki/Knuth–Morris–Pratt_algorithm) for\n * finding a pattern within a piece of text with complexity O(n + m)\n *\n * 1. Preprocess pattern to identify any suffixes that are identical to\n * prefixes. This tells us where to continue from if we get a mismatch between a\n * character in our pattern and the text.\n * 2. Step through the text one character at a time and compare it to a\n * character in the pattern updating our location within the pattern if\n * necessary\n */\n\n#include <iostream>\n#ifdef _MSC_VER\n#include <string>  // use this for MS Visual C++\n#else\n#include <cstring>\n#endif\n#include <vector>\n\n/** \\namespace string_search\n * \\brief String search algorithms\n */\nnamespace string_search {\n/**\n * Generate the partial match table aka failure function for a pattern to\n * search.\n * \\param[in] pattern text for which to create the partial match table\n * \\returns the partial match table as a vector array\n */\nstd::vector<int> getFailureArray(const std::string &pattern) {\n    int pattern_length = pattern.size();\n    std::vector<int> failure(pattern_length + 1);\n    failure[0] = -1;\n    int j = -1;\n\n    for (int i = 0; i < pattern_length; i++) {\n        while (j != -1 && pattern[j] != pattern[i]) {\n            j = failure[j];\n        }\n        j++;\n        failure[i + 1] = j;\n    }\n    return failure;\n}\n\n/**\n * KMP algorithm to find a pattern in a text\n * \\param[in] pattern string pattern to search\n * \\param[in] text text in which to search\n * \\returns `true` if pattern was found\n * \\returns `false` if pattern was not found\n */\nbool kmp(const std::string &pattern, const std::string &text) {\n    int text_length = text.size(), pattern_length = pattern.size();\n    std::vector<int> failure = getFailureArray(pattern);\n\n    int k = 0;\n    for (int j = 0; j < text_length; j++) {\n        while (k != -1 && pattern[k] != text[j]) {\n            k = failure[k];\n        }\n        k++;\n        if (k == pattern_length)\n            return true;\n    }\n    return false;\n}\n}  // namespace string_search\n\nusing string_search::kmp;\n\n/** Main function */\nint main() {\n    std::string text = \"alskfjaldsabc1abc1abc12k23adsfabcabc\";\n    std::string pattern = \"abc1abc12l\";\n\n    if (kmp(pattern, text) == true) {\n        std::cout << \"Found\" << std::endl;\n    } else {\n        std::cout << \"Not Found\" << std::endl;\n    }\n\n    text = \"abcabc\";\n    pattern = \"bca\";\n    if (kmp(pattern, text) == true) {\n        std::cout << \"Found\" << std::endl;\n    } else {\n        std::cout << \"Not Found\" << std::endl;\n    }\n\n    return 0;\n}\n","index":235},{"title":"Rabin Karp","category":"strings","id":"rabin_karp_strings","algorithm":"/**\n * \\file\n * \\brief The [Rabin-Karp\n * Algorithm](https://en.wikipedia.org/wiki/Rabin–Karp_algorithm) for finding a\n * pattern within a piece of text with complexity O(n + m)\n */\n#include <cassert>\n#include <cmath>\n#include <iostream>\n#ifdef _MSC_VER\n#include <string>  // use this for MS Visucal C++\n#else\n#include <cstring>\n#endif\n\n#define PRIME 5  ///< Prime modulus for hash functions\n\nnamespace string_search {\n/**\n * convert a string to an intger - called as hashing function\n * \\param[in] s source of string to hash\n * \\param[in] n length of substring to hash\n * \\returns hash integer\n */\nint64_t create_hash(const std::string& s, int n) {\n    int64_t result = 0;\n    for (int i = 0; i < n; ++i) {\n        result += (int64_t)(s[i] * (int64_t)pow(PRIME, i));\n    }\n    return result;\n}\n\n/**\n * re-hash a string using known existing hash\n * \\param[in] s source of string to hash\n * \\param[in] old_index previous index of string\n * \\param[in] new_index new index of string\n * \\param[in] old_hash previous hash of substring\n * \\param[in] patLength length of substring to hash\n * \\returns new hash integer\n */\nint64_t recalculate_hash(const std::string& s, int old_index, int new_index,\n                         int64_t old_hash, int patLength) {\n    int64_t new_hash = old_hash - s[old_index];\n    new_hash /= PRIME;\n    new_hash += (int64_t)(s[new_index] * (int64_t)pow(PRIME, patLength - 1));\n    return new_hash;\n}\n\n/**\n * compare if two sub-strings are equal\n * \\param[in] str1 string pattern to search\n * \\param[in] str2 text in which to search\n * \\param[in] start1,end1 start and end indices for substring in str1\n * \\param[in] start2,end2 start and end indices for substring in str2\n * \\returns `true` if pattern was found\n * \\returns `false` if pattern was not found\n * @note can this be replaced by std::string::compare?\n */\nbool check_if_equal(const std::string& str1, const std::string& str2,\n                    int start1, int end1, int start2, int end2) {\n    if (end1 - start1 != end2 - start2) {\n        return false;\n    }\n    while (start1 <= end1 && start2 <= end2) {\n        if (str1[start1] != str2[start2]) {\n            return false;\n        }\n        start1++;\n        start2++;\n    }\n    return true;\n}\n\n/**\n *  Perform string pattern search using Rabin-Karp algorithm\n *  @param[in] str string to search in\n *  @param[in] pat pattern to search for\n *  @return index of first occurrence of pattern\n *  @return -1 if pattern not found\n */\n\nint rabin_karp(const std::string& str, const std::string& pat) {\n    int64_t pat_hash = create_hash(pat, pat.size());\n    int64_t str_hash = create_hash(str, pat.size());\n    for (int i = 0; i <= str.size() - pat.size(); ++i) {\n        if (pat_hash == str_hash &&\n            check_if_equal(str, pat, i, i + pat.size() - 1, 0,\n                           pat.size() - 1)) {\n            return i;\n        }\n        if (i < str.size() - pat.size()) {\n            str_hash =\n                recalculate_hash(str, i, i + pat.size(), str_hash, pat.size());\n        }\n    }\n    return -1;  // return -1 if given pattern not found\n}\n\n}  // namespace string_search\n\nusing string_search::rabin_karp;\n\n/** Main function */\nint main(void) {\n    assert(rabin_karp(\"helloWorld\", \"world\") == -1);\n    assert(rabin_karp(\"helloWorld\", \"World\") == 5);\n    assert(rabin_karp(\"this_is_c++\", \"c++\") == 8);\n    assert(rabin_karp(\"happy_coding\", \"happy\") == 0);\n    return 0;\n}\n","index":236}]