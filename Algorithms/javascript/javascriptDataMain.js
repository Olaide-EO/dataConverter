[{"title":"Javascript-master","category":".","id":"Javascript-master","algorithm":"# JavaScript Algorithms and Data Structures\n\n[![CI](https://github.com/trekhleb/javascript-algorithms/workflows/CI/badge.svg)](https://github.com/trekhleb/javascript-algorithms/actions?query=workflow%3ACI+branch%3Amaster)\n[![codecov](https://codecov.io/gh/trekhleb/javascript-algorithms/branch/master/graph/badge.svg)](https://codecov.io/gh/trekhleb/javascript-algorithms)\n\nThis repository contains JavaScript based examples of many\npopular algorithms and data structures.\n\nEach algorithm and data structure has its own separate README\nwith related explanations and links for further reading (including ones\nto YouTube videos).\n\n_Read this in other languages:_\n[_简体中文_](README.zh-CN.md),\n[_繁體中文_](README.zh-TW.md),\n[_한국어_](README.ko-KR.md),\n[_日本語_](README.ja-JP.md),\n[_Polski_](README.pl-PL.md),\n[_Français_](README.fr-FR.md),\n[_Español_](README.es-ES.md),\n[_Português_](README.pt-BR.md),\n[_Русский_](README.ru-RU.md),\n[_Türk_](README.tr-TR.md),\n[_Italiana_](README.it-IT.md),\n[_Bahasa Indonesia_](README.id-ID.md),\n[_Українська_](README.uk-UA.md),\n[_Arabic_](README.ar-AR.md),\n[_Deutsch_](README.de-DE.md)\n\n*☝ Note that this project is meant to be used for learning and researching purposes\nonly, and it is **not** meant to be used for production.*\n\n## Data Structures\n\nA data structure is a particular way of organizing and storing data in a computer so that it can\nbe accessed and modified efficiently. More precisely, a data structure is a collection of data\nvalues, the relationships among them, and the functions or operations that can be applied to\nthe data.\n\n`B` - Beginner, `A` - Advanced\n\n* `B` [Linked List](src/data-structures/linked-list)\n* `B` [Doubly Linked List](src/data-structures/doubly-linked-list)\n* `B` [Queue](src/data-structures/queue)\n* `B` [Stack](src/data-structures/stack)\n* `B` [Hash Table](src/data-structures/hash-table)\n* `B` [Heap](src/data-structures/heap) - max and min heap versions\n* `B` [Priority Queue](src/data-structures/priority-queue)\n* `A` [Trie](src/data-structures/trie)\n* `A` [Tree](src/data-structures/tree)\n  * `A` [Binary Search Tree](src/data-structures/tree/binary-search-tree)\n  * `A` [AVL Tree](src/data-structures/tree/avl-tree)\n  * `A` [Red-Black Tree](src/data-structures/tree/red-black-tree)\n  * `A` [Segment Tree](src/data-structures/tree/segment-tree) - with min/max/sum range queries examples\n  * `A` [Fenwick Tree](src/data-structures/tree/fenwick-tree) (Binary Indexed Tree)\n* `A` [Graph](src/data-structures/graph) (both directed and undirected)\n* `A` [Disjoint Set](src/data-structures/disjoint-set)\n* `A` [Bloom Filter](src/data-structures/bloom-filter)\n\n## Algorithms\n\nAn algorithm is an unambiguous specification of how to solve a class of problems. It is\na set of rules that precisely define a sequence of operations.\n\n`B` - Beginner, `A` - Advanced\n\n### Algorithms by Topic\n\n* **Math**\n  * `B` [Bit Manipulation](src/algorithms/math/bits) - set/get/update/clear bits, multiplication/division by two, make negative etc.\n  * `B` [Factorial](src/algorithms/math/factorial)\n  * `B` [Fibonacci Number](src/algorithms/math/fibonacci) - classic and closed-form versions\n  * `B` [Prime Factors](src/algorithms/math/prime-factors) - finding prime factors and counting them using Hardy-Ramanujan's theorem\n  * `B` [Primality Test](src/algorithms/math/primality-test) (trial division method)\n  * `B` [Euclidean Algorithm](src/algorithms/math/euclidean-algorithm) - calculate the Greatest Common Divisor (GCD)\n  * `B` [Least Common Multiple](src/algorithms/math/least-common-multiple) (LCM)\n  * `B` [Sieve of Eratosthenes](src/algorithms/math/sieve-of-eratosthenes) - finding all prime numbers up to any given limit\n  * `B` [Is Power of Two](src/algorithms/math/is-power-of-two) - check if the number is power of two (naive and bitwise algorithms)\n  * `B` [Pascal's Triangle](src/algorithms/math/pascal-triangle)\n  * `B` [Complex Number](src/algorithms/math/complex-number) - complex numbers and basic operations with them\n  * `B` [Radian & Degree](src/algorithms/math/radian) - radians to degree and backwards conversion\n  * `B` [Fast Powering](src/algorithms/math/fast-powering)\n  * `B` [Horner's method](src/algorithms/math/horner-method) - polynomial evaluation\n  * `B` [Matrices](src/algorithms/math/matrix) - matrices and basic matrix operations (multiplication, transposition, etc.)\n  * `B` [Euclidean Distance](src/algorithms/math/euclidean-distance) - distance between two points/vectors/matrices\n  * `A` [Integer Partition](src/algorithms/math/integer-partition)\n  * `A` [Square Root](src/algorithms/math/square-root) - Newton's method\n  * `A` [Liu Hui π Algorithm](src/algorithms/math/liu-hui) - approximate π calculations based on N-gons\n  * `A` [Discrete Fourier Transform](src/algorithms/math/fourier-transform) - decompose a function of time (a signal) into the frequencies that make it up\n* **Sets**\n  * `B` [Cartesian Product](src/algorithms/sets/cartesian-product) - product of multiple sets\n  * `B` [Fisher–Yates Shuffle](src/algorithms/sets/fisher-yates) - random permutation of a finite sequence\n  * `A` [Power Set](src/algorithms/sets/power-set) - all subsets of a set (bitwise and backtracking solutions)\n  * `A` [Permutations](src/algorithms/sets/permutations) (with and without repetitions)\n  * `A` [Combinations](src/algorithms/sets/combinations) (with and without repetitions)\n  * `A` [Longest Common Subsequence](src/algorithms/sets/longest-common-subsequence) (LCS)\n  * `A` [Longest Increasing Subsequence](src/algorithms/sets/longest-increasing-subsequence)\n  * `A` [Shortest Common Supersequence](src/algorithms/sets/shortest-common-supersequence) (SCS)\n  * `A` [Knapsack Problem](src/algorithms/sets/knapsack-problem) - \"0/1\" and \"Unbound\" ones\n  * `A` [Maximum Subarray](src/algorithms/sets/maximum-subarray) - \"Brute Force\" and \"Dynamic Programming\" (Kadane's) versions\n  * `A` [Combination Sum](src/algorithms/sets/combination-sum) - find all combinations that form specific sum\n* **Strings**\n  * `B` [Hamming Distance](src/algorithms/string/hamming-distance) - number of positions at which the symbols are different\n  * `A` [Levenshtein Distance](src/algorithms/string/levenshtein-distance) - minimum edit distance between two sequences\n  * `A` [Knuth–Morris–Pratt Algorithm](src/algorithms/string/knuth-morris-pratt) (KMP Algorithm) - substring search (pattern matching)\n  * `A` [Z Algorithm](src/algorithms/string/z-algorithm) - substring search (pattern matching)\n  * `A` [Rabin Karp Algorithm](src/algorithms/string/rabin-karp) - substring search\n  * `A` [Longest Common Substring](src/algorithms/string/longest-common-substring)\n  * `A` [Regular Expression Matching](src/algorithms/string/regular-expression-matching)\n* **Searches**\n  * `B` [Linear Search](src/algorithms/search/linear-search)\n  * `B` [Jump Search](src/algorithms/search/jump-search) (or Block Search) - search in sorted array\n  * `B` [Binary Search](src/algorithms/search/binary-search) - search in sorted array\n  * `B` [Interpolation Search](src/algorithms/search/interpolation-search) - search in uniformly distributed sorted array\n* **Sorting**\n  * `B` [Bubble Sort](src/algorithms/sorting/bubble-sort)\n  * `B` [Selection Sort](src/algorithms/sorting/selection-sort)\n  * `B` [Insertion Sort](src/algorithms/sorting/insertion-sort)\n  * `B` [Heap Sort](src/algorithms/sorting/heap-sort)\n  * `B` [Merge Sort](src/algorithms/sorting/merge-sort)\n  * `B` [Quicksort](src/algorithms/sorting/quick-sort) - in-place and non-in-place implementations\n  * `B` [Shellsort](src/algorithms/sorting/shell-sort)\n  * `B` [Counting Sort](src/algorithms/sorting/counting-sort)\n  * `B` [Radix Sort](src/algorithms/sorting/radix-sort)\n* **Linked Lists**\n  * `B` [Straight Traversal](src/algorithms/linked-list/traversal)\n  * `B` [Reverse Traversal](src/algorithms/linked-list/reverse-traversal)\n* **Trees**\n  * `B` [Depth-First Search](src/algorithms/tree/depth-first-search) (DFS)\n  * `B` [Breadth-First Search](src/algorithms/tree/breadth-first-search) (BFS)\n* **Graphs**\n  * `B` [Depth-First Search](src/algorithms/graph/depth-first-search) (DFS)\n  * `B` [Breadth-First Search](src/algorithms/graph/breadth-first-search) (BFS)\n  * `B` [Kruskal’s Algorithm](src/algorithms/graph/kruskal) - finding Minimum Spanning Tree (MST) for weighted undirected graph\n  * `A` [Dijkstra Algorithm](src/algorithms/graph/dijkstra) - finding the shortest paths to all graph vertices from single vertex\n  * `A` [Bellman-Ford Algorithm](src/algorithms/graph/bellman-ford) - finding the shortest paths to all graph vertices from single vertex\n  * `A` [Floyd-Warshall Algorithm](src/algorithms/graph/floyd-warshall) - find the shortest paths between all pairs of vertices\n  * `A` [Detect Cycle](src/algorithms/graph/detect-cycle) - for both directed and undirected graphs (DFS and Disjoint Set based versions)\n  * `A` [Prim’s Algorithm](src/algorithms/graph/prim) - finding Minimum Spanning Tree (MST) for weighted undirected graph\n  * `A` [Topological Sorting](src/algorithms/graph/topological-sorting) - DFS method\n  * `A` [Articulation Points](src/algorithms/graph/articulation-points) - Tarjan's algorithm (DFS based)\n  * `A` [Bridges](src/algorithms/graph/bridges) - DFS based algorithm\n  * `A` [Eulerian Path and Eulerian Circuit](src/algorithms/graph/eulerian-path) - Fleury's algorithm - Visit every edge exactly once\n  * `A` [Hamiltonian Cycle](src/algorithms/graph/hamiltonian-cycle) - Visit every vertex exactly once\n  * `A` [Strongly Connected Components](src/algorithms/graph/strongly-connected-components) - Kosaraju's algorithm\n  * `A` [Travelling Salesman Problem](src/algorithms/graph/travelling-salesman) - shortest possible route that visits each city and returns to the origin city\n* **Cryptography**\n  * `B` [Polynomial Hash](src/algorithms/cryptography/polynomial-hash) - rolling hash function based on polynomial\n  * `B` [Rail Fence Cipher](src/algorithms/cryptography/rail-fence-cipher) - a transposition cipher algorithm for encoding messages\n  * `B` [Caesar Cipher](src/algorithms/cryptography/caesar-cipher) - simple substitution cipher\n  * `B` [Hill Cipher](src/algorithms/cryptography/hill-cipher) - substitution cipher based on linear algebra\n* **Machine Learning**\n  * `B` [NanoNeuron](https://github.com/trekhleb/nano-neuron) - 7 simple JS functions that illustrate how machines can actually learn (forward/backward propagation)\n  * `B` [k-NN](src/algorithms/ml/knn) - k-nearest neighbors classification algorithm\n  * `B` [k-Means](src/algorithms/ml/k-means) - k-Means clustering algorithm\n* **Image Processing**\n  * `B` [Seam Carving](src/algorithms/image-processing/seam-carving) - content-aware image resizing algorithm\n* **Uncategorized**\n  * `B` [Tower of Hanoi](src/algorithms/uncategorized/hanoi-tower)\n  * `B` [Square Matrix Rotation](src/algorithms/uncategorized/square-matrix-rotation) - in-place algorithm\n  * `B` [Jump Game](src/algorithms/uncategorized/jump-game) - backtracking, dynamic programming (top-down + bottom-up) and greedy examples\n  * `B` [Unique Paths](src/algorithms/uncategorized/unique-paths) - backtracking, dynamic programming and Pascal's Triangle based examples\n  * `B` [Rain Terraces](src/algorithms/uncategorized/rain-terraces) - trapping rain water problem (dynamic programming and brute force versions)\n  * `B` [Recursive Staircase](src/algorithms/uncategorized/recursive-staircase) - count the number of ways to reach to the top (4 solutions)\n  * `B` [Best Time To Buy Sell Stocks](src/algorithms/uncategorized/best-time-to-buy-sell-stocks) - divide and conquer and one-pass examples\n  * `A` [N-Queens Problem](src/algorithms/uncategorized/n-queens)\n  * `A` [Knight's Tour](src/algorithms/uncategorized/knight-tour)\n\n### Algorithms by Paradigm\n\nAn algorithmic paradigm is a generic method or approach which underlies the design of a class\nof algorithms. It is an abstraction higher than the notion of an algorithm, just as an\nalgorithm is an abstraction higher than a computer program.\n\n* **Brute Force** - look at all the possibilities and selects the best solution\n  * `B` [Linear Search](src/algorithms/search/linear-search)\n  * `B` [Rain Terraces](src/algorithms/uncategorized/rain-terraces) - trapping rain water problem\n  * `B` [Recursive Staircase](src/algorithms/uncategorized/recursive-staircase) - count the number of ways to reach to the top\n  * `A` [Maximum Subarray](src/algorithms/sets/maximum-subarray)\n  * `A` [Travelling Salesman Problem](src/algorithms/graph/travelling-salesman) - shortest possible route that visits each city and returns to the origin city\n  * `A` [Discrete Fourier Transform](src/algorithms/math/fourier-transform) - decompose a function of time (a signal) into the frequencies that make it up\n* **Greedy** - choose the best option at the current time, without any consideration for the future\n  * `B` [Jump Game](src/algorithms/uncategorized/jump-game)\n  * `A` [Unbound Knapsack Problem](src/algorithms/sets/knapsack-problem)\n  * `A` [Dijkstra Algorithm](src/algorithms/graph/dijkstra) - finding the shortest path to all graph vertices\n  * `A` [Prim’s Algorithm](src/algorithms/graph/prim) - finding Minimum Spanning Tree (MST) for weighted undirected graph\n  * `A` [Kruskal’s Algorithm](src/algorithms/graph/kruskal) - finding Minimum Spanning Tree (MST) for weighted undirected graph\n* **Divide and Conquer** - divide the problem into smaller parts and then solve those parts\n  * `B` [Binary Search](src/algorithms/search/binary-search)\n  * `B` [Tower of Hanoi](src/algorithms/uncategorized/hanoi-tower)\n  * `B` [Pascal's Triangle](src/algorithms/math/pascal-triangle)\n  * `B` [Euclidean Algorithm](src/algorithms/math/euclidean-algorithm) - calculate the Greatest Common Divisor (GCD)\n  * `B` [Merge Sort](src/algorithms/sorting/merge-sort)\n  * `B` [Quicksort](src/algorithms/sorting/quick-sort)\n  * `B` [Tree Depth-First Search](src/algorithms/tree/depth-first-search) (DFS)\n  * `B` [Graph Depth-First Search](src/algorithms/graph/depth-first-search) (DFS)\n  * `B` [Matrices](src/algorithms/math/matrix) - generating and traversing the matrices of different shapes\n  * `B` [Jump Game](src/algorithms/uncategorized/jump-game)\n  * `B` [Fast Powering](src/algorithms/math/fast-powering)\n  * `B` [Best Time To Buy Sell Stocks](src/algorithms/uncategorized/best-time-to-buy-sell-stocks) - divide and conquer and one-pass examples\n  * `A` [Permutations](src/algorithms/sets/permutations) (with and without repetitions)\n  * `A` [Combinations](src/algorithms/sets/combinations) (with and without repetitions)\n* **Dynamic Programming** - build up a solution using previously found sub-solutions\n  * `B` [Fibonacci Number](src/algorithms/math/fibonacci)\n  * `B` [Jump Game](src/algorithms/uncategorized/jump-game)\n  * `B` [Unique Paths](src/algorithms/uncategorized/unique-paths)\n  * `B` [Rain Terraces](src/algorithms/uncategorized/rain-terraces) - trapping rain water problem\n  * `B` [Recursive Staircase](src/algorithms/uncategorized/recursive-staircase) - count the number of ways to reach to the top\n  * `B` [Seam Carving](src/algorithms/image-processing/seam-carving) - content-aware image resizing algorithm\n  * `A` [Levenshtein Distance](src/algorithms/string/levenshtein-distance) - minimum edit distance between two sequences\n  * `A` [Longest Common Subsequence](src/algorithms/sets/longest-common-subsequence) (LCS)\n  * `A` [Longest Common Substring](src/algorithms/string/longest-common-substring)\n  * `A` [Longest Increasing Subsequence](src/algorithms/sets/longest-increasing-subsequence)\n  * `A` [Shortest Common Supersequence](src/algorithms/sets/shortest-common-supersequence)\n  * `A` [0/1 Knapsack Problem](src/algorithms/sets/knapsack-problem)\n  * `A` [Integer Partition](src/algorithms/math/integer-partition)\n  * `A` [Maximum Subarray](src/algorithms/sets/maximum-subarray)\n  * `A` [Bellman-Ford Algorithm](src/algorithms/graph/bellman-ford) - finding the shortest path to all graph vertices\n  * `A` [Floyd-Warshall Algorithm](src/algorithms/graph/floyd-warshall) - find the shortest paths between all pairs of vertices\n  * `A` [Regular Expression Matching](src/algorithms/string/regular-expression-matching)\n* **Backtracking** - similarly to brute force, try to generate all possible solutions, but each time you generate next solution you test\nif it satisfies all conditions, and only then continue generating subsequent solutions. Otherwise, backtrack, and go on a\ndifferent path of finding a solution. Normally the DFS traversal of state-space is being used.\n  * `B` [Jump Game](src/algorithms/uncategorized/jump-game)\n  * `B` [Unique Paths](src/algorithms/uncategorized/unique-paths)\n  * `B` [Power Set](src/algorithms/sets/power-set) - all subsets of a set\n  * `A` [Hamiltonian Cycle](src/algorithms/graph/hamiltonian-cycle) - Visit every vertex exactly once\n  * `A` [N-Queens Problem](src/algorithms/uncategorized/n-queens)\n  * `A` [Knight's Tour](src/algorithms/uncategorized/knight-tour)\n  * `A` [Combination Sum](src/algorithms/sets/combination-sum) - find all combinations that form specific sum\n* **Branch & Bound** - remember the lowest-cost solution found at each stage of the backtracking\nsearch, and use the cost of the lowest-cost solution found so far as a lower bound on the cost of\na least-cost solution to the problem, in order to discard partial solutions with costs larger than the\nlowest-cost solution found so far. Normally BFS traversal in combination with DFS traversal of state-space\ntree is being used.\n\n## How to use this repository\n\n**Install all dependencies**\n\n```\nnpm install\n```\n\n**Run ESLint**\n\nYou may want to run it to check code quality.\n\n```\nnpm run lint\n```\n\n**Run all tests**\n\n```\nnpm test\n```\n\n**Run tests by name**\n\n```\nnpm test -- 'LinkedList'\n```\n\n**Troubleshooting**\n\nIn case if linting or testing is failing try to delete the `node_modules` folder and re-install npm packages:\n\n```\nrm -rf ./node_modules\nnpm i\n```\n\n**Playground**\n\nYou may play with data-structures and algorithms in `./src/playground/playground.js` file and write\ntests for it in `./src/playground/__test__/playground.test.js`.\n\nThen just simply run the following command to test if your playground code works as expected:\n\n```\nnpm test -- 'playground'\n```\n\n## Useful Information\n\n### References\n\n[▶ Data Structures and Algorithms on YouTube](https://www.youtube.com/playlist?list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\n\n### Big O Notation\n\n*Big O notation* is used to classify algorithms according to how their running time or space requirements grow as the input size grows.\nOn the chart below you may find most common orders of growth of algorithms specified in Big O notation.\n\n![Big O graphs](./assets/big-o-graph.png)\n\nSource: [Big O Cheat Sheet](http://bigocheatsheet.com/).\n\nBelow is the list of some of the most used Big O notations and their performance comparisons against different sizes of the input data.\n\n| Big O Notation | Computations for 10 elements | Computations for 100 elements | Computations for 1000 elements  |\n| -------------- | ---------------------------- | ----------------------------- | ------------------------------- |\n| **O(1)**       | 1                            | 1                             | 1                               |\n| **O(log N)**   | 3                            | 6                             | 9                               |\n| **O(N)**       | 10                           | 100                           | 1000                            |\n| **O(N log N)** | 30                           | 600                           | 9000                            |\n| **O(N^2)**     | 100                          | 10000                         | 1000000                         |\n| **O(2^N)**     | 1024                         | 1.26e+29                      | 1.07e+301                       |\n| **O(N!)**      | 3628800                      | 9.3e+157                      | 4.02e+2567                      |\n\n### Data Structure Operations Complexity\n\n| Data Structure          | Access    | Search    | Insertion | Deletion  | Comments  |\n| ----------------------- | :-------: | :-------: | :-------: | :-------: | :-------- |\n| **Array**               | 1         | n         | n         | n         |           |\n| **Stack**               | n         | n         | 1         | 1         |           |\n| **Queue**               | n         | n         | 1         | 1         |           |\n| **Linked List**         | n         | n         | 1         | n         |           |\n| **Hash Table**          | -         | n         | n         | n         | In case of perfect hash function costs would be O(1) |\n| **Binary Search Tree**  | n         | n         | n         | n         | In case of balanced tree costs would be O(log(n)) |\n| **B-Tree**              | log(n)    | log(n)    | log(n)    | log(n)    |           |\n| **Red-Black Tree**      | log(n)    | log(n)    | log(n)    | log(n)    |           |\n| **AVL Tree**            | log(n)    | log(n)    | log(n)    | log(n)    |           |\n| **Bloom Filter**        | -         | 1         | 1         | -         | False positives are possible while searching |\n\n### Array Sorting Algorithms Complexity\n\n| Name                  | Best            | Average             | Worst               | Memory    | Stable    | Comments  |\n| --------------------- | :-------------: | :-----------------: | :-----------------: | :-------: | :-------: | :-------- |\n| **Bubble sort**       | n               | n<sup>2</sup>       | n<sup>2</sup>       | 1         | Yes       |           |\n| **Insertion sort**    | n               | n<sup>2</sup>       | n<sup>2</sup>       | 1         | Yes       |           |\n| **Selection sort**    | n<sup>2</sup>   | n<sup>2</sup>       | n<sup>2</sup>       | 1         | No        |           |\n| **Heap sort**         | n&nbsp;log(n)   | n&nbsp;log(n)       | n&nbsp;log(n)       | 1         | No        |           |\n| **Merge sort**        | n&nbsp;log(n)   | n&nbsp;log(n)       | n&nbsp;log(n)       | n         | Yes       |           |\n| **Quick sort**        | n&nbsp;log(n)   | n&nbsp;log(n)       | n<sup>2</sup>       | log(n)    | No        | Quicksort is usually done in-place with O(log(n)) stack space |\n| **Shell sort**        | n&nbsp;log(n)   | depends on gap sequence   | n&nbsp;(log(n))<sup>2</sup>  | 1         | No         |           |\n| **Counting sort**     | n + r           | n + r               | n + r               | n + r     | Yes       | r - biggest number in array |\n| **Radix sort**        | n * k           | n * k               | n * k               | n + k     | Yes       | k - length of longest key |\n\n## Project Backers\n\n> You may support this project via ❤️️ [GitHub](https://github.com/sponsors/trekhleb) or ❤️️ [Patreon](https://www.patreon.com/trekhleb).\n\n[Folks who are backing this project](https://github.com/trekhleb/javascript-algorithms/blob/master/BACKERS.md) `∑ = 0`\n\n> ℹ️ A few more [projects](https://trekhleb.dev/projects/) and [articles](https://trekhleb.dev/blog/) about JavaScript and algorithms on [trekhleb.dev](https://trekhleb.dev)\n","filetype":".md","index":0},{"title":"Algorithms","category":null,"id":"algorithms","index":1},{"title":"Cryptography","category":"algorithms","id":"cryptography","index":2},{"title":"Caesar-cipher","category":"cryptography","id":"caesar-cipher","algorithm":"# Caesar Cipher Algorithm\n\nIn cryptography, a **Caesar cipher**, also known as **Caesar's cipher**, the **shift cipher**, **Caesar's code** or **Caesar shift**, is one of the simplest and most widely known encryption techniques. It is a type of substitution cipher in which each letter in the plaintext is replaced by a letter some fixed number of positions down the alphabet. For example, with a left shift of `3`, `D` would be replaced by `A`, `E` would become `B`, and so on. The method is named after Julius Caesar, who used it in his private correspondence.\n\n![Caesar Cipher Algorithm](https://upload.wikimedia.org/wikipedia/commons/4/4a/Caesar_cipher_left_shift_of_3.svg)\n\n## Example\n\nThe transformation can be represented by aligning two alphabets; the cipher alphabet is the plain alphabet rotated left or right by some number of positions. For instance, here is a Caesar cipher using a left rotation of three places, equivalent to a right shift of 23 (the shift parameter is used as the key):\n\n```text\nPlain:    ABCDEFGHIJKLMNOPQRSTUVWXYZ\nCipher:   XYZABCDEFGHIJKLMNOPQRSTUVW\n```\n\nWhen encrypting, a person looks up each letter of the message in the \"plain\" line and writes down the corresponding letter in the \"cipher\" line.\n\n```text\nPlaintext:  THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\nCiphertext: QEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD\n```\n\n## Complexity\n\n- Time: `O(|n|)`\n- Space: `O(|n|)`\n\n## References\n\n- [Caesar cipher on Wikipedia](https://en.wikipedia.org/wiki/Caesar_cipher)\n","filetype":".md","index":3},{"title":"Caesar Cipher","category":"caesar-cipher","id":"caesarCipher_caesar-cipher","algorithm":"// Create alphabet array: ['a', 'b', 'c', ..., 'z'].\nconst englishAlphabet = 'abcdefghijklmnopqrstuvwxyz'.split('');\n\n/**\n * Generates a cipher map out of the alphabet.\n * Example with a shift 3: {'a': 'd', 'b': 'e', 'c': 'f', ...}\n *\n * @param {string[]} alphabet - i.e. ['a', 'b', 'c', ... , 'z']\n * @param {number} shift - i.e. 3\n * @return {Object} - i.e. {'a': 'd', 'b': 'e', 'c': 'f', ..., 'z': 'c'}\n */\nconst getCipherMap = (alphabet, shift) => {\n  return alphabet\n    .reduce((charsMap, currentChar, charIndex) => {\n      const charsMapClone = { ...charsMap };\n      // Making the shift to be cyclic (i.e. with a shift of 1 - 'z' would be mapped to 'a').\n      let encryptedCharIndex = (charIndex + shift) % alphabet.length;\n      // Support negative shifts for creating a map for decryption\n      // (i.e. with shift -1 - 'a' would be mapped to 'z').\n      if (encryptedCharIndex < 0) {\n        encryptedCharIndex += alphabet.length;\n      }\n      charsMapClone[currentChar] = alphabet[encryptedCharIndex];\n      return charsMapClone;\n    }, {});\n};\n\n/**\n * @param {string} str\n * @param {number} shift\n * @param {string[]} alphabet\n * @return {string}\n */\nexport const caesarCipherEncrypt = (str, shift, alphabet = englishAlphabet) => {\n  // Create a cipher map:\n  const cipherMap = getCipherMap(alphabet, shift);\n  return str\n    .toLowerCase()\n    .split('')\n    .map((char) => cipherMap[char] || char)\n    .join('');\n};\n\n/**\n * @param {string} str\n * @param {number} shift\n * @param {string[]} alphabet\n * @return {string}\n */\nexport const caesarCipherDecrypt = (str, shift, alphabet = englishAlphabet) => {\n  // Create a cipher map:\n  const cipherMap = getCipherMap(alphabet, -shift);\n  return str\n    .toLowerCase()\n    .split('')\n    .map((char) => cipherMap[char] || char)\n    .join('');\n};\n","filetype":".js","index":4},{"title":"Hill-cipher","category":"cryptography","id":"hill-cipher","algorithm":"# Hill Cipher\n\nThe **Hill cipher** is a [polygraphic substitution](https://en.wikipedia.org/wiki/Polygraphic_substitution) cipher based on linear algebra.\n\nEach letter is represented by a number [modulo](https://en.wikipedia.org/wiki/Modular_arithmetic) `26`. Though this is not an essential feature of the cipher, this simple scheme is often used:\n\n| **Letter** | A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z |\n| ------ | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| **Number** | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 |\n\n## Encryption\n\nTo encrypt a message, each block of `n` letters (considered as an `n`-component vector) is multiplied by an invertible `n × n` matrix, against modulus `26`.\n\nThe matrix used for encryption is the _cipher key_, and it should be chosen randomly from the set of invertible `n × n` matrices (modulo `26`). The cipher can, of course, be adapted to an alphabet with any number of letters; all arithmetic just needs to be done modulo the number of letters instead of modulo `26`.\n\nConsider the message `ACT`, and the key below (or `GYB/NQK/URP` in letters):\n\n```\n| 6   24   1  |\n| 13  16   10 |\n| 20  17   15 |\n```\n\nSince `A` is`0`, `C` is `2` and `T` is `19`, the message is the vector:\n\n```\n|  0  |\n|  2  |\n|  19 |\n```\n\nThus, the enciphered vector is given by:\n\n```\n| 6   24   1  |  |  0  |   |  67  |   |  15 |\n| 13  16   10 |  |  2  | = |  222 | ≡ |  14 | (mod 26)\n| 20  17   15 |  |  19 |   |  319 |   |  7  |\n```\n\nwhich corresponds to a ciphertext of `POH`.\n\nNow, suppose that our message is instead `CAT` (notice how we're using the same letters as in `ACT` here), or:\n\n```\n|  2  |\n|  0  |\n|  19 |\n```\n\nThis time, the enciphered vector is given by:\n\n```\n| 6   24   1  |  |  2  |   |  31  |   |  5  |\n| 13  16   10 |  |  0  | = |  216 | ≡ |  8  | (mod 26)\n| 20  17   15 |  |  19 |   |  325 |   |  13 |\n```\n\nwhich corresponds to a ciphertext of `FIN`. Every letter has changed.\n\n## Decryption\n\nTo decrypt the message, each block is multiplied by the inverse of the matrix used for encryption. We turn the ciphertext back into a vector, then simply multiply by the inverse matrix of the key matrix (`IFK/VIV/VMI` in letters). (See [matrix inversion](https://en.wikipedia.org/wiki/Matrix_inversion) for methods to calculate the inverse matrix.) We find that, modulo 26, the inverse of the matrix used in the previous example is:\n\n```\n                -1\n| 6   24   1  |                | 8   5    10 |\n| 13  16   10 |    (mod 26) ≡  | 21  8    21 |\n| 20  17   15 |                | 21  12   8  |\n```\n\nTaking the previous example ciphertext of `POH`, we get:\n\n```\n| 8   5    10 |  |  15 |   |  260 |   |  0  |\n| 21  8    21 |  |  14 | = |  574 | ≡ |  2  | (mod 26)\n| 21  12   8  |  |  7  |   |  539 |   |  19 |\n```\n\nwhich gets us back to `ACT`, as expected.\n\n## Defining the encrypting matrix\n\nTwo complications exist in picking the encrypting matrix:\n\n1. Not all matrices have an inverse. The matrix will have an inverse if and only if its [determinant](https://en.wikipedia.org/wiki/Determinant) is not zero.\n2. The determinant of the encrypting matrix must not have any common factors with the modular base.\n\nThus, if we work modulo `26` as above, the determinant must be nonzero, and must not be divisible by `2` or `13`. If the determinant is `0`, or has common factors with the modular base, then the matrix cannot be used in the Hill cipher, and another matrix must be chosen (otherwise it will not be possible to decrypt). Fortunately, matrices which satisfy the conditions to be used in the Hill cipher are fairly common.\n\n## References\n\n- [Hill cipher on Wikipedia](https://en.wikipedia.org/wiki/Hill_cipher)\n- [Matrix inversion on MathIsFun](https://www.mathsisfun.com/algebra/matrix-inverse.html)\n- [GeeksForGeeks](https://www.geeksforgeeks.org/hill-cipher/)\n\n","filetype":".md","index":5},{"title":"Hill Cipher","category":"hill-cipher","id":"hillCipher_hill-cipher","algorithm":"import * as mtrx from '../../math/matrix/Matrix';\n\n// The code of an 'A' character (equals to 65).\nconst alphabetCodeShift = 'A'.codePointAt(0);\nconst englishAlphabetSize = 26;\n\n/**\n * Generates key matrix from given keyString.\n *\n * @param {string} keyString - a string to build a key matrix (must be of matrixSize^2 length).\n * @return {number[][]} keyMatrix\n */\nconst generateKeyMatrix = (keyString) => {\n  const matrixSize = Math.sqrt(keyString.length);\n  if (!Number.isInteger(matrixSize)) {\n    throw new Error(\n      'Invalid key string length. The square root of the key string must be an integer',\n    );\n  }\n  let keyStringIndex = 0;\n  return mtrx.generate(\n    [matrixSize, matrixSize],\n    // Callback to get a value of each matrix cell.\n    // The order the matrix is being filled in is from left to right, from top to bottom.\n    () => {\n      // A → 0, B → 1, ..., a → 32, b → 33, ...\n      const charCodeShifted = (keyString.codePointAt(keyStringIndex)) % alphabetCodeShift;\n      keyStringIndex += 1;\n      return charCodeShifted;\n    },\n  );\n};\n\n/**\n * Generates a message vector from a given message.\n *\n * @param {string} message - the message to encrypt.\n * @return {number[][]} messageVector\n */\nconst generateMessageVector = (message) => {\n  return mtrx.generate(\n    [message.length, 1],\n    // Callback to get a value of each matrix cell.\n    // The order the matrix is being filled in is from left to right, from top to bottom.\n    (cellIndices) => {\n      const rowIndex = cellIndices[0];\n      return message.codePointAt(rowIndex) % alphabetCodeShift;\n    },\n  );\n};\n\n/**\n * Encrypts the given message using Hill Cipher.\n *\n * @param {string} message plaintext\n * @param {string} keyString\n * @return {string} cipherString\n */\nexport function hillCipherEncrypt(message, keyString) {\n  // The keyString and message can only contain letters.\n  const onlyLettersRegExp = /^[a-zA-Z]+$/;\n  if (!onlyLettersRegExp.test(message) || !onlyLettersRegExp.test(keyString)) {\n    throw new Error('The message and key string can only contain letters');\n  }\n\n  const keyMatrix = generateKeyMatrix(keyString);\n  const messageVector = generateMessageVector(message);\n\n  // keyString.length must equal to square of message.length\n  if (keyMatrix.length !== message.length) {\n    throw new Error('Invalid key string length. The key length must be a square of message length');\n  }\n\n  const cipherVector = mtrx.dot(keyMatrix, messageVector);\n  let cipherString = '';\n  for (let row = 0; row < cipherVector.length; row += 1) {\n    const item = cipherVector[row];\n    cipherString += String.fromCharCode((item % englishAlphabetSize) + alphabetCodeShift);\n  }\n\n  return cipherString;\n}\n\n// @TODO: Implement this method.\nexport const hillCipherDecrypt = () => {\n  throw new Error('This method is not implemented yet');\n};\n","filetype":".js","index":6},{"title":"Polynomial-hash","category":"cryptography","id":"polynomial-hash","algorithm":"# Polynomial Rolling Hash\n\n## Hash Function\n\n**Hash functions** are used to map large data sets of elements of an arbitrary \nlength (*the keys*) to smaller data sets of elements of a fixed length\n(*the fingerprints*).\n\nThe basic application of hashing is efficient testing of equality of keys by\ncomparing their fingerprints.\n\nA *collision* happens when two different keys have the same fingerprint. The way \nin which collisions are handled is crucial in most applications of hashing. \nHashing is particularly useful in construction of efficient practical algorithms.\n\n## Rolling Hash\n\nA **rolling hash** (also known as recursive hashing or rolling checksum) is a hash\nfunction where the input is hashed in a window that moves through the input.\n\nA few hash functions allow a rolling hash to be computed very quickly — the new \nhash value is rapidly calculated given only the following data:\n\n- old hash value,\n- the old value removed from the window,\n- and the new value added to the window.\n\n## Polynomial String Hashing\n\nAn ideal hash function for strings should obviously depend both on the *multiset* of\nthe symbols present in the key and on the *order* of the symbols. The most common \nfamily of such hash functions treats the symbols of a string as coefficients of \na *polynomial* with an integer variable `p` and computes its value modulo an \ninteger constant `M`:\n\nThe *Rabin–Karp string search algorithm* is often explained using a very simple\nrolling hash function that only uses multiplications and \nadditions - **polynomial rolling hash**:\n\n> H(s<sub>0</sub>, s<sub>1</sub>, ..., s<sub>k</sub>) = s<sub>0</sub> * p<sup>k-1</sup> + s<sub>1</sub> * p<sup>k-2</sup> + ... + s<sub>k</sub> * p<sup>0</sup>\n\nwhere `p` is a constant, and *(s<sub>1</sub>, ... , s<sub>k</sub>)* are the input\ncharacters.\n\nFor example we can convert short strings to key numbers by multiplying digit codes by \npowers of a constant. The three letter word `ace` could turn into a number \nby calculating:\n\n> key = 1 * 26<sup>2</sup> + 3 * 26<sup>1</sup> + 5 * 26<sup>0</sup>\n\nIn order to avoid manipulating huge `H` values, all math is done modulo `M`.\n\n> H(s<sub>0</sub>, s<sub>1</sub>, ..., s<sub>k</sub>) = (s<sub>0</sub> * p<sup>k-1</sup> + s<sub>1</sub> * p<sup>k-2</sup> + ... + s<sub>k</sub> * p<sup>0</sup>) mod M\n\nA careful choice of the parameters `M`, `p` is important to obtain “good”\nproperties of the hash function, i.e., low collision rate.\n\nThis approach has the desirable attribute of involving all the characters in the \ninput string. The calculated key value can then be hashed into an array index in\nthe usual way:\n\n```javascript\nfunction hash(key, arraySize) {\n  const base = 13;\n\n  let hash = 0;\n  for (let charIndex = 0; charIndex < key.length; charIndex += 1) {\n    const charCode = key.charCodeAt(charIndex);\n    hash += charCode * (base ** (key.length - charIndex - 1));\n  }\n\n  return hash % arraySize;\n}\n```\n\nThe `hash()` method is not as efficient as it might be. Other than the \ncharacter conversion, there are two multiplications and an addition inside \nthe loop. We can eliminate one multiplication by using **Horner's method*:\n \n> a<sub>4</sub> * x<sup>4</sup> + a<sub>3</sub> * x<sup>3</sup> + a<sub>2</sub> * x<sup>2</sup> + a<sub>1</sub> * x<sup>1</sup> + a<sub>0</sub> = (((a<sub>4</sub> * x + a<sub>3</sub>) * x + a<sub>2</sub>) * x + a<sub>1</sub>) * x + a<sub>0</sub>\n\nIn other words:\n\n> H<sub>i</sub> = (P * H<sub>i-1</sub> + S<sub>i</sub>) mod M\n\nThe `hash()` cannot handle long strings because the hashVal exceeds the size of \nint. Notice that the key always ends up being less than the array size. \nIn Horner's method we can apply the modulo (%) operator at each step in the \ncalculation. This gives the same result as applying the modulo operator once at \nthe end, but avoids the overflow.\n\n```javascript\nfunction hash(key, arraySize) {\n  const base = 13;\n\n  let hash = 0;\n  for (let charIndex = 0; charIndex < key.length; charIndex += 1) {\n    const charCode = key.charCodeAt(charIndex);\n    hash = (hash * base + charCode) % arraySize;\n  }\n\n  return hash;\n}\n```\n\nPolynomial hashing has a rolling property: the fingerprints can be updated \nefficiently when symbols are added or removed at the ends of the string\n(provided that an array of powers of p modulo M of sufficient length is stored).\nThe popular Rabin–Karp pattern matching algorithm is based on this property\n\n## References\n\n- [Where to Use Polynomial String Hashing](https://www.mii.lt/olympiads_in_informatics/pdf/INFOL119.pdf)\n- [Hashing on uTexas](https://www.cs.utexas.edu/~mitra/csSpring2017/cs313/lectures/hash.html)\n- [Hash Function on Wikipedia](https://en.wikipedia.org/wiki/Hash_function)\n- [Rolling Hash on Wikipedia](https://en.wikipedia.org/wiki/Rolling_hash)\n","filetype":".md","index":7},{"title":"Polynomial Hash","category":"polynomial-hash","id":"PolynomialHash_polynomial-hash","algorithm":"const DEFAULT_BASE = 37;\nconst DEFAULT_MODULUS = 101;\n\nexport default class PolynomialHash {\n  /**\n   * @param {number} [base] - Base number that is used to create the polynomial.\n   * @param {number} [modulus] - Modulus number that keeps the hash from overflowing.\n   */\n  constructor({ base = DEFAULT_BASE, modulus = DEFAULT_MODULUS } = {}) {\n    this.base = base;\n    this.modulus = modulus;\n  }\n\n  /**\n   * Function that creates hash representation of the word.\n   *\n   * Time complexity: O(word.length).\n   *\n   * @param {string} word - String that needs to be hashed.\n   * @return {number}\n   */\n  hash(word) {\n    const charCodes = Array.from(word).map((char) => this.charToNumber(char));\n\n    let hash = 0;\n    for (let charIndex = 0; charIndex < charCodes.length; charIndex += 1) {\n      hash *= this.base;\n      hash += charCodes[charIndex];\n      hash %= this.modulus;\n    }\n\n    return hash;\n  }\n\n  /**\n   * Function that creates hash representation of the word\n   * based on previous word (shifted by one character left) hash value.\n   *\n   * Recalculates the hash representation of a word so that it isn't\n   * necessary to traverse the whole word again.\n   *\n   * Time complexity: O(1).\n   *\n   * @param {number} prevHash\n   * @param {string} prevWord\n   * @param {string} newWord\n   * @return {number}\n   */\n  roll(prevHash, prevWord, newWord) {\n    let hash = prevHash;\n\n    const prevValue = this.charToNumber(prevWord[0]);\n    const newValue = this.charToNumber(newWord[newWord.length - 1]);\n\n    let prevValueMultiplier = 1;\n    for (let i = 1; i < prevWord.length; i += 1) {\n      prevValueMultiplier *= this.base;\n      prevValueMultiplier %= this.modulus;\n    }\n\n    hash += this.modulus;\n    hash -= (prevValue * prevValueMultiplier) % this.modulus;\n\n    hash *= this.base;\n    hash += newValue;\n    hash %= this.modulus;\n\n    return hash;\n  }\n\n  /**\n   * Converts char to number.\n   *\n   * @param {string} char\n   * @return {number}\n   */\n  charToNumber(char) {\n    let charCode = char.codePointAt(0);\n\n    // Check if character has surrogate pair.\n    const surrogate = char.codePointAt(1);\n    if (surrogate !== undefined) {\n      const surrogateShift = 2 ** 16;\n      charCode += surrogate * surrogateShift;\n    }\n\n    return charCode;\n  }\n}\n","filetype":".js","index":8},{"title":"Simple Polynomial Hash","category":"polynomial-hash","id":"SimplePolynomialHash_polynomial-hash","algorithm":"const DEFAULT_BASE = 17;\n\nexport default class SimplePolynomialHash {\n  /**\n   * @param {number} [base] - Base number that is used to create the polynomial.\n   */\n  constructor(base = DEFAULT_BASE) {\n    this.base = base;\n  }\n\n  /**\n   * Function that creates hash representation of the word.\n   *\n   * Time complexity: O(word.length).\n   *\n   * @assumption: This version of the function  doesn't use modulo operator.\n   * Thus it may produce number overflows by generating numbers that are\n   * bigger than Number.MAX_SAFE_INTEGER. This function is mentioned here\n   * for simplicity and LEARNING reasons.\n   *\n   * @param {string} word - String that needs to be hashed.\n   * @return {number}\n   */\n  hash(word) {\n    let hash = 0;\n    for (let charIndex = 0; charIndex < word.length; charIndex += 1) {\n      hash += word.charCodeAt(charIndex) * (this.base ** charIndex);\n    }\n\n    return hash;\n  }\n\n  /**\n   * Function that creates hash representation of the word\n   * based on previous word (shifted by one character left) hash value.\n   *\n   * Recalculates the hash representation of a word so that it isn't\n   * necessary to traverse the whole word again.\n   *\n   * Time complexity: O(1).\n   *\n   * @assumption: This function doesn't use modulo operator and thus is not safe since\n   * it may deal with numbers that are bigger than Number.MAX_SAFE_INTEGER. This\n   * function is mentioned here for simplicity and LEARNING reasons.\n   *\n   * @param {number} prevHash\n   * @param {string} prevWord\n   * @param {string} newWord\n   * @return {number}\n   */\n  roll(prevHash, prevWord, newWord) {\n    let hash = prevHash;\n\n    const prevValue = prevWord.charCodeAt(0);\n    const newValue = newWord.charCodeAt(newWord.length - 1);\n\n    hash -= prevValue;\n    hash /= this.base;\n    hash += newValue * (this.base ** (newWord.length - 1));\n\n    return hash;\n  }\n}\n","filetype":".js","index":9},{"title":"Rail-fence-cipher","category":"cryptography","id":"rail-fence-cipher","algorithm":"# Rail Fence Cipher\n\nThe **rail fence cipher** (also called a **zigzag cipher**) is a [transposition cipher](https://en.wikipedia.org/wiki/Transposition_cipher) in which the message is split across a set of rails on a fence for encoding. The fence is populated with the message's characters, starting at the top left and adding a character on each position, traversing them diagonally to the bottom. Upon reaching the last rail, the direction should then turn diagonal and upwards up to the very first rail in a zig-zag motion. Rinse and repeat until the message is fully disposed across the fence. The encoded message is the result of concatenating the text in each rail, from top to bottom.\n\nFrom [wikipedia](https://en.wikipedia.org/wiki/Rail_fence_cipher), this is what the message `WE ARE DISCOVERED. FLEE AT ONCE` looks like on a `3`-rail fence:\n\n```\nW . . . E . . . C . . . R . . . L . . . T . . . E\n. E . R . D . S . O . E . E . F . E . A . O . C .\n. . A . . . I . . . V . . . D . . . E . . . N . .\n-------------------------------------------------\n             WECRLTEERDSOEEFEAOCAIVDEN\n```\n\nThe message can then be decoded by re-creating the encoded fence, with the same traversal pattern, except characters should only be added on one rail at a time. To illustrate that, a dash can be added on the rails that are not supposed to be populated yet. This is what the fence would look like after populating the first rail, the dashes represent positions that were visited but not populated.\n\n```\nW . . . E . . . C . . . R . . . L . . . T . . . E\n. - . - . - . - . - . - . - . - . - . - . - . - .\n. . - . . . - . . . - . . . - . . . - . . . - . .\n```\n\nIt's time to start populating the next rail once the number of visited fence positions is equal to the number of characters in the message.\n\n## References\n\n- [Rail Fence Cipher on Wikipedia](https://en.wikipedia.org/wiki/Rail_fence_cipher)\n- [Rail Fence Cipher Calculator](https://crypto.interactive-maths.com/rail-fence-cipher.html)\n","filetype":".md","index":10},{"title":"Rail Fence Cipher","category":"rail-fence-cipher","id":"railFenceCipher_rail-fence-cipher","algorithm":"/**\n * @typedef {string[]} Rail\n * @typedef {Rail[]} Fence\n * @typedef {number} Direction\n */\n\n/**\n * @constant DIRECTIONS\n * @type {object}\n * @property {Direction} UP\n * @property {Direction} DOWN\n */\nconst DIRECTIONS = { UP: -1, DOWN: 1 };\n\n/**\n * Builds a fence with a specific number of rows.\n *\n * @param {number} rowsNum\n * @returns {Fence}\n */\nconst buildFence = (rowsNum) => Array(rowsNum)\n  .fill(null)\n  .map(() => []);\n\n/**\n * Get next direction to move (based on the current one) while traversing the fence.\n *\n * @param {object} params\n * @param {number} params.railCount - Number of rows in the fence\n * @param {number} params.currentRail - Current row that we're visiting\n * @param {Direction} params.direction - Current direction\n * @returns {Direction} - The next direction to take\n */\nconst getNextDirection = ({ railCount, currentRail, direction }) => {\n  switch (currentRail) {\n    case 0:\n      // Go down if we're on top of the fence.\n      return DIRECTIONS.DOWN;\n    case railCount - 1:\n      // Go up if we're at the bottom of the fence.\n      return DIRECTIONS.UP;\n    default:\n      // Continue with the same direction if we're in the middle of the fence.\n      return direction;\n  }\n};\n\n/**\n * @param {number} targetRailIndex\n * @param {string} letter\n * @returns {Function}\n */\nconst addCharToRail = (targetRailIndex, letter) => {\n  /**\n   * Given a rail, adds a char to it if it matches a targetIndex.\n   *\n   * @param {Rail} rail\n   * @param {number} currentRail\n   * @returns {Rail}\n   */\n  function onEachRail(rail, currentRail) {\n    return currentRail === targetRailIndex\n      ? [...rail, letter]\n      : rail;\n  }\n  return onEachRail;\n};\n\n/**\n * Hangs the characters on the fence.\n *\n * @param {object} params\n * @param {Fence} params.fence\n * @param {number} params.currentRail\n * @param {Direction} params.direction\n * @param {string[]} params.chars\n * @returns {Fence}\n */\nconst fillEncodeFence = ({\n  fence,\n  currentRail,\n  direction,\n  chars,\n}) => {\n  if (chars.length === 0) {\n    // All chars have been placed on a fence.\n    return fence;\n  }\n\n  const railCount = fence.length;\n\n  // Getting the next character to place on a fence.\n  const [letter, ...nextChars] = chars;\n  const nextDirection = getNextDirection({\n    railCount,\n    currentRail,\n    direction,\n  });\n\n  return fillEncodeFence({\n    fence: fence.map(addCharToRail(currentRail, letter)),\n    currentRail: currentRail + nextDirection,\n    direction: nextDirection,\n    chars: nextChars,\n  });\n};\n\n/**\n * @param {object} params\n * @param {number} params.strLen\n * @param {string[]} params.chars\n * @param {Fence} params.fence\n * @param {number} params.targetRail\n * @param {Direction} params.direction\n * @param {number[]} params.coords\n * @returns {Fence}\n */\nconst fillDecodeFence = (params) => {\n  const {\n    strLen, chars, fence, targetRail, direction, coords,\n  } = params;\n\n  const railCount = fence.length;\n\n  if (chars.length === 0) {\n    return fence;\n  }\n\n  const [currentRail, currentColumn] = coords;\n  const shouldGoNextRail = currentColumn === strLen - 1;\n  const nextDirection = shouldGoNextRail\n    ? DIRECTIONS.DOWN\n    : getNextDirection(\n      { railCount, currentRail, direction },\n    );\n  const nextRail = shouldGoNextRail ? targetRail + 1 : targetRail;\n  const nextCoords = [\n    shouldGoNextRail ? 0 : currentRail + nextDirection,\n    shouldGoNextRail ? 0 : currentColumn + 1,\n  ];\n\n  const shouldAddChar = currentRail === targetRail;\n  const [currentChar, ...remainderChars] = chars;\n  const nextString = shouldAddChar ? remainderChars : chars;\n  const nextFence = shouldAddChar ? fence.map(addCharToRail(currentRail, currentChar)) : fence;\n\n  return fillDecodeFence({\n    strLen,\n    chars: nextString,\n    fence: nextFence,\n    targetRail: nextRail,\n    direction: nextDirection,\n    coords: nextCoords,\n  });\n};\n\n/**\n * @param {object} params\n * @param {number} params.strLen\n * @param {Fence} params.fence\n * @param {number} params.currentRail\n * @param {Direction} params.direction\n * @param {number[]} params.code\n * @returns {string}\n */\nconst decodeFence = (params) => {\n  const {\n    strLen,\n    fence,\n    currentRail,\n    direction,\n    code,\n  } = params;\n\n  if (code.length === strLen) {\n    return code.join('');\n  }\n\n  const railCount = fence.length;\n\n  const [currentChar, ...nextRail] = fence[currentRail];\n  const nextDirection = getNextDirection(\n    { railCount, currentRail, direction },\n  );\n\n  return decodeFence({\n    railCount,\n    strLen,\n    currentRail: currentRail + nextDirection,\n    direction: nextDirection,\n    code: [...code, currentChar],\n    fence: fence.map((rail, idx) => (idx === currentRail ? nextRail : rail)),\n  });\n};\n\n/**\n * Encodes the message using Rail Fence Cipher.\n *\n * @param {string} string - The string to be encoded\n * @param {number} railCount - The number of rails in a fence\n * @returns {string} - Encoded string\n */\nexport const encodeRailFenceCipher = (string, railCount) => {\n  const fence = buildFence(railCount);\n\n  const filledFence = fillEncodeFence({\n    fence,\n    currentRail: 0,\n    direction: DIRECTIONS.DOWN,\n    chars: string.split(''),\n  });\n\n  return filledFence.flat().join('');\n};\n\n/**\n * Decodes the message using Rail Fence Cipher.\n *\n * @param {string} string - Encoded string\n * @param {number} railCount - The number of rows in a fence\n * @returns {string} - Decoded string.\n */\nexport const decodeRailFenceCipher = (string, railCount) => {\n  const strLen = string.length;\n  const emptyFence = buildFence(railCount);\n  const filledFence = fillDecodeFence({\n    strLen,\n    chars: string.split(''),\n    fence: emptyFence,\n    targetRail: 0,\n    direction: DIRECTIONS.DOWN,\n    coords: [0, 0],\n  });\n\n  return decodeFence({\n    strLen,\n    fence: filledFence,\n    currentRail: 0,\n    direction: DIRECTIONS.DOWN,\n    code: [],\n  });\n};\n","filetype":".js","index":11},{"title":"Graph","category":"algorithms","id":"graph","index":12},{"title":"Articulation-points","category":"graph","id":"articulation-points","algorithm":"# Articulation Points (or Cut Vertices)\n\nA vertex in an undirected connected graph is an articulation point\n(or cut vertex) if removing it (and edges through it) disconnects \nthe graph. Articulation points represent vulnerabilities in a \nconnected network – single points whose failure would split the \nnetwork into 2 or more disconnected components. They are useful for \ndesigning reliable networks.\n\nFor a disconnected undirected graph, an articulation point is a \nvertex removing which increases number of connected components.\n\n![Articulation Points](https://www.geeksforgeeks.org/wp-content/uploads/ArticulationPoints.png)\n\n![Articulation Points](https://www.geeksforgeeks.org/wp-content/uploads/ArticulationPoints1.png)\n\n![Articulation Points](https://www.geeksforgeeks.org/wp-content/uploads/ArticulationPoints21.png)\n\n## References\n\n- [GeeksForGeeks](https://www.geeksforgeeks.org/articulation-points-or-cut-vertices-in-a-graph/)\n- [YouTube](https://www.youtube.com/watch?v=2kREIkF9UAs&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\n","filetype":".md","index":13},{"title":"Articulation Points","category":"articulation-points","id":"articulationPoints_articulation-points","algorithm":"import depthFirstSearch from '../depth-first-search/depthFirstSearch';\n\n/**\n * Helper class for visited vertex metadata.\n */\nclass VisitMetadata {\n  constructor({ discoveryTime, lowDiscoveryTime }) {\n    this.discoveryTime = discoveryTime;\n    this.lowDiscoveryTime = lowDiscoveryTime;\n    // We need this in order to check graph root node, whether it has two\n    // disconnected children or not.\n    this.independentChildrenCount = 0;\n  }\n}\n\n/**\n * Tarjan's algorithm for finding articulation points in graph.\n *\n * @param {Graph} graph\n * @return {Object}\n */\nexport default function articulationPoints(graph) {\n  // Set of vertices we've already visited during DFS.\n  const visitedSet = {};\n\n  // Set of articulation points.\n  const articulationPointsSet = {};\n\n  // Time needed to discover to the current vertex.\n  let discoveryTime = 0;\n\n  // Peek the start vertex for DFS traversal.\n  const startVertex = graph.getAllVertices()[0];\n\n  const dfsCallbacks = {\n    /**\n     * @param {GraphVertex} currentVertex\n     * @param {GraphVertex} previousVertex\n     */\n    enterVertex: ({ currentVertex, previousVertex }) => {\n      // Tick discovery time.\n      discoveryTime += 1;\n\n      // Put current vertex to visited set.\n      visitedSet[currentVertex.getKey()] = new VisitMetadata({\n        discoveryTime,\n        lowDiscoveryTime: discoveryTime,\n      });\n\n      if (previousVertex) {\n        // Update children counter for previous vertex.\n        visitedSet[previousVertex.getKey()].independentChildrenCount += 1;\n      }\n    },\n    /**\n     * @param {GraphVertex} currentVertex\n     * @param {GraphVertex} previousVertex\n     */\n    leaveVertex: ({ currentVertex, previousVertex }) => {\n      if (previousVertex === null) {\n        // Don't do anything for the root vertex if it is already current (not previous one)\n        return;\n      }\n\n      // Update the low time with the smallest time of adjacent vertices.\n      // Get minimum low discovery time from all neighbors.\n      /** @param {GraphVertex} neighbor */\n      visitedSet[currentVertex.getKey()].lowDiscoveryTime = currentVertex.getNeighbors()\n        .filter((earlyNeighbor) => earlyNeighbor.getKey() !== previousVertex.getKey())\n        /**\n         * @param {number} lowestDiscoveryTime\n         * @param {GraphVertex} neighbor\n         */\n        .reduce(\n          (lowestDiscoveryTime, neighbor) => {\n            const neighborLowTime = visitedSet[neighbor.getKey()].lowDiscoveryTime;\n            return neighborLowTime < lowestDiscoveryTime ? neighborLowTime : lowestDiscoveryTime;\n          },\n          visitedSet[currentVertex.getKey()].lowDiscoveryTime,\n        );\n\n      // Detect whether previous vertex is articulation point or not.\n      // To do so we need to check two [OR] conditions:\n      // 1. Is it a root vertex with at least two independent children.\n      // 2. If its visited time is <= low time of adjacent vertex.\n      if (previousVertex === startVertex) {\n        // Check that root vertex has at least two independent children.\n        if (visitedSet[previousVertex.getKey()].independentChildrenCount >= 2) {\n          articulationPointsSet[previousVertex.getKey()] = previousVertex;\n        }\n      } else {\n        // Get current vertex low discovery time.\n        const currentLowDiscoveryTime = visitedSet[currentVertex.getKey()].lowDiscoveryTime;\n\n        // Compare current vertex low discovery time with parent discovery time. Check if there\n        // are any short path (back edge) exists. If we can't get to current vertex other then\n        // via parent then the parent vertex is articulation point for current one.\n        const parentDiscoveryTime = visitedSet[previousVertex.getKey()].discoveryTime;\n        if (parentDiscoveryTime <= currentLowDiscoveryTime) {\n          articulationPointsSet[previousVertex.getKey()] = previousVertex;\n        }\n      }\n    },\n    allowTraversal: ({ nextVertex }) => {\n      return !visitedSet[nextVertex.getKey()];\n    },\n  };\n\n  // Do Depth First Search traversal over submitted graph.\n  depthFirstSearch(graph, startVertex, dfsCallbacks);\n\n  return articulationPointsSet;\n}\n","filetype":".js","index":14},{"title":"Bellman-ford","category":"graph","id":"bellman-ford","algorithm":"# Bellman–Ford Algorithm\n\nThe Bellman–Ford algorithm is an algorithm that computes shortest \npaths from a single source vertex to all of the other vertices \nin a weighted digraph. It is slower than Dijkstra's algorithm \nfor the same problem, but more versatile, as it is capable of \nhandling graphs in which some of the edge weights are negative \nnumbers.\n\n![Bellman-Ford](https://upload.wikimedia.org/wikipedia/commons/2/2e/Shortest_path_Dijkstra_vs_BellmanFord.gif)\n\n## Complexity\n\nWorst-case performance `O(|V||E|)`\nBest-case performance\t`O(|E|)`\nWorst-case space complexity `O(|V|)`\n\n## References\n\n- [Wikipedia](https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm)\n- [On YouTube by Michael Sambol](https://www.youtube.com/watch?v=obWXjtg0L64&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\n","filetype":".md","index":15},{"title":"Bellman Ford","category":"bellman-ford","id":"bellmanFord_bellman-ford","algorithm":"/**\n * @param {Graph} graph\n * @param {GraphVertex} startVertex\n * @return {{distances, previousVertices}}\n */\nexport default function bellmanFord(graph, startVertex) {\n  const distances = {};\n  const previousVertices = {};\n\n  // Init all distances with infinity assuming that currently we can't reach\n  // any of the vertices except start one.\n  distances[startVertex.getKey()] = 0;\n  graph.getAllVertices().forEach((vertex) => {\n    previousVertices[vertex.getKey()] = null;\n    if (vertex.getKey() !== startVertex.getKey()) {\n      distances[vertex.getKey()] = Infinity;\n    }\n  });\n\n  // We need (|V| - 1) iterations.\n  for (let iteration = 0; iteration < (graph.getAllVertices().length - 1); iteration += 1) {\n    // During each iteration go through all vertices.\n    Object.keys(distances).forEach((vertexKey) => {\n      const vertex = graph.getVertexByKey(vertexKey);\n\n      // Go through all vertex edges.\n      graph.getNeighbors(vertex).forEach((neighbor) => {\n        const edge = graph.findEdge(vertex, neighbor);\n        // Find out if the distance to the neighbor is shorter in this iteration\n        // then in previous one.\n        const distanceToVertex = distances[vertex.getKey()];\n        const distanceToNeighbor = distanceToVertex + edge.weight;\n        if (distanceToNeighbor < distances[neighbor.getKey()]) {\n          distances[neighbor.getKey()] = distanceToNeighbor;\n          previousVertices[neighbor.getKey()] = vertex;\n        }\n      });\n    });\n  }\n\n  return {\n    distances,\n    previousVertices,\n  };\n}\n","filetype":".js","index":16},{"title":"Breadth-first-search","category":"graph","id":"breadth-first-search","algorithm":"# Breadth-First Search (BFS)\n\nBreadth-first search (BFS) is an algorithm for traversing \nor searching tree or graph data structures. It starts at\nthe tree root (or some arbitrary node of a graph, sometimes \nreferred to as a 'search key') and explores the neighbor\nnodes first, before moving to the next level neighbors.\n\n![Algorithm Visualization](https://upload.wikimedia.org/wikipedia/commons/5/5d/Breadth-First-Search-Algorithm.gif)\n\n## References\n\n- [Wikipedia](https://en.wikipedia.org/wiki/Breadth-first_search)\n- [Tree Traversals (Inorder, Preorder and Postorder)](https://www.geeksforgeeks.org/tree-traversals-inorder-preorder-and-postorder/)\n- [BFS vs DFS](https://www.geeksforgeeks.org/bfs-vs-dfs-binary-tree/)\n- [BFS Visualization](https://www.cs.usfca.edu/~galles/visualization/BFS.html)\n","filetype":".md","index":17},{"title":"Breadth First Search","category":"breadth-first-search","id":"breadthFirstSearch_breadth-first-search","algorithm":"import Queue from '../../../data-structures/queue/Queue';\n\n/**\n * @typedef {Object} Callbacks\n *\n * @property {function(vertices: Object): boolean} [allowTraversal] -\n *   Determines whether DFS should traverse from the vertex to its neighbor\n *   (along the edge). By default prohibits visiting the same vertex again.\n *\n * @property {function(vertices: Object)} [enterVertex] - Called when BFS enters the vertex.\n *\n * @property {function(vertices: Object)} [leaveVertex] - Called when BFS leaves the vertex.\n */\n\n/**\n * @param {Callbacks} [callbacks]\n * @returns {Callbacks}\n */\nfunction initCallbacks(callbacks = {}) {\n  const initiatedCallback = callbacks;\n\n  const stubCallback = () => {};\n\n  const allowTraversalCallback = (\n    () => {\n      const seen = {};\n      return ({ nextVertex }) => {\n        if (!seen[nextVertex.getKey()]) {\n          seen[nextVertex.getKey()] = true;\n          return true;\n        }\n        return false;\n      };\n    }\n  )();\n\n  initiatedCallback.allowTraversal = callbacks.allowTraversal || allowTraversalCallback;\n  initiatedCallback.enterVertex = callbacks.enterVertex || stubCallback;\n  initiatedCallback.leaveVertex = callbacks.leaveVertex || stubCallback;\n\n  return initiatedCallback;\n}\n\n/**\n * @param {Graph} graph\n * @param {GraphVertex} startVertex\n * @param {Callbacks} [originalCallbacks]\n */\nexport default function breadthFirstSearch(graph, startVertex, originalCallbacks) {\n  const callbacks = initCallbacks(originalCallbacks);\n  const vertexQueue = new Queue();\n\n  // Do initial queue setup.\n  vertexQueue.enqueue(startVertex);\n\n  let previousVertex = null;\n\n  // Traverse all vertices from the queue.\n  while (!vertexQueue.isEmpty()) {\n    const currentVertex = vertexQueue.dequeue();\n    callbacks.enterVertex({ currentVertex, previousVertex });\n\n    // Add all neighbors to the queue for future traversals.\n    graph.getNeighbors(currentVertex).forEach((nextVertex) => {\n      if (callbacks.allowTraversal({ previousVertex, currentVertex, nextVertex })) {\n        vertexQueue.enqueue(nextVertex);\n      }\n    });\n\n    callbacks.leaveVertex({ currentVertex, previousVertex });\n\n    // Memorize current vertex before next loop.\n    previousVertex = currentVertex;\n  }\n}\n","filetype":".js","index":18},{"title":"Bridges","category":"graph","id":"bridges","algorithm":"# Bridges in Graph\n\nIn graph theory, a **bridge**, **isthmus**, **cut-edge**, or **cut arc** is an edge \nof a graph whose deletion increases its number of connected components. Equivalently, \nan edge is a bridge if and only if it is not contained in any cycle. A graph is said \nto be bridgeless or isthmus-free if it contains no bridges.\n\n![Bridges in graph](https://upload.wikimedia.org/wikipedia/commons/d/df/Graph_cut_edges.svg)\n\nA graph with 16 vertices and 6 bridges (highlighted in red)\n\n![Bridgeless](https://upload.wikimedia.org/wikipedia/commons/b/bf/Undirected.svg)\n\nAn undirected connected graph with no cut edges\n\n![Bridges in graph](https://www.geeksforgeeks.org/wp-content/uploads/Bridge1.png)\n\n![Bridges in graph](https://www.geeksforgeeks.org/wp-content/uploads/Bridge2.png)\n\n![Bridges in graph](https://www.geeksforgeeks.org/wp-content/uploads/Bridge3.png)\n\n## References\n\n- [GeeksForGeeks on YouTube](https://www.youtube.com/watch?v=thLQYBlz2DM&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\n- [Wikipedia](https://en.wikipedia.org/wiki/Bridge_%28graph_theory%29#Tarjan.27s_Bridge-finding_algorithm)\n- [GeeksForGeeks](https://www.geeksforgeeks.org/bridge-in-a-graph/)\n","filetype":".md","index":19},{"title":"Graph Bridges","category":"bridges","id":"graphBridges_bridges","algorithm":"import depthFirstSearch from '../depth-first-search/depthFirstSearch';\n\n/**\n * Helper class for visited vertex metadata.\n */\nclass VisitMetadata {\n  constructor({ discoveryTime, lowDiscoveryTime }) {\n    this.discoveryTime = discoveryTime;\n    this.lowDiscoveryTime = lowDiscoveryTime;\n  }\n}\n\n/**\n * @param {Graph} graph\n * @return {Object}\n */\nexport default function graphBridges(graph) {\n  // Set of vertices we've already visited during DFS.\n  const visitedSet = {};\n\n  // Set of bridges.\n  const bridges = {};\n\n  // Time needed to discover to the current vertex.\n  let discoveryTime = 0;\n\n  // Peek the start vertex for DFS traversal.\n  const startVertex = graph.getAllVertices()[0];\n\n  const dfsCallbacks = {\n    /**\n     * @param {GraphVertex} currentVertex\n     */\n    enterVertex: ({ currentVertex }) => {\n      // Tick discovery time.\n      discoveryTime += 1;\n\n      // Put current vertex to visited set.\n      visitedSet[currentVertex.getKey()] = new VisitMetadata({\n        discoveryTime,\n        lowDiscoveryTime: discoveryTime,\n      });\n    },\n    /**\n     * @param {GraphVertex} currentVertex\n     * @param {GraphVertex} previousVertex\n     */\n    leaveVertex: ({ currentVertex, previousVertex }) => {\n      if (previousVertex === null) {\n        // Don't do anything for the root vertex if it is already current (not previous one).\n        return;\n      }\n\n      // Check if current node is connected to any early node other then previous one.\n      visitedSet[currentVertex.getKey()].lowDiscoveryTime = currentVertex.getNeighbors()\n        .filter((earlyNeighbor) => earlyNeighbor.getKey() !== previousVertex.getKey())\n        .reduce(\n          /**\n           * @param {number} lowestDiscoveryTime\n           * @param {GraphVertex} neighbor\n           */\n          (lowestDiscoveryTime, neighbor) => {\n            const neighborLowTime = visitedSet[neighbor.getKey()].lowDiscoveryTime;\n            return neighborLowTime < lowestDiscoveryTime ? neighborLowTime : lowestDiscoveryTime;\n          },\n          visitedSet[currentVertex.getKey()].lowDiscoveryTime,\n        );\n\n      // Compare low discovery times. In case if current low discovery time is less than the one\n      // in previous vertex then update previous vertex low time.\n      const currentLowDiscoveryTime = visitedSet[currentVertex.getKey()].lowDiscoveryTime;\n      const previousLowDiscoveryTime = visitedSet[previousVertex.getKey()].lowDiscoveryTime;\n      if (currentLowDiscoveryTime < previousLowDiscoveryTime) {\n        visitedSet[previousVertex.getKey()].lowDiscoveryTime = currentLowDiscoveryTime;\n      }\n\n      // Compare current vertex low discovery time with parent discovery time. Check if there\n      // are any short path (back edge) exists. If we can't get to current vertex other then\n      // via parent then the parent vertex is articulation point for current one.\n      const parentDiscoveryTime = visitedSet[previousVertex.getKey()].discoveryTime;\n      if (parentDiscoveryTime < currentLowDiscoveryTime) {\n        const bridge = graph.findEdge(previousVertex, currentVertex);\n        bridges[bridge.getKey()] = bridge;\n      }\n    },\n    allowTraversal: ({ nextVertex }) => {\n      return !visitedSet[nextVertex.getKey()];\n    },\n  };\n\n  // Do Depth First Search traversal over submitted graph.\n  depthFirstSearch(graph, startVertex, dfsCallbacks);\n\n  return bridges;\n}\n","filetype":".js","index":20},{"title":"Depth-first-search","category":"graph","id":"depth-first-search","algorithm":"# Depth-First Search (DFS)\n\nDepth-first search (DFS) is an algorithm for traversing or \nsearching tree or graph data structures. One starts at \nthe root (selecting some arbitrary node as the root in \nthe case of a graph) and explores as far as possible \nalong each branch before backtracking.\n\n![Algorithm Visualization](https://upload.wikimedia.org/wikipedia/commons/7/7f/Depth-First-Search.gif)\n\n## References\n\n- [Wikipedia](https://en.wikipedia.org/wiki/Depth-first_search)\n- [Tree Traversals (Inorder, Preorder and Postorder)](https://www.geeksforgeeks.org/tree-traversals-inorder-preorder-and-postorder/)\n- [BFS vs DFS](https://www.geeksforgeeks.org/bfs-vs-dfs-binary-tree/)\n- [DFS Visualization](https://www.cs.usfca.edu/~galles/visualization/DFS.html)\n","filetype":".md","index":21},{"title":"Depth First Search","category":"depth-first-search","id":"depthFirstSearch_depth-first-search","algorithm":"/**\n * @typedef {Object} Callbacks\n *\n * @property {function(vertices: Object): boolean} [allowTraversal] -\n *  Determines whether DFS should traverse from the vertex to its neighbor\n *  (along the edge). By default prohibits visiting the same vertex again.\n *\n * @property {function(vertices: Object)} [enterVertex] - Called when DFS enters the vertex.\n *\n * @property {function(vertices: Object)} [leaveVertex] - Called when DFS leaves the vertex.\n */\n\n/**\n * @param {Callbacks} [callbacks]\n * @returns {Callbacks}\n */\nfunction initCallbacks(callbacks = {}) {\n  const initiatedCallback = callbacks;\n\n  const stubCallback = () => {};\n\n  const allowTraversalCallback = (\n    () => {\n      const seen = {};\n      return ({ nextVertex }) => {\n        if (!seen[nextVertex.getKey()]) {\n          seen[nextVertex.getKey()] = true;\n          return true;\n        }\n        return false;\n      };\n    }\n  )();\n\n  initiatedCallback.allowTraversal = callbacks.allowTraversal || allowTraversalCallback;\n  initiatedCallback.enterVertex = callbacks.enterVertex || stubCallback;\n  initiatedCallback.leaveVertex = callbacks.leaveVertex || stubCallback;\n\n  return initiatedCallback;\n}\n\n/**\n * @param {Graph} graph\n * @param {GraphVertex} currentVertex\n * @param {GraphVertex} previousVertex\n * @param {Callbacks} callbacks\n */\nfunction depthFirstSearchRecursive(graph, currentVertex, previousVertex, callbacks) {\n  callbacks.enterVertex({ currentVertex, previousVertex });\n\n  graph.getNeighbors(currentVertex).forEach((nextVertex) => {\n    if (callbacks.allowTraversal({ previousVertex, currentVertex, nextVertex })) {\n      depthFirstSearchRecursive(graph, nextVertex, currentVertex, callbacks);\n    }\n  });\n\n  callbacks.leaveVertex({ currentVertex, previousVertex });\n}\n\n/**\n * @param {Graph} graph\n * @param {GraphVertex} startVertex\n * @param {Callbacks} [callbacks]\n */\nexport default function depthFirstSearch(graph, startVertex, callbacks) {\n  const previousVertex = null;\n  depthFirstSearchRecursive(graph, startVertex, previousVertex, initCallbacks(callbacks));\n}\n","filetype":".js","index":22},{"title":"Detect-cycle","category":"graph","id":"detect-cycle","algorithm":"# Detect Cycle in Graphs\n\nIn graph theory, a **cycle** is a path of edges and vertices \nwherein a vertex is reachable from itself. There are several \ndifferent types of cycles, principally a **closed walk** and \na **simple cycle**.\n\n## Definitions\n\nA **closed walk** consists of a sequence of vertices starting \nand ending at the same vertex, with each two consecutive vertices\nin the sequence adjacent to each other in the graph. In a directed graph,\neach edge must be traversed by the walk consistently with its direction: \nthe edge must be oriented from the earlier of two consecutive vertices \nto the later of the two vertices in the sequence. \nThe choice of starting vertex is not important: traversing the same cyclic \nsequence of edges from different starting vertices produces the same closed walk.\n\nA **simple cycle may** be defined either as a closed walk with no repetitions of \nvertices and edges allowed, other than the repetition of the starting and ending \nvertex, or as the set of edges in such a walk. The two definitions are equivalent \nin directed graphs, where simple cycles are also called directed cycles: the cyclic \nsequence of vertices and edges in a walk is completely determined by the set of \nedges that it uses. In undirected graphs the set of edges of a cycle can be \ntraversed by a walk in either of two directions, giving two possible directed cycles \nfor every undirected cycle. A circuit can be a closed walk allowing repetitions of \nvertices but not edges; however, it can also be a simple cycle, so explicit \ndefinition is recommended when it is used.\n\n## Example\n\n![Cycles](https://upload.wikimedia.org/wikipedia/commons/e/e7/Graph_cycle.gif)\n\nA graph with edges colored to illustrate **path** `H-A-B` (green), closed path or \n**walk with a repeated vertex** `B-D-E-F-D-C-B` (blue) and a **cycle with no repeated edge** or \nvertex `H-D-G-H` (red)\n\n### Cycle in undirected graph\n\n![Undirected Cycle](https://www.geeksforgeeks.org/wp-content/uploads/cycleGraph.png)\n\n### Cycle in directed graph\n\n![Directed Cycle](https://cdncontribute.geeksforgeeks.org/wp-content/uploads/cycle.png)\n\n## References\n\nGeneral information:\n\n- [Wikipedia](https://en.wikipedia.org/wiki/Cycle_(graph_theory))\n\nCycles in undirected graphs:\n\n- [Detect Cycle in Undirected Graph on GeeksForGeeks](https://www.geeksforgeeks.org/detect-cycle-undirected-graph/)\n- [Detect Cycle in Undirected Graph Algorithm on YouTube](https://www.youtube.com/watch?v=n_t0a_8H8VY&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\n\nCycles in directed graphs:\n\n- [Detect Cycle in Directed Graph on GeeksForGeeks](https://www.geeksforgeeks.org/detect-cycle-in-a-graph/)\n- [Detect Cycle in Directed Graph Algorithm on YouTube](https://www.youtube.com/watch?v=rKQaZuoUR4M&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\n","filetype":".md","index":23},{"title":"Detect Directed Cycle","category":"detect-cycle","id":"detectDirectedCycle_detect-cycle","algorithm":"import depthFirstSearch from '../depth-first-search/depthFirstSearch';\n\n/**\n * Detect cycle in directed graph using Depth First Search.\n *\n * @param {Graph} graph\n */\nexport default function detectDirectedCycle(graph) {\n  let cycle = null;\n\n  // Will store parents (previous vertices) for all visited nodes.\n  // This will be needed in order to specify what path exactly is a cycle.\n  const dfsParentMap = {};\n\n  // White set (UNVISITED) contains all the vertices that haven't been visited at all.\n  const whiteSet = {};\n\n  // Gray set (VISITING) contains all the vertices that are being visited right now\n  // (in current path).\n  const graySet = {};\n\n  // Black set (VISITED) contains all the vertices that has been fully visited.\n  // Meaning that all children of the vertex has been visited.\n  const blackSet = {};\n\n  // If we encounter vertex in gray set it means that we've found a cycle.\n  // Because when vertex in gray set it means that its neighbors or its neighbors\n  // neighbors are still being explored.\n\n  // Init white set and add all vertices to it.\n  /** @param {GraphVertex} vertex */\n  graph.getAllVertices().forEach((vertex) => {\n    whiteSet[vertex.getKey()] = vertex;\n  });\n\n  // Describe BFS callbacks.\n  const callbacks = {\n    enterVertex: ({ currentVertex, previousVertex }) => {\n      if (graySet[currentVertex.getKey()]) {\n        // If current vertex already in grey set it means that cycle is detected.\n        // Let's detect cycle path.\n        cycle = {};\n\n        let currentCycleVertex = currentVertex;\n        let previousCycleVertex = previousVertex;\n\n        while (previousCycleVertex.getKey() !== currentVertex.getKey()) {\n          cycle[currentCycleVertex.getKey()] = previousCycleVertex;\n          currentCycleVertex = previousCycleVertex;\n          previousCycleVertex = dfsParentMap[previousCycleVertex.getKey()];\n        }\n\n        cycle[currentCycleVertex.getKey()] = previousCycleVertex;\n      } else {\n        // Otherwise let's add current vertex to gray set and remove it from white set.\n        graySet[currentVertex.getKey()] = currentVertex;\n        delete whiteSet[currentVertex.getKey()];\n\n        // Update DFS parents list.\n        dfsParentMap[currentVertex.getKey()] = previousVertex;\n      }\n    },\n    leaveVertex: ({ currentVertex }) => {\n      // If all node's children has been visited let's remove it from gray set\n      // and move it to the black set meaning that all its neighbors are visited.\n      blackSet[currentVertex.getKey()] = currentVertex;\n      delete graySet[currentVertex.getKey()];\n    },\n    allowTraversal: ({ nextVertex }) => {\n      // If cycle was detected we must forbid all further traversing since it will\n      // cause infinite traversal loop.\n      if (cycle) {\n        return false;\n      }\n\n      // Allow traversal only for the vertices that are not in black set\n      // since all black set vertices have been already visited.\n      return !blackSet[nextVertex.getKey()];\n    },\n  };\n\n  // Start exploring vertices.\n  while (Object.keys(whiteSet).length) {\n    // Pick fist vertex to start BFS from.\n    const firstWhiteKey = Object.keys(whiteSet)[0];\n    const startVertex = whiteSet[firstWhiteKey];\n\n    // Do Depth First Search.\n    depthFirstSearch(graph, startVertex, callbacks);\n  }\n\n  return cycle;\n}\n","filetype":".js","index":24},{"title":"Detect Undirected Cycle","category":"detect-cycle","id":"detectUndirectedCycle_detect-cycle","algorithm":"import depthFirstSearch from '../depth-first-search/depthFirstSearch';\n\n/**\n * Detect cycle in undirected graph using Depth First Search.\n *\n * @param {Graph} graph\n */\nexport default function detectUndirectedCycle(graph) {\n  let cycle = null;\n\n  // List of vertices that we have visited.\n  const visitedVertices = {};\n\n  // List of parents vertices for every visited vertex.\n  const parents = {};\n\n  // Callbacks for DFS traversing.\n  const callbacks = {\n    allowTraversal: ({ currentVertex, nextVertex }) => {\n      // Don't allow further traversal in case if cycle has been detected.\n      if (cycle) {\n        return false;\n      }\n\n      // Don't allow traversal from child back to its parent.\n      const currentVertexParent = parents[currentVertex.getKey()];\n      const currentVertexParentKey = currentVertexParent ? currentVertexParent.getKey() : null;\n\n      return currentVertexParentKey !== nextVertex.getKey();\n    },\n    enterVertex: ({ currentVertex, previousVertex }) => {\n      if (visitedVertices[currentVertex.getKey()]) {\n        // Compile cycle path based on parents of previous vertices.\n        cycle = {};\n\n        let currentCycleVertex = currentVertex;\n        let previousCycleVertex = previousVertex;\n\n        while (previousCycleVertex.getKey() !== currentVertex.getKey()) {\n          cycle[currentCycleVertex.getKey()] = previousCycleVertex;\n          currentCycleVertex = previousCycleVertex;\n          previousCycleVertex = parents[previousCycleVertex.getKey()];\n        }\n\n        cycle[currentCycleVertex.getKey()] = previousCycleVertex;\n      } else {\n        // Add next vertex to visited set.\n        visitedVertices[currentVertex.getKey()] = currentVertex;\n        parents[currentVertex.getKey()] = previousVertex;\n      }\n    },\n  };\n\n  // Start DFS traversing.\n  const startVertex = graph.getAllVertices()[0];\n  depthFirstSearch(graph, startVertex, callbacks);\n\n  return cycle;\n}\n","filetype":".js","index":25},{"title":"Detect Undirected Cycle Using Disjoint Set","category":"detect-cycle","id":"detectUndirectedCycleUsingDisjointSet_detect-cycle","algorithm":"import DisjointSet from '../../../data-structures/disjoint-set/DisjointSet';\n\n/**\n * Detect cycle in undirected graph using disjoint sets.\n *\n * @param {Graph} graph\n */\nexport default function detectUndirectedCycleUsingDisjointSet(graph) {\n  // Create initial singleton disjoint sets for each graph vertex.\n  /** @param {GraphVertex} graphVertex */\n  const keyExtractor = (graphVertex) => graphVertex.getKey();\n  const disjointSet = new DisjointSet(keyExtractor);\n  graph.getAllVertices().forEach((graphVertex) => disjointSet.makeSet(graphVertex));\n\n  // Go trough all graph edges one by one and check if edge vertices are from the\n  // different sets. In this case joint those sets together. Do this until you find\n  // an edge where to edge vertices are already in one set. This means that current\n  // edge will create a cycle.\n  let cycleFound = false;\n  /** @param {GraphEdge} graphEdge */\n  graph.getAllEdges().forEach((graphEdge) => {\n    if (disjointSet.inSameSet(graphEdge.startVertex, graphEdge.endVertex)) {\n      // Cycle found.\n      cycleFound = true;\n    } else {\n      disjointSet.union(graphEdge.startVertex, graphEdge.endVertex);\n    }\n  });\n\n  return cycleFound;\n}\n","filetype":".js","index":26},{"title":"Dijkstra","category":"graph","id":"dijkstra","algorithm":"# Dijkstra's Algorithm\n\nDijkstra's algorithm is an algorithm for finding the shortest \npaths between nodes in a graph, which may represent, for example, \nroad networks. \n\nThe algorithm exists in many variants; Dijkstra's original variant \nfound the shortest path between two nodes, but a more common \nvariant fixes a single node as the \"source\" node and finds \nshortest paths from the source to all other nodes in the graph, \nproducing a shortest-path tree.\n\n![Dijkstra](https://upload.wikimedia.org/wikipedia/commons/5/57/Dijkstra_Animation.gif)\n\nDijkstra's algorithm to find the shortest path between `a` and `b`.\nIt picks the unvisited vertex with the lowest distance, \ncalculates the distance through it to each unvisited neighbor, \nand updates the neighbor's distance if smaller. Mark visited\n(set to red) when done with neighbors.\n\n## References\n\n- [Wikipedia](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm)\n- [On YouTube by Nathaniel Fan](https://www.youtube.com/watch?v=gdmfOwyQlcI&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\n- [On YouTube by Tushar Roy](https://www.youtube.com/watch?v=lAXZGERcDf4&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\n","filetype":".md","index":27},{"title":"Dijkstra","category":"dijkstra","id":"dijkstra_dijkstra","algorithm":"import PriorityQueue from '../../../data-structures/priority-queue/PriorityQueue';\n\n/**\n * @typedef {Object} ShortestPaths\n * @property {Object} distances - shortest distances to all vertices\n * @property {Object} previousVertices - shortest paths to all vertices.\n */\n\n/**\n * Implementation of Dijkstra algorithm of finding the shortest paths to graph nodes.\n * @param {Graph} graph - graph we're going to traverse.\n * @param {GraphVertex} startVertex - traversal start vertex.\n * @return {ShortestPaths}\n */\nexport default function dijkstra(graph, startVertex) {\n  // Init helper variables that we will need for Dijkstra algorithm.\n  const distances = {};\n  const visitedVertices = {};\n  const previousVertices = {};\n  const queue = new PriorityQueue();\n\n  // Init all distances with infinity assuming that currently we can't reach\n  // any of the vertices except the start one.\n  graph.getAllVertices().forEach((vertex) => {\n    distances[vertex.getKey()] = Infinity;\n    previousVertices[vertex.getKey()] = null;\n  });\n\n  // We are already at the startVertex so the distance to it is zero.\n  distances[startVertex.getKey()] = 0;\n\n  // Init vertices queue.\n  queue.add(startVertex, distances[startVertex.getKey()]);\n\n  // Iterate over the priority queue of vertices until it is empty.\n  while (!queue.isEmpty()) {\n    // Fetch next closest vertex.\n    const currentVertex = queue.poll();\n\n    // Iterate over every unvisited neighbor of the current vertex.\n    currentVertex.getNeighbors().forEach((neighbor) => {\n      // Don't visit already visited vertices.\n      if (!visitedVertices[neighbor.getKey()]) {\n        // Update distances to every neighbor from current vertex.\n        const edge = graph.findEdge(currentVertex, neighbor);\n\n        const existingDistanceToNeighbor = distances[neighbor.getKey()];\n        const distanceToNeighborFromCurrent = distances[currentVertex.getKey()] + edge.weight;\n\n        // If we've found shorter path to the neighbor - update it.\n        if (distanceToNeighborFromCurrent < existingDistanceToNeighbor) {\n          distances[neighbor.getKey()] = distanceToNeighborFromCurrent;\n\n          // Change priority of the neighbor in a queue since it might have became closer.\n          if (queue.hasValue(neighbor)) {\n            queue.changePriority(neighbor, distances[neighbor.getKey()]);\n          }\n\n          // Remember previous closest vertex.\n          previousVertices[neighbor.getKey()] = currentVertex;\n        }\n\n        // Add neighbor to the queue for further visiting.\n        if (!queue.hasValue(neighbor)) {\n          queue.add(neighbor, distances[neighbor.getKey()]);\n        }\n      }\n    });\n\n    // Add current vertex to visited ones to avoid visiting it again later.\n    visitedVertices[currentVertex.getKey()] = currentVertex;\n  }\n\n  // Return the set of shortest distances to all vertices and the set of\n  // shortest paths to all vertices in a graph.\n  return {\n    distances,\n    previousVertices,\n  };\n}\n","filetype":".js","index":28},{"title":"Eulerian-path","category":"graph","id":"eulerian-path","algorithm":"# Eulerian Path\n\nIn graph theory, an **Eulerian trail** (or **Eulerian path**) is a \ntrail in a finite graph which visits every edge exactly once.\nSimilarly, an **Eulerian circuit** or **Eulerian cycle** is an \nEulerian trail which starts and ends on the same vertex.\n\nEuler proved that a necessary condition for the existence of Eulerian \ncircuits is that all vertices in the graph have an even degree, and \nstated that connected graphs with all vertices of even degree have \nan Eulerian circuit.\n\n![Eulerian Circuit](https://upload.wikimedia.org/wikipedia/commons/7/72/Labelled_Eulergraph.svg)\n\nEvery vertex of this graph has an even degree. Therefore, this is \nan Eulerian graph. Following the edges in alphabetical order gives \nan Eulerian circuit/cycle.\n\nFor the existence of Eulerian trails it is necessary that zero or \ntwo vertices have an odd degree; this means the Königsberg graph \nis not Eulerian. If there are no vertices of odd degree, \nall Eulerian trails are circuits. If there are exactly two vertices \nof odd degree, all Eulerian trails start at one of them and end at \nthe other. A graph that has an Eulerian trail but not an Eulerian \ncircuit is called semi-Eulerian.\n\n![Königsberg graph](https://upload.wikimedia.org/wikipedia/commons/9/96/K%C3%B6nigsberg_graph.svg)\n\nThe Königsberg Bridges multigraph. This multigraph is not Eulerian, \ntherefore, a solution does not exist.\n\n## References\n\n- [Wikipedia](https://en.wikipedia.org/wiki/Eulerian_path)\n- [YouTube](https://www.youtube.com/watch?v=vvP4Fg4r-Ns&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\n","filetype":".md","index":29},{"title":"Eulerian Path","category":"eulerian-path","id":"eulerianPath_eulerian-path","algorithm":"import graphBridges from '../bridges/graphBridges';\n\n/**\n * Fleury's algorithm of finding Eulerian Path (visit all graph edges exactly once).\n *\n * @param {Graph} graph\n * @return {GraphVertex[]}\n */\nexport default function eulerianPath(graph) {\n  const eulerianPathVertices = [];\n\n  // Set that contains all vertices with even rank (number of neighbors).\n  const evenRankVertices = {};\n\n  // Set that contains all vertices with odd rank (number of neighbors).\n  const oddRankVertices = {};\n\n  // Set of all not visited edges.\n  const notVisitedEdges = {};\n  graph.getAllEdges().forEach((vertex) => {\n    notVisitedEdges[vertex.getKey()] = vertex;\n  });\n\n  // Detect whether graph contains Eulerian Circuit or Eulerian Path or none of them.\n  /** @params {GraphVertex} vertex */\n  graph.getAllVertices().forEach((vertex) => {\n    if (vertex.getDegree() % 2) {\n      oddRankVertices[vertex.getKey()] = vertex;\n    } else {\n      evenRankVertices[vertex.getKey()] = vertex;\n    }\n  });\n\n  // Check whether we're dealing with Eulerian Circuit or Eulerian Path only.\n  // Graph would be an Eulerian Circuit in case if all its vertices has even degree.\n  // If not all vertices have even degree then graph must contain only two odd-degree\n  // vertices in order to have Euler Path.\n  const isCircuit = !Object.values(oddRankVertices).length;\n\n  if (!isCircuit && Object.values(oddRankVertices).length !== 2) {\n    throw new Error('Eulerian path must contain two odd-ranked vertices');\n  }\n\n  // Pick start vertex for traversal.\n  let startVertex = null;\n\n  if (isCircuit) {\n    // For Eulerian Circuit it doesn't matter from what vertex to start thus we'll just\n    // peek a first node.\n    const evenVertexKey = Object.keys(evenRankVertices)[0];\n    startVertex = evenRankVertices[evenVertexKey];\n  } else {\n    // For Eulerian Path we need to start from one of two odd-degree vertices.\n    const oddVertexKey = Object.keys(oddRankVertices)[0];\n    startVertex = oddRankVertices[oddVertexKey];\n  }\n\n  // Start traversing the graph.\n  let currentVertex = startVertex;\n  while (Object.values(notVisitedEdges).length) {\n    // Add current vertex to Eulerian path.\n    eulerianPathVertices.push(currentVertex);\n\n    // Detect all bridges in graph.\n    // We need to do it in order to not delete bridges if there are other edges\n    // exists for deletion.\n    const bridges = graphBridges(graph);\n\n    // Peek the next edge to delete from graph.\n    const currentEdges = currentVertex.getEdges();\n    /** @var {GraphEdge} edgeToDelete */\n    let edgeToDelete = null;\n    if (currentEdges.length === 1) {\n      // If there is only one edge left we need to peek it.\n      [edgeToDelete] = currentEdges;\n    } else {\n      // If there are many edges left then we need to peek any of those except bridges.\n      [edgeToDelete] = currentEdges.filter((edge) => !bridges[edge.getKey()]);\n    }\n\n    // Detect next current vertex.\n    if (currentVertex.getKey() === edgeToDelete.startVertex.getKey()) {\n      currentVertex = edgeToDelete.endVertex;\n    } else {\n      currentVertex = edgeToDelete.startVertex;\n    }\n\n    // Delete edge from not visited edges set.\n    delete notVisitedEdges[edgeToDelete.getKey()];\n\n    // If last edge were deleted then add finish vertex to Eulerian Path.\n    if (Object.values(notVisitedEdges).length === 0) {\n      eulerianPathVertices.push(currentVertex);\n    }\n\n    // Delete the edge from graph.\n    graph.deleteEdge(edgeToDelete);\n  }\n\n  return eulerianPathVertices;\n}\n","filetype":".js","index":30},{"title":"Floyd-warshall","category":"graph","id":"floyd-warshall","algorithm":"# Floyd–Warshall Algorithm\n\nIn computer science, the **Floyd–Warshall algorithm** is an algorithm for finding\nshortest paths in a weighted graph with positive or negative edge weights (but\nwith no negative cycles). A single execution of the algorithm will find the \nlengths (summed weights) of shortest paths between all pairs of vertices. Although \nit does not return details of the paths themselves, it is possible to reconstruct \nthe paths with simple modifications to the algorithm.\n\n## Algorithm\n\nThe Floyd–Warshall algorithm compares all possible paths through the graph between \neach pair of vertices. It is able to do this with `O(|V|^3)` comparisons in a graph.\nThis is remarkable considering that there may be up to `|V|^2` edges in the graph, \nand every combination of edges is tested. It does so by incrementally improving an \nestimate on the shortest path between two vertices, until the estimate is optimal.\n\nConsider a graph `G` with vertices `V` numbered `1` through `N`. Further consider \na function `shortestPath(i, j, k)` that returns the shortest possible path \nfrom `i` to `j` using vertices only from the set `{1, 2, ..., k}` as \nintermediate points along the way. Now, given this function, our goal is to \nfind the shortest path from each `i` to each `j` using only vertices \nin `{1, 2, ..., N}`.\n\n![Recursive Formula](https://wikimedia.org/api/rest_v1/media/math/render/svg/f9b75e25063384ccca499c56f9a279abf661ad3b)\n\n![Recursive Formula](https://wikimedia.org/api/rest_v1/media/math/render/svg/34ac7c89bbb18df3fd660225fd38997079e5e513)\n![Recursive Formula](https://wikimedia.org/api/rest_v1/media/math/render/svg/0326d6c14def89269c029da59eba012d0f2edc9d)\n\nThis formula is the heart of the Floyd–Warshall algorithm.\n\n## Example\n\nThe algorithm above is executed on the graph on the left below:\n\n![Example](https://upload.wikimedia.org/wikipedia/commons/2/2e/Floyd-Warshall_example.svg)\n\nIn the tables below `i` is row numbers and `j` is column numbers.\n\n\n**k = 0**\n\n|       | 1   | 2   | 3   | 4   |\n|:-----:|:---:|:---:|:---:|:---:|\n| **1** |\t0   |\t∞   |\t−2  | ∞   |\n| **2** |\t4   |\t0   |\t3\t  | ∞   |\n| **3** |\t∞   |\t∞   |\t0\t  | 2   |\n| **4** |\t∞   |\t−1  | ∞   | 0   |\n\n\n**k = 1**\n\n|       | 1   | 2   | 3   | 4   |\n|:-----:|:---:|:---:|:---:|:---:|\n| **1** | 0   | ∞   | −2  | ∞   |\n| **2** | 4   | 0   |  2  | ∞   |\n| **3** | ∞   | ∞   |  0  | 2   |\n| **4** | ∞   | −   |  ∞  | 0   |\n\n\n**k = 2**\n\n|       | 1   | 2   | 3   | 4   |\n|:-----:|:---:|:---:|:---:|:---:|\n| **1** |\t0   |\t∞   |\t−2  | ∞   |\n| **2** |\t4   |\t0   | 2\t  | ∞   |\n| **3** |\t∞   |\t∞\t  | 0\t  | 2   |\n| **4** |\t3   |\t−1  | 1   | 0   |\n\n\n**k = 3**\n\n|       | 1   | 2   | 3   | 4   |\n|:-----:|:---:|:---:|:---:|:---:|\n| **1** |\t0   |\t∞   |\t−2  | 0   |\n| **2** |\t4   |\t0   |\t2\t  | 4   |\n| **3** |\t∞   |\t∞   |\t0\t  | 2   |\n| **4** |\t3   |\t−1  | 1   | 0   |\n\n\n**k = 4**\n\n|       | 1   | 2   | 3   | 4   |\n|:-----:|:---:|:---:|:---:|:---:|\n| **1** |\t0   |\t−1  | −2  | 0   |\n| **2** |\t4   |\t0\t  | 2\t  | 4   |\n| **3** |\t5   |\t1\t  | 0\t  | 2   |\n| **4** |\t3   |\t−1  | 1   | 0   |\n\n## References\n\n- [Wikipedia](https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm)\n- [YouTube (by Abdul Bari)](https://www.youtube.com/watch?v=oNI0rf2P9gE&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8&index=74)\n- [YouTube (by Tushar Roy)](https://www.youtube.com/watch?v=LwJdNfdLF9s&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8&index=75)\n","filetype":".md","index":31},{"title":"Floyd Warshall","category":"floyd-warshall","id":"floydWarshall_floyd-warshall","algorithm":"/**\n * @param {Graph} graph\n * @return {{distances: number[][], nextVertices: GraphVertex[][]}}\n */\nexport default function floydWarshall(graph) {\n  // Get all graph vertices.\n  const vertices = graph.getAllVertices();\n\n  // Init previous vertices matrix with nulls meaning that there are no\n  // previous vertices exist that will give us shortest path.\n  const nextVertices = Array(vertices.length).fill(null).map(() => {\n    return Array(vertices.length).fill(null);\n  });\n\n  // Init distances matrix with Infinities meaning there are no paths\n  // between vertices exist so far.\n  const distances = Array(vertices.length).fill(null).map(() => {\n    return Array(vertices.length).fill(Infinity);\n  });\n\n  // Init distance matrix with the distance we already now (from existing edges).\n  // And also init previous vertices from the edges.\n  vertices.forEach((startVertex, startIndex) => {\n    vertices.forEach((endVertex, endIndex) => {\n      if (startVertex === endVertex) {\n        // Distance to the vertex itself is 0.\n        distances[startIndex][endIndex] = 0;\n      } else {\n        // Find edge between the start and end vertices.\n        const edge = graph.findEdge(startVertex, endVertex);\n\n        if (edge) {\n          // There is an edge from vertex with startIndex to vertex with endIndex.\n          // Save distance and previous vertex.\n          distances[startIndex][endIndex] = edge.weight;\n          nextVertices[startIndex][endIndex] = startVertex;\n        } else {\n          distances[startIndex][endIndex] = Infinity;\n        }\n      }\n    });\n  });\n\n  // Now let's go to the core of the algorithm.\n  // Let's all pair of vertices (from start to end ones) and try to check if there\n  // is a shorter path exists between them via middle vertex. Middle vertex may also\n  // be one of the graph vertices. As you may see now we're going to have three\n  // loops over all graph vertices: for start, end and middle vertices.\n  vertices.forEach((middleVertex, middleIndex) => {\n    // Path starts from startVertex with startIndex.\n    vertices.forEach((startVertex, startIndex) => {\n      // Path ends to endVertex with endIndex.\n      vertices.forEach((endVertex, endIndex) => {\n        // Compare existing distance from startVertex to endVertex, with distance\n        // from startVertex to endVertex but via middleVertex.\n        // Save the shortest distance and previous vertex that allows\n        // us to have this shortest distance.\n        const distViaMiddle = distances[startIndex][middleIndex] + distances[middleIndex][endIndex];\n\n        if (distances[startIndex][endIndex] > distViaMiddle) {\n          // We've found a shortest pass via middle vertex.\n          distances[startIndex][endIndex] = distViaMiddle;\n          nextVertices[startIndex][endIndex] = middleVertex;\n        }\n      });\n    });\n  });\n\n  // Shortest distance from x to y: distance[x][y].\n  // Next vertex after x one in path from x to y: nextVertices[x][y].\n  return { distances, nextVertices };\n}\n","filetype":".js","index":32},{"title":"Hamiltonian-cycle","category":"graph","id":"hamiltonian-cycle","algorithm":"# Hamiltonian Path\n\n**Hamiltonian path** (or **traceable path**) is a path in an \nundirected or directed graph that visits each vertex exactly once. \nA **Hamiltonian cycle** (or **Hamiltonian circuit**) is a \nHamiltonian path that is a cycle. Determining whether such paths \nand cycles exist in graphs is the **Hamiltonian path problem**.\n\n![Hamiltonian cycle](https://upload.wikimedia.org/wikipedia/commons/6/6c/Hamiltonian_path_3d.svg)\n\nOne possible Hamiltonian cycle through every vertex of a \ndodecahedron is shown in red – like all platonic solids, the \ndodecahedron is Hamiltonian.\n\n## Naive Algorithm\n\nGenerate all possible configurations of vertices and print a \nconfiguration that satisfies the given constraints. There \nwill be `n!` (n factorial) configurations.\n\n```\nwhile there are untried configurations\n{\n   generate the next configuration\n   if ( there are edges between two consecutive vertices of this\n      configuration and there is an edge from the last vertex to \n      the first ).\n   {\n      print this configuration;\n      break;\n   }\n}\n```\n\n## Backtracking Algorithm\n\nCreate an empty path array and add vertex `0` to it. Add other \nvertices, starting from the vertex `1`. Before adding a vertex, \ncheck for whether it is adjacent to the previously added vertex \nand not already added. If we find such a vertex, we add the \nvertex as part of the solution. If we do not find a vertex \nthen we return false.\n\n## References\n\n- [Hamiltonian path on Wikipedia](https://en.wikipedia.org/wiki/Hamiltonian_path)\n- [Hamiltonian path on YouTube](https://www.youtube.com/watch?v=dQr4wZCiJJ4&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\n- [Hamiltonian cycle on GeeksForGeeks](https://www.geeksforgeeks.org/backtracking-set-7-hamiltonian-cycle/)\n","filetype":".md","index":33},{"title":"Hamiltonian Cycle","category":"hamiltonian-cycle","id":"hamiltonianCycle_hamiltonian-cycle","algorithm":"import GraphVertex from '../../../data-structures/graph/GraphVertex';\n\n/**\n * @param {number[][]} adjacencyMatrix\n * @param {object} verticesIndices\n * @param {GraphVertex[]} cycle\n * @param {GraphVertex} vertexCandidate\n * @return {boolean}\n */\nfunction isSafe(adjacencyMatrix, verticesIndices, cycle, vertexCandidate) {\n  const endVertex = cycle[cycle.length - 1];\n\n  // Get end and candidate vertices indices in adjacency matrix.\n  const candidateVertexAdjacencyIndex = verticesIndices[vertexCandidate.getKey()];\n  const endVertexAdjacencyIndex = verticesIndices[endVertex.getKey()];\n\n  // Check if last vertex in the path and candidate vertex are adjacent.\n  if (adjacencyMatrix[endVertexAdjacencyIndex][candidateVertexAdjacencyIndex] === Infinity) {\n    return false;\n  }\n\n  // Check if vertexCandidate is being added to the path for the first time.\n  const candidateDuplicate = cycle.find((vertex) => vertex.getKey() === vertexCandidate.getKey());\n\n  return !candidateDuplicate;\n}\n\n/**\n * @param {number[][]} adjacencyMatrix\n * @param {object} verticesIndices\n * @param {GraphVertex[]} cycle\n * @return {boolean}\n */\nfunction isCycle(adjacencyMatrix, verticesIndices, cycle) {\n  // Check if first and last vertices in hamiltonian path are adjacent.\n\n  // Get start and end vertices from the path.\n  const startVertex = cycle[0];\n  const endVertex = cycle[cycle.length - 1];\n\n  // Get start/end vertices indices in adjacency matrix.\n  const startVertexAdjacencyIndex = verticesIndices[startVertex.getKey()];\n  const endVertexAdjacencyIndex = verticesIndices[endVertex.getKey()];\n\n  // Check if we can go from end vertex to the start one.\n  return adjacencyMatrix[endVertexAdjacencyIndex][startVertexAdjacencyIndex] !== Infinity;\n}\n\n/**\n * @param {number[][]} adjacencyMatrix\n * @param {GraphVertex[]} vertices\n * @param {object} verticesIndices\n * @param {GraphVertex[][]} cycles\n * @param {GraphVertex[]} cycle\n */\nfunction hamiltonianCycleRecursive({\n  adjacencyMatrix,\n  vertices,\n  verticesIndices,\n  cycles,\n  cycle,\n}) {\n  // Clone cycle in order to prevent it from modification by other DFS branches.\n  const currentCycle = [...cycle].map((vertex) => new GraphVertex(vertex.value));\n\n  if (vertices.length === currentCycle.length) {\n    // Hamiltonian path is found.\n    // Now we need to check if it is cycle or not.\n    if (isCycle(adjacencyMatrix, verticesIndices, currentCycle)) {\n      // Another solution has been found. Save it.\n      cycles.push(currentCycle);\n    }\n    return;\n  }\n\n  for (let vertexIndex = 0; vertexIndex < vertices.length; vertexIndex += 1) {\n    // Get vertex candidate that we will try to put into next path step and see if it fits.\n    const vertexCandidate = vertices[vertexIndex];\n\n    // Check if it is safe to put vertex candidate to cycle.\n    if (isSafe(adjacencyMatrix, verticesIndices, currentCycle, vertexCandidate)) {\n      // Add candidate vertex to cycle path.\n      currentCycle.push(vertexCandidate);\n\n      // Try to find other vertices in cycle.\n      hamiltonianCycleRecursive({\n        adjacencyMatrix,\n        vertices,\n        verticesIndices,\n        cycles,\n        cycle: currentCycle,\n      });\n\n      // BACKTRACKING.\n      // Remove candidate vertex from cycle path in order to try another one.\n      currentCycle.pop();\n    }\n  }\n}\n\n/**\n * @param {Graph} graph\n * @return {GraphVertex[][]}\n */\nexport default function hamiltonianCycle(graph) {\n  // Gather some information about the graph that we will need to during\n  // the problem solving.\n  const verticesIndices = graph.getVerticesIndices();\n  const adjacencyMatrix = graph.getAdjacencyMatrix();\n  const vertices = graph.getAllVertices();\n\n  // Define start vertex. We will always pick the first one\n  // this it doesn't matter which vertex to pick in a cycle.\n  // Every vertex is in a cycle so we can start from any of them.\n  const startVertex = vertices[0];\n\n  // Init cycles array that will hold all solutions.\n  const cycles = [];\n\n  // Init cycle array that will hold current cycle path.\n  const cycle = [startVertex];\n\n  // Try to find cycles recursively in Depth First Search order.\n  hamiltonianCycleRecursive({\n    adjacencyMatrix,\n    vertices,\n    verticesIndices,\n    cycles,\n    cycle,\n  });\n\n  // Return found cycles.\n  return cycles;\n}\n","filetype":".js","index":34},{"title":"Kruskal","category":"graph","id":"kruskal","algorithm":"# Kruskal's Algorithm\n\nKruskal's algorithm is a minimum-spanning-tree algorithm which \nfinds an edge of the least possible weight that connects any two \ntrees in the forest. It is a greedy algorithm in graph theory \nas it finds a minimum spanning tree for a connected weighted \ngraph adding increasing cost arcs at each step. This means it \nfinds a subset of the edges that forms a tree that includes every\nvertex, where the total weight of all the edges in the tree is \nminimized. If the graph is not connected, then it finds a \nminimum spanning forest (a minimum spanning tree for each \nconnected component).\n\n![Kruskal Algorithm](https://upload.wikimedia.org/wikipedia/commons/5/5c/MST_kruskal_en.gif)\n\n![Kruskal Demo](https://upload.wikimedia.org/wikipedia/commons/b/bb/KruskalDemo.gif)\n\nA demo for Kruskal's algorithm based on Euclidean distance.\n\n## Minimum Spanning Tree\n\nA **minimum spanning tree** (MST) or minimum weight spanning tree \nis a subset of the edges of a connected, edge-weighted \n(un)directed graph that connects all the vertices together, \nwithout any cycles and with the minimum possible total edge \nweight. That is, it is a spanning tree whose sum of edge weights \nis as small as possible. More generally, any edge-weighted \nundirected graph (not necessarily connected) has a minimum \nspanning forest, which is a union of the minimum spanning \ntrees for its connected components.\n\n![Minimum Spanning Tree](https://upload.wikimedia.org/wikipedia/commons/d/d2/Minimum_spanning_tree.svg)\n\nA planar graph and its minimum spanning tree. Each edge is \nlabeled with its weight, which here is roughly proportional \nto its length.\n\n![Minimum Spanning Tree](https://upload.wikimedia.org/wikipedia/commons/c/c9/Multiple_minimum_spanning_trees.svg)\n\nThis figure shows there may be more than one minimum spanning \ntree in a graph. In the figure, the two trees below the graph \nare two possibilities of minimum spanning tree of the given graph.\n\n## References\n\n- [Minimum Spanning Tree on Wikipedia](https://en.wikipedia.org/wiki/Minimum_spanning_tree)\n- [Kruskal's Algorithm on Wikipedia](https://en.wikipedia.org/wiki/Kruskal%27s_algorithm)\n- [Kruskal's Algorithm on YouTube by Tushar Roy](https://www.youtube.com/watch?v=fAuF0EuZVCk&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\n- [Kruskal's Algorithm on YouTube by Michael Sambol](https://www.youtube.com/watch?v=71UQH7Pr9kU&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\n","filetype":".md","index":35},{"title":"Kruskal","category":"kruskal","id":"kruskal_kruskal","algorithm":"import Graph from '../../../data-structures/graph/Graph';\nimport QuickSort from '../../sorting/quick-sort/QuickSort';\nimport DisjointSet from '../../../data-structures/disjoint-set/DisjointSet';\n\n/**\n * @param {Graph} graph\n * @return {Graph}\n */\nexport default function kruskal(graph) {\n  // It should fire error if graph is directed since the algorithm works only\n  // for undirected graphs.\n  if (graph.isDirected) {\n    throw new Error('Kruskal\\'s algorithms works only for undirected graphs');\n  }\n\n  // Init new graph that will contain minimum spanning tree of original graph.\n  const minimumSpanningTree = new Graph();\n\n  // Sort all graph edges in increasing order.\n  const sortingCallbacks = {\n    /**\n     * @param {GraphEdge} graphEdgeA\n     * @param {GraphEdge} graphEdgeB\n     */\n    compareCallback: (graphEdgeA, graphEdgeB) => {\n      if (graphEdgeA.weight === graphEdgeB.weight) {\n        return 1;\n      }\n\n      return graphEdgeA.weight <= graphEdgeB.weight ? -1 : 1;\n    },\n  };\n  const sortedEdges = new QuickSort(sortingCallbacks).sort(graph.getAllEdges());\n\n  // Create disjoint sets for all graph vertices.\n  const keyCallback = (graphVertex) => graphVertex.getKey();\n  const disjointSet = new DisjointSet(keyCallback);\n\n  graph.getAllVertices().forEach((graphVertex) => {\n    disjointSet.makeSet(graphVertex);\n  });\n\n  // Go through all edges started from the minimum one and try to add them\n  // to minimum spanning tree. The criteria of adding the edge would be whether\n  // it is forms the cycle or not (if it connects two vertices from one disjoint\n  // set or not).\n  for (let edgeIndex = 0; edgeIndex < sortedEdges.length; edgeIndex += 1) {\n    /** @var {GraphEdge} currentEdge */\n    const currentEdge = sortedEdges[edgeIndex];\n\n    // Check if edge forms the cycle. If it does then skip it.\n    if (!disjointSet.inSameSet(currentEdge.startVertex, currentEdge.endVertex)) {\n      // Unite two subsets into one.\n      disjointSet.union(currentEdge.startVertex, currentEdge.endVertex);\n\n      // Add this edge to spanning tree.\n      minimumSpanningTree.addEdge(currentEdge);\n    }\n  }\n\n  return minimumSpanningTree;\n}\n","filetype":".js","index":36},{"title":"Prim","category":"graph","id":"prim","algorithm":"# Prim's Algorithm\n\nIn computer science, **Prim's algorithm** is a greedy algorithm that \nfinds a minimum spanning tree for a weighted undirected graph. \n\nThe algorithm operates by building this tree one vertex at a \ntime, from an arbitrary starting vertex, at each step adding \nthe cheapest possible connection from the tree to another vertex.\n\n![Prim's Algorithm](https://upload.wikimedia.org/wikipedia/commons/f/f7/Prim%27s_algorithm.svg)\n\nPrim's algorithm starting at vertex `A`. In the third step, edges \n`BD` and `AB` both have weight `2`, so `BD` is chosen arbitrarily. \nAfter that step, `AB` is no longer a candidate for addition \nto the tree because it links two nodes that are already \nin the tree.\n\n## Minimum Spanning Tree\n\nA **minimum spanning tree** (MST) or minimum weight spanning tree \nis a subset of the edges of a connected, edge-weighted \n(un)directed graph that connects all the vertices together, \nwithout any cycles and with the minimum possible total edge \nweight. That is, it is a spanning tree whose sum of edge weights \nis as small as possible. More generally, any edge-weighted \nundirected graph (not necessarily connected) has a minimum \nspanning forest, which is a union of the minimum spanning \ntrees for its connected components.\n\n![Minimum Spanning Tree](https://upload.wikimedia.org/wikipedia/commons/d/d2/Minimum_spanning_tree.svg)\n\nA planar graph and its minimum spanning tree. Each edge is \nlabeled with its weight, which here is roughly proportional \nto its length.\n\n![Minimum Spanning Tree](https://upload.wikimedia.org/wikipedia/commons/c/c9/Multiple_minimum_spanning_trees.svg)\n\nThis figure shows there may be more than one minimum spanning \ntree in a graph. In the figure, the two trees below the graph \nare two possibilities of minimum spanning tree of the given graph.\n\n## References\n\n- [Minimum Spanning Tree on Wikipedia](https://en.wikipedia.org/wiki/Minimum_spanning_tree)\n- [Prim's Algorithm on Wikipedia](https://en.wikipedia.org/wiki/Prim%27s_algorithm)\n- [Prim's Algorithm on YouTube by Tushar Roy](https://www.youtube.com/watch?v=oP2-8ysT3QQ&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\n- [Prim's Algorithm on YouTube by Michael Sambol](https://www.youtube.com/watch?v=cplfcGZmX7I&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\n","filetype":".md","index":37},{"title":"Prim","category":"prim","id":"prim_prim","algorithm":"import Graph from '../../../data-structures/graph/Graph';\nimport PriorityQueue from '../../../data-structures/priority-queue/PriorityQueue';\n\n/**\n * @param {Graph} graph\n * @return {Graph}\n */\nexport default function prim(graph) {\n  // It should fire error if graph is directed since the algorithm works only\n  // for undirected graphs.\n  if (graph.isDirected) {\n    throw new Error('Prim\\'s algorithms works only for undirected graphs');\n  }\n\n  // Init new graph that will contain minimum spanning tree of original graph.\n  const minimumSpanningTree = new Graph();\n\n  // This priority queue will contain all the edges that are starting from\n  // visited nodes and they will be ranked by edge weight - so that on each step\n  // we would always pick the edge with minimal edge weight.\n  const edgesQueue = new PriorityQueue();\n\n  // Set of vertices that has been already visited.\n  const visitedVertices = {};\n\n  // Vertex from which we will start graph traversal.\n  const startVertex = graph.getAllVertices()[0];\n\n  // Add start vertex to the set of visited ones.\n  visitedVertices[startVertex.getKey()] = startVertex;\n\n  // Add all edges of start vertex to the queue.\n  startVertex.getEdges().forEach((graphEdge) => {\n    edgesQueue.add(graphEdge, graphEdge.weight);\n  });\n\n  // Now let's explore all queued edges.\n  while (!edgesQueue.isEmpty()) {\n    // Fetch next queued edge with minimal weight.\n    /** @var {GraphEdge} currentEdge */\n    const currentMinEdge = edgesQueue.poll();\n\n    // Find out the next unvisited minimal vertex to traverse.\n    let nextMinVertex = null;\n    if (!visitedVertices[currentMinEdge.startVertex.getKey()]) {\n      nextMinVertex = currentMinEdge.startVertex;\n    } else if (!visitedVertices[currentMinEdge.endVertex.getKey()]) {\n      nextMinVertex = currentMinEdge.endVertex;\n    }\n\n    // If all vertices of current edge has been already visited then skip this round.\n    if (nextMinVertex) {\n      // Add current min edge to MST.\n      minimumSpanningTree.addEdge(currentMinEdge);\n\n      // Add vertex to the set of visited ones.\n      visitedVertices[nextMinVertex.getKey()] = nextMinVertex;\n\n      // Add all current vertex's edges to the queue.\n      nextMinVertex.getEdges().forEach((graphEdge) => {\n        // Add only vertices that link to unvisited nodes.\n        if (\n          !visitedVertices[graphEdge.startVertex.getKey()]\n          || !visitedVertices[graphEdge.endVertex.getKey()]\n        ) {\n          edgesQueue.add(graphEdge, graphEdge.weight);\n        }\n      });\n    }\n  }\n\n  return minimumSpanningTree;\n}\n","filetype":".js","index":38},{"title":"Strongly-connected-components","category":"graph","id":"strongly-connected-components","algorithm":"# Strongly Connected Component\n\nA directed graph is called **strongly connected** if there is a path \nin each direction between each pair of vertices of the graph. \nIn a directed graph G that may not itself be strongly connected, \na pair of vertices `u` and `v` are said to be strongly connected \nto each other if there is a path in each direction between them.\n\n![Strongly Connected](https://upload.wikimedia.org/wikipedia/commons/5/5c/Scc.png)\n\nGraph with strongly connected components marked\n\n## References\n\n- [Wikipedia](https://en.wikipedia.org/wiki/Strongly_connected_component)\n- [YouTube](https://www.youtube.com/watch?v=RpgcYiky7uw&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\n","filetype":".md","index":39},{"title":"Strongly Connected Components","category":"strongly-connected-components","id":"stronglyConnectedComponents_strongly-connected-components","algorithm":"import Stack from '../../../data-structures/stack/Stack';\nimport depthFirstSearch from '../depth-first-search/depthFirstSearch';\n\n/**\n * @param {Graph} graph\n * @return {Stack}\n */\nfunction getVerticesSortedByDfsFinishTime(graph) {\n  // Set of all visited vertices during DFS pass.\n  const visitedVerticesSet = {};\n\n  // Stack of vertices by finish time.\n  // All vertices in this stack are ordered by finished time in decreasing order.\n  // Vertex that has been finished first will be at the bottom of the stack and\n  // vertex that has been finished last will be at the top of the stack.\n  const verticesByDfsFinishTime = new Stack();\n\n  // Set of all vertices we're going to visit.\n  const notVisitedVerticesSet = {};\n  graph.getAllVertices().forEach((vertex) => {\n    notVisitedVerticesSet[vertex.getKey()] = vertex;\n  });\n\n  // Specify DFS traversal callbacks.\n  const dfsCallbacks = {\n    enterVertex: ({ currentVertex }) => {\n      // Add current vertex to visited set.\n      visitedVerticesSet[currentVertex.getKey()] = currentVertex;\n\n      // Delete current vertex from not visited set.\n      delete notVisitedVerticesSet[currentVertex.getKey()];\n    },\n    leaveVertex: ({ currentVertex }) => {\n      // Push vertex to the stack when leaving it.\n      // This will make stack to be ordered by finish time in decreasing order.\n      verticesByDfsFinishTime.push(currentVertex);\n    },\n    allowTraversal: ({ nextVertex }) => {\n      // Don't allow to traverse the nodes that have been already visited.\n      return !visitedVerticesSet[nextVertex.getKey()];\n    },\n  };\n\n  // Do FIRST DFS PASS traversal for all graph vertices to fill the verticesByFinishTime stack.\n  while (Object.values(notVisitedVerticesSet).length) {\n    // Peek any vertex to start DFS traversal from.\n    const startVertexKey = Object.keys(notVisitedVerticesSet)[0];\n    const startVertex = notVisitedVerticesSet[startVertexKey];\n    delete notVisitedVerticesSet[startVertexKey];\n\n    depthFirstSearch(graph, startVertex, dfsCallbacks);\n  }\n\n  return verticesByDfsFinishTime;\n}\n\n/**\n * @param {Graph} graph\n * @param {Stack} verticesByFinishTime\n * @return {*[]}\n */\nfunction getSCCSets(graph, verticesByFinishTime) {\n  // Array of arrays of strongly connected vertices.\n  const stronglyConnectedComponentsSets = [];\n\n  // Array that will hold all vertices that are being visited during one DFS run.\n  let stronglyConnectedComponentsSet = [];\n\n  // Visited vertices set.\n  const visitedVerticesSet = {};\n\n  // Callbacks for DFS traversal.\n  const dfsCallbacks = {\n    enterVertex: ({ currentVertex }) => {\n      // Add current vertex to SCC set of current DFS round.\n      stronglyConnectedComponentsSet.push(currentVertex);\n\n      // Add current vertex to visited set.\n      visitedVerticesSet[currentVertex.getKey()] = currentVertex;\n    },\n    leaveVertex: ({ previousVertex }) => {\n      // Once DFS traversal is finished push the set of found strongly connected\n      // components during current DFS round to overall strongly connected components set.\n      // The sign that traversal is about to be finished is that we came back to start vertex\n      // which doesn't have parent.\n      if (previousVertex === null) {\n        stronglyConnectedComponentsSets.push([...stronglyConnectedComponentsSet]);\n      }\n    },\n    allowTraversal: ({ nextVertex }) => {\n      // Don't allow traversal of already visited vertices.\n      return !visitedVerticesSet[nextVertex.getKey()];\n    },\n  };\n\n  while (!verticesByFinishTime.isEmpty()) {\n    /** @var {GraphVertex} startVertex */\n    const startVertex = verticesByFinishTime.pop();\n\n    // Reset the set of strongly connected vertices.\n    stronglyConnectedComponentsSet = [];\n\n    // Don't do DFS on already visited vertices.\n    if (!visitedVerticesSet[startVertex.getKey()]) {\n      // Do DFS traversal.\n      depthFirstSearch(graph, startVertex, dfsCallbacks);\n    }\n  }\n\n  return stronglyConnectedComponentsSets;\n}\n\n/**\n * Kosaraju's algorithm.\n *\n * @param {Graph} graph\n * @return {*[]}\n */\nexport default function stronglyConnectedComponents(graph) {\n  // In this algorithm we will need to do TWO DFS PASSES overt the graph.\n\n  // Get stack of vertices ordered by DFS finish time.\n  // All vertices in this stack are ordered by finished time in decreasing order:\n  // Vertex that has been finished first will be at the bottom of the stack and\n  // vertex that has been finished last will be at the top of the stack.\n  const verticesByFinishTime = getVerticesSortedByDfsFinishTime(graph);\n\n  // Reverse the graph.\n  graph.reverse();\n\n  // Do DFS once again on reversed graph.\n  return getSCCSets(graph, verticesByFinishTime);\n}\n","filetype":".js","index":40},{"title":"Topological-sorting","category":"graph","id":"topological-sorting","algorithm":"# Topological Sorting\n\nIn the field of computer science, a topological sort or \ntopological ordering of a directed graph is a linear ordering \nof its vertices such that for every directed edge `uv` from \nvertex `u` to vertex `v`, `u` comes before `v` in the ordering.\n\nFor instance, the vertices of the graph may represent tasks to \nbe performed, and the edges may represent constraints that one \ntask must be performed before another; in this application, a \ntopological ordering is just a valid sequence for the tasks.\n\nA topological ordering is possible if and only if the graph has\nno directed cycles, that is, if it is a [directed acyclic graph](https://en.wikipedia.org/wiki/Directed_acyclic_graph) \n(DAG). Any DAG has at least one topological ordering, and algorithms are \nknown for constructing a topological ordering of any DAG in linear time.\n\n![Directed Acyclic Graph](https://upload.wikimedia.org/wikipedia/commons/c/c6/Topological_Ordering.svg)\n\nA topological ordering of a directed acyclic graph: every edge goes from \nearlier in the ordering (upper left) to later in the ordering (lower right). \nA directed graph is acyclic if and only if it has a topological ordering.\n\n## Example\n\n![Topologic Sorting](https://upload.wikimedia.org/wikipedia/commons/0/03/Directed_acyclic_graph_2.svg)\n\nThe graph shown above has many valid topological sorts, including:\n\n- `5, 7, 3, 11, 8, 2, 9, 10` (visual left-to-right, top-to-bottom)\n- `3, 5, 7, 8, 11, 2, 9, 10` (smallest-numbered available vertex first)\n- `5, 7, 3, 8, 11, 10, 9, 2` (fewest edges first)\n- `7, 5, 11, 3, 10, 8, 9, 2` (largest-numbered available vertex first)\n- `5, 7, 11, 2, 3, 8, 9, 10` (attempting top-to-bottom, left-to-right)\n- `3, 7, 8, 5, 11, 10, 2, 9` (arbitrary)\n\n## Application\n\nThe canonical application of topological sorting is in \n**scheduling a sequence of jobs** or tasks based on their dependencies. The jobs \nare represented by vertices, and there is an edge from `x` to `y` if \njob `x` must be completed before job `y` can be started (for \nexample, when washing clothes, the washing machine must finish \nbefore we put the clothes in the dryer). Then, a topological sort \ngives an order in which to perform the jobs.\n\nOther application is **dependency resolution**. Each vertex is a package\nand each edge is a dependency of package `a` on package 'b'. Then topological\nsorting will provide a sequence of installing dependencies in a way that every\nnext dependency has its dependent packages to be installed in prior.\n\n## References\n\n- [Wikipedia](https://en.wikipedia.org/wiki/Topological_sorting)\n- [Topological Sorting on YouTube by Tushar Roy](https://www.youtube.com/watch?v=ddTC4Zovtbc&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\n","filetype":".md","index":41},{"title":"Topological Sort","category":"topological-sorting","id":"topologicalSort_topological-sorting","algorithm":"import Stack from '../../../data-structures/stack/Stack';\nimport depthFirstSearch from '../depth-first-search/depthFirstSearch';\n\n/**\n * @param {Graph} graph\n */\nexport default function topologicalSort(graph) {\n  // Create a set of all vertices we want to visit.\n  const unvisitedSet = {};\n  graph.getAllVertices().forEach((vertex) => {\n    unvisitedSet[vertex.getKey()] = vertex;\n  });\n\n  // Create a set for all vertices that we've already visited.\n  const visitedSet = {};\n\n  // Create a stack of already ordered vertices.\n  const sortedStack = new Stack();\n\n  const dfsCallbacks = {\n    enterVertex: ({ currentVertex }) => {\n      // Add vertex to visited set in case if all its children has been explored.\n      visitedSet[currentVertex.getKey()] = currentVertex;\n\n      // Remove this vertex from unvisited set.\n      delete unvisitedSet[currentVertex.getKey()];\n    },\n    leaveVertex: ({ currentVertex }) => {\n      // If the vertex has been totally explored then we may push it to stack.\n      sortedStack.push(currentVertex);\n    },\n    allowTraversal: ({ nextVertex }) => {\n      return !visitedSet[nextVertex.getKey()];\n    },\n  };\n\n  // Let's go and do DFS for all unvisited nodes.\n  while (Object.keys(unvisitedSet).length) {\n    const currentVertexKey = Object.keys(unvisitedSet)[0];\n    const currentVertex = unvisitedSet[currentVertexKey];\n\n    // Do DFS for current node.\n    depthFirstSearch(graph, currentVertex, dfsCallbacks);\n  }\n\n  return sortedStack.toArray();\n}\n","filetype":".js","index":42},{"title":"Travelling-salesman","category":"graph","id":"travelling-salesman","algorithm":"# Travelling Salesman Problem\n\nThe travelling salesman problem (TSP) asks the following question: \n\"Given a list of cities and the distances between each pair of \ncities, what is the shortest possible route that visits each city \nand returns to the origin city?\"\n\n![Travelling Salesman](https://upload.wikimedia.org/wikipedia/commons/1/11/GLPK_solution_of_a_travelling_salesman_problem.svg)\n\nSolution of a travelling salesman problem: the black line shows \nthe shortest possible loop that connects every red dot.\n\n![Travelling Salesman Graph](https://upload.wikimedia.org/wikipedia/commons/3/30/Weighted_K4.svg)\n\nTSP can be modelled as an undirected weighted graph, such that \ncities are the graph's vertices, paths are the graph's edges, \nand a path's distance is the edge's weight. It is a minimization \nproblem starting and finishing at a specified vertex after having \nvisited each other vertex exactly once. Often, the model is a \ncomplete graph (i.e. each pair of vertices is connected by an \nedge). If no path exists between two cities, adding an arbitrarily \nlong edge will complete the graph without affecting the optimal tour.\n\n## References\n\n- [Wikipedia](https://en.wikipedia.org/wiki/Travelling_salesman_problem)\n","filetype":".md","index":43},{"title":"Bf Travelling Salesman","category":"travelling-salesman","id":"bfTravellingSalesman_travelling-salesman","algorithm":"/**\n * Get all possible paths\n * @param {GraphVertex} startVertex\n * @param {GraphVertex[][]} [paths]\n * @param {GraphVertex[]} [path]\n */\nfunction findAllPaths(startVertex, paths = [], path = []) {\n  // Clone path.\n  const currentPath = [...path];\n\n  // Add startVertex to the path.\n  currentPath.push(startVertex);\n\n  // Generate visited set from path.\n  const visitedSet = currentPath.reduce((accumulator, vertex) => {\n    const updatedAccumulator = { ...accumulator };\n    updatedAccumulator[vertex.getKey()] = vertex;\n\n    return updatedAccumulator;\n  }, {});\n\n  // Get all unvisited neighbors of startVertex.\n  const unvisitedNeighbors = startVertex.getNeighbors().filter((neighbor) => {\n    return !visitedSet[neighbor.getKey()];\n  });\n\n  // If there no unvisited neighbors then treat current path as complete and save it.\n  if (!unvisitedNeighbors.length) {\n    paths.push(currentPath);\n\n    return paths;\n  }\n\n  // Go through all the neighbors.\n  for (let neighborIndex = 0; neighborIndex < unvisitedNeighbors.length; neighborIndex += 1) {\n    const currentUnvisitedNeighbor = unvisitedNeighbors[neighborIndex];\n    findAllPaths(currentUnvisitedNeighbor, paths, currentPath);\n  }\n\n  return paths;\n}\n\n/**\n * @param {number[][]} adjacencyMatrix\n * @param {object} verticesIndices\n * @param {GraphVertex[]} cycle\n * @return {number}\n */\nfunction getCycleWeight(adjacencyMatrix, verticesIndices, cycle) {\n  let weight = 0;\n\n  for (let cycleIndex = 1; cycleIndex < cycle.length; cycleIndex += 1) {\n    const fromVertex = cycle[cycleIndex - 1];\n    const toVertex = cycle[cycleIndex];\n    const fromVertexIndex = verticesIndices[fromVertex.getKey()];\n    const toVertexIndex = verticesIndices[toVertex.getKey()];\n    weight += adjacencyMatrix[fromVertexIndex][toVertexIndex];\n  }\n\n  return weight;\n}\n\n/**\n * BRUTE FORCE approach to solve Traveling Salesman Problem.\n *\n * @param {Graph} graph\n * @return {GraphVertex[]}\n */\nexport default function bfTravellingSalesman(graph) {\n  // Pick starting point from where we will traverse the graph.\n  const startVertex = graph.getAllVertices()[0];\n\n  // BRUTE FORCE.\n  // Generate all possible paths from startVertex.\n  const allPossiblePaths = findAllPaths(startVertex);\n\n  // Filter out paths that are not cycles.\n  const allPossibleCycles = allPossiblePaths.filter((path) => {\n    /** @var {GraphVertex} */\n    const lastVertex = path[path.length - 1];\n    const lastVertexNeighbors = lastVertex.getNeighbors();\n\n    return lastVertexNeighbors.includes(startVertex);\n  });\n\n  // Go through all possible cycles and pick the one with minimum overall tour weight.\n  const adjacencyMatrix = graph.getAdjacencyMatrix();\n  const verticesIndices = graph.getVerticesIndices();\n  let salesmanPath = [];\n  let salesmanPathWeight = null;\n  for (let cycleIndex = 0; cycleIndex < allPossibleCycles.length; cycleIndex += 1) {\n    const currentCycle = allPossibleCycles[cycleIndex];\n    const currentCycleWeight = getCycleWeight(adjacencyMatrix, verticesIndices, currentCycle);\n\n    // If current cycle weight is smaller then previous ones treat current cycle as most optimal.\n    if (salesmanPathWeight === null || currentCycleWeight < salesmanPathWeight) {\n      salesmanPath = currentCycle;\n      salesmanPathWeight = currentCycleWeight;\n    }\n  }\n\n  // Return the solution.\n  return salesmanPath;\n}\n","filetype":".js","index":44},{"title":"Image-processing","category":"algorithms","id":"image-processing","index":45},{"title":"Seam-carving","category":"image-processing","id":"seam-carving","algorithm":"# Content-aware image resizing in JavaScript\n\n![Content-aware image resizing in JavaScript](https://raw.githubusercontent.com/trekhleb/trekhleb.github.io/master/src/posts/2021/content-aware-image-resizing-in-javascript/assets/01-cover-02.png)\n\n> There is an [interactive version of this post](https://trekhleb.dev/blog/2021/content-aware-image-resizing-in-javascript/) available where you can upload and resize your custom images.\n\n## TL;DR\n\nThere are many great articles written about the *Seam Carving algorithm* already, but I couldn't resist the temptation to explore this elegant, powerful, and *yet simple* algorithm on my own, and to write about my personal experience with it. Another point that drew my attention (as a creator of [javascript-algorithms](https://github.com/trekhleb/javascript-algorithms) repo) was the fact that *Dynamic Programming (DP)* approach might be smoothly applied to solve it. And, if you're like me and still on your \"learning algorithms\" journey, this algorithmic solution may enrich your personal DP arsenal.\n\nSo, with this article I want to do three things:\n\n1. Provide you with an interactive **content-aware resizer** so that you could play around with resizing your own images\n2. Explain the idea behind the **Seam Carving algorithm**\n3. Explain the **dynamic programming approach** to implement the algorithm (we'll be using TypeScript for it)\n\n### Content-aware image resizing\n\n*Content-aware image resizing* might be applied when it comes to changing the image proportions (i.e. reducing the width while keeping the height) and when losing some parts of the image is not desirable. Doing the straightforward image scaling in this case would distort the objects in it. To preserve the proportions of the objects while changing the image proportions we may use the [Seam Carving algorithm](https://perso.crans.org/frenoy/matlab2012/seamcarving.pdf) that was introduced by *Shai Avidan* and *Ariel Shamir*.\n\nThe example below shows how the original image width was reduced by 50% using *content-aware resizing* (left image) and *straightforward scaling* (right image). In this particular case, the left image looks more natural since the proportions of the balloons were preserved.\n\n![Content-aware image resizing](https://raw.githubusercontent.com/trekhleb/trekhleb.github.io/master/src/posts/2021/content-aware-image-resizing-in-javascript/assets/01-resizing-options.png)\n\nThe Seam Carving algorithm's idea is to find the *seam* (continuous sequence of pixels) with the lowest contribution to the image content and then *carve* (remove) it. This process repeats over and over again until we get the required image width or height. In the example below you may see that the hot air balloon pixels contribute more to the content of the image than the sky pixels. Thus, the sky pixels are being removed first.\n\n![JS IMAGE CARVER DEMO](https://raw.githubusercontent.com/trekhleb/trekhleb.github.io/master/src/posts/2021/content-aware-image-resizing-in-javascript/assets/10-demo-01.gif)\n\nFinding the seam with the lowest energy is a computationally expensive task (especially for large images). To make the seam search faster the *dynamic programming* approach might be applied (we will go through the implementation details below).\n\n### Objects removal\n\nThe importance of each pixel (so-called pixel's energy) is being calculated based on its color (`R`, `G`, `B`, `A`) difference between two neighbor pixels. Now, if we set the pixel energy to some really low level artificially (i.e. by drawing a mask on top of them), the Seam Carving algorithm would perform an **object removal** for us for free.\n\n![JS IMAGE CARVER OBJECT REMOVAL DEMO](https://raw.githubusercontent.com/trekhleb/trekhleb.github.io/master/src/posts/2021/content-aware-image-resizing-in-javascript/assets/10-demo-02.gif)\n\n### JS IMAGE CARVER demo\n\nI've created the [JS IMAGE CARVER](https://trekhleb.dev/js-image-carver/) web-app (and also [open-sourced it on GitHub](https://github.com/trekhleb/js-image-carver)) that you may use to play around with resizing of your custom images.\n\n### More examples\n\nHere are some more examples of how the algorithm copes with more complex backgrounds.\n\nMountains on the background are being shrunk smoothly without visible seams.\n\n![Resizing demo with more complex backgrounds](https://raw.githubusercontent.com/trekhleb/trekhleb.github.io/master/src/posts/2021/content-aware-image-resizing-in-javascript/assets/11-demo-01.png)\n\nThe same goes for the ocean waves. The algorithm preserved the wave structure without distorting the surfers.\n\n![Resizing demo with more complex backgrounds](https://raw.githubusercontent.com/trekhleb/trekhleb.github.io/master/src/posts/2021/content-aware-image-resizing-in-javascript/assets/11-demo-02.png)\n\nWe need to keep in mind that the Seam Carving algorithm is not a silver bullet, and it may fail to resize the images where *most of the pixels are edges* (look important to the algorithm). In this case, it starts distorting even the important parts of the image. In the example below the content-aware image resizing looks pretty similar to a straightforward scaling since for the algorithm all the pixels look important, and it is hard for it to distinguish Van Gogh's face from the background.\n\n![Example when the algorithm does not work as expected](https://raw.githubusercontent.com/trekhleb/trekhleb.github.io/master/src/posts/2021/content-aware-image-resizing-in-javascript/assets/12-demo-01.png)\n\n## How Seam Carving algorithms works\n\nImagine we have a `1000 x 500 px` picture, and we want to change its size to `500 x 500 px` to make it square (let's say the square ratio would better fit the Instagram feed). We might want to set up several **requirements to the resizing process** in this case:\n\n- *Preserve the important parts of the image* (i.e. if there were 5 trees before the resizing we want to have 5 trees after resizing as well).\n- *Preserve the proportions* of the important parts of the image (i.e. circle car wheels should not be squeezed to the ellipse wheels)\n\nTo avoid changing the important parts of the image we may find the **continuous sequence of pixels (the seam)**, that goes from top to bottom and has *the lowest contribution to the content* of the image (avoids important parts) and then remove it. The seam removal will shrink the image by 1 pixel. We will then repeat this step until the image will get the desired width.\n\nThe question is how to define *the importance of the pixel* and its contribution to the content (in the original paper the authors are using the term **energy of the pixel**). One of the ways to do it is to treat all the pixels that form the edges as important ones. In case if a pixel is a part of the edge its color would have a greater difference between the neighbors (left and right pixels) than the pixel that isn't a part of the edge.\n\n![Pixels color difference](https://raw.githubusercontent.com/trekhleb/trekhleb.github.io/master/src/posts/2021/content-aware-image-resizing-in-javascript/assets/30-pixel-energy-comparison.png)\n\nAssuming that the color of a pixel is represented by *4* numbers (`R` - red, `G` - green, `B` - blue, `A` - alpha) we may use the following formula to calculate the color difference (the pixel energy):\n\n![Pixel energy formula](https://raw.githubusercontent.com/trekhleb/trekhleb.github.io/master/src/posts/2021/content-aware-image-resizing-in-javascript/assets/20-energy-formula.png)\n\nWhere:\n\n- `mEnergy` - *Energy* (importance) of the *middle* pixel (`[0..626]` if rounded)\n- `lR` - *Red* channel value for the *left* pixel (`[0..255]`)\n- `mR` - *Red* channel value for the *middle* pixel (`[0..255]`)\n- `rR` - *Red* channel value for the *right* pixel (`[0..255]`)\n- `lG` - *Green* channel value for the *left* pixel (`[0..255]`)\n- and so on...\n\nIn the formula above we're omitting the alpha (transparency) channel, for now, assuming that there are no transparent pixels in the image. Later we will use the alpha channel for masking and for object removal.\n\n![Example of pixel energy calculation](https://raw.githubusercontent.com/trekhleb/trekhleb.github.io/master/src/posts/2021/content-aware-image-resizing-in-javascript/assets/30-pixel-energy-calculation-example.png)\n\nNow, since we know how to find the energy of one pixel, we can calculate, so-called, **energy map** which will contain the energies of each pixel of the image. On each resizing step the energy map should be re-calculated (at least partially, more about it below) and would have the same size as the image.\n\nFor example, on the 1st resizing step we will have a `1000 x 500` image and a `1000 x 500` energy map. On the 2nd resizing step we will remove the seam from the image and re-calculate the energy map based on the new shrunk image. Thus, we will get a `999 x 500` image and a `999 x 500` energy map.\n\nThe higher the energy of the pixel the more likely it is a part of an edge, and it is important for the image content and the less likely that we need to remove it.\n\nTo visualize the energy map we may assign a brighter color to the pixels with the higher energy and darker colors to the pixels with the lower energy. Here is an artificial example of how the random part of the energy map might look like. You may see the bright line which represents the edge and which we want to preserve during the resizing.\n\n![Energy map sketch](https://raw.githubusercontent.com/trekhleb/trekhleb.github.io/master/src/posts/2021/content-aware-image-resizing-in-javascript/assets/30-energy-map-padding.png)\n\nHere is a real example of the energy map for the demo image you saw above (with hot air balloons).\n\n![Energy map example](https://raw.githubusercontent.com/trekhleb/trekhleb.github.io/master/src/posts/2021/content-aware-image-resizing-in-javascript/assets/40-energy-map.png)\n\nYou may play around with your custom images and see how the energy map would look like in the [interactive version of the post](https://trekhleb.dev/blog/2021/content-aware-image-resizing-in-javascript/).\n\nWe may use the energy map to find the seams (one after another) with the lowest energy and by doing this to decide which pixels should be ultimately deleted.\n\n![Searching the seam](https://raw.githubusercontent.com/trekhleb/trekhleb.github.io/master/src/posts/2021/content-aware-image-resizing-in-javascript/assets/41-seam-search.png)\n\nFinding the seam with the lowest energy is not a trivial task and requires exploring many possible pixel combinations before making the decision. We will apply the dynamic programming approach to speed it up.\n\nIn the example below, you may see the energy map with the first lowest energy seam that was found for it.\n\n![Energy map example with seam](https://raw.githubusercontent.com/trekhleb/trekhleb.github.io/master/src/posts/2021/content-aware-image-resizing-in-javascript/assets/40-energy-map-with-seam.png)\n\nIn the examples above we were reducing the width of the image. A similar approach may be taken to reduce the image height. We need to \"rotate\" the approach though:\n\n- start using *top* and *bottom* pixel neighbors (instead of *left* and *right* ones) to calculate the pixel energy\n- when searching for a seam we need to move from *left* to *right* (instead of from *up* to *bottom*)\n\n## Implementation in TypeScript\n\n> You may find the source code, and the functions mentioned below in the [js-image-carver](https://github.com/trekhleb/js-image-carver) repository.\n\nTo implement the algorithm we will be using TypeScript. If you want a JavaScript version, you may ignore (remove) type definitions and their usages.\n\nFor simplicity reasons let's implement the seam carving algorithm only for the image *width* reduction.\n\n### Content-aware width resizing (the entry function)\n\nFirst, let's define some common types that we're going to use while implementing the algorithm.\n\n```typescript\n// Type that describes the image size (width and height).\ntype ImageSize = { w: number, h: number };\n\n// The coordinate of the pixel.\ntype Coordinate = { x: number, y: number };\n\n// The seam is a sequence of pixels (coordinates).\ntype Seam = Coordinate[];\n\n// Energy map is a 2D array that has the same width and height\n// as the image the map is being calculated for.\ntype EnergyMap = number[][];\n\n// Type that describes the image pixel's RGBA color.\ntype Color = [\n  r: number, // Red\n  g: number, // Green\n  b: number, // Blue\n  a: number, // Alpha (transparency)\n] | Uint8ClampedArray;\n```\n\nOn the high level the algorithm consists of the following steps:\n\n1. Calculate the **energy map** for the current version of the image.\n2. Find the **seam** with the lowest energy based on the energy map (this is where we will apply Dynamic Programming).\n3. **Delete the seam** with the lowest energy seam from the image.\n4. **Repeat** until the image width is reduced to the desired value.\n\n```typescript\ntype ResizeImageWidthArgs = {\n  img: ImageData, // Image data we want to resize.\n  toWidth: number, // Final image width we want the image to shrink to.\n};\n\ntype ResizeImageWidthResult = {\n  img: ImageData, // Resized image data.\n  size: ImageSize, // Resized image size (w x h).\n};\n\n// Performs the content-aware image width resizing using the seam carving method.\nexport const resizeImageWidth = (\n  { img, toWidth }: ResizeImageWidthArgs,\n): ResizeImageWidthResult => {\n  // For performance reasons we want to avoid changing the img data array size.\n  // Instead we'll just keep the record of the resized image width and height separately.\n  const size: ImageSize = { w: img.width, h: img.height };\n\n  // Calculating the number of pixels to remove.\n  const pxToRemove = img.width - toWidth;\n  if (pxToRemove < 0) {\n    throw new Error('Upsizing is not supported for now');\n  }\n\n  let energyMap: EnergyMap | null = null;\n  let seam: Seam | null = null;\n\n  // Removing the lowest energy seams one by one.\n  for (let i = 0; i < pxToRemove; i += 1) {\n    // 1. Calculate the energy map for the current version of the image.\n    energyMap = calculateEnergyMap(img, size);\n\n    // 2. Find the seam with the lowest energy based on the energy map.\n    seam = findLowEnergySeam(energyMap, size);\n\n    // 3. Delete the seam with the lowest energy seam from the image.\n    deleteSeam(img, seam, size);\n\n    // Reduce the image width, and continue iterations.\n    size.w -= 1;\n  }\n\n  // Returning the resized image and its final size.\n  // The img is actually a reference to the ImageData, so technically\n  // the caller of the function already has this pointer. But let's\n  // still return it for better code readability.\n  return { img, size };\n};\n```\n\nThe image that needs to be resized is being passed to the function in [ImageData](https://developer.mozilla.org/en-US/docs/Web/API/ImageData) format. You may draw the image on the canvas and then extract the ImageData from the canvas like this:\n\n```javascript\nconst ctx = canvas.getContext('2d');\nconst imgData = ctx.getImageData(0, 0, imgWidth, imgHeight);\n```\n\n> The way of uploading and drawing images in JavaScript is out of scope for this article, but you may find the complete source code of how it may be done using React in [js-image-carver](https://github.com/trekhleb/js-image-carver) repo.\n\nLet's break down each step ony be one and implement the `calculateEnergyMap()`, `findLowEnergySeam()` and `deleteSeam()` functions.\n\n### Calculating the pixel's energy\n\nHere we apply the color difference formula described above. For the left and right borders (when there are no left or right neighbors), we ignore the neighbors and don't take them into account during the energy calculation.\n\n```typescript\n// Calculates the energy of a pixel.\nconst getPixelEnergy = (left: Color | null, middle: Color, right: Color | null): number => {\n  // Middle pixel is the pixel we're calculating the energy for.\n  const [mR, mG, mB] = middle;\n\n  // Energy from the left pixel (if it exists).\n  let lEnergy = 0;\n  if (left) {\n    const [lR, lG, lB] = left;\n    lEnergy = (lR - mR) ** 2 + (lG - mG) ** 2 + (lB - mB) ** 2;\n  }\n\n  // Energy from the right pixel (if it exists).\n  let rEnergy = 0;\n  if (right) {\n    const [rR, rG, rB] = right;\n    rEnergy = (rR - mR) ** 2 + (rG - mG) ** 2 + (rB - mB) ** 2;\n  }\n\n  // Resulting pixel energy.\n  return Math.sqrt(lEnergy + rEnergy);\n};\n```\n\n### Calculating the energy map\n\nThe image we're working with has the [ImageData](https://developer.mozilla.org/en-US/docs/Web/API/ImageData) format. It means that all the pixels (and their colors) are stored in a flat (*1D*) [Uint8ClampedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray) array. For readability purposes let's introduce the couple of helper functions that will allow us to work with the Uint8ClampedArray array as with a *2D* matrix instead.\n\n```typescript\n// Helper function that returns the color of the pixel.\nconst getPixel = (img: ImageData, { x, y }: Coordinate): Color => {\n  // The ImageData data array is a flat 1D array.\n  // Thus we need to convert x and y coordinates to the linear index.\n  const i = y * img.width + x;\n  const cellsPerColor = 4; // RGBA\n  // For better efficiency, instead of creating a new sub-array we return\n  // a pointer to the part of the ImageData array.\n  return img.data.subarray(i * cellsPerColor, i * cellsPerColor + cellsPerColor);\n};\n\n// Helper function that sets the color of the pixel.\nconst setPixel = (img: ImageData, { x, y }: Coordinate, color: Color): void => {\n  // The ImageData data array is a flat 1D array.\n  // Thus we need to convert x and y coordinates to the linear index.\n  const i = y * img.width + x;\n  const cellsPerColor = 4; // RGBA\n  img.data.set(color, i * cellsPerColor);\n};\n```\n\nTo calculate the energy map we go through each image pixel and call the previously described `getPixelEnergy()` function against it.\n\n```typescript\n// Helper function that creates a matrix (2D array) of specific\n// size (w x h) and fills it with specified value.\nconst matrix = <T>(w: number, h: number, filler: T): T[][] => {\n  return new Array(h)\n    .fill(null)\n    .map(() => {\n      return new Array(w).fill(filler);\n    });\n};\n\n// Calculates the energy of each pixel of the image.\nconst calculateEnergyMap = (img: ImageData, { w, h }: ImageSize): EnergyMap => {\n  // Create an empty energy map where each pixel has infinitely high energy.\n  // We will update the energy of each pixel.\n  const energyMap: number[][] = matrix<number>(w, h, Infinity);\n  for (let y = 0; y < h; y += 1) {\n    for (let x = 0; x < w; x += 1) {\n      // Left pixel might not exist if we're on the very left edge of the image.\n      const left = (x - 1) >= 0 ? getPixel(img, { x: x - 1, y }) : null;\n      // The color of the middle pixel that we're calculating the energy for.\n      const middle = getPixel(img, { x, y });\n      // Right pixel might not exist if we're on the very right edge of the image.\n      const right = (x + 1) < w ? getPixel(img, { x: x + 1, y }) : null;\n      energyMap[y][x] = getPixelEnergy(left, middle, right);\n    }\n  }\n  return energyMap;\n};\n```\n\n> The energy map is going to be recalculated on every resize iteration. It means that it will be recalculated, let's say, 500 times if we need to shrink the image by 500 pixels which is not optimal. To speed up the energy map calculation on the 2nd, 3rd, and further steps, we may re-calculate the energy only for those pixels that are placed around the seam that is going to be removed. For simplicity reasons this optimization is omitted here, but you may find the example source-code in [js-image-carver](https://github.com/trekhleb/js-image-carver) repo.\n\n### Finding the seam with the lowest energy (Dynamic Programming approach)\n\n> I've described some Dynamic Programming basics in [Dynamic Programming vs Divide-and-Conquer](https://trekhleb.dev/blog/2018/dynamic-programming-vs-divide-and-conquer/) article before. There is a DP example based on the minimum edit distance problem. You might want to check it out to get some more context.\n\nThe issue we need to solve now is to find the path (the seam) on the energy map that goes from top to bottom and has the minimum sum of pixel energies.\n\n#### The naive approach\n\nThe naive approach would be to check all possible paths one after another.\n\n![The naive approach](https://raw.githubusercontent.com/trekhleb/trekhleb.github.io/master/src/posts/2021/content-aware-image-resizing-in-javascript/assets/50-naive-approach.png)\n\nGoing from top to bottom, for each pixel, we have 3 options (↙︎ go down-left, ↓ go down, ↘︎ go down-right). This gives us the time complexity of `O(w * 3^h)` or simply `O(3^h)`, where `w` and `h` are the width and the height of the image. This approach looks slow.\n\n#### The greedy approach\n\nWe may also try to choose the next pixel as a pixel with the lowest energy, hoping that the resulting seam energy will be the smallest one.\n\n![The greedy approach](https://raw.githubusercontent.com/trekhleb/trekhleb.github.io/master/src/posts/2021/content-aware-image-resizing-in-javascript/assets/51-greedy-approach.png)\n\nThis approach gives not the worst solution, but it cannot guarantee that we will find the best available solution. On the image above you may see how the greedy approach chose `5` instead of `10` at first and missed the chain of optimal pixels.\n\nThe good part about this approach is that it is fast, and it has a time complexity of `O(w + h)`, where `w` and `h` are the width and the height of the image. In this case, the cost of the speed is the low quality of resizing. We need to find a minimum value in the first row (traversing `w` cells) and then we explore only 3 neighbor pixels for each row (traversing `h` rows).\n\n#### The dynamic programming approach\n\nYou might have noticed that in the naive approach we summed up the same pixel energies over and over again while calculating the resulting seams' energy.\n\n![Repeated problems](https://raw.githubusercontent.com/trekhleb/trekhleb.github.io/master/src/posts/2021/content-aware-image-resizing-in-javascript/assets/52-dp-repeated-problems.png)\n\nIn the example above you see that for the first two seams we are re-using the energy of the shorter seam (which has the energy of `235`). Instead of doing just one operation `235 + 70` to calculate the energy of the 2nd seam we're doing four operations `(5 + 0 + 80 + 150) + 70`.\n\n> This fact that we're re-using the energy of the previous seam to calculate the current seam's energy might be applied recursively to all the shorter seams up to the very top 1st row seam. When we have such overlapping sub-problems, [it is a sign](https://trekhleb.dev/blog/2018/dynamic-programming-vs-divide-and-conquer/) that the general problem *might* be optimized by dynamic programming approach.\n\nSo, we may **save the energy of the current seam** at the particular pixel in an additional `seamsEnergies` table to make it re-usable for calculating the next seams faster (the `seamsEnergies` table will have the same size as the energy map and the image itself).\n\nLet's also keep in mind that for one particular pixel on the image (i.e. the bottom left one) we may have *several* values of the previous seams energies.\n\n![What seam to choose](https://raw.githubusercontent.com/trekhleb/trekhleb.github.io/master/src/posts/2021/content-aware-image-resizing-in-javascript/assets/53-dp-what-to-choose.png)\n\nSince we're looking for a seam with the lowest resulting energy it would make sense to pick the previous seam with the lowest resulting energy as well.\n\n![Seams energies example](https://raw.githubusercontent.com/trekhleb/trekhleb.github.io/master/src/posts/2021/content-aware-image-resizing-in-javascript/assets/56-dp-seams-energies-example.png)\n\nIn general, we have three possible previous seems to choose from:\n\n![Three options to choose from](https://raw.githubusercontent.com/trekhleb/trekhleb.github.io/master/src/posts/2021/content-aware-image-resizing-in-javascript/assets/55-dp-three-options.png)\n\nYou may think about it this way:\n\n- The cell `[1][x]`: contains the lowest possible energy of the seam that starts somewhere on the row `[0][?]` and ends up at cell `[1][x]`\n- **The current cell** `[2][3]`: contains the lowest possible energy of the seam that starts somewhere on the row `[0][?]` and ends up at cell `[2][3]`. To calculate it we need to sum up the energy of the current pixel `[2][3]` (from the energy map) with the `min(seam_energy_1_2, seam_energy_1_3, seam_energy_1_4)`\n\nIf we fill the `seamsEnergies` table completely, then the minimum number in the lowest row would be the lowest possible seam energy.\n\nLet's try to fill several cells of this table to see how it works.\n\n![Seams energies map traversal](https://raw.githubusercontent.com/trekhleb/trekhleb.github.io/master/src/posts/2021/content-aware-image-resizing-in-javascript/assets/57-dp-seams-energies-traversal.png)\n\nAfter filling out the `seamsEnergies` table we may see that the lowest energy pixel has an energy of `50`. For convenience, during the `seamsEnergies` generation for each pixel, we may save not only the energy of the seam but also the coordinates of the previous lowest energy seam. This will give us the possibility to reconstruct the seam path from the bottom to the top easily.\n\nThe time complexity of DP approach would be `O(w * h)`, where `w` and `h` are the width and the height of the image. We need to calculate energies for *every* pixel of the image.\n\nHere is an example of how this logic might be implemented:\n\n```typescript\n// The metadata for the pixels in the seam.\ntype SeamPixelMeta = {\n  energy: number, // The energy of the pixel.\n  coordinate: Coordinate, // The coordinate of the pixel.\n  previous: Coordinate | null, // The previous pixel in a seam.\n};\n\n// Finds the seam (the sequence of pixels from top to bottom) that has the\n// lowest resulting energy using the Dynamic Programming approach.\nconst findLowEnergySeam = (energyMap: EnergyMap, { w, h }: ImageSize): Seam => {\n  // The 2D array of the size of w and h, where each pixel contains the\n  // seam metadata (pixel energy, pixel coordinate and previous pixel from\n  // the lowest energy seam at this point).\n  const seamsEnergies: (SeamPixelMeta | null)[][] = matrix<SeamPixelMeta | null>(w, h, null);\n\n  // Populate the first row of the map by just copying the energies\n  // from the energy map.\n  for (let x = 0; x < w; x += 1) {\n    const y = 0;\n    seamsEnergies[y][x] = {\n      energy: energyMap[y][x],\n      coordinate: { x, y },\n      previous: null,\n    };\n  }\n\n  // Populate the rest of the rows.\n  for (let y = 1; y < h; y += 1) {\n    for (let x = 0; x < w; x += 1) {\n      // Find the top adjacent cell with minimum energy.\n      // This cell would be the tail of a seam with lowest energy at this point.\n      // It doesn't mean that this seam (path) has lowest energy globally.\n      // Instead, it means that we found a path with the lowest energy that may lead\n      // us to the current pixel with the coordinates x and y.\n      let minPrevEnergy = Infinity;\n      let minPrevX: number = x;\n      for (let i = (x - 1); i <= (x + 1); i += 1) {\n        if (i >= 0 && i < w && seamsEnergies[y - 1][i].energy < minPrevEnergy) {\n          minPrevEnergy = seamsEnergies[y - 1][i].energy;\n          minPrevX = i;\n        }\n      }\n\n      // Update the current cell.\n      seamsEnergies[y][x] = {\n        energy: minPrevEnergy + energyMap[y][x],\n        coordinate: { x, y },\n        previous: { x: minPrevX, y: y - 1 },\n      };\n    }\n  }\n\n  // Find where the minimum energy seam ends.\n  // We need to find the tail of the lowest energy seam to start\n  // traversing it from its tail to its head (from the bottom to the top).\n  let lastMinCoordinate: Coordinate | null = null;\n  let minSeamEnergy = Infinity;\n  for (let x = 0; x < w; x += 1) {\n    const y = h - 1;\n    if (seamsEnergies[y][x].energy < minSeamEnergy) {\n      minSeamEnergy = seamsEnergies[y][x].energy;\n      lastMinCoordinate = { x, y };\n    }\n  }\n\n  // Find the lowest energy energy seam.\n  // Once we know where the tail is we may traverse and assemble the lowest\n  // energy seam based on the \"previous\" value of the seam pixel metadata.\n  const seam: Seam = [];\n  if (!lastMinCoordinate) {\n    return seam;\n  }\n\n  const { x: lastMinX, y: lastMinY } = lastMinCoordinate;\n\n  // Adding new pixel to the seam path one by one until we reach the top.\n  let currentSeam = seamsEnergies[lastMinY][lastMinX];\n  while (currentSeam) {\n    seam.push(currentSeam.coordinate);\n    const prevMinCoordinates = currentSeam.previous;\n    if (!prevMinCoordinates) {\n      currentSeam = null;\n    } else {\n      const { x: prevMinX, y: prevMinY } = prevMinCoordinates;\n      currentSeam = seamsEnergies[prevMinY][prevMinX];\n    }\n  }\n\n  return seam;\n};\n```\n\n### Removing the seam with the lowest energy\n\nOnce we found the lowest energy seam, we need to remove (to carve) the pixels that form it from the image. The removal is happening by shifting the pixels to the right of the seam by `1px` to the left. For performance reasons, we don't actually delete the last columns. Instead, the rendering component will just ignore the part of the image that lays beyond the resized image width.\n\n![Deleting the seam](https://raw.githubusercontent.com/trekhleb/trekhleb.github.io/master/src/posts/2021/content-aware-image-resizing-in-javascript/assets/60-deleting-example.png)\n\n```typescript\n// Deletes the seam from the image data.\n// We delete the pixel in each row and then shift the rest of the row pixels to the left.\nconst deleteSeam = (img: ImageData, seam: Seam, { w }: ImageSize): void => {\n  seam.forEach(({ x: seamX, y: seamY }: Coordinate) => {\n    for (let x = seamX; x < (w - 1); x += 1) {\n      const nextPixel = getPixel(img, { x: x + 1, y: seamY });\n      setPixel(img, { x, y: seamY }, nextPixel);\n    }\n  });\n};\n```\n\n## Objects removal\n\nThe Seam Carving algorithm tries to remove the seams which consist of low energy pixels first. We could leverage this fact and by assigning low energy to some pixels manually (i.e. by drawing on the image and masking out some areas of it) we could make the Seam Carving algorithm to do *objects removal* for us for free.\n\nCurrently, in `getPixelEnergy()` function we were using only the `R`, `G`, `B` color channels to calculate the pixel's energy. But there is also the `A` (alpha, transparency) parameter of the color that we didn't use yet. We may use the transparency channel to tell the algorithm that transparent pixels are the pixels we want to remove. You may check the [source-code of the energy function](https://github.com/trekhleb/js-image-carver/blob/main/src/utils/contentAwareResizer.ts#L54) that takes transparency into account.\n\nHere is how the algorithm works for object removal.\n\n![JS IMAGE CARVER OBJECT REMOVAL DEMO](https://raw.githubusercontent.com/trekhleb/trekhleb.github.io/master/src/posts/2021/content-aware-image-resizing-in-javascript/assets/10-demo-02.gif)\n\n## Issues and what's next\n\nThe [JS IMAGE CARVER](https://github.com/trekhleb/js-image-carver) web app is far from being a production ready resizer of course. Its main purpose was to experiment with the Seam Carving algorithm interactively. So the plan for the future is to continue experimentation.\n\nThe [original paper](https://perso.crans.org/frenoy/matlab2012/seamcarving.pdf) describes how the Seam Carving algorithm might be used not only for the downscaling but also for the **upscaling of the images**. The upscaling, in turn, might be used to **upscale the image back to its original width after the objects' removal**.\n\nAnother interesting area of experimentation might be to make the algorithm work in a **real-time**.\n\n> Those are the plans for the future, but for now, I hope that the example with image downsizing was interesting and useful for you. I also hope that you've got the idea of using dynamic programming to implement it.\n>\n> So, good luck with your own experiments!\n","filetype":".md","index":46},{"title":"__tests__","category":"seam-carving","id":"__tests__","index":47},{"title":"Resize Image Width.test","category":"__tests__","id":"resizeImageWidth.test___tests__","algorithm":"import { createCanvas, loadImage } from 'canvas';\nimport resizeImageWidth from '../resizeImageWidth';\n\nconst testImageBeforePath = './src/algorithms/image-processing/seam-carving/__tests__/test-image-before.jpg';\nconst testImageAfterPath = './src/algorithms/image-processing/seam-carving/__tests__/test-image-after.jpg';\n\n/**\n * Compares two images and finds the number of different pixels.\n *\n * @param {ImageData} imgA - ImageData for the first image.\n * @param {ImageData} imgB - ImageData for the second image.\n * @param {number} threshold - Color difference threshold [0..255]. Smaller - stricter.\n * @returns {number} - Number of different pixels.\n */\nfunction pixelsDiff(imgA, imgB, threshold = 0) {\n  if (imgA.width !== imgB.width || imgA.height !== imgB.height) {\n    throw new Error('Images must have the same size');\n  }\n\n  let differentPixels = 0;\n  const numColorParams = 4; // RGBA\n\n  for (let pixelIndex = 0; pixelIndex < imgA.data.length; pixelIndex += numColorParams) {\n    // Get pixel's color for each image.\n    const [aR, aG, aB] = imgA.data.subarray(pixelIndex, pixelIndex + numColorParams);\n    const [bR, bG, bB] = imgB.data.subarray(pixelIndex, pixelIndex + numColorParams);\n\n    // Get average pixel's color for each image (make them greyscale).\n    const aAvgColor = Math.floor((aR + aG + aB) / 3);\n    const bAvgColor = Math.floor((bR + bG + bB) / 3);\n\n    // Compare pixel colors.\n    if (Math.abs(aAvgColor - bAvgColor) > threshold) {\n      differentPixels += 1;\n    }\n  }\n\n  return differentPixels;\n}\n\ndescribe('resizeImageWidth', () => {\n  it('should perform content-aware image width reduction', () => {\n    // @see: https://jestjs.io/docs/asynchronous\n    return Promise.all([\n      loadImage(testImageBeforePath),\n      loadImage(testImageAfterPath),\n    ]).then(([imgBefore, imgAfter]) => {\n      // Original image.\n      const canvasBefore = createCanvas(imgBefore.width, imgBefore.height);\n      const ctxBefore = canvasBefore.getContext('2d');\n      ctxBefore.drawImage(imgBefore, 0, 0, imgBefore.width, imgBefore.height);\n      const imgDataBefore = ctxBefore.getImageData(0, 0, imgBefore.width, imgBefore.height);\n\n      // Resized image saved.\n      const canvasAfter = createCanvas(imgAfter.width, imgAfter.height);\n      const ctxAfter = canvasAfter.getContext('2d');\n      ctxAfter.drawImage(imgAfter, 0, 0, imgAfter.width, imgAfter.height);\n      const imgDataAfter = ctxAfter.getImageData(0, 0, imgAfter.width, imgAfter.height);\n\n      const toWidth = Math.floor(imgBefore.width / 2);\n\n      const {\n        img: resizedImg,\n        size: resizedSize,\n      } = resizeImageWidth({ img: imgDataBefore, toWidth });\n\n      expect(resizedImg).toBeDefined();\n      expect(resizedSize).toBeDefined();\n\n      // Resized image generated.\n      const canvasTest = createCanvas(resizedSize.w, resizedSize.h);\n      const ctxTest = canvasTest.getContext('2d');\n      ctxTest.putImageData(resizedImg, 0, 0, 0, 0, resizedSize.w, resizedSize.h);\n      const imgDataTest = ctxTest.getImageData(0, 0, resizedSize.w, resizedSize.h);\n\n      expect(resizedSize).toEqual({ w: toWidth, h: imgBefore.height });\n      expect(imgDataTest.width).toBe(toWidth);\n      expect(imgDataTest.height).toBe(imgBefore.height);\n      expect(imgDataTest.width).toBe(imgAfter.width);\n      expect(imgDataTest.height).toBe(imgAfter.height);\n\n      const colorThreshold = 50;\n      const differentPixels = pixelsDiff(imgDataTest, imgDataAfter, colorThreshold);\n\n      // Allow 10% of pixels to be different\n      const pixelsThreshold = Math.floor((imgAfter.width * imgAfter.height) / 10);\n\n      expect(differentPixels).toBeLessThanOrEqual(pixelsThreshold);\n    });\n  });\n});\n","filetype":".js","index":48},{"title":"Resize Image Width","category":"seam-carving","id":"resizeImageWidth_seam-carving","algorithm":"import { getPixel, setPixel } from '../utils/imageData';\n\n/**\n * The seam is a sequence of pixels (coordinates).\n * @typedef {PixelCoordinate[]} Seam\n */\n\n/**\n * Energy map is a 2D array that has the same width and height\n * as the image the map is being calculated for.\n * @typedef {number[][]} EnergyMap\n */\n\n/**\n * The metadata for the pixels in the seam.\n * @typedef {Object} SeamPixelMeta\n * @property {number} energy - the energy of the pixel.\n * @property {PixelCoordinate} coordinate - the coordinate of the pixel.\n * @property {?PixelCoordinate} previous - the previous pixel in a seam.\n */\n\n/**\n * Type that describes the image size (width and height)\n * @typedef {Object} ImageSize\n * @property {number} w - image width.\n * @property {number} h - image height.\n */\n\n/**\n * @typedef {Object} ResizeImageWidthArgs\n * @property {ImageData} img - image data we want to resize.\n * @property {number} toWidth - final image width we want the image to shrink to.\n */\n\n/**\n * @typedef {Object} ResizeImageWidthResult\n * @property {ImageData} img - resized image data.\n * @property {ImageSize} size - resized image size.\n */\n\n/**\n * Helper function that creates a matrix (2D array) of specific\n * size (w x h) and fills it with specified value.\n * @param {number} w\n * @param {number} h\n * @param {?(number | SeamPixelMeta)} filler\n * @returns {?(number | SeamPixelMeta)[][]}\n */\nconst matrix = (w, h, filler) => {\n  return new Array(h)\n    .fill(null)\n    .map(() => {\n      return new Array(w).fill(filler);\n    });\n};\n\n/**\n * Calculates the energy of a pixel.\n * @param {?PixelColor} left\n * @param {PixelColor} middle\n * @param {?PixelColor} right\n * @returns {number}\n */\nconst getPixelEnergy = (left, middle, right) => {\n  // Middle pixel is the pixel we're calculating the energy for.\n  const [mR, mG, mB] = middle;\n\n  // Energy from the left pixel (if it exists).\n  let lEnergy = 0;\n  if (left) {\n    const [lR, lG, lB] = left;\n    lEnergy = (lR - mR) ** 2 + (lG - mG) ** 2 + (lB - mB) ** 2;\n  }\n\n  // Energy from the right pixel (if it exists).\n  let rEnergy = 0;\n  if (right) {\n    const [rR, rG, rB] = right;\n    rEnergy = (rR - mR) ** 2 + (rG - mG) ** 2 + (rB - mB) ** 2;\n  }\n\n  // Resulting pixel energy.\n  return Math.sqrt(lEnergy + rEnergy);\n};\n\n/**\n * Calculates the energy of each pixel of the image.\n * @param {ImageData} img\n * @param {ImageSize} size\n * @returns {EnergyMap}\n */\nconst calculateEnergyMap = (img, { w, h }) => {\n  // Create an empty energy map where each pixel has infinitely high energy.\n  // We will update the energy of each pixel.\n  const energyMap = matrix(w, h, Infinity);\n  for (let y = 0; y < h; y += 1) {\n    for (let x = 0; x < w; x += 1) {\n      // Left pixel might not exist if we're on the very left edge of the image.\n      const left = (x - 1) >= 0 ? getPixel(img, { x: x - 1, y }) : null;\n      // The color of the middle pixel that we're calculating the energy for.\n      const middle = getPixel(img, { x, y });\n      // Right pixel might not exist if we're on the very right edge of the image.\n      const right = (x + 1) < w ? getPixel(img, { x: x + 1, y }) : null;\n      energyMap[y][x] = getPixelEnergy(left, middle, right);\n    }\n  }\n  return energyMap;\n};\n\n/**\n * Finds the seam (the sequence of pixels from top to bottom) that has the\n * lowest resulting energy using the Dynamic Programming approach.\n * @param {EnergyMap} energyMap\n * @param {ImageSize} size\n * @returns {Seam}\n */\nconst findLowEnergySeam = (energyMap, { w, h }) => {\n  // The 2D array of the size of w and h, where each pixel contains the\n  // seam metadata (pixel energy, pixel coordinate and previous pixel from\n  // the lowest energy seam at this point).\n  const seamPixelsMap = matrix(w, h, null);\n\n  // Populate the first row of the map by just copying the energies\n  // from the energy map.\n  for (let x = 0; x < w; x += 1) {\n    const y = 0;\n    seamPixelsMap[y][x] = {\n      energy: energyMap[y][x],\n      coordinate: { x, y },\n      previous: null,\n    };\n  }\n\n  // Populate the rest of the rows.\n  for (let y = 1; y < h; y += 1) {\n    for (let x = 0; x < w; x += 1) {\n      // Find the top adjacent cell with minimum energy.\n      // This cell would be the tail of a seam with lowest energy at this point.\n      // It doesn't mean that this seam (path) has lowest energy globally.\n      // Instead, it means that we found a path with the lowest energy that may lead\n      // us to the current pixel with the coordinates x and y.\n      let minPrevEnergy = Infinity;\n      let minPrevX = x;\n      for (let i = (x - 1); i <= (x + 1); i += 1) {\n        if (i >= 0 && i < w && seamPixelsMap[y - 1][i].energy < minPrevEnergy) {\n          minPrevEnergy = seamPixelsMap[y - 1][i].energy;\n          minPrevX = i;\n        }\n      }\n\n      // Update the current cell.\n      seamPixelsMap[y][x] = {\n        energy: minPrevEnergy + energyMap[y][x],\n        coordinate: { x, y },\n        previous: { x: minPrevX, y: y - 1 },\n      };\n    }\n  }\n\n  // Find where the minimum energy seam ends.\n  // We need to find the tail of the lowest energy seam to start\n  // traversing it from its tail to its head (from the bottom to the top).\n  let lastMinCoordinate = null;\n  let minSeamEnergy = Infinity;\n  for (let x = 0; x < w; x += 1) {\n    const y = h - 1;\n    if (seamPixelsMap[y][x].energy < minSeamEnergy) {\n      minSeamEnergy = seamPixelsMap[y][x].energy;\n      lastMinCoordinate = { x, y };\n    }\n  }\n\n  // Find the lowest energy energy seam.\n  // Once we know where the tail is we may traverse and assemble the lowest\n  // energy seam based on the \"previous\" value of the seam pixel metadata.\n  const seam = [];\n\n  const { x: lastMinX, y: lastMinY } = lastMinCoordinate;\n\n  // Adding new pixel to the seam path one by one until we reach the top.\n  let currentSeam = seamPixelsMap[lastMinY][lastMinX];\n  while (currentSeam) {\n    seam.push(currentSeam.coordinate);\n    const prevMinCoordinates = currentSeam.previous;\n    if (!prevMinCoordinates) {\n      currentSeam = null;\n    } else {\n      const { x: prevMinX, y: prevMinY } = prevMinCoordinates;\n      currentSeam = seamPixelsMap[prevMinY][prevMinX];\n    }\n  }\n\n  return seam;\n};\n\n/**\n * Deletes the seam from the image data.\n * We delete the pixel in each row and then shift the rest of the row pixels to the left.\n * @param {ImageData} img\n * @param {Seam} seam\n * @param {ImageSize} size\n */\nconst deleteSeam = (img, seam, { w }) => {\n  seam.forEach(({ x: seamX, y: seamY }) => {\n    for (let x = seamX; x < (w - 1); x += 1) {\n      const nextPixel = getPixel(img, { x: x + 1, y: seamY });\n      setPixel(img, { x, y: seamY }, nextPixel);\n    }\n  });\n};\n\n/**\n * Performs the content-aware image width resizing using the seam carving method.\n * @param {ResizeImageWidthArgs} args\n * @returns {ResizeImageWidthResult}\n */\nconst resizeImageWidth = ({ img, toWidth }) => {\n  /**\n   * For performance reasons we want to avoid changing the img data array size.\n   * Instead we'll just keep the record of the resized image width and height separately.\n   * @type {ImageSize}\n   */\n  const size = { w: img.width, h: img.height };\n\n  // Calculating the number of pixels to remove.\n  const pxToRemove = img.width - toWidth;\n\n  let energyMap = null;\n  let seam = null;\n\n  // Removing the lowest energy seams one by one.\n  for (let i = 0; i < pxToRemove; i += 1) {\n    // 1. Calculate the energy map for the current version of the image.\n    energyMap = calculateEnergyMap(img, size);\n\n    // 2. Find the seam with the lowest energy based on the energy map.\n    seam = findLowEnergySeam(energyMap, size);\n\n    // 3. Delete the seam with the lowest energy seam from the image.\n    deleteSeam(img, seam, size);\n\n    // Reduce the image width, and continue iterations.\n    size.w -= 1;\n  }\n\n  // Returning the resized image and its final size.\n  // The img is actually a reference to the ImageData, so technically\n  // the caller of the function already has this pointer. But let's\n  // still return it for better code readability.\n  return { img, size };\n};\n\nexport default resizeImageWidth;\n","filetype":".js","index":49},{"title":"Utils","category":"image-processing","id":"utils","index":50},{"title":"Image Data","category":"utils","id":"imageData_utils","algorithm":"/**\n * @typedef {ArrayLike<number> | Uint8ClampedArray} PixelColor\n */\n\n/**\n * @typedef {Object} PixelCoordinate\n * @property {number} x - horizontal coordinate.\n * @property {number} y - vertical coordinate.\n */\n\n/**\n * Helper function that returns the color of the pixel.\n * @param {ImageData} img\n * @param {PixelCoordinate} coordinate\n * @returns {PixelColor}\n */\nexport const getPixel = (img, { x, y }) => {\n  // The ImageData data array is a flat 1D array.\n  // Thus we need to convert x and y coordinates to the linear index.\n  const i = y * img.width + x;\n  const cellsPerColor = 4; // RGBA\n  // For better efficiency, instead of creating a new sub-array we return\n  // a pointer to the part of the ImageData array.\n  return img.data.subarray(i * cellsPerColor, i * cellsPerColor + cellsPerColor);\n};\n\n/**\n * Helper function that sets the color of the pixel.\n * @param {ImageData} img\n * @param {PixelCoordinate} coordinate\n * @param {PixelColor} color\n */\nexport const setPixel = (img, { x, y }, color) => {\n  // The ImageData data array is a flat 1D array.\n  // Thus we need to convert x and y coordinates to the linear index.\n  const i = y * img.width + x;\n  const cellsPerColor = 4; // RGBA\n  img.data.set(color, i * cellsPerColor);\n};\n","filetype":".js","index":51},{"title":"Linked-list","category":"algorithms","id":"linked-list","index":52},{"title":"Reverse-traversal","category":"linked-list","id":"reverse-traversal","algorithm":"# Reversed Linked List Traversal\n\nThe task is to traverse the given linked list in reversed order.\n\nFor example for the following linked list: \n\n![](https://upload.wikimedia.org/wikipedia/commons/6/6d/Singly-linked-list.svg)\n\nThe order of traversal should be:\n\n```text\n37 → 99 → 12\n```\n\nThe time complexity is `O(n)` because we visit every node only once.\n\n## Reference\n\n- [Wikipedia](https://en.wikipedia.org/wiki/Linked_list)\n","filetype":".md","index":53},{"title":"Reverse Traversal","category":"reverse-traversal","id":"reverseTraversal_reverse-traversal","algorithm":"/**\n * Traversal callback function.\n * @callback traversalCallback\n * @param {*} nodeValue\n */\n\n/**\n * @param {LinkedListNode} node\n * @param {traversalCallback} callback\n */\nfunction reverseTraversalRecursive(node, callback) {\n  if (node) {\n    reverseTraversalRecursive(node.next, callback);\n    callback(node.value);\n  }\n}\n\n/**\n * @param {LinkedList} linkedList\n * @param {traversalCallback} callback\n */\nexport default function reverseTraversal(linkedList, callback) {\n  reverseTraversalRecursive(linkedList.head, callback);\n}\n","filetype":".js","index":54},{"title":"Traversal","category":"linked-list","id":"traversal","algorithm":"# Linked List Traversal\n\n_Read this in other languages:_\n[_Русский_](README.ru-RU.md)\n\nThe task is to traverse the given linked list in straight order.\n\nFor example for the following linked list:\n\n![Singly linked list](https://upload.wikimedia.org/wikipedia/commons/6/6d/Singly-linked-list.svg)\n\nThe order of traversal should be:\n\n```text\n12 → 99 → 37\n```\n\nThe time complexity is `O(n)` because we visit every node only once.\n\n## Reference\n\n- [Wikipedia](https://en.wikipedia.org/wiki/Linked_list)\n","filetype":".md","index":55},{"title":"Traversal","category":"traversal","id":"traversal_traversal","algorithm":"/**\n * Traversal callback function.\n * @callback traversalCallback\n * @param {*} nodeValue\n */\n\n/**\n * @param {LinkedList} linkedList\n * @param {traversalCallback} callback\n */\nexport default function traversal(linkedList, callback) {\n  let currentNode = linkedList.head;\n\n  while (currentNode) {\n    callback(currentNode.value);\n    currentNode = currentNode.next;\n  }\n}\n","filetype":".js","index":56},{"title":"Math","category":"algorithms","id":"math","index":57},{"title":"Bits","category":"math","id":"bits","algorithm":"# Bit Manipulation\n\n_Read this in other languages:_\n[français](README.fr-FR.md),\n[简体中文](README.zh-CN.md).\n\n#### Get Bit\n\nThis method shifts the relevant bit to the zeroth position.\nThen we perform `AND` operation with one which has bit\npattern like `0001`. This clears all bits from the original\nnumber except the relevant one. If the relevant bit is one,\nthe result is `1`, otherwise the result is `0`.\n\n> See [getBit.js](getBit.js) for further details.\n\n#### Set Bit\n\nThis method shifts `1` over by `bitPosition` bits, creating a\nvalue that looks like `00100`. Then we perform `OR` operation\nthat sets specific bit into `1` but it does not affect on\nother bits of the number.\n\n> See [setBit.js](setBit.js) for further details.\n\n#### Clear Bit\n\nThis method shifts `1` over by `bitPosition` bits, creating a\nvalue that looks like `00100`. Than it inverts this mask to get\nthe number that looks like `11011`. Then `AND` operation is\nbeing applied to both the number and the mask. That operation\nunsets the bit.\n\n> See [clearBit.js](clearBit.js) for further details.\n\n#### Update Bit\n\nThis method is a combination of \"Clear Bit\" and \"Set Bit\" methods.\n\n> See [updateBit.js](updateBit.js) for further details.\n\n#### isEven\n\nThis method determines if the number provided is even.\nIt is based on the fact that odd numbers have their last\nright bit to be set to 1.\n\n```text\nNumber: 5 = 0b0101\nisEven: false\n\nNumber: 4 = 0b0100\nisEven: true\n```\n\n> See [isEven.js](isEven.js) for further details.\n\n#### isPositive\n\nThis method determines if the number is positive. It is based on the fact that all positive\nnumbers have their leftmost bit to be set to `0`. However, if the number provided is zero\nor negative zero, it should still return `false`.\n\n```text\nNumber: 1 = 0b0001\nisPositive: true\n\nNumber: -1 = -0b0001\nisPositive: false\n```\n\n> See [isPositive.js](isPositive.js) for further details.\n\n#### Multiply By Two\n\nThis method shifts original number by one bit to the left.\nThus all binary number components (powers of two) are being\nmultiplying by two and thus the number itself is being\nmultiplied by two.\n\n```\nBefore the shift\nNumber: 0b0101 = 5\nPowers of two: 0 + 2^2 + 0 + 2^0\n\nAfter the shift\nNumber: 0b1010 = 10\nPowers of two: 2^3 + 0 + 2^1 + 0\n```\n\n> See [multiplyByTwo.js](multiplyByTwo.js) for further details.\n\n#### Divide By Two\n\nThis method shifts original number by one bit to the right.\nThus all binary number components (powers of two) are being\ndivided by two and thus the number itself is being\ndivided by two without remainder.\n\n```\nBefore the shift\nNumber: 0b0101 = 5\nPowers of two: 0 + 2^2 + 0 + 2^0\n\nAfter the shift\nNumber: 0b0010 = 2\nPowers of two: 0 + 0 + 2^1 + 0\n```\n\n> See [divideByTwo.js](divideByTwo.js) for further details.\n\n#### Switch Sign\n\nThis method make positive numbers to be negative and backwards.\nTo do so it uses \"Twos Complement\" approach which does it by\ninverting all of the bits of the number and adding 1 to it.\n\n```\n1101 -3\n1110 -2\n1111 -1\n0000  0\n0001  1\n0010  2\n0011  3\n```\n\n> See [switchSign.js](switchSign.js) for further details.\n\n#### Multiply Two Signed Numbers\n\nThis method multiplies two signed integer numbers using bitwise operators.\nThis method is based on the following facts:\n\n```text\na * b can be written in the below formats:\n  0                     if a is zero or b is zero or both a and b are zeroes\n  2a * (b/2)            if b is even\n  2a * (b - 1)/2 + a    if b is odd and positive\n  2a * (b + 1)/2 - a    if b is odd and negative\n```\n\nThe advantage of this approach is that in each recursive step one of the operands\nreduces to half its original value. Hence, the run time complexity is `O(log(b))` where `b` is\nthe operand that reduces to half on each recursive step.\n\n> See [multiply.js](multiply.js) for further details.\n\n#### Multiply Two Unsigned Numbers\n\nThis method multiplies two integer numbers using bitwise operators.\nThis method is based on that \"Every number can be denoted as the sum of powers of 2\".\n\nThe main idea of bitwise multiplication is that every number may be split\nto the sum of powers of two:\n\nI.e.\n\n```text\n19 = 2^4 + 2^1 + 2^0\n```\n\nThen multiplying number `x` by `19` is equivalent of:\n\n```text\nx * 19 = x * 2^4 + x * 2^1 + x * 2^0\n```\n\nNow we need to remember that `x * 2^4` is equivalent of shifting `x` left\nby `4` bits (`x << 4`).\n\n> See [multiplyUnsigned.js](multiplyUnsigned.js) for further details.\n\n#### Count Set Bits\n\nThis method counts the number of set bits in a number using bitwise operators.\nThe main idea is that we shift the number right by one bit at a time and check\nthe result of `&` operation that is `1` if bit is set and `0` otherwise.\n\n```text\nNumber: 5 = 0b0101\nCount of set bits = 2\n```\n\n> See [countSetBits.js](countSetBits.js) for further details.\n\n#### Count Bits to Flip One Number to Another\n\nThis methods outputs the number of bits required to convert one number to another.\nThis makes use of property that when numbers are `XOR`-ed the result will be number\nof different bits.\n\n```\n5 = 0b0101\n1 = 0b0001\nCount of Bits to be Flipped: 1\n```\n\n> See [bitsDiff.js](bitsDiff.js) for further details.\n\n#### Count Bits of a Number\n\nTo calculate the number of valuable bits we need to shift `1` one bit left each\ntime and see if shifted number is bigger than the input number.\n\n```\n5 = 0b0101\nCount of valuable bits is: 3\nWhen we shift 1 four times it will become bigger than 5.\n```\n\n> See [bitLength.js](bitLength.js) for further details.\n\n#### Is Power of Two\n\nThis method checks if a number provided is power of two. It uses the following\nproperty. Let's say that `powerNumber` is a number that has been formed as a power\nof two (i.e. 2, 4, 8, 16 etc.). Then if we'll do `&` operation between `powerNumber`\nand `powerNumber - 1` it will return `0` (in case if number is power of two).\n\n```\nNumber: 4 = 0b0100\nNumber: 3 = (4 - 1) = 0b0011\n4 & 3 = 0b0100 & 0b0011 = 0b0000 <-- Equal to zero, is power of two.\n\nNumber: 10 = 0b01010\nNumber: 9 = (10 - 1) = 0b01001\n10 & 9 = 0b01010 & 0b01001 = 0b01000 <-- Not equal to zero, not a power of two.\n```\n\n> See [isPowerOfTwo.js](isPowerOfTwo.js) for further details.\n\n#### Full Adder\n\nThis method adds up two integer numbers using bitwise operators.\n\nIt implements [full adder](<https://en.wikipedia.org/wiki/Adder_(electronics)>)\nelectronics circuit logic to sum two 32-bit integers in two's complement format.\nIt's using the boolean logic to cover all possible cases of adding two input bits:\nwith and without a \"carry bit\" from adding the previous less-significant stage.\n\nLegend:\n\n- `A`: Number `A`\n- `B`: Number `B`\n- `ai`: ith bit of number `A`\n- `bi`: ith bit of number `B`\n- `carryIn`: a bit carried in from the previous less-significant stage\n- `carryOut`: a bit to carry to the next most-significant stage\n- `bitSum`: The sum of `ai`, `bi`, and `carryIn`\n- `resultBin`: The full result of adding current stage with all less-significant stages (in binary)\n- `resultDec`: The full result of adding current stage with all less-significant stages (in decimal)\n\n```\nA = 3: 011\nB = 6: 110\n┌──────┬────┬────┬─────────┬──────────┬─────────┬───────────┬───────────┐\n│  bit │ ai │ bi │ carryIn │ carryOut │  bitSum │ resultBin │ resultDec │\n├──────┼────┼────┼─────────┼──────────┼─────────┼───────────┼───────────┤\n│   0  │ 1  │ 0  │    0    │    0     │     1   │       1   │     1     │\n│   1  │ 1  │ 1  │    0    │    1     │     0   │      01   │     1     │\n│   2  │ 0  │ 1  │    1    │    1     │     0   │     001   │     1     │\n│   3  │ 0  │ 0  │    1    │    0     │     1   │    1001   │     9     │\n└──────┴────┴────┴─────────┴──────────┴─────────┴───────────┴───────────┘\n```\n\n> See [fullAdder.js](fullAdder.js) for further details.\n> See [Full Adder on YouTube](https://www.youtube.com/watch?v=wvJc9CZcvBc&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8).\n\n## References\n\n- [Bit Manipulation on YouTube](https://www.youtube.com/watch?v=NLKQEOgBAnw&t=0s&index=28&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\n- [Negative Numbers in binary on YouTube](https://www.youtube.com/watch?v=4qH4unVtJkE&t=0s&index=30&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\n- [Bit Hacks on stanford.edu](https://graphics.stanford.edu/~seander/bithacks.html)\n","filetype":".md","index":58},{"title":"Bit Length","category":"bits","id":"bitLength_bits","algorithm":"/**\n * Return the number of bits used in the binary representation of the number.\n *\n * @param {number} number\n * @return {number}\n */\nexport default function bitLength(number) {\n  let bitsCounter = 0;\n\n  while ((1 << bitsCounter) <= number) {\n    bitsCounter += 1;\n  }\n\n  return bitsCounter;\n}\n","filetype":".js","index":59},{"title":"Bits Diff","category":"bits","id":"bitsDiff_bits","algorithm":"import countSetBits from './countSetBits';\n\n/**\n * Counts the number of bits that need to be change in order\n * to convert numberA to numberB.\n *\n * @param {number} numberA\n * @param {number} numberB\n * @return {number}\n */\nexport default function bitsDiff(numberA, numberB) {\n  return countSetBits(numberA ^ numberB);\n}\n","filetype":".js","index":60},{"title":"Clear Bit","category":"bits","id":"clearBit_bits","algorithm":"/**\n * @param {number} number\n * @param {number} bitPosition - zero based.\n * @return {number}\n */\nexport default function clearBit(number, bitPosition) {\n  const mask = ~(1 << bitPosition);\n\n  return number & mask;\n}\n","filetype":".js","index":61},{"title":"Count Set Bits","category":"bits","id":"countSetBits_bits","algorithm":"/**\n * @param {number} originalNumber\n * @return {number}\n */\nexport default function countSetBits(originalNumber) {\n  let setBitsCount = 0;\n  let number = originalNumber;\n\n  while (number) {\n    // Add last bit of the number to the sum of set bits.\n    setBitsCount += number & 1;\n\n    // Shift number right by one bit to investigate other bits.\n    number >>>= 1;\n  }\n\n  return setBitsCount;\n}\n","filetype":".js","index":62},{"title":"Divide By Two","category":"bits","id":"divideByTwo_bits","algorithm":"/**\n * @param {number} number\n * @return {number}\n */\nexport default function divideByTwo(number) {\n  return number >> 1;\n}\n","filetype":".js","index":63},{"title":"Full Adder","category":"bits","id":"fullAdder_bits","algorithm":"import getBit from './getBit';\n\n/**\n * Add two numbers using only binary operators.\n *\n * This is an implementation of full adders logic circuit.\n * https://en.wikipedia.org/wiki/Adder_(electronics)\n * Inspired by: https://www.youtube.com/watch?v=wvJc9CZcvBc\n *\n * Table(1)\n *  INPUT  | OUT\n *  C Ai Bi | C Si | Row\n * -------- | -----| ---\n *  0  0  0 | 0  0 | 1\n *  0  0  1 | 0  1 | 2\n *  0  1  0 | 0  1 | 3\n *  0  1  1 | 1  0 | 4\n * -------- | ---- | --\n *  1  0  0 | 0  1 | 5\n *  1  0  1 | 1  0 | 6\n *  1  1  0 | 1  0 | 7\n *  1  1  1 | 1  1 | 8\n * ---------------------\n *\n * Legend:\n * INPUT C = Carry in, from the previous less-significant stage\n * INPUT Ai = ith bit of Number A\n * INPUT Bi = ith bit of Number B\n * OUT C = Carry out to the next most-significant stage\n * OUT Si = Bit Sum, ith least significant bit of the result\n *\n *\n * @param {number} a\n * @param {number} b\n * @return {number}\n */\nexport default function fullAdder(a, b) {\n  let result = 0;\n  let carry = 0;\n\n  // The operands of all bitwise operators are converted to signed\n  // 32-bit integers in two's complement format.\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Signed_32-bit_integers\n  for (let i = 0; i < 32; i += 1) {\n    const ai = getBit(a, i);\n    const bi = getBit(b, i);\n    const carryIn = carry;\n\n    // Calculate binary Ai + Bi without carry (half adder)\n    // See Table(1) rows 1 - 4: Si = Ai ^ Bi\n    const aiPlusBi = ai ^ bi;\n\n    // Calculate ith bit of the result by adding the carry bit to Ai + Bi\n    // For Table(1) rows 5 - 8 carryIn = 1: Si = Ai ^ Bi ^ 1, flip the bit\n    // Fpr Table(1) rows 1 - 4 carryIn = 0: Si = Ai ^ Bi ^ 0, a no-op.\n    const bitSum = aiPlusBi ^ carryIn;\n\n    // Carry out one to the next most-significant stage\n    // when at least one of these is true:\n    // 1) Table(1) rows 6, 7: one of Ai OR Bi is 1 AND carryIn = 1\n    // 2) Table(1) rows 4, 8: Both Ai AND Bi are 1\n    const carryOut = (aiPlusBi & carryIn) | (ai & bi);\n    carry = carryOut;\n\n    // Set ith least significant bit of the result to bitSum.\n    result |= bitSum << i;\n  }\n\n  return result;\n}\n","filetype":".js","index":64},{"title":"Get Bit","category":"bits","id":"getBit_bits","algorithm":"/**\n * @param {number} number\n * @param {number} bitPosition - zero based.\n * @return {number}\n */\nexport default function getBit(number, bitPosition) {\n  return (number >> bitPosition) & 1;\n}\n","filetype":".js","index":65},{"title":"Is Even","category":"bits","id":"isEven_bits","algorithm":"/**\n * @param {number} number\n * @return {boolean}\n */\nexport default function isEven(number) {\n  return (number & 1) === 0;\n}\n","filetype":".js","index":66},{"title":"Is Positive","category":"bits","id":"isPositive_bits","algorithm":"/**\n * @param {number} number - 32-bit integer.\n * @return {boolean}\n */\nexport default function isPositive(number) {\n  // Zero is neither a positive nor a negative number.\n  if (number === 0) {\n    return false;\n  }\n\n  // The most significant 32nd bit can be used to determine whether the number is positive.\n  return ((number >> 31) & 1) === 0;\n}\n","filetype":".js","index":67},{"title":"Is Power Of Two","category":"bits","id":"isPowerOfTwo_bits","algorithm":"/**\n * @param {number} number\n * @return bool\n */\nexport default function isPowerOfTwo(number) {\n  return (number & (number - 1)) === 0;\n}\n","filetype":".js","index":68},{"title":"Multiply","category":"bits","id":"multiply_bits","algorithm":"import multiplyByTwo from './multiplyByTwo';\nimport divideByTwo from './divideByTwo';\nimport isEven from './isEven';\nimport isPositive from './isPositive';\n\n/**\n * Multiply two signed numbers using bitwise operations.\n *\n * If a is zero or b is zero or if both a and b are zeros:\n * multiply(a, b) = 0\n *\n * If b is even:\n * multiply(a, b) = multiply(2a, b/2)\n *\n * If b is odd and b is positive:\n * multiply(a, b) = multiply(2a, (b-1)/2) + a\n *\n * If b is odd and b is negative:\n * multiply(a, b) = multiply(2a, (b+1)/2) - a\n *\n * Time complexity: O(log b)\n *\n * @param {number} a\n * @param {number} b\n * @return {number}\n */\nexport default function multiply(a, b) {\n  // If a is zero or b is zero or if both a and b are zeros then the production is also zero.\n  if (b === 0 || a === 0) {\n    return 0;\n  }\n\n  // Otherwise we will have four different cases that are described above.\n  const multiplyByOddPositive = () => multiply(multiplyByTwo(a), divideByTwo(b - 1)) + a;\n  const multiplyByOddNegative = () => multiply(multiplyByTwo(a), divideByTwo(b + 1)) - a;\n\n  const multiplyByEven = () => multiply(multiplyByTwo(a), divideByTwo(b));\n  const multiplyByOdd = () => (isPositive(b) ? multiplyByOddPositive() : multiplyByOddNegative());\n\n  return isEven(b) ? multiplyByEven() : multiplyByOdd();\n}\n","filetype":".js","index":69},{"title":"Multiply By Two","category":"bits","id":"multiplyByTwo_bits","algorithm":"/**\n * @param {number} number\n * @return {number}\n */\nexport default function multiplyByTwo(number) {\n  return number << 1;\n}\n","filetype":".js","index":70},{"title":"Multiply Unsigned","category":"bits","id":"multiplyUnsigned_bits","algorithm":"/**\n * Multiply to unsigned numbers using bitwise operator.\n *\n * The main idea of bitwise multiplication is that every number may be split\n * to the sum of powers of two:\n *\n * I.e. 19 = 2^4 + 2^1 + 2^0\n *\n * Then multiplying number x by 19 is equivalent of:\n *\n * x * 19 = x * 2^4 + x * 2^1 + x * 2^0\n *\n * Now we need to remember that (x * 2^4) is equivalent of shifting x left by 4 bits (x << 4).\n *\n * @param {number} number1\n * @param {number} number2\n * @return {number}\n */\nexport default function multiplyUnsigned(number1, number2) {\n  let result = 0;\n\n  // Let's treat number2 as a multiplier for the number1.\n  let multiplier = number2;\n\n  // Multiplier current bit index.\n  let bitIndex = 0;\n\n  // Go through all bits of number2.\n  while (multiplier !== 0) {\n    // Check if current multiplier bit is set.\n    if (multiplier & 1) {\n      // In case if multiplier's bit at position bitIndex is set\n      // it would mean that we need to multiply number1 by the power\n      // of bit with index bitIndex and then add it to the result.\n      result += (number1 << bitIndex);\n    }\n\n    bitIndex += 1;\n    multiplier >>= 1;\n  }\n\n  return result;\n}\n","filetype":".js","index":71},{"title":"Set Bit","category":"bits","id":"setBit_bits","algorithm":"/**\n * @param {number} number\n * @param {number} bitPosition - zero based.\n * @return {number}\n */\nexport default function setBit(number, bitPosition) {\n  return number | (1 << bitPosition);\n}\n","filetype":".js","index":72},{"title":"Switch Sign","category":"bits","id":"switchSign_bits","algorithm":"/**\n * Switch the sign of the number using \"Twos Complement\" approach.\n * @param {number} number\n * @return {number}\n */\nexport default function switchSign(number) {\n  return ~number + 1;\n}\n","filetype":".js","index":73},{"title":"Update Bit","category":"bits","id":"updateBit_bits","algorithm":"/**\n * @param {number} number\n * @param {number} bitPosition - zero based.\n * @param {number} bitValue - 0 or 1.\n * @return {number}\n */\nexport default function updateBit(number, bitPosition, bitValue) {\n  // Normalized bit value.\n  const bitValueNormalized = bitValue ? 1 : 0;\n\n  // Init clear mask.\n  const clearMask = ~(1 << bitPosition);\n\n  // Clear bit value and then set it up to required value.\n  return (number & clearMask) | (bitValueNormalized << bitPosition);\n}\n","filetype":".js","index":74},{"title":"Complex-number","category":"math","id":"complex-number","algorithm":"# Complex Number\n\n_Read this in other languages:_\n[français](README.fr-FR.md).\n\nA **complex number** is a number that can be expressed in the\nform `a + b * i`, where `a` and `b` are real numbers, and `i` is a solution of\nthe equation `x^2 = −1`. Because no _real number_ satisfies this\nequation, `i` is called an _imaginary number_. For the complex\nnumber `a + b * i`, `a` is called the _real part_, and `b` is called\nthe _imaginary part_.\n\n![Complex Number](https://www.mathsisfun.com/numbers/images/complex-example.svg)\n\nA Complex Number is a combination of a Real Number and an Imaginary Number:\n\n![Complex Number](https://www.mathsisfun.com/numbers/images/complex-number.svg)\n\nGeometrically, complex numbers extend the concept of the one-dimensional number\nline to the _two-dimensional complex plane_ by using the horizontal axis for the\nreal part and the vertical axis for the imaginary part. The complex\nnumber `a + b * i` can be identified with the point `(a, b)` in the complex plane.\n\nA complex number whose real part is zero is said to be _purely imaginary_; the\npoints for these numbers lie on the vertical axis of the complex plane. A complex\nnumber whose imaginary part is zero can be viewed as a _real number_; its point\nlies on the horizontal axis of the complex plane.\n\n| Complex Number | Real Part | Imaginary Part |                  |\n| :------------- | :-------: | :------------: | ---------------- |\n| 3 + 2i         |     3     |       2        |                  |\n| 5              |     5     |     **0**      | Purely Real      |\n| −6i            |   **0**   |       -6       | Purely Imaginary |\n\nA complex number can be visually represented as a pair of numbers `(a, b)` forming\na vector on a diagram called an _Argand diagram_, representing the _complex plane_.\n`Re` is the real axis, `Im` is the imaginary axis, and `i` satisfies `i^2 = −1`.\n\n![Complex Number](https://upload.wikimedia.org/wikipedia/commons/a/af/Complex_number_illustration.svg)\n\n> Complex does not mean complicated. It means the two types of numbers, real and\n> imaginary, together form a complex, just like a building complex (buildings\n> joined together).\n\n## Polar Form\n\nAn alternative way of defining a point `P` in the complex plane, other than using\nthe x- and y-coordinates, is to use the distance of the point from `O`, the point\nwhose coordinates are `(0, 0)` (the origin), together with the angle subtended\nbetween the positive real axis and the line segment `OP` in a counterclockwise\ndirection. This idea leads to the polar form of complex numbers.\n\n![Polar Form](https://upload.wikimedia.org/wikipedia/commons/7/7a/Complex_number_illustration_modarg.svg)\n\nThe _absolute value_ (or modulus or magnitude) of a complex number `z = x + yi` is:\n\n![Radius](https://wikimedia.org/api/rest_v1/media/math/render/svg/b59629c801aa0ddcdf17ee489e028fb9f8d4ea75)\n\nThe argument of `z` (in many applications referred to as the \"phase\") is the angle\nof the radius `OP` with the positive real axis, and is written as `arg(z)`. As\nwith the modulus, the argument can be found from the rectangular form `x+yi`:\n\n![Phase](https://wikimedia.org/api/rest_v1/media/math/render/svg/7cbbdd9bb1dd5df86dd2b820b20f82995023e566)\n\nTogether, `r` and `φ` give another way of representing complex numbers, the\npolar form, as the combination of modulus and argument fully specify the\nposition of a point on the plane. Recovering the original rectangular\nco-ordinates from the polar form is done by the formula called trigonometric\nform:\n\n![Polar Form](https://wikimedia.org/api/rest_v1/media/math/render/svg/b03de1e1b7b049880b5e4870b68a57bc180ff6ce)\n\nUsing Euler's formula this can be written as:\n\n![Euler's Form](https://wikimedia.org/api/rest_v1/media/math/render/svg/0a087c772212e7375cb321d83fc1fcc715cd0ed2)\n\n## Basic Operations\n\n### Adding\n\nTo add two complex numbers we add each part separately:\n\n```text\n(a + b * i) + (c + d * i) = (a + c) + (b + d) * i\n```\n\n**Example**\n\n```text\n(3 + 5i) + (4 − 3i) = (3 + 4) + (5 − 3)i = 7 + 2i\n```\n\nOn complex plane the adding operation will look like the following:\n\n![Complex Addition](https://www.mathsisfun.com/algebra/images/complex-plane-vector-add.svg)\n\n### Subtracting\n\nTo subtract two complex numbers we subtract each part separately:\n\n```text\n(a + b * i) - (c + d * i) = (a - c) + (b - d) * i\n```\n\n**Example**\n\n```text\n(3 + 5i) - (4 − 3i) = (3 - 4) + (5 + 3)i = -1 + 8i\n```\n\n### Multiplying\n\nTo multiply complex numbers each part of the first complex number gets multiplied\nby each part of the second complex number:\n\nJust use \"FOIL\", which stands for \"**F**irsts, **O**uters, **I**nners, **L**asts\" (\nsee [Binomial Multiplication](ttps://www.mathsisfun.com/algebra/polynomials-multiplying.html) for\nmore details):\n\n![Complex Multiplication](https://www.mathsisfun.com/algebra/images/foil-complex.svg)\n\n- Firsts: `a × c`\n- Outers: `a × di`\n- Inners: `bi × c`\n- Lasts: `bi × di`\n\nIn general it looks like this:\n\n```text\n(a + bi)(c + di) = ac + adi + bci + bdi^2\n```\n\nBut there is also a quicker way!\n\nUse this rule:\n\n```text\n(a + bi)(c + di) = (ac − bd) + (ad + bc)i\n```\n\n**Example**\n\n```text\n(3 + 2i)(1 + 7i)\n= 3×1 + 3×7i + 2i×1+ 2i×7i\n= 3 + 21i + 2i + 14i^2\n= 3 + 21i + 2i − 14   (because i^2 = −1)\n= −11 + 23i\n```\n\n```text\n(3 + 2i)(1 + 7i) = (3×1 − 2×7) + (3×7 + 2×1)i = −11 + 23i\n```\n\n### Conjugates\n\nWe will need to know about conjugates in a minute!\n\nA conjugate is where we change the sign in the middle like this:\n\n![Complex Conjugate](https://www.mathsisfun.com/numbers/images/complex-conjugate.svg)\n\nA conjugate is often written with a bar over it:\n\n```text\n______\n5 − 3i   =   5 + 3i\n```\n\nOn the complex plane the conjugate number will be mirrored against real axes.\n\n![Complex Conjugate](https://upload.wikimedia.org/wikipedia/commons/6/69/Complex_conjugate_picture.svg)\n\n### Dividing\n\nThe conjugate is used to help complex division.\n\nThe trick is to _multiply both top and bottom by the conjugate of the bottom_.\n\n**Example**\n\n```text\n2 + 3i\n------\n4 − 5i\n```\n\nMultiply top and bottom by the conjugate of `4 − 5i`:\n\n```text\n  (2 + 3i) * (4 + 5i)   8 + 10i + 12i + 15i^2\n= ------------------- = ----------------------\n  (4 − 5i) * (4 + 5i)   16 + 20i − 20i − 25i^2\n```\n\nNow remember that `i^2 = −1`, so:\n\n```text\n  8 + 10i + 12i − 15    −7 + 22i   −7   22\n= ------------------- = -------- = -- + -- * i\n  16 + 20i − 20i + 25      41      41   41\n\n```\n\nThere is a faster way though.\n\nIn the previous example, what happened on the bottom was interesting:\n\n```text\n(4 − 5i)(4 + 5i) = 16 + 20i − 20i − 25i\n```\n\nThe middle terms `(20i − 20i)` cancel out! Also `i^2 = −1` so we end up with this:\n\n```text\n(4 − 5i)(4 + 5i) = 4^2 + 5^2\n```\n\nWhich is really quite a simple result. The general rule is:\n\n```text\n(a + bi)(a − bi) = a^2 + b^2\n```\n\n## References\n\n- [Wikipedia](https://en.wikipedia.org/wiki/Complex_number)\n- [Math is Fun](https://www.mathsisfun.com/numbers/complex-numbers.html)\n","filetype":".md","index":75},{"title":"Complex Number","category":"complex-number","id":"ComplexNumber_complex-number","algorithm":"import radianToDegree from '../radian/radianToDegree';\n\nexport default class ComplexNumber {\n  /**\n   * z = re + im * i\n   * z = radius * e^(i * phase)\n   *\n   * @param {number} [re]\n   * @param {number} [im]\n   */\n  constructor({ re = 0, im = 0 } = {}) {\n    this.re = re;\n    this.im = im;\n  }\n\n  /**\n   * @param {ComplexNumber|number} addend\n   * @return {ComplexNumber}\n   */\n  add(addend) {\n    // Make sure we're dealing with complex number.\n    const complexAddend = this.toComplexNumber(addend);\n\n    return new ComplexNumber({\n      re: this.re + complexAddend.re,\n      im: this.im + complexAddend.im,\n    });\n  }\n\n  /**\n   * @param {ComplexNumber|number} subtrahend\n   * @return {ComplexNumber}\n   */\n  subtract(subtrahend) {\n    // Make sure we're dealing with complex number.\n    const complexSubtrahend = this.toComplexNumber(subtrahend);\n\n    return new ComplexNumber({\n      re: this.re - complexSubtrahend.re,\n      im: this.im - complexSubtrahend.im,\n    });\n  }\n\n  /**\n   * @param {ComplexNumber|number} multiplicand\n   * @return {ComplexNumber}\n   */\n  multiply(multiplicand) {\n    // Make sure we're dealing with complex number.\n    const complexMultiplicand = this.toComplexNumber(multiplicand);\n\n    return new ComplexNumber({\n      re: this.re * complexMultiplicand.re - this.im * complexMultiplicand.im,\n      im: this.re * complexMultiplicand.im + this.im * complexMultiplicand.re,\n    });\n  }\n\n  /**\n   * @param {ComplexNumber|number} divider\n   * @return {ComplexNumber}\n   */\n  divide(divider) {\n    // Make sure we're dealing with complex number.\n    const complexDivider = this.toComplexNumber(divider);\n\n    // Get divider conjugate.\n    const dividerConjugate = this.conjugate(complexDivider);\n\n    // Multiply dividend by divider's conjugate.\n    const finalDivident = this.multiply(dividerConjugate);\n\n    // Calculating final divider using formula (a + bi)(a − bi) = a^2 + b^2\n    const finalDivider = (complexDivider.re ** 2) + (complexDivider.im ** 2);\n\n    return new ComplexNumber({\n      re: finalDivident.re / finalDivider,\n      im: finalDivident.im / finalDivider,\n    });\n  }\n\n  /**\n   * @param {ComplexNumber|number} number\n   */\n  conjugate(number) {\n    // Make sure we're dealing with complex number.\n    const complexNumber = this.toComplexNumber(number);\n\n    return new ComplexNumber({\n      re: complexNumber.re,\n      im: -1 * complexNumber.im,\n    });\n  }\n\n  /**\n   * @return {number}\n   */\n  getRadius() {\n    return Math.sqrt((this.re ** 2) + (this.im ** 2));\n  }\n\n  /**\n   * @param {boolean} [inRadians]\n   * @return {number}\n   */\n  getPhase(inRadians = true) {\n    let phase = Math.atan(Math.abs(this.im) / Math.abs(this.re));\n\n    if (this.re < 0 && this.im > 0) {\n      phase = Math.PI - phase;\n    } else if (this.re < 0 && this.im < 0) {\n      phase = -(Math.PI - phase);\n    } else if (this.re > 0 && this.im < 0) {\n      phase = -phase;\n    } else if (this.re === 0 && this.im > 0) {\n      phase = Math.PI / 2;\n    } else if (this.re === 0 && this.im < 0) {\n      phase = -Math.PI / 2;\n    } else if (this.re < 0 && this.im === 0) {\n      phase = Math.PI;\n    } else if (this.re > 0 && this.im === 0) {\n      phase = 0;\n    } else if (this.re === 0 && this.im === 0) {\n      // More correctly would be to set 'indeterminate'.\n      // But just for simplicity reasons let's set zero.\n      phase = 0;\n    }\n\n    if (!inRadians) {\n      phase = radianToDegree(phase);\n    }\n\n    return phase;\n  }\n\n  /**\n   * @param {boolean} [inRadians]\n   * @return {{radius: number, phase: number}}\n   */\n  getPolarForm(inRadians = true) {\n    return {\n      radius: this.getRadius(),\n      phase: this.getPhase(inRadians),\n    };\n  }\n\n  /**\n   * Convert real numbers to complex number.\n   * In case if complex number is provided then lefts it as is.\n   *\n   * @param {ComplexNumber|number} number\n   * @return {ComplexNumber}\n   */\n  toComplexNumber(number) {\n    if (number instanceof ComplexNumber) {\n      return number;\n    }\n\n    return new ComplexNumber({ re: number });\n  }\n}\n","filetype":".js","index":76},{"title":"Euclidean-algorithm","category":"math","id":"euclidean-algorithm","algorithm":"# Euclidean algorithm\n\n_Read this in other languages:_\n[français](README.fr-FR.md).\n\nIn mathematics, the Euclidean algorithm, or Euclid's algorithm,\nis an efficient method for computing the greatest common divisor\n(GCD) of two numbers, the largest number that divides both of\nthem without leaving a remainder.\n\nThe Euclidean algorithm is based on the principle that the\ngreatest common divisor of two numbers does not change if\nthe larger number is replaced by its difference with the\nsmaller number. For example, `21` is the GCD of `252` and\n`105` (as `252 = 21 × 12` and `105 = 21 × 5`), and the same\nnumber `21` is also the GCD of `105` and `252 − 105 = 147`.\nSince this replacement reduces the larger of the two numbers,\nrepeating this process gives successively smaller pairs of\nnumbers until the two numbers become equal.\nWhen that occurs, they are the GCD of the original two numbers.\n\nBy reversing the steps, the GCD can be expressed as a sum of\nthe two original numbers each multiplied by a positive or\nnegative integer, e.g., `21 = 5 × 105 + (−2) × 252`.\nThe fact that the GCD can always be expressed in this way is\nknown as Bézout's identity.\n\n![GCD](https://upload.wikimedia.org/wikipedia/commons/3/37/Euclid%27s_algorithm_Book_VII_Proposition_2_3.png)\n\nEuclid's method for finding the greatest common divisor (GCD)\nof two starting lengths `BA` and `DC`, both defined to be\nmultiples of a common \"unit\" length. The length `DC` being\nshorter, it is used to \"measure\" `BA`, but only once because\nremainder `EA` is less than `DC`. EA now measures (twice)\nthe shorter length `DC`, with remainder `FC` shorter than `EA`.\nThen `FC` measures (three times) length `EA`. Because there is\nno remainder, the process ends with `FC` being the `GCD`.\nOn the right Nicomachus' example with numbers `49` and `21`\nresulting in their GCD of `7` (derived from Heath 1908:300).\n\n![GCD](https://upload.wikimedia.org/wikipedia/commons/7/74/24x60.svg)\n\nA `24-by-60` rectangle is covered with ten `12-by-12` square\ntiles, where `12` is the GCD of `24` and `60`. More generally,\nan `a-by-b` rectangle can be covered with square tiles of\nside-length `c` only if `c` is a common divisor of `a` and `b`.\n\n![GCD](https://upload.wikimedia.org/wikipedia/commons/1/1c/Euclidean_algorithm_1071_462.gif)\n\nSubtraction-based animation of the Euclidean algorithm.\nThe initial rectangle has dimensions `a = 1071` and `b = 462`.\nSquares of size `462×462` are placed within it leaving a\n`462×147` rectangle. This rectangle is tiled with `147×147`\nsquares until a `21×147` rectangle is left, which in turn is\ntiled with `21×21` squares, leaving no uncovered area.\nThe smallest square size, `21`, is the GCD of `1071` and `462`.\n\n## References\n\n[Wikipedia](https://en.wikipedia.org/wiki/Euclidean_algorithm)\n","filetype":".md","index":77},{"title":"Euclidean Algorithm","category":"euclidean-algorithm","id":"euclideanAlgorithm_euclidean-algorithm","algorithm":"/**\n * Recursive version of Euclidean Algorithm of finding greatest common divisor (GCD).\n * @param {number} originalA\n * @param {number} originalB\n * @return {number}\n */\nexport default function euclideanAlgorithm(originalA, originalB) {\n  // Make input numbers positive.\n  const a = Math.abs(originalA);\n  const b = Math.abs(originalB);\n\n  // To make algorithm work faster instead of subtracting one number from the other\n  // we may use modulo operation.\n  return (b === 0) ? a : euclideanAlgorithm(b, a % b);\n}\n","filetype":".js","index":78},{"title":"Euclidean Algorithm Iterative","category":"euclidean-algorithm","id":"euclideanAlgorithmIterative_euclidean-algorithm","algorithm":"/**\n * Iterative version of Euclidean Algorithm of finding greatest common divisor (GCD).\n * @param {number} originalA\n * @param {number} originalB\n * @return {number}\n */\nexport default function euclideanAlgorithmIterative(originalA, originalB) {\n  // Make input numbers positive.\n  let a = Math.abs(originalA);\n  let b = Math.abs(originalB);\n\n  // Subtract one number from another until both numbers would become the same.\n  // This will be out GCD. Also quit the loop if one of the numbers is zero.\n  while (a && b && a !== b) {\n    [a, b] = a > b ? [a - b, b] : [a, b - a];\n  }\n\n  // Return the number that is not equal to zero since the last subtraction (it will be a GCD).\n  return a || b;\n}\n","filetype":".js","index":79},{"title":"Euclidean-distance","category":"math","id":"euclidean-distance","algorithm":"# Euclidean Distance\n\nIn mathematics, the **Euclidean distance** between two points in Euclidean space is the length of a line segment between the two points. It can be calculated from the Cartesian coordinates of the points using the Pythagorean theorem, therefore occasionally being called the Pythagorean distance.\n\n![Euclidean distance between two points](https://upload.wikimedia.org/wikipedia/commons/5/55/Euclidean_distance_2d.svg)\n\n## Distance formulas\n\n### One dimension\n\nThe distance between any two points on the real line is the absolute value of the numerical difference of their coordinates\n\n![One dimension formula](https://wikimedia.org/api/rest_v1/media/math/render/svg/7d75418dbec9482dbcb70f9063ad66e9cf7b5db9)\n\n### Two dimensions\n\n![Two dimensions formula](https://wikimedia.org/api/rest_v1/media/math/render/svg/9c0157084fd89f5f3d462efeedc47d3d7aa0b773)\n\n### Higher dimensions\n\nIn three dimensions, for points given by their Cartesian coordinates, the distance is\n\n![Three dimensions formula](https://wikimedia.org/api/rest_v1/media/math/render/svg/d1d13a40a7b203b455ae6d4be8b3cce898bda625)\n\nExample: the distance between the two points `(8,2,6)` and `(3,5,7)`:\n\n![3-dimension example](https://www.mathsisfun.com/algebra/images/dist-2-points-3d.svg)\n\nIn general, for points given by Cartesian coordinates in `n`-dimensional Euclidean space, the distance is\n\n![n-dimensional formula](https://wikimedia.org/api/rest_v1/media/math/render/svg/a0ef4fe055b2a51b4cca43a05e5d1cd93f758dcc)\n\n## References\n\n- [Euclidean Distance on MathIsFun](https://www.mathsisfun.com/algebra/distance-2-points.html)\n- [Euclidean Distance on Wikipedia](https://en.wikipedia.org/wiki/Euclidean_distance)\n","filetype":".md","index":80},{"title":"__tests__","category":"euclidean-distance","id":"__tests__","index":81},{"title":"Euclidean Distance.test","category":"__tests__","id":"euclideanDistance.test___tests__","algorithm":"import euclideanDistance from '../euclideanDistance';\n\ndescribe('euclideanDistance', () => {\n  it('should calculate euclidean distance between vectors', () => {\n    expect(euclideanDistance([[1]], [[2]])).toEqual(1);\n    expect(euclideanDistance([[2]], [[1]])).toEqual(1);\n    expect(euclideanDistance([[5, 8]], [[7, 3]])).toEqual(5.39);\n    expect(euclideanDistance([[5], [8]], [[7], [3]])).toEqual(5.39);\n    expect(euclideanDistance([[8, 2, 6]], [[3, 5, 7]])).toEqual(5.92);\n    expect(euclideanDistance([[8], [2], [6]], [[3], [5], [7]])).toEqual(5.92);\n    expect(euclideanDistance([[[8]], [[2]], [[6]]], [[[3]], [[5]], [[7]]])).toEqual(5.92);\n  });\n\n  it('should throw an error in case if two matrices are of different shapes', () => {\n    expect(() => euclideanDistance([[1]], [[[2]]])).toThrowError(\n      'Matrices have different dimensions',\n    );\n\n    expect(() => euclideanDistance([[1]], [[2, 3]])).toThrowError(\n      'Matrices have different shapes',\n    );\n  });\n});\n","filetype":".js","index":82},{"title":"Euclidean Distance","category":"euclidean-distance","id":"euclideanDistance_euclidean-distance","algorithm":"/**\n * @typedef {import('../matrix/Matrix.js').Matrix} Matrix\n */\n\nimport * as mtrx from '../matrix/Matrix';\n\n/**\n * Calculates the euclidean distance between 2 matrices.\n *\n * @param {Matrix} a\n * @param {Matrix} b\n * @returns {number}\n * @trows {Error}\n */\nconst euclideanDistance = (a, b) => {\n  mtrx.validateSameShape(a, b);\n\n  let squaresTotal = 0;\n\n  mtrx.walk(a, (indices, aCellValue) => {\n    const bCellValue = mtrx.getCellAtIndex(b, indices);\n    squaresTotal += (aCellValue - bCellValue) ** 2;\n  });\n\n  return Number(Math.sqrt(squaresTotal).toFixed(2));\n};\n\nexport default euclideanDistance;\n","filetype":".js","index":83},{"title":"Factorial","category":"math","id":"factorial","algorithm":"# Factorial\n\n_Read this in other languages:_\n[_简体中文_](README.zh-CN.md), [français](README.fr-FR.md).\n\nIn mathematics, the factorial of a non-negative integer `n`,\ndenoted by `n!`, is the product of all positive integers less\nthan or equal to `n`. For example:\n\n```\n5! = 5 * 4 * 3 * 2 * 1 = 120\n```\n\n| n   |                n! |\n| --- | ----------------: |\n| 0   |                 1 |\n| 1   |                 1 |\n| 2   |                 2 |\n| 3   |                 6 |\n| 4   |                24 |\n| 5   |               120 |\n| 6   |               720 |\n| 7   |             5 040 |\n| 8   |            40 320 |\n| 9   |           362 880 |\n| 10  |         3 628 800 |\n| 11  |        39 916 800 |\n| 12  |       479 001 600 |\n| 13  |     6 227 020 800 |\n| 14  |    87 178 291 200 |\n| 15  | 1 307 674 368 000 |\n\n## References\n\n[Wikipedia](https://en.wikipedia.org/wiki/Factorial)\n","filetype":".md","index":84},{"title":"Factorial","category":"factorial","id":"factorial_factorial","algorithm":"/**\n * @param {number} number\n * @return {number}\n */\nexport default function factorial(number) {\n  let result = 1;\n\n  for (let i = 2; i <= number; i += 1) {\n    result *= i;\n  }\n\n  return result;\n}\n","filetype":".js","index":85},{"title":"Factorial Recursive","category":"factorial","id":"factorialRecursive_factorial","algorithm":"/**\n * @param {number} number\n * @return {number}\n */\nexport default function factorialRecursive(number) {\n  return number > 1 ? number * factorialRecursive(number - 1) : 1;\n}\n","filetype":".js","index":86},{"title":"Fast-powering","category":"math","id":"fast-powering","algorithm":"# Fast Powering Algorithm\n\n_Read this in other languages:_\n[français](README.fr-FR.md).\n\n**The power of a number** says how many times to use the number in a\nmultiplication.\n\nIt is written as a small number to the right and above the base number.\n\n![Power](https://www.mathsisfun.com/algebra/images/exponent-8-2.svg)\n\n## Naive Algorithm Complexity\n\nHow to find `a` raised to the power `b`?\n\nWe multiply `a` to itself, `b` times. That\nis, `a^b = a * a * a * ... * a` (`b` occurrences of `a`).\n\nThis operation will take `O(n)` time since we need to do multiplication operation\nexactly `n` times.\n\n## Fast Power Algorithm\n\nCan we do better than naive algorithm does? Yes we may solve the task of\npowering in `O(log(n))` time.\n\nThe algorithm uses divide and conquer approach to compute power. Currently the\nalgorithm work for two positive integers `X` and `Y`.\n\nThe idea behind the algorithm is based on the fact that:\n\nFor **even** `Y`:\n\n```text\nX^Y = X^(Y/2) * X^(Y/2)\n```\n\nFor **odd** `Y`:\n\n```text\nX^Y = X^(Y//2) * X^(Y//2) * X\nwhere Y//2 is result of division of Y by 2 without reminder.\n```\n\n**For example**\n\n```text\n2^4 = (2 * 2) * (2 * 2) = (2^2) * (2^2)\n```\n\n```text\n2^5 = (2 * 2) * (2 * 2) * 2 = (2^2) * (2^2) * (2)\n```\n\nNow, since on each step we need to compute the same `X^(Y/2)` power twice we may optimise\nit by saving it to some intermediate variable to avoid its duplicate calculation.\n\n**Time Complexity**\n\nSince each iteration we split the power by half then we will call function\nrecursively `log(n)` times. This the time complexity of the algorithm is reduced to:\n\n```text\nO(log(n))\n```\n\n## References\n\n- [YouTube](https://www.youtube.com/watch?v=LUWavfN9zEo&index=80&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8&t=0s)\n- [Wikipedia](https://en.wikipedia.org/wiki/Exponentiation_by_squaring)\n","filetype":".md","index":87},{"title":"Fast Powering","category":"fast-powering","id":"fastPowering_fast-powering","algorithm":"/**\n * Fast Powering Algorithm.\n * Recursive implementation to compute power.\n *\n * Complexity: log(n)\n *\n * @param {number} base - Number that will be raised to the power.\n * @param {number} power - The power that number will be raised to.\n * @return {number}\n */\nexport default function fastPowering(base, power) {\n  if (power === 0) {\n    // Anything that is raised to the power of zero is 1.\n    return 1;\n  }\n\n  if (power % 2 === 0) {\n    // If the power is even...\n    // we may recursively redefine the result via twice smaller powers:\n    // x^8 = x^4 * x^4.\n    const multiplier = fastPowering(base, power / 2);\n    return multiplier * multiplier;\n  }\n\n  // If the power is odd...\n  // we may recursively redefine the result via twice smaller powers:\n  // x^9 = x^4 * x^4 * x.\n  const multiplier = fastPowering(base, Math.floor(power / 2));\n  return multiplier * multiplier * base;\n}\n","filetype":".js","index":88},{"title":"Fibonacci","category":"math","id":"fibonacci","algorithm":"# Fibonacci Number\n\n_Read this in other languages:_\n[français](README.fr-FR.md),\n[简体中文](README.zh-CN.md).\n\nIn mathematics, the Fibonacci numbers are the numbers in the following\ninteger sequence, called the Fibonacci sequence, and characterized by\nthe fact that every number after the first two is the sum of the two\npreceding ones:\n\n`0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ...`\n\nA tiling with squares whose side lengths are successive Fibonacci numbers\n\n![Fibonacci](https://upload.wikimedia.org/wikipedia/commons/d/db/34%2A21-FibonacciBlocks.png)\n\nThe Fibonacci spiral: an approximation of the golden spiral created by drawing circular arcs connecting the opposite corners of squares in the Fibonacci tiling;[4] this one uses squares of sizes 1, 1, 2, 3, 5, 8, 13 and 21.\n\n![Fibonacci Spiral](https://upload.wikimedia.org/wikipedia/commons/2/2e/FibonacciSpiral.svg)\n\n## References\n\n- [Wikipedia](https://en.wikipedia.org/wiki/Fibonacci_number)\n","filetype":".md","index":89},{"title":"Fibonacci","category":"fibonacci","id":"fibonacci_fibonacci","algorithm":"/**\n * Return a fibonacci sequence as an array.\n *\n * @param n\n * @return {number[]}\n */\nexport default function fibonacci(n) {\n  const fibSequence = [1];\n\n  let currentValue = 1;\n  let previousValue = 0;\n\n  if (n === 1) {\n    return fibSequence;\n  }\n\n  let iterationsCounter = n - 1;\n\n  while (iterationsCounter) {\n    currentValue += previousValue;\n    previousValue = currentValue - previousValue;\n\n    fibSequence.push(currentValue);\n\n    iterationsCounter -= 1;\n  }\n\n  return fibSequence;\n}\n","filetype":".js","index":90},{"title":"Fibonacci Nth","category":"fibonacci","id":"fibonacciNth_fibonacci","algorithm":"/**\n * Calculate fibonacci number at specific position using Dynamic Programming approach.\n *\n * @param n\n * @return {number}\n */\nexport default function fibonacciNth(n) {\n  let currentValue = 1;\n  let previousValue = 0;\n\n  if (n === 1) {\n    return 1;\n  }\n\n  let iterationsCounter = n - 1;\n\n  while (iterationsCounter) {\n    currentValue += previousValue;\n    previousValue = currentValue - previousValue;\n\n    iterationsCounter -= 1;\n  }\n\n  return currentValue;\n}\n","filetype":".js","index":91},{"title":"Fibonacci Nth Closed Form","category":"fibonacci","id":"fibonacciNthClosedForm_fibonacci","algorithm":"/**\n * Calculate fibonacci number at specific position using closed form function (Binet's formula).\n * @see: https://en.wikipedia.org/wiki/Fibonacci_number#Closed-form_expression\n *\n * @param {number} position - Position number of fibonacci sequence (must be number from 1 to 75).\n * @return {number}\n */\nexport default function fibonacciClosedForm(position) {\n  const topMaxValidPosition = 70;\n\n  // Check that position is valid.\n  if (position < 1 || position > topMaxValidPosition) {\n    throw new Error(`Can't handle position smaller than 1 or greater than ${topMaxValidPosition}`);\n  }\n\n  // Calculate √5 to re-use it in further formulas.\n  const sqrt5 = Math.sqrt(5);\n  // Calculate φ constant (≈ 1.61803).\n  const phi = (1 + sqrt5) / 2;\n\n  // Calculate fibonacci number using Binet's formula.\n  return Math.floor((phi ** position) / sqrt5 + 0.5);\n}\n","filetype":".js","index":92},{"title":"Fourier-transform","category":"math","id":"fourier-transform","algorithm":"# Fourier Transform\n\n_Read this in other languages:_\n[français](README.fr-FR.md).\n\n## Definitions\n\nThe **Fourier Transform** (**FT**) decomposes a function of time (a signal) into\nthe frequencies that make it up, in a way similar to how a musical chord can be\nexpressed as the frequencies (or pitches) of its constituent notes.\n\nThe **Discrete Fourier Transform** (**DFT**) converts a finite sequence of\nequally-spaced samples of a function into a same-length sequence of\nequally-spaced samples of the discrete-time Fourier transform (DTFT), which is a\ncomplex-valued function of frequency. The interval at which the DTFT is sampled\nis the reciprocal of the duration of the input sequence. An inverse DFT is a\nFourier series, using the DTFT samples as coefficients of complex sinusoids at\nthe corresponding DTFT frequencies. It has the same sample-values as the original\ninput sequence. The DFT is therefore said to be a frequency domain representation\nof the original input sequence. If the original sequence spans all the non-zero\nvalues of a function, its DTFT is continuous (and periodic), and the DFT provides\ndiscrete samples of one cycle. If the original sequence is one cycle of a periodic\nfunction, the DFT provides all the non-zero values of one DTFT cycle.\n\nThe Discrete Fourier transform transforms a sequence of `N` complex numbers:\n\n{x<sub>n</sub>} = x<sub>0</sub>, x<sub>1</sub>, x<sub>2</sub> ..., x<sub>N-1</sub>\n\ninto another sequence of complex numbers:\n\n{X<sub>k</sub>} = X<sub>0</sub>, X<sub>1</sub>, X<sub>2</sub> ..., X<sub>N-1</sub>\n\nwhich is defined by:\n\n![DFT](https://wikimedia.org/api/rest_v1/media/math/render/svg/1af0a78dc50bbf118ab6bd4c4dcc3c4ff8502223)\n\nThe **Discrete-Time Fourier Transform** (**DTFT**) is a form of Fourier analysis\nthat is applicable to the uniformly-spaced samples of a continuous function. The\nterm discrete-time refers to the fact that the transform operates on discrete data\n(samples) whose interval often has units of time. From only the samples, it\nproduces a function of frequency that is a periodic summation of the continuous\nFourier transform of the original continuous function.\n\nA **Fast Fourier Transform** (**FFT**) is an algorithm that samples a signal over\na period of time (or space) and divides it into its frequency components. These\ncomponents are single sinusoidal oscillations at distinct frequencies each with\ntheir own amplitude and phase.\n\nThis transformation is illustrated in Diagram below. Over the time period measured\nin the diagram, the signal contains 3 distinct dominant frequencies.\n\nView of a signal in the time and frequency domain:\n\n![FFT](https://upload.wikimedia.org/wikipedia/commons/6/61/FFT-Time-Frequency-View.png)\n\nAn FFT algorithm computes the discrete Fourier transform (DFT) of a sequence, or\nits inverse (IFFT). Fourier analysis converts a signal from its original domain\nto a representation in the frequency domain and vice versa. An FFT rapidly\ncomputes such transformations by factorizing the DFT matrix into a product of\nsparse (mostly zero) factors. As a result, it manages to reduce the complexity of\ncomputing the DFT from O(n<sup>2</sup>), which arises if one simply applies the\ndefinition of DFT, to O(n log n), where n is the data size.\n\nHere a discrete Fourier analysis of a sum of cosine waves at 10, 20, 30, 40,\nand 50 Hz:\n\n![FFT](https://upload.wikimedia.org/wikipedia/commons/6/64/FFT_of_Cosine_Summation_Function.png)\n\n## Explanation\n\nThe Fourier Transform is one of deepest insights ever made. Unfortunately, the\nmeaning is buried within dense equations:\n\n![](https://betterexplained.com/wp-content/plugins/wp-latexrender/pictures/45c088dbb767150fc0bacfeb49dd49e5.png)\n\nand\n\n![](https://betterexplained.com/wp-content/plugins/wp-latexrender/pictures/faeb9c5bf2e60add63ae4a70b293c7b4.png)\n\nRather than jumping into the symbols, let's experience the key idea firsthand. Here's a plain-English metaphor:\n\n- _What does the Fourier Transform do?_ Given a smoothie, it finds the recipe.\n- _How?_ Run the smoothie through filters to extract each ingredient.\n- _Why?_ Recipes are easier to analyze, compare, and modify than the smoothie itself.\n- _How do we get the smoothie back?_ Blend the ingredients.\n\n**Think With Circles, Not Just Sinusoids**\n\nThe Fourier Transform is about circular paths (not 1-d sinusoids) and Euler's\nformula is a clever way to generate one:\n\n![](https://betterexplained.com/wp-content/uploads/euler/equal_paths.png)\n\nMust we use imaginary exponents to move in a circle? Nope. But it's convenient\nand compact. And sure, we can describe our path as coordinated motion in two\ndimensions (real and imaginary), but don't forget the big picture: we're just\nmoving in a circle.\n\n**Discovering The Full Transform**\n\nThe big insight: our signal is just a bunch of time spikes! If we merge the\nrecipes for each time spike, we should get the recipe for the full signal.\n\nThe Fourier Transform builds the recipe frequency-by-frequency:\n\n![](https://betterexplained.com/wp-content/uploads/images/fourier-explained-20121219-224649.png)\n\nA few notes:\n\n- N = number of time samples we have\n- n = current sample we're considering (0 ... N-1)\n- x<sub>n</sub> = value of the signal at time n\n- k = current frequency we're considering (0 Hertz up to N-1 Hertz)\n- X<sub>k</sub> = amount of frequency k in the signal (amplitude and phase, a complex number)\n- The 1/N factor is usually moved to the reverse transform (going from frequencies back to time). This is allowed, though I prefer 1/N in the forward transform since it gives the actual sizes for the time spikes. You can get wild and even use 1/sqrt(N) on both transforms (going forward and back creates the 1/N factor).\n- n/N is the percent of the time we've gone through. 2 _ pi _ k is our speed in radians / sec. e^-ix is our backwards-moving circular path. The combination is how far we've moved, for this speed and time.\n- The raw equations for the Fourier Transform just say \"add the complex numbers\". Many programming languages cannot handle complex numbers directly, so you convert everything to rectangular coordinates and add those.\n\nStuart Riffle has a great interpretation of the Fourier Transform:\n\n![](https://betterexplained.com/wp-content/uploads/images/DerivedDFT.png)\n\n## References\n\n- [An Interactive Guide To The Fourier Transform](https://betterexplained.com/articles/an-interactive-guide-to-the-fourier-transform/)\n- [DFT on YouTube by Better Explained](https://www.youtube.com/watch?v=iN0VG9N2q0U&t=0s&index=77&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\n- [FT on YouTube by 3Blue1Brown](https://www.youtube.com/watch?v=spUNpyF58BY&t=0s&index=76&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\n- [FFT on YouTube by Simon Xu](https://www.youtube.com/watch?v=htCj9exbGo0&index=78&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8&t=0s)\n- Wikipedia\n  - [FT](https://en.wikipedia.org/wiki/Fourier_transform)\n  - [DFT](https://www.wikiwand.com/en/Discrete_Fourier_transform)\n  - [DTFT](https://en.wikipedia.org/wiki/Discrete-time_Fourier_transform)\n  - [FFT](https://www.wikiwand.com/en/Fast_Fourier_transform)\n","filetype":".md","index":93},{"title":"Discrete Fourier Transform","category":"fourier-transform","id":"discreteFourierTransform_fourier-transform","algorithm":"import ComplexNumber from '../complex-number/ComplexNumber';\n\nconst CLOSE_TO_ZERO_THRESHOLD = 1e-10;\n\n/**\n * Discrete Fourier Transform (DFT): time to frequencies.\n *\n * Time complexity: O(N^2)\n *\n * @param {number[]} inputAmplitudes - Input signal amplitudes over time (complex\n * numbers with real parts only).\n * @param {number} zeroThreshold - Threshold that is used to convert real and imaginary numbers\n * to zero in case if they are smaller then this.\n *\n * @return {ComplexNumber[]} - Array of complex number. Each of the number represents the frequency\n * or signal. All signals together will form input signal over discrete time periods. Each signal's\n * complex number has radius (amplitude) and phase (angle) in polar form that describes the signal.\n *\n * @see https://gist.github.com/anonymous/129d477ddb1c8025c9ac\n * @see https://betterexplained.com/articles/an-interactive-guide-to-the-fourier-transform/\n */\nexport default function dft(inputAmplitudes, zeroThreshold = CLOSE_TO_ZERO_THRESHOLD) {\n  const N = inputAmplitudes.length;\n  const signals = [];\n\n  // Go through every discrete frequency.\n  for (let frequency = 0; frequency < N; frequency += 1) {\n    // Compound signal at current frequency that will ultimately\n    // take part in forming input amplitudes.\n    let frequencySignal = new ComplexNumber();\n\n    // Go through every discrete point in time.\n    for (let timer = 0; timer < N; timer += 1) {\n      const currentAmplitude = inputAmplitudes[timer];\n\n      // Calculate rotation angle.\n      const rotationAngle = -1 * (2 * Math.PI) * frequency * (timer / N);\n\n      // Remember that e^ix = cos(x) + i * sin(x);\n      const dataPointContribution = new ComplexNumber({\n        re: Math.cos(rotationAngle),\n        im: Math.sin(rotationAngle),\n      }).multiply(currentAmplitude);\n\n      // Add this data point's contribution.\n      frequencySignal = frequencySignal.add(dataPointContribution);\n    }\n\n    // Close to zero? You're zero.\n    if (Math.abs(frequencySignal.re) < zeroThreshold) {\n      frequencySignal.re = 0;\n    }\n\n    if (Math.abs(frequencySignal.im) < zeroThreshold) {\n      frequencySignal.im = 0;\n    }\n\n    // Average contribution at this frequency.\n    // The 1/N factor is usually moved to the reverse transform (going from frequencies\n    // back to time). This is allowed, though it would be nice to have 1/N in the forward\n    // transform since it gives the actual sizes for the time spikes.\n    frequencySignal = frequencySignal.divide(N);\n\n    // Add current frequency signal to the list of compound signals.\n    signals[frequency] = frequencySignal;\n  }\n\n  return signals;\n}\n","filetype":".js","index":94},{"title":"Fast Fourier Transform","category":"fourier-transform","id":"fastFourierTransform_fourier-transform","algorithm":"import ComplexNumber from '../complex-number/ComplexNumber';\nimport bitLength from '../bits/bitLength';\n\n/**\n * Returns the number which is the flipped binary representation of input.\n *\n * @param {number} input\n * @param {number} bitsCount\n * @return {number}\n */\nfunction reverseBits(input, bitsCount) {\n  let reversedBits = 0;\n\n  for (let bitIndex = 0; bitIndex < bitsCount; bitIndex += 1) {\n    reversedBits *= 2;\n\n    if (Math.floor(input / (1 << bitIndex)) % 2 === 1) {\n      reversedBits += 1;\n    }\n  }\n\n  return reversedBits;\n}\n\n/**\n * Returns the radix-2 fast fourier transform of the given array.\n * Optionally computes the radix-2 inverse fast fourier transform.\n *\n * @param {ComplexNumber[]} inputData\n * @param {boolean} [inverse]\n * @return {ComplexNumber[]}\n */\nexport default function fastFourierTransform(inputData, inverse = false) {\n  const bitsCount = bitLength(inputData.length - 1);\n  const N = 1 << bitsCount;\n\n  while (inputData.length < N) {\n    inputData.push(new ComplexNumber());\n  }\n\n  const output = [];\n  for (let dataSampleIndex = 0; dataSampleIndex < N; dataSampleIndex += 1) {\n    output[dataSampleIndex] = inputData[reverseBits(dataSampleIndex, bitsCount)];\n  }\n\n  for (let blockLength = 2; blockLength <= N; blockLength *= 2) {\n    const imaginarySign = inverse ? -1 : 1;\n    const phaseStep = new ComplexNumber({\n      re: Math.cos((2 * Math.PI) / blockLength),\n      im: imaginarySign * Math.sin((2 * Math.PI) / blockLength),\n    });\n\n    for (let blockStart = 0; blockStart < N; blockStart += blockLength) {\n      let phase = new ComplexNumber({ re: 1, im: 0 });\n\n      for (let signalId = blockStart; signalId < (blockStart + blockLength / 2); signalId += 1) {\n        const component = output[signalId + blockLength / 2].multiply(phase);\n\n        const upd1 = output[signalId].add(component);\n        const upd2 = output[signalId].subtract(component);\n\n        output[signalId] = upd1;\n        output[signalId + blockLength / 2] = upd2;\n\n        phase = phase.multiply(phaseStep);\n      }\n    }\n  }\n\n  if (inverse) {\n    for (let signalId = 0; signalId < N; signalId += 1) {\n      output[signalId] /= N;\n    }\n  }\n\n  return output;\n}\n","filetype":".js","index":95},{"title":"Inverse Discrete Fourier Transform","category":"fourier-transform","id":"inverseDiscreteFourierTransform_fourier-transform","algorithm":"import ComplexNumber from '../complex-number/ComplexNumber';\n\nconst CLOSE_TO_ZERO_THRESHOLD = 1e-10;\n\n/**\n * Inverse Discrete Fourier Transform (IDFT): frequencies to time.\n *\n * Time complexity: O(N^2)\n *\n * @param {ComplexNumber[]} frequencies - Frequencies summands of the final signal.\n * @param {number} zeroThreshold - Threshold that is used to convert real and imaginary numbers\n * to zero in case if they are smaller then this.\n *\n * @return {number[]} - Discrete amplitudes distributed in time.\n */\nexport default function inverseDiscreteFourierTransform(\n  frequencies,\n  zeroThreshold = CLOSE_TO_ZERO_THRESHOLD,\n) {\n  const N = frequencies.length;\n  const amplitudes = [];\n\n  // Go through every discrete point of time.\n  for (let timer = 0; timer < N; timer += 1) {\n    // Compound amplitude at current time.\n    let amplitude = new ComplexNumber();\n\n    // Go through all discrete frequencies.\n    for (let frequency = 0; frequency < N; frequency += 1) {\n      const currentFrequency = frequencies[frequency];\n\n      // Calculate rotation angle.\n      const rotationAngle = (2 * Math.PI) * frequency * (timer / N);\n\n      // Remember that e^ix = cos(x) + i * sin(x);\n      const frequencyContribution = new ComplexNumber({\n        re: Math.cos(rotationAngle),\n        im: Math.sin(rotationAngle),\n      }).multiply(currentFrequency);\n\n      amplitude = amplitude.add(frequencyContribution);\n    }\n\n    // Close to zero? You're zero.\n    if (Math.abs(amplitude.re) < zeroThreshold) {\n      amplitude.re = 0;\n    }\n\n    if (Math.abs(amplitude.im) < zeroThreshold) {\n      amplitude.im = 0;\n    }\n\n    // Add current frequency signal to the list of compound signals.\n    amplitudes[timer] = amplitude.re;\n  }\n\n  return amplitudes;\n}\n","filetype":".js","index":96},{"title":"Horner-method","category":"math","id":"horner-method","algorithm":"# Horner's Method\n\nIn mathematics, Horner's method (or Horner's scheme) is an algorithm for polynomial evaluation. With this method, it is possible to evaluate a polynomial with only `n` additions and `n` multiplications. Hence, its storage requirements are `n` times the number of bits of `x`.\n\nHorner's method can be based on the following identity:\n\n![Horner's rule](https://wikimedia.org/api/rest_v1/media/math/render/svg/2a576e42d875496f8b0f0dda5ebff7c2415532e4)\n\nThis identity is called _Horner's rule_.\n\nTo solve the right part of the identity above, for a given `x`, we start by iterating through the polynomial from the inside out, accumulating each iteration result. After `n` iterations, with `n` being the order of the polynomial, the accumulated result gives us the polynomial evaluation. \n\n**Using the polynomial:**\n`4 * x^4 + 2 * x^3 + 3 * x^2 + x^1 + 3`, a traditional approach to evaluate it at `x = 2`, could be representing it as an array `[3, 1, 3, 2, 4]` and iterate over it saving each iteration value at an accumulator, such as `acc += pow(x=2, index) * array[index]`. In essence, each power of a number (`pow`) operation is `n-1` multiplications. So, in this scenario, a total of `14` operations would have happened, composed of `4` additions, `5` multiplications, and `5` pows (we're assuming that each power is calculated by repeated multiplication).\n\nNow, **using the same scenario but with Horner's rule**, the polynomial can be re-written as `x * (x * (x * (4 * x + 2) + 3) + 1) + 3`, representing it as `[4, 2, 3, 1, 3]` it is possible to save the first iteration as `acc = arr[0] * (x=2) + arr[1]`, and then finish iterations for `acc *= (x=2) + arr[index]`. In the same scenario but using Horner's rule, a total of `10` operations would have happened, composed of only `4` additions and `4` multiplications.\n\n## References\n\n- [Wikipedia](https://en.wikipedia.org/wiki/Horner%27s_method)\n","filetype":".md","index":97},{"title":"Classic Polynome","category":"horner-method","id":"classicPolynome_horner-method","algorithm":"/**\n * Returns the evaluation of a polynomial function at a certain point.\n * Uses straightforward approach with powers.\n *\n * @param {number[]} coefficients - i.e. [4, 3, 2] for (4 * x^2 + 3 * x + 2)\n * @param {number} xVal\n * @return {number}\n */\nexport default function classicPolynome(coefficients, xVal) {\n  return coefficients.reverse().reduce(\n    (accumulator, currentCoefficient, index) => {\n      return accumulator + currentCoefficient * (xVal ** index);\n    },\n    0,\n  );\n}\n","filetype":".js","index":98},{"title":"Horner Method","category":"horner-method","id":"hornerMethod_horner-method","algorithm":"/**\n * Returns the evaluation of a polynomial function at a certain point.\n * Uses Horner's rule.\n *\n * @param {number[]} coefficients - i.e. [4, 3, 2] for (4 * x^2 + 3 * x + 2)\n * @param {number} xVal\n * @return {number}\n */\nexport default function hornerMethod(coefficients, xVal) {\n  return coefficients.reduce(\n    (accumulator, currentCoefficient) => {\n      return accumulator * xVal + currentCoefficient;\n    },\n    0,\n  );\n}\n","filetype":".js","index":99},{"title":"Integer-partition","category":"math","id":"integer-partition","algorithm":"# Integer Partition\n\nIn number theory and combinatorics, a partition of a positive \ninteger `n`, also called an **integer partition**, is a way of \nwriting `n` as a sum of positive integers. \n\nTwo sums that differ only in the order of their summands are \nconsidered the same partition. For example, `4` can be partitioned \nin five distinct ways:\n\n```\n4\n3 + 1\n2 + 2\n2 + 1 + 1\n1 + 1 + 1 + 1\n```\n\nThe order-dependent composition `1 + 3` is the same partition\nas `3 + 1`, while the two distinct \ncompositions `1 + 2 + 1` and `1 + 1 + 2` represent the same \npartition `2 + 1 + 1`.\n\nYoung diagrams associated to the partitions of the positive\nintegers `1` through `8`. They are arranged so that images \nunder the reflection about the main diagonal of the square \nare conjugate partitions.\n\n![Integer Partition](https://upload.wikimedia.org/wikipedia/commons/d/d8/Ferrer_partitioning_diagrams.svg)\n\n## References\n\n- [Wikipedia](https://en.wikipedia.org/wiki/Partition_(number_theory))\n- [YouTube](https://www.youtube.com/watch?v=ZaVM057DuzE&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\n","filetype":".md","index":100},{"title":"Integer Partition","category":"integer-partition","id":"integerPartition_integer-partition","algorithm":"/**\n * @param {number} number\n * @return {number}\n */\nexport default function integerPartition(number) {\n  // Create partition matrix for solving this task using Dynamic Programming.\n  const partitionMatrix = Array(number + 1).fill(null).map(() => {\n    return Array(number + 1).fill(null);\n  });\n\n  // Fill partition matrix with initial values.\n\n  // Let's fill the first row that represents how many ways we would have\n  // to combine the numbers 1, 2, 3, ..., n with number 0. We would have zero\n  // ways obviously since with zero number we may form only zero.\n  for (let numberIndex = 1; numberIndex <= number; numberIndex += 1) {\n    partitionMatrix[0][numberIndex] = 0;\n  }\n\n  // Let's fill the first column. It represents the number of ways we can form\n  // number zero out of numbers 0, 0 and 1, 0 and 1 and 2, 0 and 1 and 2 and 3, ...\n  // Obviously there is only one way we could form number 0\n  // and it is with number 0 itself.\n  for (let summandIndex = 0; summandIndex <= number; summandIndex += 1) {\n    partitionMatrix[summandIndex][0] = 1;\n  }\n\n  // Now let's go through other possible options of how we could form number m out of\n  // summands 0, 1, ..., m using Dynamic Programming approach.\n  for (let summandIndex = 1; summandIndex <= number; summandIndex += 1) {\n    for (let numberIndex = 1; numberIndex <= number; numberIndex += 1) {\n      if (summandIndex > numberIndex) {\n        // If summand number is bigger then current number itself then just it won't add\n        // any new ways of forming the number. Thus we may just copy the number from row above.\n        partitionMatrix[summandIndex][numberIndex] = partitionMatrix[summandIndex - 1][numberIndex];\n      } else {\n        /*\n         * The number of combinations would equal to number of combinations of forming the same\n         * number but WITHOUT current summand number PLUS number of combinations of forming the\n         * <current number - current summand> number but WITH current summand.\n         *\n         * Example:\n         * Number of ways to form 5 using summands {0, 1, 2} would equal the SUM of:\n         * - number of ways to form 5 using summands {0, 1} (we've excluded summand 2)\n         * - number of ways to form 3 (because 5 - 2 = 3) using summands {0, 1, 2}\n         * (we've included summand 2)\n        */\n        const combosWithoutSummand = partitionMatrix[summandIndex - 1][numberIndex];\n        const combosWithSummand = partitionMatrix[summandIndex][numberIndex - summandIndex];\n\n        partitionMatrix[summandIndex][numberIndex] = combosWithoutSummand + combosWithSummand;\n      }\n    }\n  }\n\n  return partitionMatrix[number][number];\n}\n","filetype":".js","index":101},{"title":"Is-power-of-two","category":"math","id":"is-power-of-two","algorithm":"# Is a power of two\n\nGiven a positive integer, write a function to find if it is\na power of two or not.\n\n**Naive solution**\n\nIn naive solution we just keep dividing the number by two\nunless the number becomes `1` and every time we do so, we\ncheck that remainder after division is always `0`. Otherwise, the number can't be a power of two.\n\n**Bitwise solution**\n\nPowers of two in binary form always have just one bit set.\nThe only exception is with a signed integer (e.g. an 8-bit\nsigned integer with a value of -128 looks like: `10000000`)\n\n```\n1: 0001\n2: 0010\n4: 0100\n8: 1000\n```\n\nSo after checking that the number is greater than zero,\nwe can use a bitwise hack to test that one and only one\nbit is set.\n\n```\nnumber & (number - 1)\n```\n\nFor example for number `8` that operations will look like:\n\n```\n  1000\n- 0001\n  ----\n  0111\n\n  1000\n& 0111\n  ----\n  0000\n```\n\n## References\n\n- [GeeksForGeeks](https://www.geeksforgeeks.org/program-to-find-whether-a-no-is-power-of-two/)\n- [Bitwise Solution on Stanford](http://www.graphics.stanford.edu/~seander/bithacks.html#DetermineIfPowerOf2)\n- [Binary number subtraction on YouTube](https://www.youtube.com/watch?v=S9LJknZTyos&t=0s&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8&index=66)\n","filetype":".md","index":102},{"title":"Is Power Of Two","category":"is-power-of-two","id":"isPowerOfTwo_is-power-of-two","algorithm":"/**\n * @param {number} number\n * @return {boolean}\n */\nexport default function isPowerOfTwo(number) {\n  // 1 (2^0) is the smallest power of two.\n  if (number < 1) {\n    return false;\n  }\n\n  // Let's find out if we can divide the number by two\n  // many times without remainder.\n  let dividedNumber = number;\n  while (dividedNumber !== 1) {\n    if (dividedNumber % 2 !== 0) {\n      // For every case when remainder isn't zero we can say that this number\n      // couldn't be a result of power of two.\n      return false;\n    }\n\n    dividedNumber /= 2;\n  }\n\n  return true;\n}\n","filetype":".js","index":103},{"title":"Is Power Of Two Bitwise","category":"is-power-of-two","id":"isPowerOfTwoBitwise_is-power-of-two","algorithm":"/**\n * @param {number} number\n * @return {boolean}\n */\nexport default function isPowerOfTwoBitwise(number) {\n  // 1 (2^0) is the smallest power of two.\n  if (number < 1) {\n    return false;\n  }\n\n  /*\n   * Powers of two in binary look like this:\n   * 1: 0001\n   * 2: 0010\n   * 4: 0100\n   * 8: 1000\n   *\n   * Note that there is always exactly 1 bit set. The only exception is with a signed integer.\n   * e.g. An 8-bit signed integer with a value of -128 looks like:\n   * 10000000\n   *\n   * So after checking that the number is greater than zero, we can use a clever little bit\n   * hack to test that one and only one bit is set.\n   */\n  return (number & (number - 1)) === 0;\n}\n","filetype":".js","index":104},{"title":"Least-common-multiple","category":"math","id":"least-common-multiple","algorithm":"# Least common multiple\n\nIn arithmetic and number theory, the least common multiple, \nlowest common multiple, or smallest common multiple of \ntwo integers `a` and `b`, usually denoted by `LCM(a, b)`, is \nthe smallest positive integer that is divisible by \nboth `a` and `b`. Since division of integers by zero is \nundefined, this definition has meaning only if `a` and `b` are \nboth different from zero. However, some authors define `lcm(a,0)`\nas `0` for all `a`, which is the result of taking the `lcm`\nto be the least upper bound in the lattice of divisibility.\n\n## Example\n\nWhat is the LCM of 4 and 6?\n\nMultiples of `4` are:\n\n```\n4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 68, 72, 76, ...\n```\n\nand the multiples of `6` are:\n\n```\n6, 12, 18, 24, 30, 36, 42, 48, 54, 60, 66, 72, ...\n```\n\nCommon multiples of `4` and `6` are simply the numbers \nthat are in both lists:\n\n```\n12, 24, 36, 48, 60, 72, ....\n```\n\nSo, from this list of the first few common multiples of \nthe numbers `4` and `6`, their least common multiple is `12`.\n\n## Computing the least common multiple\n\nThe following formula reduces the problem of computing the \nleast common multiple to the problem of computing the greatest \ncommon divisor (GCD), also known as the greatest common factor:\n\n```\nlcm(a, b) = |a * b| / gcd(a, b)\n```\n\n![LCM](https://upload.wikimedia.org/wikipedia/commons/c/c9/Symmetrical_5-set_Venn_diagram_LCM_2_3_4_5_7.svg)\n\nA Venn diagram showing the least common multiples of \ncombinations of `2`, `3`, `4`, `5` and `7` (`6` is skipped as \nit is `2 × 3`, both of which are already represented).\n\nFor example, a card game which requires its cards to be \ndivided equally among up to `5` players requires at least `60`\ncards, the number at the intersection of the `2`, `3`, `4`\nand `5` sets, but not the `7` set.\n\n## References\n\n[Wikipedia](https://en.wikipedia.org/wiki/Least_common_multiple)\n","filetype":".md","index":105},{"title":"Least Common Multiple","category":"least-common-multiple","id":"leastCommonMultiple_least-common-multiple","algorithm":"import euclideanAlgorithm from '../euclidean-algorithm/euclideanAlgorithm';\n\n/**\n * @param {number} a\n * @param {number} b\n * @return {number}\n */\n\nexport default function leastCommonMultiple(a, b) {\n  return ((a === 0) || (b === 0)) ? 0 : Math.abs(a * b) / euclideanAlgorithm(a, b);\n}\n","filetype":".js","index":106},{"title":"Liu-hui","category":"math","id":"liu-hui","algorithm":"# Liu Hui's π Algorithm\n\nLiu Hui remarked in his commentary to The Nine Chapters on the Mathematical Art,\nthat the ratio of the circumference of an inscribed hexagon to the diameter of \nthe circle was `three`, hence `π` must be greater than three. He went on to provide \na detailed step-by-step description of an iterative algorithm to calculate `π` to \nany required accuracy based on bisecting polygons; he calculated `π` to \nbetween `3.141024` and `3.142708` with a 96-gon; he suggested that `3.14` was \na good enough approximation, and expressed `π` as `157/50`; he admitted that \nthis number was a bit small. Later he invented an ingenious quick method to \nimprove on it, and obtained `π ≈ 3.1416` with only a 96-gon, with an accuracy \ncomparable to that from a 1536-gon. His most important contribution in this \narea was his simple iterative `π` algorithm.\n\n## Area of a circle\n\nLiu Hui argued:\n\n> Multiply one side of a hexagon by the radius (of its \ncircumcircle), then multiply this by three, to yield the \narea of a dodecagon; if we cut a hexagon into a \ndodecagon, multiply its side by its radius, then again \nmultiply by six, we get the area of a 24-gon; the finer \nwe cut, the smaller the loss with respect to the area \nof circle, thus with further cut after cut, the area of \nthe resulting polygon will coincide and become one with \nthe circle; there will be no loss\n\n![Liu Hui](https://upload.wikimedia.org/wikipedia/commons/6/69/Cutcircle2.svg)\n\nLiu Hui's method of calculating the area of a circle.\n\nFurther, Liu Hui proved that the area of a circle is half of its circumference \nmultiplied by its radius. He said:\n\n> Between a polygon and a circle, there is excess radius. Multiply the excess \nradius by a side of the polygon. The resulting area exceeds the boundary of \nthe circle\n\nIn the diagram `d = excess radius`. Multiplying `d` by one side results in \noblong `ABCD` which exceeds the boundary of the circle. If a side of the polygon \nis small (i.e. there is a very large number of sides), then the excess radius \nwill be small, hence excess area will be small.\n\n> Multiply the side of a polygon by its radius, and the area doubles; \nhence multiply half the circumference by the radius to yield the area of circle.\n\n![Liu Hui](https://upload.wikimedia.org/wikipedia/commons/9/95/Cutcircle.svg)\n\nThe area within a circle is equal to the radius multiplied by half the \ncircumference, or `A = r x C/2 = r x r x π`.\n\n## Iterative algorithm\n\nLiu Hui began with an inscribed hexagon. Let `M` be the length of one side `AB` of \nhexagon, `r` is the radius of circle.\n\n![Liu Hui](https://upload.wikimedia.org/wikipedia/commons/4/46/Liuhui_geyuanshu.svg)\n\nBisect `AB` with line `OPC`, `AC` becomes one side of dodecagon (12-gon), let \nits length be `m`. Let the length of `PC` be `j` and the length of `OP` be `G`.\n\n`AOP`, `APC` are two right angle triangles. Liu Hui used \nthe [Gou Gu](https://en.wikipedia.org/wiki/Pythagorean_theorem) (Pythagorean theorem)\ntheorem repetitively:\n\n![](https://wikimedia.org/api/rest_v1/media/math/render/svg/dbfc192c78539c3901c7bad470302ededb76f813)\n\n![](https://wikimedia.org/api/rest_v1/media/math/render/svg/ccd12a402367c2d6614c88e75006d50bfc3a9929)\n\n![](https://wikimedia.org/api/rest_v1/media/math/render/svg/65d77869fc02c302d2d46d45f75ad7e79ae524fb)\n\n![](https://wikimedia.org/api/rest_v1/media/math/render/svg/a7a0d0d7f505a0f434e5dd80c2fef6d2b30d6100)\n\n![](https://wikimedia.org/api/rest_v1/media/math/render/svg/c31b9acf38f9d1a248d4023c3bf286bd03007f37)\n\n![](https://wikimedia.org/api/rest_v1/media/math/render/svg/0dee798efb0b1e3e64d6b3542106cb3ecaa4a383)\n\n![](https://wikimedia.org/api/rest_v1/media/math/render/svg/3ffeafe88d2983b364ad3442746063e3207fe842)\n\n\nFrom here, there is now a technique to determine `m` from `M`, which gives the \nside length for a polygon with twice the number of edges. Starting with a \nhexagon, Liu Hui could determine the side length of a dodecagon using this \nformula. Then continue repetitively to determine the side length of a \n24-gon given the side length of a dodecagon. He could do this recursively as \nmany times as necessary. Knowing how to determine the area of these polygons, \nLiu Hui could then approximate `π`.\n\n## References\n\n- [Wikipedia](https://en.wikipedia.org/wiki/Liu_Hui%27s_%CF%80_algorithm)\n","filetype":".md","index":107},{"title":"Liu Hui","category":"liu-hui","id":"liuHui_liu-hui","algorithm":"/*\n * Let circleRadius is the radius of circle.\n * circleRadius is also the side length of the inscribed hexagon\n */\nconst circleRadius = 1;\n\n/**\n * @param {number} sideLength\n * @param {number} splitCounter\n * @return {number}\n */\nfunction getNGonSideLength(sideLength, splitCounter) {\n  if (splitCounter <= 0) {\n    return sideLength;\n  }\n\n  const halfSide = sideLength / 2;\n\n  // Liu Hui used the Gou Gu (Pythagorean theorem) theorem repetitively.\n  const perpendicular = Math.sqrt((circleRadius ** 2) - (halfSide ** 2));\n  const excessRadius = circleRadius - perpendicular;\n  const splitSideLength = Math.sqrt((excessRadius ** 2) + (halfSide ** 2));\n\n  return getNGonSideLength(splitSideLength, splitCounter - 1);\n}\n\n/**\n * @param {number} splitCount\n * @return {number}\n */\nfunction getNGonSideCount(splitCount) {\n  // Liu Hui began with an inscribed hexagon (6-gon).\n  const hexagonSidesCount = 6;\n\n  // On every split iteration we make N-gons: 6-gon, 12-gon, 24-gon, 48-gon and so on.\n  return hexagonSidesCount * (splitCount ? 2 ** splitCount : 1);\n}\n\n/**\n * Calculate the π value using Liu Hui's π algorithm\n *\n * @param {number} splitCount - number of times we're going to split 6-gon.\n *  On each split we will receive 12-gon, 24-gon and so on.\n * @return {number}\n */\nexport default function liuHui(splitCount = 1) {\n  const nGonSideLength = getNGonSideLength(circleRadius, splitCount - 1);\n  const nGonSideCount = getNGonSideCount(splitCount - 1);\n  const nGonPerimeter = nGonSideLength * nGonSideCount;\n  const approximateCircleArea = (nGonPerimeter / 2) * circleRadius;\n\n  // Return approximate value of pi.\n  return approximateCircleArea / (circleRadius ** 2);\n}\n","filetype":".js","index":108},{"title":"Matrix","category":"math","id":"matrix","algorithm":"# Matrices\n\nIn mathematics, a **matrix** (plural **matrices**) is a rectangular array or table of numbers, symbols, or expressions, arranged in rows and columns. For example, the dimension of the matrix below is `2 × 3` (read \"two by three\"), because there are two rows and three columns:\n\n```\n| 1  9 -13 |\n| 20 5 -6  |\n```\n\n![An `m × n` matrix](https://upload.wikimedia.org/wikipedia/commons/b/bf/Matris.png)\n\nAn `m × n` matrix: the `m` rows are horizontal, and the `n` columns are vertical. Each element of a matrix is often denoted by a variable with two subscripts. For example, <i>a<sub>2,1</sub></i> represents the element at the second row and first column of the matrix\n\n## Operations on matrices\n\n### Addition\n\nTo add two matrices: add the numbers in the matching positions:\n\n![Matrices addition](https://www.mathsisfun.com/algebra/images/matrix-addition.gif)\n\nThe two matrices must be the same size, i.e. the rows must match in size, and the columns must match in size.\n\n### Subtracting\n\nTo subtract two matrices: subtract the numbers in the matching positions:\n\n![Matrices subtraction](https://www.mathsisfun.com/algebra/images/matrix-subtraction.gif)\n\n### Multiply by a Constant\n\nWe can multiply a matrix by a constant (the value 2 in this case):\n\n![Matrices multiplication be a constant](https://www.mathsisfun.com/algebra/images/matrix-multiply-constant.gif)\n\n### Multiplying by Another Matrix\n\nTo multiply a matrix by another matrix we need to do the [dot product](https://www.mathsisfun.com/algebra/vectors-dot-product.html) of rows and columns.\n\nTo work out the answer for the **1st row** and **1st column**:\n\n![Matrices multiplication - 1st step](https://www.mathsisfun.com/algebra/images/matrix-multiply-a.svg)\n\nHere it is for the 1st row and 2nd column:\n\n![Matrices multiplication - 2st step](https://www.mathsisfun.com/algebra/images/matrix-multiply-b.svg)\n\nIf we'll do the same for the rest of the rows and columns we'll get the following resulting matrix:\n\n![Matrices multiplication - Result](https://www.mathsisfun.com/algebra/images/matrix-multiply-c.svg)\n\n### Transposing\n\nTo \"transpose\" a matrix, swap the rows and columns.\n\nWe put a \"T\" in the top right-hand corner to mean transpose:\n\n![Transposing](https://www.mathsisfun.com/algebra/images/matrix-transpose.gif)\n\n## References\n\n- [Matrices on MathIsFun](https://www.mathsisfun.com/algebra/matrix-introduction.html)\n- [Matrix on Wikipedia](https://en.wikipedia.org/wiki/Matrix_(mathematics))\n","filetype":".md","index":109},{"title":"Matrix","category":"matrix","id":"Matrix_matrix","algorithm":"/**\n * @typedef {number} Cell\n * @typedef {Cell[][]|Cell[][][]} Matrix\n * @typedef {number[]} Shape\n * @typedef {number[]} CellIndices\n */\n\n/**\n * Gets the matrix's shape.\n *\n * @param {Matrix} m\n * @returns {Shape}\n */\nexport const shape = (m) => {\n  const shapes = [];\n  let dimension = m;\n  while (dimension && Array.isArray(dimension)) {\n    shapes.push(dimension.length);\n    dimension = (dimension.length && [...dimension][0]) || null;\n  }\n  return shapes;\n};\n\n/**\n * Checks if matrix has a correct type.\n *\n * @param {Matrix} m\n * @throws {Error}\n */\nconst validateType = (m) => {\n  if (\n    !m\n    || !Array.isArray(m)\n    || !Array.isArray(m[0])\n  ) {\n    throw new Error('Invalid matrix format');\n  }\n};\n\n/**\n * Checks if matrix is two dimensional.\n *\n * @param {Matrix} m\n * @throws {Error}\n */\nconst validate2D = (m) => {\n  validateType(m);\n  const aShape = shape(m);\n  if (aShape.length !== 2) {\n    throw new Error('Matrix is not of 2D shape');\n  }\n};\n\n/**\n * Validates that matrices are of the same shape.\n *\n * @param {Matrix} a\n * @param {Matrix} b\n * @trows {Error}\n */\nexport const validateSameShape = (a, b) => {\n  validateType(a);\n  validateType(b);\n\n  const aShape = shape(a);\n  const bShape = shape(b);\n\n  if (aShape.length !== bShape.length) {\n    throw new Error('Matrices have different dimensions');\n  }\n\n  while (aShape.length && bShape.length) {\n    if (aShape.pop() !== bShape.pop()) {\n      throw new Error('Matrices have different shapes');\n    }\n  }\n};\n\n/**\n * Generates the matrix of specific shape with specific values.\n *\n * @param {Shape} mShape - the shape of the matrix to generate\n * @param {function({CellIndex}): Cell} fill - cell values of a generated matrix.\n * @returns {Matrix}\n */\nexport const generate = (mShape, fill) => {\n  /**\n   * Generates the matrix recursively.\n   *\n   * @param {Shape} recShape - the shape of the matrix to generate\n   * @param {CellIndices} recIndices\n   * @returns {Matrix}\n   */\n  const generateRecursively = (recShape, recIndices) => {\n    if (recShape.length === 1) {\n      return Array(recShape[0])\n        .fill(null)\n        .map((cellValue, cellIndex) => fill([...recIndices, cellIndex]));\n    }\n    const m = [];\n    for (let i = 0; i < recShape[0]; i += 1) {\n      m.push(generateRecursively(recShape.slice(1), [...recIndices, i]));\n    }\n    return m;\n  };\n\n  return generateRecursively(mShape, []);\n};\n\n/**\n * Generates the matrix of zeros of specified shape.\n *\n * @param {Shape} mShape - shape of the matrix\n * @returns {Matrix}\n */\nexport const zeros = (mShape) => {\n  return generate(mShape, () => 0);\n};\n\n/**\n * @param {Matrix} a\n * @param {Matrix} b\n * @return Matrix\n * @throws {Error}\n */\nexport const dot = (a, b) => {\n  // Validate inputs.\n  validate2D(a);\n  validate2D(b);\n\n  // Check dimensions.\n  const aShape = shape(a);\n  const bShape = shape(b);\n  if (aShape[1] !== bShape[0]) {\n    throw new Error('Matrices have incompatible shape for multiplication');\n  }\n\n  // Perform matrix multiplication.\n  const outputShape = [aShape[0], bShape[1]];\n  const c = zeros(outputShape);\n\n  for (let bCol = 0; bCol < b[0].length; bCol += 1) {\n    for (let aRow = 0; aRow < a.length; aRow += 1) {\n      let cellSum = 0;\n      for (let aCol = 0; aCol < a[aRow].length; aCol += 1) {\n        cellSum += a[aRow][aCol] * b[aCol][bCol];\n      }\n      c[aRow][bCol] = cellSum;\n    }\n  }\n\n  return c;\n};\n\n/**\n * Transposes the matrix.\n *\n * @param {Matrix} m\n * @returns Matrix\n * @throws {Error}\n */\nexport const t = (m) => {\n  validate2D(m);\n  const mShape = shape(m);\n  const transposed = zeros([mShape[1], mShape[0]]);\n  for (let row = 0; row < m.length; row += 1) {\n    for (let col = 0; col < m[0].length; col += 1) {\n      transposed[col][row] = m[row][col];\n    }\n  }\n  return transposed;\n};\n\n/**\n * Traverses the matrix.\n *\n * @param {Matrix} m\n * @param {function(indices: CellIndices, c: Cell)} visit\n */\nexport const walk = (m, visit) => {\n  /**\n   * Traverses the matrix recursively.\n   *\n   * @param {Matrix} recM\n   * @param {CellIndices} cellIndices\n   * @return {Matrix}\n   */\n  const recWalk = (recM, cellIndices) => {\n    const recMShape = shape(recM);\n\n    if (recMShape.length === 1) {\n      for (let i = 0; i < recM.length; i += 1) {\n        visit([...cellIndices, i], recM[i]);\n      }\n    }\n    for (let i = 0; i < recM.length; i += 1) {\n      recWalk(recM[i], [...cellIndices, i]);\n    }\n  };\n\n  recWalk(m, []);\n};\n\n/**\n * Gets the matrix cell value at specific index.\n *\n * @param {Matrix} m - Matrix that contains the cell that needs to be updated\n * @param {CellIndices} cellIndices - Array of cell indices\n * @return {Cell}\n */\nexport const getCellAtIndex = (m, cellIndices) => {\n  // We start from the row at specific index.\n  let cell = m[cellIndices[0]];\n  // Going deeper into the next dimensions but not to the last one to preserve\n  // the pointer to the last dimension array.\n  for (let dimIdx = 1; dimIdx < cellIndices.length - 1; dimIdx += 1) {\n    cell = cell[cellIndices[dimIdx]];\n  }\n  // At this moment the cell variable points to the array at the last needed dimension.\n  return cell[cellIndices[cellIndices.length - 1]];\n};\n\n/**\n * Update the matrix cell at specific index.\n *\n * @param {Matrix} m - Matrix that contains the cell that needs to be updated\n * @param {CellIndices} cellIndices - Array of cell indices\n * @param {Cell} cellValue - New cell value\n */\nexport const updateCellAtIndex = (m, cellIndices, cellValue) => {\n  // We start from the row at specific index.\n  let cell = m[cellIndices[0]];\n  // Going deeper into the next dimensions but not to the last one to preserve\n  // the pointer to the last dimension array.\n  for (let dimIdx = 1; dimIdx < cellIndices.length - 1; dimIdx += 1) {\n    cell = cell[cellIndices[dimIdx]];\n  }\n  // At this moment the cell variable points to the array at the last needed dimension.\n  cell[cellIndices[cellIndices.length - 1]] = cellValue;\n};\n\n/**\n * Adds two matrices element-wise.\n *\n * @param {Matrix} a\n * @param {Matrix} b\n * @return {Matrix}\n */\nexport const add = (a, b) => {\n  validateSameShape(a, b);\n  const result = zeros(shape(a));\n\n  walk(a, (cellIndices, cellValue) => {\n    updateCellAtIndex(result, cellIndices, cellValue);\n  });\n\n  walk(b, (cellIndices, cellValue) => {\n    const currentCellValue = getCellAtIndex(result, cellIndices);\n    updateCellAtIndex(result, cellIndices, currentCellValue + cellValue);\n  });\n\n  return result;\n};\n\n/**\n * Multiplies two matrices element-wise.\n *\n * @param {Matrix} a\n * @param {Matrix} b\n * @return {Matrix}\n */\nexport const mul = (a, b) => {\n  validateSameShape(a, b);\n  const result = zeros(shape(a));\n\n  walk(a, (cellIndices, cellValue) => {\n    updateCellAtIndex(result, cellIndices, cellValue);\n  });\n\n  walk(b, (cellIndices, cellValue) => {\n    const currentCellValue = getCellAtIndex(result, cellIndices);\n    updateCellAtIndex(result, cellIndices, currentCellValue * cellValue);\n  });\n\n  return result;\n};\n\n/**\n * Subtract two matrices element-wise.\n *\n * @param {Matrix} a\n * @param {Matrix} b\n * @return {Matrix}\n */\nexport const sub = (a, b) => {\n  validateSameShape(a, b);\n  const result = zeros(shape(a));\n\n  walk(a, (cellIndices, cellValue) => {\n    updateCellAtIndex(result, cellIndices, cellValue);\n  });\n\n  walk(b, (cellIndices, cellValue) => {\n    const currentCellValue = getCellAtIndex(result, cellIndices);\n    updateCellAtIndex(result, cellIndices, currentCellValue - cellValue);\n  });\n\n  return result;\n};\n","filetype":".js","index":110},{"title":"__tests__","category":"matrix","id":"__tests__","index":111},{"title":"Matrix.test","category":"__tests__","id":"Matrix.test___tests__","algorithm":"import * as mtrx from '../Matrix';\n\ndescribe('Matrix', () => {\n  it('should throw when trying to add matrices of invalid shapes', () => {\n    expect(\n      () => mtrx.dot([0], [1]),\n    ).toThrowError('Invalid matrix format');\n    expect(\n      () => mtrx.dot([[0]], [1]),\n    ).toThrowError('Invalid matrix format');\n    expect(\n      () => mtrx.dot([[[0]]], [[1]]),\n    ).toThrowError('Matrix is not of 2D shape');\n    expect(\n      () => mtrx.dot([[0]], [[1], [2]]),\n    ).toThrowError('Matrices have incompatible shape for multiplication');\n  });\n\n  it('should calculate matrices dimensions', () => {\n    expect(mtrx.shape([])).toEqual([0]);\n\n    expect(mtrx.shape([\n      [],\n    ])).toEqual([1, 0]);\n\n    expect(mtrx.shape([\n      [0],\n    ])).toEqual([1, 1]);\n\n    expect(mtrx.shape([\n      [0, 0],\n    ])).toEqual([1, 2]);\n\n    expect(mtrx.shape([\n      [0, 0],\n      [0, 0],\n    ])).toEqual([2, 2]);\n\n    expect(mtrx.shape([\n      [0, 0, 0],\n      [0, 0, 0],\n    ])).toEqual([2, 3]);\n\n    expect(mtrx.shape([\n      [0, 0],\n      [0, 0],\n      [0, 0],\n    ])).toEqual([3, 2]);\n\n    expect(mtrx.shape([\n      [0, 0, 0],\n      [0, 0, 0],\n      [0, 0, 0],\n    ])).toEqual([3, 3]);\n\n    expect(mtrx.shape([\n      [0],\n      [0],\n      [0],\n    ])).toEqual([3, 1]);\n\n    expect(mtrx.shape([\n      [[0], [0], [0]],\n      [[0], [0], [0]],\n      [[0], [0], [0]],\n    ])).toEqual([3, 3, 1]);\n\n    expect(mtrx.shape([\n      [[0, 0, 0], [0, 0, 0], [0, 0, 0]],\n      [[0, 0, 0], [0, 0, 0], [0, 0, 0]],\n      [[0, 0, 0], [0, 0, 0], [0, 0, 0]],\n    ])).toEqual([3, 3, 3]);\n  });\n\n  it('should generate the matrix of zeros', () => {\n    expect(mtrx.zeros([1, 0])).toEqual([\n      [],\n    ]);\n\n    expect(mtrx.zeros([1, 1])).toEqual([\n      [0],\n    ]);\n\n    expect(mtrx.zeros([1, 3])).toEqual([\n      [0, 0, 0],\n    ]);\n\n    expect(mtrx.zeros([3, 3])).toEqual([\n      [0, 0, 0],\n      [0, 0, 0],\n      [0, 0, 0],\n    ]);\n\n    expect(mtrx.zeros([3, 3, 1])).toEqual([\n      [[0], [0], [0]],\n      [[0], [0], [0]],\n      [[0], [0], [0]],\n    ]);\n  });\n\n  it('should generate the matrix with custom values', () => {\n    expect(mtrx.generate([1, 0], () => 1)).toEqual([\n      [],\n    ]);\n\n    expect(mtrx.generate([1, 1], () => 1)).toEqual([\n      [1],\n    ]);\n\n    expect(mtrx.generate([1, 3], () => 1)).toEqual([\n      [1, 1, 1],\n    ]);\n\n    expect(mtrx.generate([3, 3], () => 1)).toEqual([\n      [1, 1, 1],\n      [1, 1, 1],\n      [1, 1, 1],\n    ]);\n\n    expect(mtrx.generate([3, 3, 1], () => 1)).toEqual([\n      [[1], [1], [1]],\n      [[1], [1], [1]],\n      [[1], [1], [1]],\n    ]);\n  });\n\n  it('should generate a custom matrix based on specific cell indices', () => {\n    const indicesCallback = jest.fn((indices) => {\n      return indices[0] * 10 + indices[1];\n    });\n    const m = mtrx.generate([3, 3], indicesCallback);\n\n    expect(indicesCallback).toHaveBeenCalledTimes(3 * 3);\n    expect(indicesCallback.mock.calls[0][0]).toEqual([0, 0]);\n    expect(indicesCallback.mock.calls[1][0]).toEqual([0, 1]);\n    expect(indicesCallback.mock.calls[2][0]).toEqual([0, 2]);\n    expect(indicesCallback.mock.calls[3][0]).toEqual([1, 0]);\n    expect(indicesCallback.mock.calls[4][0]).toEqual([1, 1]);\n    expect(indicesCallback.mock.calls[5][0]).toEqual([1, 2]);\n    expect(indicesCallback.mock.calls[6][0]).toEqual([2, 0]);\n    expect(indicesCallback.mock.calls[7][0]).toEqual([2, 1]);\n    expect(indicesCallback.mock.calls[8][0]).toEqual([2, 2]);\n    expect(m).toEqual([\n      [0, 1, 2],\n      [10, 11, 12],\n      [20, 21, 22],\n    ]);\n  });\n\n  it('should multiply two matrices', () => {\n    let c;\n    c = mtrx.dot(\n      [\n        [1, 2],\n        [3, 4],\n      ],\n      [\n        [5, 6],\n        [7, 8],\n      ],\n    );\n    expect(mtrx.shape(c)).toEqual([2, 2]);\n    expect(c).toEqual([\n      [19, 22],\n      [43, 50],\n    ]);\n\n    c = mtrx.dot(\n      [\n        [1, 2],\n        [3, 4],\n      ],\n      [\n        [5],\n        [6],\n      ],\n    );\n    expect(mtrx.shape(c)).toEqual([2, 1]);\n    expect(c).toEqual([\n      [17],\n      [39],\n    ]);\n\n    c = mtrx.dot(\n      [\n        [1, 2, 3],\n        [4, 5, 6],\n      ],\n      [\n        [7, 8],\n        [9, 10],\n        [11, 12],\n      ],\n    );\n    expect(mtrx.shape(c)).toEqual([2, 2]);\n    expect(c).toEqual([\n      [58, 64],\n      [139, 154],\n    ]);\n\n    c = mtrx.dot(\n      [\n        [3, 4, 2],\n      ],\n      [\n        [13, 9, 7, 5],\n        [8, 7, 4, 6],\n        [6, 4, 0, 3],\n      ],\n    );\n    expect(mtrx.shape(c)).toEqual([1, 4]);\n    expect(c).toEqual([\n      [83, 63, 37, 45],\n    ]);\n  });\n\n  it('should transpose matrices', () => {\n    expect(mtrx.t([[1, 2, 3]])).toEqual([\n      [1],\n      [2],\n      [3],\n    ]);\n\n    expect(mtrx.t([\n      [1],\n      [2],\n      [3],\n    ])).toEqual([\n      [1, 2, 3],\n    ]);\n\n    expect(mtrx.t([\n      [1, 2, 3],\n      [4, 5, 6],\n    ])).toEqual([\n      [1, 4],\n      [2, 5],\n      [3, 6],\n    ]);\n\n    expect(mtrx.t([\n      [1, 2, 3],\n      [4, 5, 6],\n      [7, 8, 9],\n    ])).toEqual([\n      [1, 4, 7],\n      [2, 5, 8],\n      [3, 6, 9],\n    ]);\n  });\n\n  it('should throw when trying to transpose non 2D matrix', () => {\n    expect(() => {\n      mtrx.t([[[1]]]);\n    }).toThrowError('Matrix is not of 2D shape');\n  });\n\n  it('should add two matrices', () => {\n    expect(mtrx.add([[1]], [[2]])).toEqual([[3]]);\n\n    expect(mtrx.add(\n      [[1, 2, 3]],\n      [[4, 5, 6]],\n    ))\n      .toEqual(\n        [[5, 7, 9]],\n      );\n\n    expect(mtrx.add(\n      [[1], [2], [3]],\n      [[4], [5], [6]],\n    ))\n      .toEqual(\n        [[5], [7], [9]],\n      );\n\n    expect(mtrx.add(\n      [\n        [1, 2, 3],\n        [4, 5, 6],\n        [7, 8, 9],\n      ],\n      [\n        [10, 11, 12],\n        [13, 14, 15],\n        [16, 17, 18],\n      ],\n    ))\n      .toEqual(\n        [\n          [11, 13, 15],\n          [17, 19, 21],\n          [23, 25, 27],\n        ],\n      );\n\n    expect(mtrx.add(\n      [\n        [[1], [2], [3]],\n        [[4], [5], [6]],\n        [[7], [8], [9]],\n      ],\n      [\n        [[10], [11], [12]],\n        [[13], [14], [15]],\n        [[16], [17], [18]],\n      ],\n    ))\n      .toEqual(\n        [\n          [[11], [13], [15]],\n          [[17], [19], [21]],\n          [[23], [25], [27]],\n        ],\n      );\n  });\n\n  it('should throw when trying to add matrices of different shape', () => {\n    expect(() => mtrx.add([[0]], [[[0]]])).toThrowError(\n      'Matrices have different dimensions',\n    );\n\n    expect(() => mtrx.add([[0]], [[0, 0]])).toThrowError(\n      'Matrices have different shapes',\n    );\n  });\n\n  it('should do element wise multiplication two matrices', () => {\n    expect(mtrx.mul([[2]], [[3]])).toEqual([[6]]);\n\n    expect(mtrx.mul(\n      [[1, 2, 3]],\n      [[4, 5, 6]],\n    ))\n      .toEqual(\n        [[4, 10, 18]],\n      );\n\n    expect(mtrx.mul(\n      [[1], [2], [3]],\n      [[4], [5], [6]],\n    ))\n      .toEqual(\n        [[4], [10], [18]],\n      );\n\n    expect(mtrx.mul(\n      [\n        [1, 2],\n        [3, 4],\n      ],\n      [\n        [5, 6],\n        [7, 8],\n      ],\n    ))\n      .toEqual(\n        [\n          [5, 12],\n          [21, 32],\n        ],\n      );\n\n    expect(mtrx.mul(\n      [\n        [[1], [2]],\n        [[3], [4]],\n      ],\n      [\n        [[5], [6]],\n        [[7], [8]],\n      ],\n    ))\n      .toEqual(\n        [\n          [[5], [12]],\n          [[21], [32]],\n        ],\n      );\n  });\n\n  it('should throw when trying to multiply matrices element-wise of different shape', () => {\n    expect(() => mtrx.mul([[0]], [[[0]]])).toThrowError(\n      'Matrices have different dimensions',\n    );\n\n    expect(() => mtrx.mul([[0]], [[0, 0]])).toThrowError(\n      'Matrices have different shapes',\n    );\n  });\n\n  it('should do element wise subtraction two matrices', () => {\n    expect(mtrx.sub([[3]], [[2]])).toEqual([[1]]);\n\n    expect(mtrx.sub(\n      [[10, 12, 14]],\n      [[4, 5, 6]],\n    ))\n      .toEqual(\n        [[6, 7, 8]],\n      );\n\n    expect(mtrx.sub(\n      [[[10], [12], [14]]],\n      [[[4], [5], [6]]],\n    ))\n      .toEqual(\n        [[[6], [7], [8]]],\n      );\n\n    expect(mtrx.sub(\n      [\n        [10, 20],\n        [30, 40],\n      ],\n      [\n        [5, 6],\n        [7, 8],\n      ],\n    ))\n      .toEqual(\n        [\n          [5, 14],\n          [23, 32],\n        ],\n      );\n\n    expect(mtrx.sub(\n      [\n        [[10], [20]],\n        [[30], [40]],\n      ],\n      [\n        [[5], [6]],\n        [[7], [8]],\n      ],\n    ))\n      .toEqual(\n        [\n          [[5], [14]],\n          [[23], [32]],\n        ],\n      );\n  });\n\n  it('should throw when trying to subtract matrices element-wise of different shape', () => {\n    expect(() => mtrx.sub([[0]], [[[0]]])).toThrowError(\n      'Matrices have different dimensions',\n    );\n\n    expect(() => mtrx.sub([[0]], [[0, 0]])).toThrowError(\n      'Matrices have different shapes',\n    );\n  });\n});\n","filetype":".js","index":112},{"title":"Pascal-triangle","category":"math","id":"pascal-triangle","algorithm":"# Pascal's Triangle\n\nIn mathematics, **Pascal's triangle** is a triangular array of \nthe [binomial coefficients](https://en.wikipedia.org/wiki/Binomial_coefficient).\n\nThe rows of Pascal's triangle are conventionally enumerated \nstarting with row `n = 0` at the top (the `0th` row). The \nentries in each row are numbered from the left beginning \nwith `k = 0` and are usually staggered relative to the \nnumbers in the adjacent rows. The triangle may be constructed\nin the following manner: In row `0` (the topmost row), there \nis a unique nonzero entry `1`. Each entry of each subsequent\nrow is constructed by adding the number above and to the \nleft with the number above and to the right, treating blank \nentries as `0`. For example, the initial number in the \nfirst (or any other) row is `1` (the sum of `0` and `1`),\nwhereas the numbers `1` and `3` in the third row are added \nto produce the number `4` in the fourth row.\n\n![Pascal's Triangle](https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif)\n\n## Formula\n\nThe entry in the `nth` row and `kth` column of Pascal's \ntriangle is denoted ![Formula](https://wikimedia.org/api/rest_v1/media/math/render/svg/206415d3742167e319b2e52c2ca7563b799abad7).\nFor example, the unique nonzero entry in the topmost \nrow is ![Formula example](https://wikimedia.org/api/rest_v1/media/math/render/svg/b7e35f86368d5978b46c07fd6dddca86bd6e635c).\n\nWith this notation, the construction of the previous \nparagraph may be written as follows:\n\n![Formula](https://wikimedia.org/api/rest_v1/media/math/render/svg/203b128a098e18cbb8cf36d004bd7282b28461bf)\n\nfor any non-negative integer `n` and any \ninteger `k` between `0` and `n`, inclusive.\n\n![Binomial Coefficient](https://wikimedia.org/api/rest_v1/media/math/render/svg/a2457a7ef3c77831e34e06a1fe17a80b84a03181)\n\n## Calculating triangle entries in O(n) time\n\nWe know that `i`-th entry in a line number `lineNumber` is \nBinomial Coefficient `C(lineNumber, i)` and all lines start \nwith value `1`. The idea is to \ncalculate `C(lineNumber, i)` using `C(lineNumber, i-1)`. It \ncan be calculated in `O(1)` time using the following:\n\n```\nC(lineNumber, i)   = lineNumber! / ((lineNumber - i)! * i!)\nC(lineNumber, i - 1) = lineNumber! / ((lineNumber - i + 1)! * (i - 1)!)\n```\n\nWe can derive following expression from above two expressions:\n\n```\nC(lineNumber, i) = C(lineNumber, i - 1) * (lineNumber - i + 1) / i\n```\n\nSo `C(lineNumber, i)` can be calculated \nfrom `C(lineNumber, i - 1)` in `O(1)` time.\n\n## References\n\n- [Wikipedia](https://en.wikipedia.org/wiki/Pascal%27s_triangle)\n- [GeeksForGeeks](https://www.geeksforgeeks.org/pascal-triangle/)\n","filetype":".md","index":113},{"title":"Pascal Triangle","category":"pascal-triangle","id":"pascalTriangle_pascal-triangle","algorithm":"/**\n * @param {number} lineNumber - zero based.\n * @return {number[]}\n */\nexport default function pascalTriangle(lineNumber) {\n  const currentLine = [1];\n\n  const currentLineSize = lineNumber + 1;\n\n  for (let numIndex = 1; numIndex < currentLineSize; numIndex += 1) {\n    // See explanation of this formula in README.\n    currentLine[numIndex] = (currentLine[numIndex - 1] * (lineNumber - numIndex + 1)) / numIndex;\n  }\n\n  return currentLine;\n}\n","filetype":".js","index":114},{"title":"Pascal Triangle Recursive","category":"pascal-triangle","id":"pascalTriangleRecursive_pascal-triangle","algorithm":"/**\n * @param {number} lineNumber - zero based.\n * @return {number[]}\n */\nexport default function pascalTriangleRecursive(lineNumber) {\n  if (lineNumber === 0) {\n    return [1];\n  }\n\n  const currentLineSize = lineNumber + 1;\n  const previousLineSize = currentLineSize - 1;\n\n  // Create container for current line values.\n  const currentLine = [];\n\n  // We'll calculate current line based on previous one.\n  const previousLine = pascalTriangleRecursive(lineNumber - 1);\n\n  // Let's go through all elements of current line except the first and\n  // last one (since they were and will be filled with 1's) and calculate\n  // current coefficient based on previous line.\n  for (let numIndex = 0; numIndex < currentLineSize; numIndex += 1) {\n    const leftCoefficient = (numIndex - 1) >= 0 ? previousLine[numIndex - 1] : 0;\n    const rightCoefficient = numIndex < previousLineSize ? previousLine[numIndex] : 0;\n\n    currentLine[numIndex] = leftCoefficient + rightCoefficient;\n  }\n\n  return currentLine;\n}\n","filetype":".js","index":115},{"title":"Primality-test","category":"math","id":"primality-test","algorithm":"# Primality Test\n\nA **prime number** (or a **prime**) is a natural number greater than `1` that \ncannot be formed by multiplying two smaller natural numbers. A natural number \ngreater than `1` that is not prime is called a composite number. For \nexample, `5` is prime because the only ways of writing it as a \nproduct, `1 × 5` or `5 × 1`, involve `5` itself. However, `6` is \ncomposite because it is the product of two numbers `(2 × 3)` that are \nboth smaller than `6`. \n\n![Prime Numbers](https://upload.wikimedia.org/wikipedia/commons/f/f0/Primes-vs-composites.svg)\n\nA **primality test** is an algorithm for determining whether an input \nnumber is prime. Among other fields of mathematics, it is used \nfor cryptography. Unlike integer factorization, primality tests \ndo not generally give prime factors, only stating whether the \ninput number is prime or not. Factorization is thought to be \na computationally difficult problem, whereas primality testing \nis comparatively easy (its running time is polynomial in the \nsize of the input). \n\n## References\n\n- [Prime Numbers on Wikipedia](https://en.wikipedia.org/wiki/Prime_number)\n- [Primality Test on Wikipedia](https://en.wikipedia.org/wiki/Primality_test)\n","filetype":".md","index":116},{"title":"Trial Division","category":"primality-test","id":"trialDivision_primality-test","algorithm":"/**\n * @param {number} number\n * @return {boolean}\n */\nexport default function trialDivision(number) {\n  // Check if number is integer.\n  if (number % 1 !== 0) {\n    return false;\n  }\n\n  if (number <= 1) {\n    // If number is less than one then it isn't prime by definition.\n    return false;\n  }\n\n  if (number <= 3) {\n    // All numbers from 2 to 3 are prime.\n    return true;\n  }\n\n  // If the number is not divided by 2 then we may eliminate all further even dividers.\n  if (number % 2 === 0) {\n    return false;\n  }\n\n  // If there is no dividers up to square root of n then there is no higher dividers as well.\n  const dividerLimit = Math.sqrt(number);\n  for (let divider = 3; divider <= dividerLimit; divider += 2) {\n    if (number % divider === 0) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","filetype":".js","index":117},{"title":"Prime-factors","category":"math","id":"prime-factors","algorithm":"# Prime Factors\n\n_Read this in other languages:_\n[简体中文](README.zh-CN.md).\n\n**Prime number** is a whole number greater than `1` that **cannot** be made by multiplying other whole numbers. The first few prime numbers are: `2`, `3`, `5`, `7`, `11`, `13`, `17`, `19` and so on.\n\nIf we **can** make it by multiplying other whole numbers it is a **Composite Number**.\n\n![Composite numbers](https://www.mathsisfun.com/numbers/images/prime-composite.svg)\n\n_Image source: [Math is Fun](https://www.mathsisfun.com/prime-factorization.html)_\n\n**Prime factors** are those [prime numbers](https://en.wikipedia.org/wiki/Prime_number) which multiply together to give the original number. For example `39` will have prime factors of `3` and `13` which are also prime numbers. Another example is `15` whose prime factors are `3` and `5`.\n\n![Factors](https://www.mathsisfun.com/numbers/images/factor-2x3.svg)\n\n_Image source: [Math is Fun](https://www.mathsisfun.com/prime-factorization.html)_\n\n## Finding the prime factors and their count accurately\n\nThe approach is to keep on dividing the natural number `n` by indexes from `i = 2` to `i = n` (by prime indexes only). The value of `n` is being overridden by `(n / i)` on each iteration.\n\nThe time complexity till now is `O(n)` in the worst case scenario since the loop runs from index `i = 2` to `i = n`. This time complexity can be reduced from `O(n)` to `O(sqrt(n))`. The optimisation is achievable when loop runs from `i = 2` to `i = sqrt(n)`. Now, we go only till `O(sqrt(n))` because when `i` becomes greater than `sqrt(n)`, we have the confirmation that there is no index `i` left which can divide `n` completely other than `n` itself.\n\n## Hardy-Ramanujan formula for approximate calculation of prime-factor count\n\nIn 1917, a theorem was formulated by G.H Hardy and Srinivasa Ramanujan which states that the normal order of the number `ω(n)` of distinct prime factors of a number `n` is `log(log(n))`.\n\nRoughly speaking, this means that most numbers have about this number of distinct prime factors.\n\n## References\n\n- [Prime numbers on Math is Fun](https://www.mathsisfun.com/prime-factorization.html)\n- [Prime numbers on Wikipedia](https://en.wikipedia.org/wiki/Prime_number)\n- [Hardy–Ramanujan theorem on Wikipedia](https://en.wikipedia.org/wiki/Hardy%E2%80%93Ramanujan_theorem)\n- [Prime factorization of a number on Youtube](https://www.youtube.com/watch?v=6PDtgHhpCHo&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8&index=82)\n","filetype":".md","index":118},{"title":"Prime Factors","category":"prime-factors","id":"primeFactors_prime-factors","algorithm":"/**\n * Finds prime factors of a number.\n *\n * @param {number} n - the number that is going to be split into prime factors.\n * @returns {number[]} - array of prime factors.\n */\nexport function primeFactors(n) {\n  // Clone n to avoid function arguments override.\n  let nn = n;\n\n  // Array that stores the all the prime factors.\n  const factors = [];\n\n  // Running the loop till sqrt(n) instead of n to optimise time complexity from O(n) to O(sqrt(n)).\n  for (let factor = 2; factor <= Math.sqrt(nn); factor += 1) {\n    // Check that factor divides n without a reminder.\n    while (nn % factor === 0) {\n      // Overriding the value of n.\n      nn /= factor;\n      // Saving the factor.\n      factors.push(factor);\n    }\n  }\n\n  // The ultimate reminder should be a last prime factor,\n  // unless it is not 1 (since 1 is not a prime number).\n  if (nn !== 1) {\n    factors.push(nn);\n  }\n\n  return factors;\n}\n\n/**\n * Hardy-Ramanujan approximation of prime factors count.\n *\n * @param {number} n\n * @returns {number} - approximate number of prime factors.\n */\nexport function hardyRamanujan(n) {\n  return Math.log(Math.log(n));\n}\n","filetype":".js","index":119},{"title":"Radian","category":"math","id":"radian","algorithm":"# Radian\n\nThe **radian** (symbol **rad**) is the unit for measuring angles, and is the \nstandard unit of angular measure used in many areas of mathematics.\n\nThe length of an arc of a unit circle is numerically equal to the measurement \nin radians of the angle that it subtends; one radian is just under `57.3` degrees.\n\nAn arc of a circle with the same length as the radius of that circle subtends an \nangle of `1 radian`. The circumference subtends an angle of `2π radians`.\n\n![Radian](https://upload.wikimedia.org/wikipedia/commons/4/4e/Circle_radians.gif)\n\nA complete revolution is 2π radians (shown here with a circle of radius one and \nthus circumference `2π`).\n\n![2 pi Radian](https://upload.wikimedia.org/wikipedia/commons/6/67/2pi-unrolled.gif)\n\n**Conversions**\n\n| Radians | Degrees |\n| :-----: | :-----: |\n| 0       | 0°      |\n| π/12    | 15°     |\n| π/6     | 30°     |\n| π/4     | 45°     |\n| 1       | 57.3°   |\n| π/3     | 60°     |\n| π/2     | 90°     |\n| π       | 180°    |\n| 2π      | 360°    |\n\n\n## References\n\n- [Wikipedia](https://en.wikipedia.org/wiki/Radian)\n","filetype":".md","index":120},{"title":"Degree To Radian","category":"radian","id":"degreeToRadian_radian","algorithm":"/**\n * @param {number} degree\n * @return {number}\n */\nexport default function degreeToRadian(degree) {\n  return degree * (Math.PI / 180);\n}\n","filetype":".js","index":121},{"title":"Radian To Degree","category":"radian","id":"radianToDegree_radian","algorithm":"/**\n * @param {number} radian\n * @return {number}\n */\nexport default function radianToDegree(radian) {\n  return radian * (180 / Math.PI);\n}\n","filetype":".js","index":122},{"title":"Sieve-of-eratosthenes","category":"math","id":"sieve-of-eratosthenes","algorithm":"# Sieve of Eratosthenes\n\nThe Sieve of Eratosthenes is an algorithm for finding all prime numbers up to some limit `n`.\n\nIt is attributed to Eratosthenes of Cyrene, an ancient Greek mathematician.\n\n## How it works\n\n1. Create a boolean array of `n + 1` positions (to represent the numbers `0` through `n`)\n2. Set positions `0` and `1` to `false`, and the rest to `true`\n3. Start at position `p = 2` (the first prime number)\n4. Mark as `false` all the multiples of `p` (that is, positions `2 * p`, `3 * p`, `4 * p`... until you reach the end of the array)\n5. Find the first position greater than `p` that is `true` in the array. If there is no such position, stop. Otherwise, let `p` equal this new number (which is the next prime), and repeat from step 4\n\nWhen the algorithm terminates, the numbers remaining `true` in the array are all \nthe primes below `n`.\n\nAn improvement of this algorithm is, in step 4, start marking multiples \nof `p` from `p * p`, and not from `2 * p`. The reason why this works is because, \nat that point, smaller multiples of `p` will have already been marked `false`.\n\n## Example\n\n![Sieve](https://upload.wikimedia.org/wikipedia/commons/b/b9/Sieve_of_Eratosthenes_animation.gif)\n\n## Complexity\n\nThe algorithm has a complexity of `O(n log(log n))`.\n\n## References\n\n- [Wikipedia](https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes)\n","filetype":".md","index":123},{"title":"Sieve Of Eratosthenes","category":"sieve-of-eratosthenes","id":"sieveOfEratosthenes_sieve-of-eratosthenes","algorithm":"/**\n * @param {number} maxNumber\n * @return {number[]}\n */\nexport default function sieveOfEratosthenes(maxNumber) {\n  const isPrime = new Array(maxNumber + 1).fill(true);\n  isPrime[0] = false;\n  isPrime[1] = false;\n\n  const primes = [];\n\n  for (let number = 2; number <= maxNumber; number += 1) {\n    if (isPrime[number] === true) {\n      primes.push(number);\n\n      /*\n       * Optimisation.\n       * Start marking multiples of `p` from `p * p`, and not from `2 * p`.\n       * The reason why this works is because, at that point, smaller multiples\n       * of `p` will have already been marked `false`.\n       *\n       * Warning: When working with really big numbers, the following line may cause overflow\n       * In that case, it can be changed to:\n       * let nextNumber = 2 * number;\n       */\n      let nextNumber = number * number;\n\n      while (nextNumber <= maxNumber) {\n        isPrime[nextNumber] = false;\n        nextNumber += number;\n      }\n    }\n  }\n\n  return primes;\n}\n","filetype":".js","index":124},{"title":"Square-root","category":"math","id":"square-root","algorithm":"# Square Root (Newton's Method)\n\nIn numerical analysis, a branch of mathematics, there are several square root \nalgorithms or methods of computing the principal square root of a non-negative real \nnumber. As, generally, the roots of a function cannot be computed exactly.\nThe root-finding algorithms provide approximations to roots expressed as floating\npoint numbers.\n\nFinding ![](https://wikimedia.org/api/rest_v1/media/math/render/svg/bff86975b0e7944720b3e635c53c22c032a7a6f1) is\nthe same as solving the equation ![](https://wikimedia.org/api/rest_v1/media/math/render/svg/6cf57722151ef19ba1ca918d702b95c335e21cad) for a\npositive `x`. Therefore, any general numerical root-finding algorithm can be used.\n\n**Newton's method** (also known as the Newton–Raphson method), named after \n_Isaac Newton_ and _Joseph Raphson_, is one example of a root-finding algorithm. It is a \nmethod for finding successively better approximations to the roots of a real-valued function.\n\nLet's start by explaining the general idea of Newton's method and then apply it to our particular\ncase with finding a square root of the number.\n\n## Newton's Method General Idea\n\nThe Newton–Raphson method in one variable is implemented as follows:\n\nThe method starts with a function `f` defined over the real numbers `x`, the function's derivative `f'`, and an \ninitial guess `x0` for a root of the function `f`. If the function satisfies the assumptions made in the derivation \nof the formula and the initial guess is close, then a better approximation `x1` is:\n\n![](https://wikimedia.org/api/rest_v1/media/math/render/svg/52c50eca0b7c4d64ef2fdca678665b73e944cb84)\n\nGeometrically, `(x1, 0)` is the intersection of the `x`-axis and the tangent of \nthe graph of `f` at `(x0, f (x0))`.\n\nThe process is repeated as:\n\n![](https://wikimedia.org/api/rest_v1/media/math/render/svg/710c11b9ec4568d1cfff49b7c7d41e0a7829a736)\n\nuntil a sufficiently accurate value is reached.\n\n![](https://upload.wikimedia.org/wikipedia/commons/e/e0/NewtonIteration_Ani.gif)\n\n## Newton's Method of Finding a Square Root\n\nAs it was mentioned above, finding ![](https://wikimedia.org/api/rest_v1/media/math/render/svg/bff86975b0e7944720b3e635c53c22c032a7a6f1) is\nthe same as solving the equation ![](https://wikimedia.org/api/rest_v1/media/math/render/svg/6cf57722151ef19ba1ca918d702b95c335e21cad) for a\npositive `x`.\n\nThe derivative of the function `f(x)` in case of square root problem is `2x`.\n\nAfter applying the Newton's formula (see above) we get the following equation for our algorithm iterations:\n\n```text\nx := x - (x² - S) / (2x)\n```\n\nThe `x² − S` above is how far away `x²` is from where it needs to be, and the \ndivision by `2x` is the derivative of `x²`, to scale how much we adjust `x` by how \nquickly `x²` is changing.\n\n## References\n\n- [Methods of computing square roots on Wikipedia](https://en.wikipedia.org/wiki/Methods_of_computing_square_roots)\n- [Newton's method on Wikipedia](https://en.wikipedia.org/wiki/Newton%27s_method)\n","filetype":".md","index":125},{"title":"Square Root","category":"square-root","id":"squareRoot_square-root","algorithm":"/**\n * Calculates the square root of the number with given tolerance (precision)\n * by using Newton's method.\n *\n * @param number - the number we want to find a square root for.\n * @param [tolerance] - how many precise numbers after the floating point we want to get.\n * @return {number}\n */\nexport default function squareRoot(number, tolerance = 0) {\n  // For now we won't support operations that involves manipulation with complex numbers.\n  if (number < 0) {\n    throw new Error('The method supports only positive integers');\n  }\n\n  // Handle edge case with finding the square root of zero.\n  if (number === 0) {\n    return 0;\n  }\n\n  // We will start approximation from value 1.\n  let root = 1;\n\n  // Delta is a desired distance between the number and the square of the root.\n  // - if tolerance=0 then delta=1\n  // - if tolerance=1 then delta=0.1\n  // - if tolerance=2 then delta=0.01\n  // - and so on...\n  const requiredDelta = 1 / (10 ** tolerance);\n\n  // Approximating the root value to the point when we get a desired precision.\n  while (Math.abs(number - (root ** 2)) > requiredDelta) {\n    // Newton's method reduces in this case to the so-called Babylonian method.\n    // These methods generally yield approximate results, but can be made arbitrarily\n    // precise by increasing the number of calculation steps.\n    root -= ((root ** 2) - number) / (2 * root);\n  }\n\n  // Cut off undesired floating digits and return the root value.\n  return Math.round(root * (10 ** tolerance)) / (10 ** tolerance);\n}\n","filetype":".js","index":126},{"title":"Ml","category":"algorithms","id":"ml","index":127},{"title":"K-means","category":"ml","id":"k-means","algorithm":"# k-Means Algorithm\n\nThe **k-Means algorithm** is an unsupervised Machine Learning algorithm. It's a clustering algorithm, which groups the sample data on the basis of similarity between dimensions of vectors.\n\nIn k-Means classification, the output is a set of classes assigned to each vector. Each cluster location is continuously optimized in order to get the accurate locations of each cluster such that they represent each group clearly.\n\nThe idea is to calculate the similarity between cluster location and data vectors, and reassign clusters based on it. [Euclidean distance](https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/math/euclidean-distance) is used mostly for this task.\n\n![Euclidean distance between two points](https://upload.wikimedia.org/wikipedia/commons/5/55/Euclidean_distance_2d.svg)\n\n_Image source: [Wikipedia](https://en.wikipedia.org/wiki/Euclidean_distance)_\n\nThe algorithm is as follows:\n\n1. Check for errors like invalid/inconsistent data\n2. Initialize the `k` cluster locations with initial/random `k` points\n3. Calculate the distance of each data point from each cluster\n4. Assign the cluster label of each data point equal to that of the cluster at its minimum distance\n5. Calculate the centroid of each cluster based on the data points it contains\n6. Repeat each of the above steps until the centroid locations are varying\n\nHere is a visualization of k-Means clustering for better understanding:\n\n![KNN Visualization 1](https://upload.wikimedia.org/wikipedia/commons/e/ea/K-means_convergence.gif)\n\n_Image source: [Wikipedia](https://en.wikipedia.org/wiki/K-means_clustering)_\n\nThe centroids are moving continuously in order to create better distinction between the different set of data points. As we can see, after a few iterations, the difference in centroids is quite low between iterations. For example between iterations `13` and `14` the difference is quite small because there the optimizer is tuning boundary cases.\n\n## References\n\n- [k-Means neighbors algorithm on Wikipedia](https://en.wikipedia.org/wiki/K-means_clustering)\n","filetype":".md","index":128},{"title":"K Means","category":"k-means","id":"kMeans_k-means","algorithm":"import * as mtrx from '../../math/matrix/Matrix';\nimport euclideanDistance from '../../math/euclidean-distance/euclideanDistance';\n\n/**\n * Classifies the point in space based on k-Means algorithm.\n *\n * @param {number[][]} data - array of dataSet points, i.e. [[0, 1], [3, 4], [5, 7]]\n * @param {number} k - number of clusters\n * @return {number[]} - the class of the point\n */\nexport default function KMeans(\n  data,\n  k = 1,\n) {\n  if (!data) {\n    throw new Error('The data is empty');\n  }\n\n  // Assign k clusters locations equal to the location of initial k points.\n  const dataDim = data[0].length;\n  const clusterCenters = data.slice(0, k);\n\n  // Continue optimization till convergence.\n  // Centroids should not be moving once optimized.\n  // Calculate distance of each candidate vector from each cluster center.\n  // Assign cluster number to each data vector according to minimum distance.\n\n  // Matrix of distance from each data point to each cluster centroid.\n  const distances = mtrx.zeros([data.length, k]);\n\n  // Vector data points' classes. The value of -1 means that no class has bee assigned yet.\n  const classes = Array(data.length).fill(-1);\n\n  let iterate = true;\n  while (iterate) {\n    iterate = false;\n\n    // Calculate and store the distance of each data point from each cluster.\n    for (let dataIndex = 0; dataIndex < data.length; dataIndex += 1) {\n      for (let clusterIndex = 0; clusterIndex < k; clusterIndex += 1) {\n        distances[dataIndex][clusterIndex] = euclideanDistance(\n          [clusterCenters[clusterIndex]],\n          [data[dataIndex]],\n        );\n      }\n      // Assign the closest cluster number to each dataSet point.\n      const closestClusterIdx = distances[dataIndex].indexOf(\n        Math.min(...distances[dataIndex]),\n      );\n\n      // Check if data point class has been changed and we still need to re-iterate.\n      if (classes[dataIndex] !== closestClusterIdx) {\n        iterate = true;\n      }\n\n      classes[dataIndex] = closestClusterIdx;\n    }\n\n    // Recalculate cluster centroid values via all dimensions of the points under it.\n    for (let clusterIndex = 0; clusterIndex < k; clusterIndex += 1) {\n      // Reset cluster center coordinates since we need to recalculate them.\n      clusterCenters[clusterIndex] = Array(dataDim).fill(0);\n      let clusterSize = 0;\n      for (let dataIndex = 0; dataIndex < data.length; dataIndex += 1) {\n        if (classes[dataIndex] === clusterIndex) {\n          // Register one more data point of current cluster.\n          clusterSize += 1;\n          for (let dimensionIndex = 0; dimensionIndex < dataDim; dimensionIndex += 1) {\n            // Add data point coordinates to the cluster center coordinates.\n            clusterCenters[clusterIndex][dimensionIndex] += data[dataIndex][dimensionIndex];\n          }\n        }\n      }\n      // Calculate the average for each cluster center coordinate.\n      for (let dimensionIndex = 0; dimensionIndex < dataDim; dimensionIndex += 1) {\n        clusterCenters[clusterIndex][dimensionIndex] = parseFloat(Number(\n          clusterCenters[clusterIndex][dimensionIndex] / clusterSize,\n        ).toFixed(2));\n      }\n    }\n  }\n\n  // Return the clusters assigned.\n  return classes;\n}\n","filetype":".js","index":129},{"title":"Knn","category":"ml","id":"knn","algorithm":"# k-Nearest Neighbors Algorithm\n\nThe **k-nearest neighbors algorithm (k-NN)** is a supervised Machine Learning algorithm. It's a classification algorithm, determining the class of a sample vector using a sample data.\n\nIn k-NN classification, the output is a class membership. An object is classified by a plurality vote of its neighbors, with the object being assigned to the class most common among its `k` nearest neighbors (`k` is a positive integer, typically small). If `k = 1`, then the object is simply assigned to the class of that single nearest neighbor.\n\nThe idea is to calculate the similarity between two data points on the basis of a distance metric. [Euclidean distance](https://en.wikipedia.org/wiki/Euclidean_distance) is used mostly for this task.\n\n![Euclidean distance between two points](https://upload.wikimedia.org/wikipedia/commons/5/55/Euclidean_distance_2d.svg)\n\n_Image source: [Wikipedia](https://en.wikipedia.org/wiki/Euclidean_distance)_\n\nThe algorithm is as follows:\n\n1. Check for errors like invalid data/labels.\n2. Calculate the euclidean distance of all the data points in training data with the classification point\n3. Sort the distances of points along with their classes in ascending order\n4. Take the initial `K` classes and find the mode to get the most similar class\n5. Report the most similar class\n\nHere is a visualization of k-NN classification for better understanding:\n\n![KNN Visualization 1](https://upload.wikimedia.org/wikipedia/commons/e/e7/KnnClassification.svg)\n\n_Image source: [Wikipedia](https://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm)_\n\nThe test sample (green dot) should be classified either to blue squares or to red triangles. If `k = 3` (solid line circle) it is assigned to the red triangles because there are `2` triangles and only `1` square inside the inner circle. If `k = 5` (dashed line circle) it is assigned to the blue squares (`3` squares vs. `2` triangles inside the outer circle).\n\nAnother k-NN classification example:\n\n![KNN Visualization 2](https://media.geeksforgeeks.org/wp-content/uploads/graph2-2.png)\n\n_Image source: [GeeksForGeeks](https://media.geeksforgeeks.org/wp-content/uploads/graph2-2.png)_\n\nHere, as we can see, the classification of unknown points will be judged by their proximity to other points.\n\nIt is important to note that `K` is preferred to have odd values in order to break ties. Usually `K` is taken as `3` or `5`.\n\n## References\n\n- [k-nearest neighbors algorithm on Wikipedia](https://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm)\n","filetype":".md","index":130},{"title":"K N N","category":"knn","id":"kNN_knn","algorithm":"/**\n * Classifies the point in space based on k-nearest neighbors algorithm.\n *\n * @param {number[][]} dataSet - array of data points, i.e. [[0, 1], [3, 4], [5, 7]]\n * @param {number[]} labels - array of classes (labels), i.e. [1, 1, 2]\n * @param {number[]} toClassify - the point in space that needs to be classified, i.e. [5, 4]\n * @param {number} k - number of nearest neighbors which will be taken into account (preferably odd)\n * @return {number} - the class of the point\n */\n\nimport euclideanDistance from '../../math/euclidean-distance/euclideanDistance';\n\nexport default function kNN(\n  dataSet,\n  labels,\n  toClassify,\n  k = 3,\n) {\n  if (!dataSet || !labels || !toClassify) {\n    throw new Error('Either dataSet or labels or toClassify were not set');\n  }\n\n  // Calculate distance from toClassify to each point for all dimensions in dataSet.\n  // Store distance and point's label into distances list.\n  const distances = [];\n  for (let i = 0; i < dataSet.length; i += 1) {\n    distances.push({\n      dist: euclideanDistance([dataSet[i]], [toClassify]),\n      label: labels[i],\n    });\n  }\n\n  // Sort distances list (from closer point to further ones).\n  // Take initial k values, count with class index\n  const kNearest = distances.sort((a, b) => {\n    if (a.dist === b.dist) {\n      return 0;\n    }\n    return a.dist < b.dist ? -1 : 1;\n  }).slice(0, k);\n\n  // Count the number of instances of each class in top k members.\n  const labelsCounter = {};\n  let topClass = 0;\n  let topClassCount = 0;\n  for (let i = 0; i < kNearest.length; i += 1) {\n    if (kNearest[i].label in labelsCounter) {\n      labelsCounter[kNearest[i].label] += 1;\n    } else {\n      labelsCounter[kNearest[i].label] = 1;\n    }\n    if (labelsCounter[kNearest[i].label] > topClassCount) {\n      topClassCount = labelsCounter[kNearest[i].label];\n      topClass = kNearest[i].label;\n    }\n  }\n\n  // Return the class with highest count.\n  return topClass;\n}\n","filetype":".js","index":131},{"title":"Search","category":"algorithms","id":"search","index":132},{"title":"Binary-search","category":"search","id":"binary-search","algorithm":"# Binary Search\n\nIn computer science, binary search, also known as half-interval \nsearch, logarithmic search, or binary chop, is a search algorithm \nthat finds the position of a target value within a sorted \narray. Binary search compares the target value to the middle \nelement of the array; if they are unequal, the half in which \nthe target cannot lie is eliminated and the search continues \non the remaining half until it is successful. If the search \nends with the remaining half being empty, the target is not \nin the array.\n\n![Binary Search](https://upload.wikimedia.org/wikipedia/commons/8/83/Binary_Search_Depiction.svg)\n\n## Complexity\n\n**Time Complexity**: `O(log(n))` - since we split search area by two for every\nnext iteration.\n\n## References\n\n- [Wikipedia](https://en.wikipedia.org/wiki/Binary_search_algorithm)\n- [YouTube](https://www.youtube.com/watch?v=P3YID7liBug&index=29&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\n","filetype":".md","index":133},{"title":"Binary Search","category":"binary-search","id":"binarySearch_binary-search","algorithm":"import Comparator from '../../../utils/comparator/Comparator';\n\n/**\n * Binary search implementation.\n *\n * @param {*[]} sortedArray\n * @param {*} seekElement\n * @param {function(a, b)} [comparatorCallback]\n * @return {number}\n */\n\nexport default function binarySearch(sortedArray, seekElement, comparatorCallback) {\n  // Let's create comparator from the comparatorCallback function.\n  // Comparator object will give us common comparison methods like equal() and lessThen().\n  const comparator = new Comparator(comparatorCallback);\n\n  // These two indices will contain current array (sub-array) boundaries.\n  let startIndex = 0;\n  let endIndex = sortedArray.length - 1;\n\n  // Let's continue to split array until boundaries are collapsed\n  // and there is nothing to split anymore.\n  while (startIndex <= endIndex) {\n    // Let's calculate the index of the middle element.\n    const middleIndex = startIndex + Math.floor((endIndex - startIndex) / 2);\n\n    // If we've found the element just return its position.\n    if (comparator.equal(sortedArray[middleIndex], seekElement)) {\n      return middleIndex;\n    }\n\n    // Decide which half to choose for seeking next: left or right one.\n    if (comparator.lessThan(sortedArray[middleIndex], seekElement)) {\n      // Go to the right half of the array.\n      startIndex = middleIndex + 1;\n    } else {\n      // Go to the left half of the array.\n      endIndex = middleIndex - 1;\n    }\n  }\n\n  // Return -1 if we have not found anything.\n  return -1;\n}\n","filetype":".js","index":134},{"title":"Interpolation-search","category":"search","id":"interpolation-search","algorithm":"# Interpolation Search\n\n**Interpolation search** is an algorithm for searching for a key in an array that \nhas been ordered by numerical values assigned to the keys (key values).\n\nFor example we have a sorted array of `n` uniformly distributed values `arr[]`, \nand we need to write a function to search for a particular element `x` in the array.\n\n**Linear Search** finds the element in `O(n)` time, **Jump Search** takes `O(√ n)` time \nand **Binary Search** take `O(Log n)` time.\n\nThe **Interpolation Search** is an improvement over Binary Search for instances, \nwhere the values in a sorted array are _uniformly_ distributed. Binary Search \nalways goes to the middle element to check. On the other hand, interpolation \nsearch may go to different locations according to the value of the key being \nsearched. For example, if the value of the key is closer to the last element, \ninterpolation search is likely to start search toward the end side.\n\nTo find the position to be searched, it uses following formula:\n\n```\n// The idea of formula is to return higher value of pos\n// when element to be searched is closer to arr[hi]. And\n// smaller value when closer to arr[lo]\npos = lo + ((x - arr[lo]) * (hi - lo) / (arr[hi] - arr[Lo]))\n\narr[] - Array where elements need to be searched\nx - Element to be searched\nlo - Starting index in arr[]\nhi - Ending index in arr[]\n```\n\n## Complexity\n\n**Time complexity**: `O(log(log(n))`\n\n## References\n\n- [GeeksForGeeks](https://www.geeksforgeeks.org/interpolation-search/)\n- [Wikipedia](https://en.wikipedia.org/wiki/Interpolation_search)\n","filetype":".md","index":135},{"title":"Interpolation Search","category":"interpolation-search","id":"interpolationSearch_interpolation-search","algorithm":"/**\n * Interpolation search implementation.\n *\n * @param {*[]} sortedArray - sorted array with uniformly distributed values\n * @param {*} seekElement\n * @return {number}\n */\nexport default function interpolationSearch(sortedArray, seekElement) {\n  let leftIndex = 0;\n  let rightIndex = sortedArray.length - 1;\n\n  while (leftIndex <= rightIndex) {\n    const rangeDelta = sortedArray[rightIndex] - sortedArray[leftIndex];\n    const indexDelta = rightIndex - leftIndex;\n    const valueDelta = seekElement - sortedArray[leftIndex];\n\n    // If valueDelta is less then zero it means that there is no seek element\n    // exists in array since the lowest element from the range is already higher\n    // then seek element.\n    if (valueDelta < 0) {\n      return -1;\n    }\n\n    // If range delta is zero then subarray contains all the same numbers\n    // and thus there is nothing to search for unless this range is all\n    // consists of seek number.\n    if (!rangeDelta) {\n      // By doing this we're also avoiding division by zero while\n      // calculating the middleIndex later.\n      return sortedArray[leftIndex] === seekElement ? leftIndex : -1;\n    }\n\n    // Do interpolation of the middle index.\n    const middleIndex = leftIndex + Math.floor((valueDelta * indexDelta) / rangeDelta);\n\n    // If we've found the element just return its position.\n    if (sortedArray[middleIndex] === seekElement) {\n      return middleIndex;\n    }\n\n    // Decide which half to choose for seeking next: left or right one.\n    if (sortedArray[middleIndex] < seekElement) {\n      // Go to the right half of the array.\n      leftIndex = middleIndex + 1;\n    } else {\n      // Go to the left half of the array.\n      rightIndex = middleIndex - 1;\n    }\n  }\n\n  return -1;\n}\n","filetype":".js","index":136},{"title":"Jump-search","category":"search","id":"jump-search","algorithm":"# Jump Search\n\nLike Binary Search, **Jump Search** (or **Block Search**) is a searching algorithm \nfor sorted arrays. The basic idea is to check fewer elements (than linear search) \nby jumping ahead by fixed steps or skipping some elements in place of searching all \nelements.\n\nFor example, suppose we have an array `arr[]` of size `n` and block (to be jumped)\nof size `m`. Then we search at the indexes `arr[0]`, `arr[m]`, `arr[2 * m]`, ..., `arr[k * m]` and \nso on. Once we find the interval `arr[k * m] < x < arr[(k+1) * m]`, we perform a \nlinear search operation from the index `k * m` to find the element `x`.\n\n**What is the optimal block size to be skipped?**\nIn the worst case, we have to do `n/m` jumps and if the last checked value is \ngreater than the element to be searched for, we perform `m - 1` comparisons more \nfor linear search. Therefore the total number of comparisons in the worst case \nwill be `((n/m) + m - 1)`. The value of the function `((n/m) + m - 1)` will be \nminimum when `m = √n`. Therefore, the best step size is `m = √n`.\n\n## Complexity\n\n**Time complexity**: `O(√n)` - because we do search by blocks of size `√n`.\n\n## References\n\n- [GeeksForGeeks](https://www.geeksforgeeks.org/jump-search/)\n- [Wikipedia](https://en.wikipedia.org/wiki/Jump_search)\n","filetype":".md","index":137},{"title":"Jump Search","category":"jump-search","id":"jumpSearch_jump-search","algorithm":"import Comparator from '../../../utils/comparator/Comparator';\n\n/**\n * Jump (block) search implementation.\n *\n * @param {*[]} sortedArray\n * @param {*} seekElement\n * @param {function(a, b)} [comparatorCallback]\n * @return {number}\n */\nexport default function jumpSearch(sortedArray, seekElement, comparatorCallback) {\n  const comparator = new Comparator(comparatorCallback);\n  const arraySize = sortedArray.length;\n\n  if (!arraySize) {\n    // We can't find anything in empty array.\n    return -1;\n  }\n\n  // Calculate optimal jump size.\n  // Total number of comparisons in the worst case will be ((arraySize/jumpSize) + jumpSize - 1).\n  // The value of the function ((arraySize/jumpSize) + jumpSize - 1) will be minimum\n  // when jumpSize = √array.length.\n  const jumpSize = Math.floor(Math.sqrt(arraySize));\n\n  // Find the block where the seekElement belong to.\n  let blockStart = 0;\n  let blockEnd = jumpSize;\n  while (comparator.greaterThan(seekElement, sortedArray[Math.min(blockEnd, arraySize) - 1])) {\n    // Jump to the next block.\n    blockStart = blockEnd;\n    blockEnd += jumpSize;\n\n    // If our next block is out of array then we couldn't found the element.\n    if (blockStart > arraySize) {\n      return -1;\n    }\n  }\n\n  // Do linear search for seekElement in subarray starting from blockStart.\n  let currentIndex = blockStart;\n  while (currentIndex < Math.min(blockEnd, arraySize)) {\n    if (comparator.equal(sortedArray[currentIndex], seekElement)) {\n      return currentIndex;\n    }\n\n    currentIndex += 1;\n  }\n\n  return -1;\n}\n","filetype":".js","index":138},{"title":"Linear-search","category":"search","id":"linear-search","algorithm":"# Linear Search\nIn computer science, linear search or sequential search is a \nmethod for finding a target value within a list. It sequentially \nchecks each element of the list for the target value until a \nmatch is found or until all the elements have been searched.\nLinear search runs in at worst linear time and makes at most `n` \ncomparisons, where `n` is the length of the list. \n\n![Linear Search](https://www.tutorialspoint.com/data_structures_algorithms/images/linear_search.gif)\n\n## Complexity\n\n**Time Complexity**: `O(n)` - since in worst case we're checking each element\nexactly once.\n\n## References\n- [Wikipedia](https://en.wikipedia.org/wiki/Linear_search)\n- [TutorialsPoint](https://www.tutorialspoint.com/data_structures_algorithms/linear_search_algorithm.htm)\n- [Youtube](https://www.youtube.com/watch?v=SGU9duLE30w)\n","filetype":".md","index":139},{"title":"Linear Search","category":"linear-search","id":"linearSearch_linear-search","algorithm":"import Comparator from '../../../utils/comparator/Comparator';\n\n/**\n * Linear search implementation.\n *\n * @param {*[]} array\n * @param {*} seekElement\n * @param {function(a, b)} [comparatorCallback]\n * @return {number[]}\n */\nexport default function linearSearch(array, seekElement, comparatorCallback) {\n  const comparator = new Comparator(comparatorCallback);\n  const foundIndices = [];\n\n  array.forEach((element, index) => {\n    if (comparator.equal(element, seekElement)) {\n      foundIndices.push(index);\n    }\n  });\n\n  return foundIndices;\n}\n","filetype":".js","index":140},{"title":"Sets","category":"algorithms","id":"sets","index":141},{"title":"Cartesian-product","category":"sets","id":"cartesian-product","algorithm":"# Cartesian Product\n\nIn set theory a Cartesian product is a mathematical operation that returns a set \n(or product set or simply product) from multiple sets. That is, for sets A and B,\nthe Cartesian product A × B is the set of all ordered pairs (a, b)\nwhere a ∈ A and b ∈ B. \n\nCartesian product `AxB` of two sets `A={x,y,z}` and `B={1,2,3}`\n\n![Cartesian Product of Two Sets](https://upload.wikimedia.org/wikipedia/commons/4/4e/Cartesian_Product_qtl1.svg)\n\n## References\n\n[Wikipedia](https://en.wikipedia.org/wiki/Cartesian_product)\n","filetype":".md","index":142},{"title":"Cartesian Product","category":"cartesian-product","id":"cartesianProduct_cartesian-product","algorithm":"/**\n * Generates Cartesian Product of two sets.\n * @param {*[]} setA\n * @param {*[]} setB\n * @return {*[]}\n */\nexport default function cartesianProduct(setA, setB) {\n  // Check if input sets are not empty.\n  // Otherwise return null since we can't generate Cartesian Product out of them.\n  if (!setA || !setB || !setA.length || !setB.length) {\n    return null;\n  }\n\n  // Init product set.\n  const product = [];\n\n  // Now, let's go through all elements of a first and second set and form all possible pairs.\n  for (let indexA = 0; indexA < setA.length; indexA += 1) {\n    for (let indexB = 0; indexB < setB.length; indexB += 1) {\n      // Add current product pair to the product set.\n      product.push([setA[indexA], setB[indexB]]);\n    }\n  }\n\n  // Return cartesian product set.\n  return product;\n}\n","filetype":".js","index":143},{"title":"Combination-sum","category":"sets","id":"combination-sum","algorithm":"# Combination Sum Problem\n\nGiven a **set** of candidate numbers (`candidates`) **(without duplicates)** and \na target number (`target`), find all unique combinations in `candidates` where \nthe candidate numbers sums to `target`.\n\nThe **same** repeated number may be chosen from `candidates` unlimited number \nof times.\n\n**Note:**\n\n- All numbers (including `target`) will be positive integers.\n- The solution set must not contain duplicate combinations.\n\n## Examples\n\n```\nInput: candidates = [2,3,6,7], target = 7,\n\nA solution set is:\n[\n  [7],\n  [2,2,3]\n]\n```\n\n```\nInput: candidates = [2,3,5], target = 8,\n\nA solution set is:\n[\n  [2,2,2,2],\n  [2,3,3],\n  [3,5]\n]\n```\n\n## Explanations\n\nSince the problem is to get all the possible results, not the best or the \nnumber of result, thus we don’t need to consider DP (dynamic programming),\nbacktracking approach using recursion is needed to handle it.\n\nHere is an example of decision tree for the situation when `candidates = [2, 3]` and `target = 6`:\n\n```\n                0\n              /   \\\n           +2      +3\n          /   \\      \\\n       +2       +3    +3\n      /  \\     /  \\     \\\n    +2    ✘   ✘   ✘     ✓\n   /  \\\n  ✓    ✘    \n```\n\n## References\n\n- [LeetCode](https://leetcode.com/problems/combination-sum/description/)\n","filetype":".md","index":144},{"title":"Combination Sum","category":"combination-sum","id":"combinationSum_combination-sum","algorithm":"/**\n * @param {number[]} candidates - candidate numbers we're picking from.\n * @param {number} remainingSum - remaining sum after adding candidates to currentCombination.\n * @param {number[][]} finalCombinations - resulting list of combinations.\n * @param {number[]} currentCombination - currently explored candidates.\n * @param {number} startFrom - index of the candidate to start further exploration from.\n * @return {number[][]}\n */\nfunction combinationSumRecursive(\n  candidates,\n  remainingSum,\n  finalCombinations = [],\n  currentCombination = [],\n  startFrom = 0,\n) {\n  if (remainingSum < 0) {\n    // By adding another candidate we've gone below zero.\n    // This would mean that the last candidate was not acceptable.\n    return finalCombinations;\n  }\n\n  if (remainingSum === 0) {\n    // If after adding the previous candidate our remaining sum\n    // became zero - we need to save the current combination since it is one\n    // of the answers we're looking for.\n    finalCombinations.push(currentCombination.slice());\n\n    return finalCombinations;\n  }\n\n  // If we haven't reached zero yet let's continue to add all\n  // possible candidates that are left.\n  for (let candidateIndex = startFrom; candidateIndex < candidates.length; candidateIndex += 1) {\n    const currentCandidate = candidates[candidateIndex];\n\n    // Let's try to add another candidate.\n    currentCombination.push(currentCandidate);\n\n    // Explore further option with current candidate being added.\n    combinationSumRecursive(\n      candidates,\n      remainingSum - currentCandidate,\n      finalCombinations,\n      currentCombination,\n      candidateIndex,\n    );\n\n    // BACKTRACKING.\n    // Let's get back, exclude current candidate and try another ones later.\n    currentCombination.pop();\n  }\n\n  return finalCombinations;\n}\n\n/**\n * Backtracking algorithm of finding all possible combination for specific sum.\n *\n * @param {number[]} candidates\n * @param {number} target\n * @return {number[][]}\n */\nexport default function combinationSum(candidates, target) {\n  return combinationSumRecursive(candidates, target);\n}\n","filetype":".js","index":145},{"title":"Combinations","category":"sets","id":"combinations","algorithm":"# Combinations\n\nWhen the order doesn't matter, it is a **Combination**.\n\nWhen the order **does** matter it is a **Permutation**.\n\n**\"My fruit salad is a combination of apples, grapes and bananas\"**\nWe don't care what order the fruits are in, they could also be \n\"bananas, grapes and apples\" or \"grapes, apples and bananas\", \nits the same fruit salad.\n\n## Combinations without repetitions\n\nThis is how lotteries work. The numbers are drawn one at a \ntime, and if we have the lucky numbers (no matter what order) \nwe win!\n\nNo Repetition: such as lottery numbers `(2,14,15,27,30,33)`\n\n**Number of combinations**\n\n![Formula](https://www.mathsisfun.com/combinatorics/images/combinations-no-repeat.png)\n\nwhere `n` is the number of things to choose from, and we choose `r` of them,\nno repetition, order doesn't matter.\n\nIt is often called \"n choose r\" (such as \"16 choose 3\"). And is also known as the Binomial Coefficient.\n\n## Combinations with repetitions\n\nRepetition is Allowed: such as coins in your pocket `(5,5,5,10,10)`\n\nOr let us say there are five flavours of ice cream: \n`banana`, `chocolate`, `lemon`, `strawberry` and `vanilla`.\n\nWe can have three scoops. How many variations will there be?\n\nLet's use letters for the flavours: `{b, c, l, s, v}`. \nExample selections include:\n\n- `{c, c, c}` (3 scoops of chocolate)\n- `{b, l, v}` (one each of banana, lemon and vanilla)\n- `{b, v, v}` (one of banana, two of vanilla)\n\n**Number of combinations**\n\n![Formula](https://www.mathsisfun.com/combinatorics/images/combinations-repeat.gif)\n\nWhere `n` is the number of things to choose from, and we \nchoose `r` of them. Repetition allowed, \norder doesn't matter.\n\n## Cheat Sheets\n\nPermutations cheat sheet\n\n![Permutations Cheat Sheet](https://cdn-images-1.medium.com/max/2000/1*JNK-n0Pt0Vbxk0lxVpgT5A.png)\n\nCombinations cheat sheet\n\n![Combinations Cheat Sheet](https://cdn-images-1.medium.com/max/2000/1*7cFRn8jW4g_91YgDAbmxRQ.png)\n\nPermutations/combinations algorithm ideas.\n\n![Algorithms Idea](https://cdn-images-1.medium.com/max/2000/1*vLsSsZMnesCFPCYTYMbxrQ.png)\n\n## References\n\n- [Math Is Fun](https://www.mathsisfun.com/combinatorics/combinations-permutations.html)\n- [Permutations/combinations cheat sheets](https://medium.com/@trekhleb/permutations-combinations-algorithms-cheat-sheet-68c14879aba5)\n","filetype":".md","index":146},{"title":"Combine With Repetitions","category":"combinations","id":"combineWithRepetitions_combinations","algorithm":"/**\n * @param {*[]} comboOptions\n * @param {number} comboLength\n * @return {*[]}\n */\nexport default function combineWithRepetitions(comboOptions, comboLength) {\n  // If the length of the combination is 1 then each element of the original array\n  // is a combination itself.\n  if (comboLength === 1) {\n    return comboOptions.map((comboOption) => [comboOption]);\n  }\n\n  // Init combinations array.\n  const combos = [];\n\n  // Remember characters one by one and concatenate them to combinations of smaller lengths.\n  // We don't extract elements here because the repetitions are allowed.\n  comboOptions.forEach((currentOption, optionIndex) => {\n    // Generate combinations of smaller size.\n    const smallerCombos = combineWithRepetitions(\n      comboOptions.slice(optionIndex),\n      comboLength - 1,\n    );\n\n    // Concatenate currentOption with all combinations of smaller size.\n    smallerCombos.forEach((smallerCombo) => {\n      combos.push([currentOption].concat(smallerCombo));\n    });\n  });\n\n  return combos;\n}\n","filetype":".js","index":147},{"title":"Combine Without Repetitions","category":"combinations","id":"combineWithoutRepetitions_combinations","algorithm":"/**\n * @param {*[]} comboOptions\n * @param {number} comboLength\n * @return {*[]}\n */\nexport default function combineWithoutRepetitions(comboOptions, comboLength) {\n  // If the length of the combination is 1 then each element of the original array\n  // is a combination itself.\n  if (comboLength === 1) {\n    return comboOptions.map((comboOption) => [comboOption]);\n  }\n\n  // Init combinations array.\n  const combos = [];\n\n  // Extract characters one by one and concatenate them to combinations of smaller lengths.\n  // We need to extract them because we don't want to have repetitions after concatenation.\n  comboOptions.forEach((currentOption, optionIndex) => {\n    // Generate combinations of smaller size.\n    const smallerCombos = combineWithoutRepetitions(\n      comboOptions.slice(optionIndex + 1),\n      comboLength - 1,\n    );\n\n    // Concatenate currentOption with all combinations of smaller size.\n    smallerCombos.forEach((smallerCombo) => {\n      combos.push([currentOption].concat(smallerCombo));\n    });\n  });\n\n  return combos;\n}\n","filetype":".js","index":148},{"title":"Fisher-yates","category":"sets","id":"fisher-yates","algorithm":"# Fisher–Yates shuffle\n\nThe Fisher–Yates shuffle is an algorithm for generating a random \npermutation of a finite sequence—in plain terms, the algorithm \nshuffles the sequence. The algorithm effectively puts all the \nelements into a hat; it continually determines the next element \nby randomly drawing an element from the hat until no elements \nremain. The algorithm produces an unbiased permutation: every \npermutation is equally likely. The modern version of the \nalgorithm is efficient: it takes time proportional to the \nnumber of items being shuffled and shuffles them in place.\n\n## References\n\n[Wikipedia](https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle)\n","filetype":".md","index":149},{"title":"Fisher Yates","category":"fisher-yates","id":"fisherYates_fisher-yates","algorithm":"/**\n * @param {*[]} originalArray\n * @return {*[]}\n */\nexport default function fisherYates(originalArray) {\n  // Clone array from preventing original array from modification (for testing purpose).\n  const array = originalArray.slice(0);\n\n  for (let i = (array.length - 1); i > 0; i -= 1) {\n    const randomIndex = Math.floor(Math.random() * (i + 1));\n    [array[i], array[randomIndex]] = [array[randomIndex], array[i]];\n  }\n\n  return array;\n}\n","filetype":".js","index":150},{"title":"Knapsack-problem","category":"sets","id":"knapsack-problem","algorithm":"# Knapsack Problem\n\nThe knapsack problem or rucksack problem is a problem in \ncombinatorial optimization: Given a set of items, each with \na weight and a value, determine the number of each item to \ninclude in a collection so that the total weight is less \nthan or equal to a given limit and the total value is as \nlarge as possible.\n\nIt derives its name from the problem faced by someone who is \nconstrained by a fixed-size knapsack and must fill it with the \nmost valuable items.\n\nExample of a one-dimensional (constraint) knapsack problem: \nwhich boxes should be chosen to maximize the amount of money \nwhile still keeping the overall weight under or equal to 15 kg?\n\n![knapsack problem](https://upload.wikimedia.org/wikipedia/commons/f/fd/Knapsack.svg)\n\n## Definition\n\n### 0/1 knapsack problem\n\nThe most common problem being solved is the **0/1 knapsack problem**, \nwhich restricts the number `xi` of copies of each kind of item to zero or one.\n\nGiven a set of n items numbered from `1` up to `n`, each with a \nweight `wi` and a value `vi`, along with a maximum weight \ncapacity `W`,\n\nmaximize ![0/1 knapsack](https://wikimedia.org/api/rest_v1/media/math/render/svg/85620037d368d2136fb3361702df6a489416931b)\n\nsubject to ![0/1 knapsack](https://wikimedia.org/api/rest_v1/media/math/render/svg/dd6e7c9bca4397980976ea6d19237500ce3b8176)\nand ![0/1 knapsack](https://wikimedia.org/api/rest_v1/media/math/render/svg/07dda71da2a630762c7b21b51ea54f86f422f951)\n\nHere `xi` represents the number of instances of item `i` to \ninclude in the knapsack. Informally, the problem is to maximize \nthe sum of the values of the items in the knapsack so that the \nsum of the weights is less than or equal to the knapsack's \ncapacity.\n\n### Bounded knapsack problem (BKP)\n\nThe **bounded knapsack problem (BKP)** removes the restriction \nthat there is only one of each item, but restricts the number \n`xi` of copies of each kind of item to a maximum non-negative \ninteger value `c`:\n\nmaximize ![bounded knapsack](https://wikimedia.org/api/rest_v1/media/math/render/svg/85620037d368d2136fb3361702df6a489416931b)\n\nsubject to ![bounded knapsack](https://wikimedia.org/api/rest_v1/media/math/render/svg/dd6e7c9bca4397980976ea6d19237500ce3b8176)\nand ![bounded knapsack](https://wikimedia.org/api/rest_v1/media/math/render/svg/6c8c5ac4f8247b3b8e01e89de76a1df0ea969821)\n\n### Unbounded knapsack problem (UKP)\n\nThe **unbounded knapsack problem (UKP)** places no upper bound \non the number of copies of each kind of item and can be \nformulated as above except for that the only restriction \non `xi` is that it is a non-negative integer.\n\nmaximize ![unbounded knapsack](https://wikimedia.org/api/rest_v1/media/math/render/svg/85620037d368d2136fb3361702df6a489416931b)\n\nsubject to ![unbounded knapsack](https://wikimedia.org/api/rest_v1/media/math/render/svg/dd6e7c9bca4397980976ea6d19237500ce3b8176) \nand ![unbounded knapsack](https://wikimedia.org/api/rest_v1/media/math/render/svg/90a99710f61d5dea19e49ae5b31164d2b56b07e3)\n\n## References\n\n- [Wikipedia](https://en.wikipedia.org/wiki/Knapsack_problem)\n- [0/1 Knapsack Problem on YouTube](https://www.youtube.com/watch?v=8LusJS5-AGo&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\n","filetype":".md","index":151},{"title":"Knapsack","category":"knapsack-problem","id":"Knapsack_knapsack-problem","algorithm":"import MergeSort from '../../sorting/merge-sort/MergeSort';\n\nexport default class Knapsack {\n  /**\n   * @param {KnapsackItem[]} possibleItems\n   * @param {number} weightLimit\n   */\n  constructor(possibleItems, weightLimit) {\n    this.selectedItems = [];\n    this.weightLimit = weightLimit;\n    this.possibleItems = possibleItems;\n  }\n\n  sortPossibleItemsByWeight() {\n    this.possibleItems = new MergeSort({\n      /**\n       * @var KnapsackItem itemA\n       * @var KnapsackItem itemB\n       */\n      compareCallback: (itemA, itemB) => {\n        if (itemA.weight === itemB.weight) {\n          return 0;\n        }\n\n        return itemA.weight < itemB.weight ? -1 : 1;\n      },\n    }).sort(this.possibleItems);\n  }\n\n  sortPossibleItemsByValue() {\n    this.possibleItems = new MergeSort({\n      /**\n       * @var KnapsackItem itemA\n       * @var KnapsackItem itemB\n       */\n      compareCallback: (itemA, itemB) => {\n        if (itemA.value === itemB.value) {\n          return 0;\n        }\n\n        return itemA.value > itemB.value ? -1 : 1;\n      },\n    }).sort(this.possibleItems);\n  }\n\n  sortPossibleItemsByValuePerWeightRatio() {\n    this.possibleItems = new MergeSort({\n      /**\n       * @var KnapsackItem itemA\n       * @var KnapsackItem itemB\n       */\n      compareCallback: (itemA, itemB) => {\n        if (itemA.valuePerWeightRatio === itemB.valuePerWeightRatio) {\n          return 0;\n        }\n\n        return itemA.valuePerWeightRatio > itemB.valuePerWeightRatio ? -1 : 1;\n      },\n    }).sort(this.possibleItems);\n  }\n\n  // Solve 0/1 knapsack problem\n  // Dynamic Programming approach.\n  solveZeroOneKnapsackProblem() {\n    // We do two sorts because in case of equal weights but different values\n    // we need to take the most valuable items first.\n    this.sortPossibleItemsByValue();\n    this.sortPossibleItemsByWeight();\n\n    this.selectedItems = [];\n\n    // Create knapsack values matrix.\n    const numberOfRows = this.possibleItems.length;\n    const numberOfColumns = this.weightLimit;\n    const knapsackMatrix = Array(numberOfRows).fill(null).map(() => {\n      return Array(numberOfColumns + 1).fill(null);\n    });\n\n    // Fill the first column with zeros since it would mean that there is\n    // no items we can add to knapsack in case if weight limitation is zero.\n    for (let itemIndex = 0; itemIndex < this.possibleItems.length; itemIndex += 1) {\n      knapsackMatrix[itemIndex][0] = 0;\n    }\n\n    // Fill the first row with max possible values we would get by just adding\n    // or not adding the first item to the knapsack.\n    for (let weightIndex = 1; weightIndex <= this.weightLimit; weightIndex += 1) {\n      const itemIndex = 0;\n      const itemWeight = this.possibleItems[itemIndex].weight;\n      const itemValue = this.possibleItems[itemIndex].value;\n      knapsackMatrix[itemIndex][weightIndex] = itemWeight <= weightIndex ? itemValue : 0;\n    }\n\n    // Go through combinations of how we may add items to knapsack and\n    // define what weight/value we would receive using Dynamic Programming\n    // approach.\n    for (let itemIndex = 1; itemIndex < this.possibleItems.length; itemIndex += 1) {\n      for (let weightIndex = 1; weightIndex <= this.weightLimit; weightIndex += 1) {\n        const currentItemWeight = this.possibleItems[itemIndex].weight;\n        const currentItemValue = this.possibleItems[itemIndex].value;\n\n        if (currentItemWeight > weightIndex) {\n          // In case if item's weight is bigger then currently allowed weight\n          // then we can't add it to knapsack and the max possible value we can\n          // gain at the moment is the max value we got for previous item.\n          knapsackMatrix[itemIndex][weightIndex] = knapsackMatrix[itemIndex - 1][weightIndex];\n        } else {\n          // Else we need to consider the max value we can gain at this point by adding\n          // current value or just by keeping the previous item for current weight.\n          knapsackMatrix[itemIndex][weightIndex] = Math.max(\n            currentItemValue + knapsackMatrix[itemIndex - 1][weightIndex - currentItemWeight],\n            knapsackMatrix[itemIndex - 1][weightIndex],\n          );\n        }\n      }\n    }\n\n    // Now let's trace back the knapsack matrix to see what items we're going to add\n    // to the knapsack.\n    let itemIndex = this.possibleItems.length - 1;\n    let weightIndex = this.weightLimit;\n\n    while (itemIndex > 0) {\n      const currentItem = this.possibleItems[itemIndex];\n      const prevItem = this.possibleItems[itemIndex - 1];\n\n      // Check if matrix value came from top (from previous item).\n      // In this case this would mean that we need to include previous item\n      // to the list of selected items.\n      if (\n        knapsackMatrix[itemIndex][weightIndex]\n        && knapsackMatrix[itemIndex][weightIndex] === knapsackMatrix[itemIndex - 1][weightIndex]\n      ) {\n        // Check if there are several items with the same weight but with the different values.\n        // We need to add highest item in the matrix that is possible to get the highest value.\n        const prevSumValue = knapsackMatrix[itemIndex - 1][weightIndex];\n        const prevPrevSumValue = knapsackMatrix[itemIndex - 2][weightIndex];\n        if (\n          !prevSumValue\n          || (prevSumValue && prevPrevSumValue !== prevSumValue)\n        ) {\n          this.selectedItems.push(prevItem);\n        }\n      } else if (knapsackMatrix[itemIndex - 1][weightIndex - currentItem.weight]) {\n        this.selectedItems.push(prevItem);\n        weightIndex -= currentItem.weight;\n      }\n\n      itemIndex -= 1;\n    }\n  }\n\n  // Solve unbounded knapsack problem.\n  // Greedy approach.\n  solveUnboundedKnapsackProblem() {\n    this.sortPossibleItemsByValue();\n    this.sortPossibleItemsByValuePerWeightRatio();\n\n    for (let itemIndex = 0; itemIndex < this.possibleItems.length; itemIndex += 1) {\n      if (this.totalWeight < this.weightLimit) {\n        const currentItem = this.possibleItems[itemIndex];\n\n        // Detect how much of current items we can push to knapsack.\n        const availableWeight = this.weightLimit - this.totalWeight;\n        const maxPossibleItemsCount = Math.floor(availableWeight / currentItem.weight);\n\n        if (maxPossibleItemsCount > currentItem.itemsInStock) {\n          // If we have more items in stock then it is allowed to add\n          // let's add the maximum allowed number of them.\n          currentItem.quantity = currentItem.itemsInStock;\n        } else if (maxPossibleItemsCount) {\n          // In case if we don't have specified number of items in stock\n          // let's add only items we have in stock.\n          currentItem.quantity = maxPossibleItemsCount;\n        }\n\n        this.selectedItems.push(currentItem);\n      }\n    }\n  }\n\n  get totalValue() {\n    /** @var {KnapsackItem} item */\n    return this.selectedItems.reduce((accumulator, item) => {\n      return accumulator + item.totalValue;\n    }, 0);\n  }\n\n  get totalWeight() {\n    /** @var {KnapsackItem} item */\n    return this.selectedItems.reduce((accumulator, item) => {\n      return accumulator + item.totalWeight;\n    }, 0);\n  }\n}\n","filetype":".js","index":152},{"title":"Knapsack Item","category":"knapsack-problem","id":"KnapsackItem_knapsack-problem","algorithm":"export default class KnapsackItem {\n  /**\n   * @param {Object} itemSettings - knapsack item settings,\n   * @param {number} itemSettings.value - value of the item.\n   * @param {number} itemSettings.weight - weight of the item.\n   * @param {number} itemSettings.itemsInStock - how many items are available to be added.\n   */\n  constructor({ value, weight, itemsInStock = 1 }) {\n    this.value = value;\n    this.weight = weight;\n    this.itemsInStock = itemsInStock;\n    // Actual number of items that is going to be added to knapsack.\n    this.quantity = 1;\n  }\n\n  get totalValue() {\n    return this.value * this.quantity;\n  }\n\n  get totalWeight() {\n    return this.weight * this.quantity;\n  }\n\n  // This coefficient shows how valuable the 1 unit of weight is\n  // for current item.\n  get valuePerWeightRatio() {\n    return this.value / this.weight;\n  }\n\n  toString() {\n    return `v${this.value} w${this.weight} x ${this.quantity}`;\n  }\n}\n","filetype":".js","index":153},{"title":"Longest-common-subsequence","category":"sets","id":"longest-common-subsequence","algorithm":"# Longest common subsequence problem\n\nThe longest common subsequence (LCS) problem is the problem of finding \nthe longest subsequence common to all sequences in a set of sequences \n(often just two sequences). It differs from the longest common substring\nproblem: unlike substrings, subsequences are not required to occupy \nconsecutive positions within the original sequences. \n\n## Application\n\nThe longest common subsequence problem is a classic computer science \nproblem, the basis of data comparison programs such as the diff utility, \nand has applications in bioinformatics. It is also widely used by \nrevision control systems such as Git for reconciling multiple changes \nmade to a revision-controlled collection of files.\n\n## Example\n\n- LCS for input Sequences `ABCDGH` and `AEDFHR` is `ADH` of length 3.\n- LCS for input Sequences `AGGTAB` and `GXTXAYB` is `GTAB` of length 4.\n\n## References\n\n- [Wikipedia](https://en.wikipedia.org/wiki/Longest_common_subsequence_problem)\n- [YouTube](https://www.youtube.com/watch?v=NnD96abizww&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\n","filetype":".md","index":154},{"title":"Longest Common Subsequence","category":"longest-common-subsequence","id":"longestCommonSubsequence_longest-common-subsequence","algorithm":"/**\n * @param {string[]} set1\n * @param {string[]} set2\n * @return {string[]}\n */\nexport default function longestCommonSubsequence(set1, set2) {\n  // Init LCS matrix.\n  const lcsMatrix = Array(set2.length + 1).fill(null).map(() => Array(set1.length + 1).fill(null));\n\n  // Fill first row with zeros.\n  for (let columnIndex = 0; columnIndex <= set1.length; columnIndex += 1) {\n    lcsMatrix[0][columnIndex] = 0;\n  }\n\n  // Fill first column with zeros.\n  for (let rowIndex = 0; rowIndex <= set2.length; rowIndex += 1) {\n    lcsMatrix[rowIndex][0] = 0;\n  }\n\n  // Fill rest of the column that correspond to each of two strings.\n  for (let rowIndex = 1; rowIndex <= set2.length; rowIndex += 1) {\n    for (let columnIndex = 1; columnIndex <= set1.length; columnIndex += 1) {\n      if (set1[columnIndex - 1] === set2[rowIndex - 1]) {\n        lcsMatrix[rowIndex][columnIndex] = lcsMatrix[rowIndex - 1][columnIndex - 1] + 1;\n      } else {\n        lcsMatrix[rowIndex][columnIndex] = Math.max(\n          lcsMatrix[rowIndex - 1][columnIndex],\n          lcsMatrix[rowIndex][columnIndex - 1],\n        );\n      }\n    }\n  }\n\n  // Calculate LCS based on LCS matrix.\n  if (!lcsMatrix[set2.length][set1.length]) {\n    // If the length of largest common string is zero then return empty string.\n    return [''];\n  }\n\n  const longestSequence = [];\n  let columnIndex = set1.length;\n  let rowIndex = set2.length;\n\n  while (columnIndex > 0 || rowIndex > 0) {\n    if (set1[columnIndex - 1] === set2[rowIndex - 1]) {\n      // Move by diagonal left-top.\n      longestSequence.unshift(set1[columnIndex - 1]);\n      columnIndex -= 1;\n      rowIndex -= 1;\n    } else if (lcsMatrix[rowIndex][columnIndex] === lcsMatrix[rowIndex][columnIndex - 1]) {\n      // Move left.\n      columnIndex -= 1;\n    } else {\n      // Move up.\n      rowIndex -= 1;\n    }\n  }\n\n  return longestSequence;\n}\n","filetype":".js","index":155},{"title":"Longest-increasing-subsequence","category":"sets","id":"longest-increasing-subsequence","algorithm":"# Longest Increasing Subsequence\n\nThe longest increasing subsequence problem is to find a subsequence of a \ngiven sequence in which the subsequence's elements are in sorted order, \nlowest to highest, and in which the subsequence is as long as possible. \nThis subsequence is not necessarily contiguous, or unique. \n\n## Complexity\n\nThe longest increasing subsequence problem is solvable in \ntime `O(n log n)`, where `n` denotes the length of the input sequence.\n\nDynamic programming approach has complexity `O(n * n)`.\n\n## Example\n\nIn the first 16 terms of the binary Van der Corput sequence\n\n```\n0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15\n```\n\na longest increasing subsequence is\n\n```\n0, 2, 6, 9, 11, 15.\n```\n\nThis subsequence has length six; \nthe input sequence has no seven-member increasing subsequences. \nThe longest increasing subsequence in this example is not unique: for \ninstance,\n\n```\n0, 4, 6, 9, 11, 15 or\n0, 2, 6, 9, 13, 15 or\n0, 4, 6, 9, 13, 15\n```\n\nare other increasing subsequences of equal length in the same \ninput sequence.\n\n## References\n\n- [Wikipedia](https://en.wikipedia.org/wiki/Longest_increasing_subsequence)\n- [Dynamic Programming Approach on YouTube](https://www.youtube.com/watch?v=CE2b_-XfVDk&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\n","filetype":".md","index":156},{"title":"Dp Longest Increasing Subsequence","category":"longest-increasing-subsequence","id":"dpLongestIncreasingSubsequence_longest-increasing-subsequence","algorithm":"/**\n * Dynamic programming approach to find longest increasing subsequence.\n * Complexity: O(n * n)\n *\n * @param {number[]} sequence\n * @return {number}\n */\nexport default function dpLongestIncreasingSubsequence(sequence) {\n  // Create array with longest increasing substrings length and\n  // fill it with 1-s that would mean that each element of the sequence\n  // is itself a minimum increasing subsequence.\n  const lengthsArray = Array(sequence.length).fill(1);\n\n  let previousElementIndex = 0;\n  let currentElementIndex = 1;\n\n  while (currentElementIndex < sequence.length) {\n    if (sequence[previousElementIndex] < sequence[currentElementIndex]) {\n      // If current element is bigger then the previous one then\n      // current element is a part of increasing subsequence which\n      // length is by one bigger then the length of increasing subsequence\n      // for previous element.\n      const newLength = lengthsArray[previousElementIndex] + 1;\n      if (newLength > lengthsArray[currentElementIndex]) {\n        // Increase only if previous element would give us bigger subsequence length\n        // then we already have for current element.\n        lengthsArray[currentElementIndex] = newLength;\n      }\n    }\n\n    // Move previous element index right.\n    previousElementIndex += 1;\n\n    // If previous element index equals to current element index then\n    // shift current element right and reset previous element index to zero.\n    if (previousElementIndex === currentElementIndex) {\n      currentElementIndex += 1;\n      previousElementIndex = 0;\n    }\n  }\n\n  // Find the biggest element in lengthsArray.\n  // This number is the biggest length of increasing subsequence.\n  let longestIncreasingLength = 0;\n\n  for (let i = 0; i < lengthsArray.length; i += 1) {\n    if (lengthsArray[i] > longestIncreasingLength) {\n      longestIncreasingLength = lengthsArray[i];\n    }\n  }\n\n  return longestIncreasingLength;\n}\n","filetype":".js","index":157},{"title":"Maximum-subarray","category":"sets","id":"maximum-subarray","algorithm":"# Maximum subarray problem\n\nThe maximum subarray problem is the task of finding the contiguous \nsubarray within a one-dimensional array, `a[1...n]`, of numbers \nwhich has the largest sum, where,\n\n![Maximum subarray](https://wikimedia.org/api/rest_v1/media/math/render/svg/e8960f093107b71b21827e726e2bad8b023779b2)\n\n![Maximum subarray](https://www.geeksforgeeks.org/wp-content/uploads/kadane-Algorithm.png)\n\n## Example\n\nThe list usually contains both positive and negative numbers along \nwith `0`. For example, for the array of \nvalues `−2, 1, −3, 4, −1, 2, 1, −5, 4` the contiguous subarray \nwith the largest sum is `4, −1, 2, 1`, with sum `6`.\n\n## References\n\n- [Wikipedia](https://en.wikipedia.org/wiki/Maximum_subarray_problem)\n- [YouTube](https://www.youtube.com/watch?v=ohHWQf1HDfU&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\n- [GeeksForGeeks](https://www.geeksforgeeks.org/largest-sum-contiguous-subarray/)\n","filetype":".md","index":158},{"title":"Bf Maximum Subarray","category":"maximum-subarray","id":"bfMaximumSubarray_maximum-subarray","algorithm":"/**\n * Brute Force solution.\n * Complexity: O(n^2)\n *\n * @param {Number[]} inputArray\n * @return {Number[]}\n */\nexport default function bfMaximumSubarray(inputArray) {\n  let maxSubarrayStartIndex = 0;\n  let maxSubarrayLength = 0;\n  let maxSubarraySum = null;\n\n  for (let startIndex = 0; startIndex < inputArray.length; startIndex += 1) {\n    let subarraySum = 0;\n    for (let arrLength = 1; arrLength <= (inputArray.length - startIndex); arrLength += 1) {\n      subarraySum += inputArray[startIndex + (arrLength - 1)];\n      if (maxSubarraySum === null || subarraySum > maxSubarraySum) {\n        maxSubarraySum = subarraySum;\n        maxSubarrayStartIndex = startIndex;\n        maxSubarrayLength = arrLength;\n      }\n    }\n  }\n\n  return inputArray.slice(maxSubarrayStartIndex, maxSubarrayStartIndex + maxSubarrayLength);\n}\n","filetype":".js","index":159},{"title":"Dp Maximum Subarray","category":"maximum-subarray","id":"dpMaximumSubarray_maximum-subarray","algorithm":"/**\n * Dynamic Programming solution.\n * Complexity: O(n)\n *\n * @param {Number[]} inputArray\n * @return {Number[]}\n */\nexport default function dpMaximumSubarray(inputArray) {\n  // We iterate through the inputArray once, using a greedy approach to keep track of the maximum\n  // sum we've seen so far and the current sum.\n  //\n  // The currentSum variable gets reset to 0 every time it drops below 0.\n  //\n  // The maxSum variable is set to -Infinity so that if all numbers are negative, the highest\n  // negative number will constitute the maximum subarray.\n\n  let maxSum = -Infinity;\n  let currentSum = 0;\n\n  // We need to keep track of the starting and ending indices that contributed to our maxSum\n  // so that we can return the actual subarray. From the beginning let's assume that whole array\n  // is contributing to maxSum.\n  let maxStartIndex = 0;\n  let maxEndIndex = inputArray.length - 1;\n  let currentStartIndex = 0;\n\n  inputArray.forEach((currentNumber, currentIndex) => {\n    currentSum += currentNumber;\n\n    // Update maxSum and the corresponding indices if we have found a new max.\n    if (maxSum < currentSum) {\n      maxSum = currentSum;\n      maxStartIndex = currentStartIndex;\n      maxEndIndex = currentIndex;\n    }\n\n    // Reset currentSum and currentStartIndex if currentSum drops below 0.\n    if (currentSum < 0) {\n      currentSum = 0;\n      currentStartIndex = currentIndex + 1;\n    }\n  });\n\n  return inputArray.slice(maxStartIndex, maxEndIndex + 1);\n}\n","filetype":".js","index":160},{"title":"Permutations","category":"sets","id":"permutations","algorithm":"# Permutations\n\nWhen the order doesn't matter, it is a **Combination**.\n\nWhen the order **does** matter it is a **Permutation**.\n\n**\"The combination to the safe is 472\"**. We do care about the order. `724` won't work, nor will `247`. \nIt has to be exactly `4-7-2`.\n\n## Permutations without repetitions\n\nA permutation, also called an “arrangement number” or “order”, is a rearrangement of \nthe elements of an ordered list `S` into a one-to-one correspondence with `S` itself. \n\nBelow are the permutations of string `ABC`.\n\n`ABC ACB BAC BCA CBA CAB`\n\nOr for example the first three people in a running race: you can't be first and second.\n\n**Number of combinations**\n\n```\nn * (n-1) * (n -2) * ... * 1 = n!\n```\n\n## Permutations with repetitions\n\nWhen repetition is allowed we have permutations with repetitions.\nFor example the the lock below: it could be `333`.\n\n![Permutation Lock](https://www.mathsisfun.com/combinatorics/images/combination-lock.jpg)\n\n**Number of combinations**\n\n```\nn * n * n ... (r times) = n^r\n```\n\n## Cheat Sheets\n\nPermutations cheat sheet\n\n![Permutations Cheat Sheet](https://cdn-images-1.medium.com/max/2000/1*JNK-n0Pt0Vbxk0lxVpgT5A.png)\n\nCombinations cheat sheet\n\n![Combinations Cheat Sheet](https://cdn-images-1.medium.com/max/2000/1*7cFRn8jW4g_91YgDAbmxRQ.png)\n\nPermutations/combinations algorithm ideas.\n\n![Algorithms Idea](https://cdn-images-1.medium.com/max/2000/1*vLsSsZMnesCFPCYTYMbxrQ.png)\n\n## References\n\n- [Math Is Fun](https://www.mathsisfun.com/combinatorics/combinations-permutations.html)\n- [Permutations/combinations cheat sheets](https://medium.com/@trekhleb/permutations-combinations-algorithms-cheat-sheet-68c14879aba5)\n","filetype":".md","index":161},{"title":"Permutate With Repetitions","category":"permutations","id":"permutateWithRepetitions_permutations","algorithm":"/**\n * @param {*[]} permutationOptions\n * @param {number} permutationLength\n * @return {*[]}\n */\nexport default function permutateWithRepetitions(\n  permutationOptions,\n  permutationLength = permutationOptions.length,\n) {\n  if (permutationLength === 1) {\n    return permutationOptions.map((permutationOption) => [permutationOption]);\n  }\n\n  // Init permutations array.\n  const permutations = [];\n\n  // Get smaller permutations.\n  const smallerPermutations = permutateWithRepetitions(\n    permutationOptions,\n    permutationLength - 1,\n  );\n\n  // Go through all options and join it to the smaller permutations.\n  permutationOptions.forEach((currentOption) => {\n    smallerPermutations.forEach((smallerPermutation) => {\n      permutations.push([currentOption].concat(smallerPermutation));\n    });\n  });\n\n  return permutations;\n}\n","filetype":".js","index":162},{"title":"Permutate Without Repetitions","category":"permutations","id":"permutateWithoutRepetitions_permutations","algorithm":"/**\n * @param {*[]} permutationOptions\n * @return {*[]}\n */\nexport default function permutateWithoutRepetitions(permutationOptions) {\n  if (permutationOptions.length === 1) {\n    return [permutationOptions];\n  }\n\n  // Init permutations array.\n  const permutations = [];\n\n  // Get all permutations for permutationOptions excluding the first element.\n  const smallerPermutations = permutateWithoutRepetitions(permutationOptions.slice(1));\n\n  // Insert first option into every possible position of every smaller permutation.\n  const firstOption = permutationOptions[0];\n\n  for (let permIndex = 0; permIndex < smallerPermutations.length; permIndex += 1) {\n    const smallerPermutation = smallerPermutations[permIndex];\n\n    // Insert first option into every possible position of smallerPermutation.\n    for (let positionIndex = 0; positionIndex <= smallerPermutation.length; positionIndex += 1) {\n      const permutationPrefix = smallerPermutation.slice(0, positionIndex);\n      const permutationSuffix = smallerPermutation.slice(positionIndex);\n      permutations.push(permutationPrefix.concat([firstOption], permutationSuffix));\n    }\n  }\n\n  return permutations;\n}\n","filetype":".js","index":163},{"title":"Power-set","category":"sets","id":"power-set","algorithm":"# Power Set\n\nPower set of a set `S` is the set of all of the subsets of `S`, including the\nempty set and `S` itself. Power set of set `S` is denoted as `P(S)`. \n\nFor example for `{x, y, z}`, the subsets\nare:\n\n```text\n{\n  {}, // (also denoted empty set ∅ or the null set)\n  {x},\n  {y},\n  {z},\n  {x, y},\n  {x, z},\n  {y, z},\n  {x, y, z}\n}\n```\n\n![Power Set](https://www.mathsisfun.com/sets/images/power-set.svg)\n\nHere is how we may illustrate the elements of the power set of the set `{x, y, z}` ordered with respect to \ninclusion:\n\n![](https://upload.wikimedia.org/wikipedia/commons/e/ea/Hasse_diagram_of_powerset_of_3.svg)\n\n**Number of Subsets**\n\nIf `S` is a finite set with `|S| = n` elements, then the number of subsets \nof `S` is `|P(S)| = 2^n`. This fact, which is the motivation for the \nnotation `2^S`, may be demonstrated simply as follows:\n\n> First, order the elements of `S` in any manner. We write any subset of `S` in \nthe format `{γ1, γ2, ..., γn}` where `γi , 1 ≤ i ≤ n`, can take the value \nof `0` or `1`. If `γi = 1`, the `i`-th element of `S` is in the subset;\notherwise, the `i`-th element is not in the subset. Clearly the number of \ndistinct subsets that can be constructed this way is `2^n` as `γi ∈ {0, 1}`.\n\n## Algorithms\n\n### Bitwise Solution\n\nEach number in binary representation in a range from `0` to `2^n` does exactly \nwhat we need: it shows by its bits (`0` or `1`) whether to include related \nelement from the set or not. For example, for the set `{1, 2, 3}` the binary \nnumber of `0b010` would mean that we need to include only `2` to the current set.\n\n|       | `abc` | Subset        |\n| :---: | :---: | :-----------: |\n| `0`   | `000` | `{}`          |\n| `1`   | `001` | `{c}`         |\n| `2`   | `010` | `{b}`         | \n| `3`   | `011` | `{c, b}`      |\n| `4`   | `100` | `{a}`         |\n| `5`   | `101` | `{a, c}`      |\n| `6`   | `110` | `{a, b}`      |\n| `7`   | `111` | `{a, b, c}`   |\n\n> See [bwPowerSet.js](./bwPowerSet.js) file for bitwise solution.\n\n### Backtracking Solution\n\nIn backtracking approach we're constantly trying to add next element of the set\nto the subset, memorizing it and then removing it and try the same with the next\nelement.\n\n> See [btPowerSet.js](./btPowerSet.js) file for backtracking solution.\n\n## References\n\n* [Wikipedia](https://en.wikipedia.org/wiki/Power_set)\n* [Math is Fun](https://www.mathsisfun.com/sets/power-set.html)\n","filetype":".md","index":164},{"title":"Bt Power Set","category":"power-set","id":"btPowerSet_power-set","algorithm":"/**\n * @param {*[]} originalSet - Original set of elements we're forming power-set of.\n * @param {*[][]} allSubsets - All subsets that have been formed so far.\n * @param {*[]} currentSubSet - Current subset that we're forming at the moment.\n * @param {number} startAt - The position of in original set we're starting to form current subset.\n * @return {*[][]} - All subsets of original set.\n */\nfunction btPowerSetRecursive(originalSet, allSubsets = [[]], currentSubSet = [], startAt = 0) {\n  // Let's iterate over originalSet elements that may be added to the subset\n  // without having duplicates. The value of startAt prevents adding the duplicates.\n  for (let position = startAt; position < originalSet.length; position += 1) {\n    // Let's push current element to the subset\n    currentSubSet.push(originalSet[position]);\n\n    // Current subset is already valid so let's memorize it.\n    // We do array destruction here to save the clone of the currentSubSet.\n    // We need to save a clone since the original currentSubSet is going to be\n    // mutated in further recursive calls.\n    allSubsets.push([...currentSubSet]);\n\n    // Let's try to generate all other subsets for the current subset.\n    // We're increasing the position by one to avoid duplicates in subset.\n    btPowerSetRecursive(originalSet, allSubsets, currentSubSet, position + 1);\n\n    // BACKTRACK. Exclude last element from the subset and try the next valid one.\n    currentSubSet.pop();\n  }\n\n  // Return all subsets of a set.\n  return allSubsets;\n}\n\n/**\n * Find power-set of a set using BACKTRACKING approach.\n *\n * @param {*[]} originalSet\n * @return {*[][]}\n */\nexport default function btPowerSet(originalSet) {\n  return btPowerSetRecursive(originalSet);\n}\n","filetype":".js","index":165},{"title":"Bw Power Set","category":"power-set","id":"bwPowerSet_power-set","algorithm":"/**\n * Find power-set of a set using BITWISE approach.\n *\n * @param {*[]} originalSet\n * @return {*[][]}\n */\nexport default function bwPowerSet(originalSet) {\n  const subSets = [];\n\n  // We will have 2^n possible combinations (where n is a length of original set).\n  // It is because for every element of original set we will decide whether to include\n  // it or not (2 options for each set element).\n  const numberOfCombinations = 2 ** originalSet.length;\n\n  // Each number in binary representation in a range from 0 to 2^n does exactly what we need:\n  // it shows by its bits (0 or 1) whether to include related element from the set or not.\n  // For example, for the set {1, 2, 3} the binary number of 0b010 would mean that we need to\n  // include only \"2\" to the current set.\n  for (let combinationIndex = 0; combinationIndex < numberOfCombinations; combinationIndex += 1) {\n    const subSet = [];\n\n    for (let setElementIndex = 0; setElementIndex < originalSet.length; setElementIndex += 1) {\n      // Decide whether we need to include current element into the subset or not.\n      if (combinationIndex & (1 << setElementIndex)) {\n        subSet.push(originalSet[setElementIndex]);\n      }\n    }\n\n    // Add current subset to the list of all subsets.\n    subSets.push(subSet);\n  }\n\n  return subSets;\n}\n","filetype":".js","index":166},{"title":"Shortest-common-supersequence","category":"sets","id":"shortest-common-supersequence","algorithm":"# Shortest Common Supersequence\n\nThe shortest common supersequence (SCS) of two sequences `X` and `Y` \nis the shortest sequence which has `X` and `Y` as subsequences.\n\nIn other words assume we're given two strings str1 and str2, find \nthe shortest string that has both str1 and str2 as subsequences.\n\nThis is a problem closely related to the longest common \nsubsequence problem.\n\n## Example\n\n```\nInput:   str1 = \"geek\",  str2 = \"eke\"\nOutput: \"geeke\"\n\nInput:   str1 = \"AGGTAB\",  str2 = \"GXTXAYB\"\nOutput:  \"AGXGTXAYB\"\n```\n\n## References\n\n- [GeeksForGeeks](https://www.geeksforgeeks.org/shortest-common-supersequence/)\n","filetype":".md","index":167},{"title":"Shortest Common Supersequence","category":"shortest-common-supersequence","id":"shortestCommonSupersequence_shortest-common-supersequence","algorithm":"import longestCommonSubsequence from '../longest-common-subsequence/longestCommonSubsequence';\n\n/**\n * @param {string[]} set1\n * @param {string[]} set2\n * @return {string[]}\n */\n\nexport default function shortestCommonSupersequence(set1, set2) {\n  // Let's first find the longest common subsequence of two sets.\n  const lcs = longestCommonSubsequence(set1, set2);\n\n  // If LCS is empty then the shortest common supersequence would be just\n  // concatenation of two sequences.\n  if (lcs.length === 1 && lcs[0] === '') {\n    return set1.concat(set2);\n  }\n\n  // Now let's add elements of set1 and set2 in order before/inside/after the LCS.\n  let supersequence = [];\n\n  let setIndex1 = 0;\n  let setIndex2 = 0;\n  let lcsIndex = 0;\n  let setOnHold1 = false;\n  let setOnHold2 = false;\n\n  while (lcsIndex < lcs.length) {\n    // Add elements of the first set to supersequence in correct order.\n    if (setIndex1 < set1.length) {\n      if (!setOnHold1 && set1[setIndex1] !== lcs[lcsIndex]) {\n        supersequence.push(set1[setIndex1]);\n        setIndex1 += 1;\n      } else {\n        setOnHold1 = true;\n      }\n    }\n\n    // Add elements of the second set to supersequence in correct order.\n    if (setIndex2 < set2.length) {\n      if (!setOnHold2 && set2[setIndex2] !== lcs[lcsIndex]) {\n        supersequence.push(set2[setIndex2]);\n        setIndex2 += 1;\n      } else {\n        setOnHold2 = true;\n      }\n    }\n\n    // Add LCS element to the supersequence in correct order.\n    if (setOnHold1 && setOnHold2) {\n      supersequence.push(lcs[lcsIndex]);\n      lcsIndex += 1;\n      setIndex1 += 1;\n      setIndex2 += 1;\n      setOnHold1 = false;\n      setOnHold2 = false;\n    }\n  }\n\n  // Attach set1 leftovers.\n  if (setIndex1 < set1.length) {\n    supersequence = supersequence.concat(set1.slice(setIndex1));\n  }\n\n  // Attach set2 leftovers.\n  if (setIndex2 < set2.length) {\n    supersequence = supersequence.concat(set2.slice(setIndex2));\n  }\n\n  return supersequence;\n}\n","filetype":".js","index":168},{"title":"Sorting","category":"algorithms","id":"sorting","index":169},{"title":"Sort","category":"sorting","id":"Sort_sorting","algorithm":"import Comparator from '../../utils/comparator/Comparator';\n\n/**\n * @typedef {Object} SorterCallbacks\n * @property {function(a: *, b: *)} compareCallback - If provided then all elements comparisons\n *  will be done through this callback.\n * @property {function(a: *)} visitingCallback - If provided it will be called each time the sorting\n *  function is visiting the next element.\n */\n\nexport default class Sort {\n  constructor(originalCallbacks) {\n    this.callbacks = Sort.initSortingCallbacks(originalCallbacks);\n    this.comparator = new Comparator(this.callbacks.compareCallback);\n  }\n\n  /**\n   * @param {SorterCallbacks} originalCallbacks\n   * @returns {SorterCallbacks}\n   */\n  static initSortingCallbacks(originalCallbacks) {\n    const callbacks = originalCallbacks || {};\n    const stubCallback = () => {};\n\n    callbacks.compareCallback = callbacks.compareCallback || undefined;\n    callbacks.visitingCallback = callbacks.visitingCallback || stubCallback;\n\n    return callbacks;\n  }\n\n  sort() {\n    throw new Error('sort method must be implemented');\n  }\n}\n","filetype":".js","index":170},{"title":"Sort Tester","category":"sorting","id":"SortTester_sorting","algorithm":"export const sortedArr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20];\nexport const reverseArr = [20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1];\nexport const notSortedArr = [15, 8, 5, 12, 10, 1, 16, 9, 11, 7, 20, 3, 2, 6, 17, 18, 4, 13, 14, 19];\nexport const equalArr = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];\nexport const negativeArr = [-1, 0, 5, -10, 20, 13, -7, 3, 2, -3];\nexport const negativeArrSorted = [-10, -7, -3, -1, 0, 2, 3, 5, 13, 20];\n\nexport class SortTester {\n  static testSort(SortingClass) {\n    const sorter = new SortingClass();\n\n    expect(sorter.sort([])).toEqual([]);\n    expect(sorter.sort([1])).toEqual([1]);\n    expect(sorter.sort([1, 2])).toEqual([1, 2]);\n    expect(sorter.sort([2, 1])).toEqual([1, 2]);\n    expect(sorter.sort([3, 4, 2, 1, 0, 0, 4, 3, 4, 2])).toEqual([0, 0, 1, 2, 2, 3, 3, 4, 4, 4]);\n    expect(sorter.sort(sortedArr)).toEqual(sortedArr);\n    expect(sorter.sort(reverseArr)).toEqual(sortedArr);\n    expect(sorter.sort(notSortedArr)).toEqual(sortedArr);\n    expect(sorter.sort(equalArr)).toEqual(equalArr);\n  }\n\n  static testNegativeNumbersSort(SortingClass) {\n    const sorter = new SortingClass();\n    expect(sorter.sort(negativeArr)).toEqual(negativeArrSorted);\n  }\n\n  static testSortWithCustomComparator(SortingClass) {\n    const callbacks = {\n      compareCallback: (a, b) => {\n        if (a.length === b.length) {\n          return 0;\n        }\n        return a.length < b.length ? -1 : 1;\n      },\n    };\n\n    const sorter = new SortingClass(callbacks);\n\n    expect(sorter.sort([''])).toEqual(['']);\n    expect(sorter.sort(['a'])).toEqual(['a']);\n    expect(sorter.sort(['aa', 'a'])).toEqual(['a', 'aa']);\n    expect(sorter.sort(['aa', 'q', 'bbbb', 'ccc'])).toEqual(['q', 'aa', 'ccc', 'bbbb']);\n    expect(sorter.sort(['aa', 'aa'])).toEqual(['aa', 'aa']);\n  }\n\n  static testSortStability(SortingClass) {\n    const callbacks = {\n      compareCallback: (a, b) => {\n        if (a.length === b.length) {\n          return 0;\n        }\n        return a.length < b.length ? -1 : 1;\n      },\n    };\n\n    const sorter = new SortingClass(callbacks);\n\n    expect(sorter.sort(['bb', 'aa', 'c'])).toEqual(['c', 'bb', 'aa']);\n    expect(sorter.sort(['aa', 'q', 'a', 'bbbb', 'ccc'])).toEqual(['q', 'a', 'aa', 'ccc', 'bbbb']);\n  }\n\n  static testAlgorithmTimeComplexity(SortingClass, arrayToBeSorted, numberOfVisits) {\n    const visitingCallback = jest.fn();\n    const callbacks = { visitingCallback };\n    const sorter = new SortingClass(callbacks);\n\n    sorter.sort(arrayToBeSorted);\n\n    expect(visitingCallback).toHaveBeenCalledTimes(numberOfVisits);\n  }\n}\n","filetype":".js","index":171},{"title":"Bubble-sort","category":"sorting","id":"bubble-sort","algorithm":"# Bubble Sort\n\n_Read this in other languages:_\n[_Português_](README.pt-BR.md)\n\nBubble sort, sometimes referred to as sinking sort, is a\nsimple sorting algorithm that repeatedly steps through\nthe list to be sorted, compares each pair of adjacent\nitems and swaps them if they are in the wrong order\n(ascending or descending arrangement). The pass through\nthe list is repeated until no swaps are needed, which\nindicates that the list is sorted.\n\n![Algorithm Visualization](https://upload.wikimedia.org/wikipedia/commons/c/c8/Bubble-sort-example-300px.gif)\n\n## Complexity\n\n| Name                  | Best            | Average             | Worst               | Memory    | Stable    | Comments  |\n| --------------------- | :-------------: | :-----------------: | :-----------------: | :-------: | :-------: | :-------- |\n| **Bubble sort**       | n               | n<sup>2</sup>       | n<sup>2</sup>       | 1         | Yes       |           |\n\n## References\n\n- [Wikipedia](https://en.wikipedia.org/wiki/Bubble_sort)\n- [YouTube](https://www.youtube.com/watch?v=6Gv8vg0kcHc&index=27&t=0s&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\n","filetype":".md","index":172},{"title":"Bubble Sort","category":"bubble-sort","id":"BubbleSort_bubble-sort","algorithm":"import Sort from '../Sort';\n\nexport default class BubbleSort extends Sort {\n  sort(originalArray) {\n    // Flag that holds info about whether the swap has occur or not.\n    let swapped = false;\n    // Clone original array to prevent its modification.\n    const array = [...originalArray];\n\n    for (let i = 1; i < array.length; i += 1) {\n      swapped = false;\n\n      // Call visiting callback.\n      this.callbacks.visitingCallback(array[i]);\n\n      for (let j = 0; j < array.length - i; j += 1) {\n        // Call visiting callback.\n        this.callbacks.visitingCallback(array[j]);\n\n        // Swap elements if they are in wrong order.\n        if (this.comparator.lessThan(array[j + 1], array[j])) {\n          [array[j], array[j + 1]] = [array[j + 1], array[j]];\n\n          // Register the swap.\n          swapped = true;\n        }\n      }\n\n      // If there were no swaps then array is already sorted and there is\n      // no need to proceed.\n      if (!swapped) {\n        return array;\n      }\n    }\n\n    return array;\n  }\n}\n","filetype":".js","index":173},{"title":"Counting-sort","category":"sorting","id":"counting-sort","algorithm":"# Counting Sort\n\nIn computer science, **counting sort** is an algorithm for sorting \na collection of objects according to keys that are small integers; \nthat is, it is an integer sorting algorithm. It operates by \ncounting the number of objects that have each distinct key value, \nand using arithmetic on those counts to determine the positions \nof each key value in the output sequence. Its running time is \nlinear in the number of items and the difference between the \nmaximum and minimum key values, so it is only suitable for direct \nuse in situations where the variation in keys is not significantly \ngreater than the number of items. However, it is often used as a \nsubroutine in another sorting algorithm, radix sort, that can \nhandle larger keys more efficiently.\n\nBecause counting sort uses key values as indexes into an array, \nit is not a comparison sort, and the `Ω(n log n)` lower bound for \ncomparison sorting does not apply to it. Bucket sort may be used \nfor many of the same tasks as counting sort, with a similar time \nanalysis; however, compared to counting sort, bucket sort requires \nlinked lists, dynamic arrays or a large amount of preallocated \nmemory to hold the sets of items within each bucket, whereas \ncounting sort instead stores a single number (the count of items) \nper bucket.\n\nCounting sorting works best when the range of numbers for each array\nelement is very small.\n\n## Algorithm\n\n**Step I**\n\nIn first step we calculate the count of all the elements of the \ninput array `A`. Then Store the result in the count array `C`.\nThe way we count is depicted below.\n\n![Counting Sort](https://3.bp.blogspot.com/-jJchly1BkTc/WLGqCFDdvCI/AAAAAAAAAHA/luljAlz2ptMndIZNH0KLTTuQMNsfzDeFQCLcB/s1600/CSortUpdatedStepI.gif)\n\n**Step II**\n\nIn second step we calculate how many elements exist in the input \narray `A` which are less than or equals for the given index. \n`Ci` = numbers of elements less than or equals to `i` in input array.\n\n![Counting Sort](https://1.bp.blogspot.com/-1vFu-VIRa9Y/WLHGuZkdF3I/AAAAAAAAAHs/8jKu2dbQee4ap9xlVcNsILrclqw0UxAVACLcB/s1600/Step-II.png)\n\n**Step III**\n\nIn this step we place the input array `A` element at sorted \nposition by taking help of constructed count array `C` ,i.e what \nwe constructed in step two. We used the result array `B` to store \nthe sorted elements. Here we handled the index of `B` start from\nzero.\n \n![Counting Sort](https://1.bp.blogspot.com/-xPqylngqASY/WLGq3p9n9vI/AAAAAAAAAHM/JHdtXAkJY8wYzDMBXxqarjmhpPhM0u8MACLcB/s1600/ResultArrayCS.gif)\n\n## Complexity\n\n| Name                  | Best            | Average             | Worst               | Memory    | Stable    | Comments  |\n| --------------------- | :-------------: | :-----------------: | :-----------------: | :-------: | :-------: | :-------- |\n| **Counting sort**     | n + r           | n + r               | n + r               | n + r     | Yes       | r - biggest number in array |\n\n## References\n\n- [Wikipedia](https://en.wikipedia.org/wiki/Counting_sort)\n- [YouTube](https://www.youtube.com/watch?v=OKd534EWcdk&index=61&t=0s&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\n- [EfficientAlgorithms](https://efficientalgorithms.blogspot.com/2016/09/lenear-sorting-counting-sort.html)\n","filetype":".md","index":174},{"title":"Counting Sort","category":"counting-sort","id":"CountingSort_counting-sort","algorithm":"import Sort from '../Sort';\n\nexport default class CountingSort extends Sort {\n  /**\n   * @param {number[]} originalArray\n   * @param {number} [smallestElement]\n   * @param {number} [biggestElement]\n   */\n  sort(originalArray, smallestElement = undefined, biggestElement = undefined) {\n    // Init biggest and smallest elements in array in order to build number bucket array later.\n    let detectedSmallestElement = smallestElement || 0;\n    let detectedBiggestElement = biggestElement || 0;\n\n    if (smallestElement === undefined || biggestElement === undefined) {\n      originalArray.forEach((element) => {\n        // Visit element.\n        this.callbacks.visitingCallback(element);\n\n        // Detect biggest element.\n        if (this.comparator.greaterThan(element, detectedBiggestElement)) {\n          detectedBiggestElement = element;\n        }\n\n        // Detect smallest element.\n        if (this.comparator.lessThan(element, detectedSmallestElement)) {\n          detectedSmallestElement = element;\n        }\n      });\n    }\n\n    // Init buckets array.\n    // This array will hold frequency of each number from originalArray.\n    const buckets = Array(detectedBiggestElement - detectedSmallestElement + 1).fill(0);\n\n    originalArray.forEach((element) => {\n      // Visit element.\n      this.callbacks.visitingCallback(element);\n\n      buckets[element - detectedSmallestElement] += 1;\n    });\n\n    // Add previous frequencies to the current one for each number in bucket\n    // to detect how many numbers less then current one should be standing to\n    // the left of current one.\n    for (let bucketIndex = 1; bucketIndex < buckets.length; bucketIndex += 1) {\n      buckets[bucketIndex] += buckets[bucketIndex - 1];\n    }\n\n    // Now let's shift frequencies to the right so that they show correct numbers.\n    // I.e. if we won't shift right than the value of buckets[5] will display how many\n    // elements less than 5 should be placed to the left of 5 in sorted array\n    // INCLUDING 5th. After shifting though this number will not include 5th anymore.\n    buckets.pop();\n    buckets.unshift(0);\n\n    // Now let's assemble sorted array.\n    const sortedArray = Array(originalArray.length).fill(null);\n    for (let elementIndex = 0; elementIndex < originalArray.length; elementIndex += 1) {\n      // Get the element that we want to put into correct sorted position.\n      const element = originalArray[elementIndex];\n\n      // Visit element.\n      this.callbacks.visitingCallback(element);\n\n      // Get correct position of this element in sorted array.\n      const elementSortedPosition = buckets[element - detectedSmallestElement];\n\n      // Put element into correct position in sorted array.\n      sortedArray[elementSortedPosition] = element;\n\n      // Increase position of current element in the bucket for future correct placements.\n      buckets[element - detectedSmallestElement] += 1;\n    }\n\n    // Return sorted array.\n    return sortedArray;\n  }\n}\n","filetype":".js","index":175},{"title":"Heap-sort","category":"sorting","id":"heap-sort","algorithm":"# Heap Sort\n\nHeapsort is a comparison-based sorting algorithm.\nHeapsort can be thought of as an improved selection\nsort: like that algorithm, it divides its input into\na sorted and an unsorted region, and it iteratively\nshrinks the unsorted region by extracting the largest\nelement and moving that to the sorted region. The \nimprovement consists of the use of a heap data structure\nrather than a linear-time search to find the maximum.\n\n![Algorithm Visualization](https://upload.wikimedia.org/wikipedia/commons/1/1b/Sorting_heapsort_anim.gif)\n\n![Algorithm Visualization](https://upload.wikimedia.org/wikipedia/commons/4/4d/Heapsort-example.gif)\n\n## Complexity\n\n| Name                  | Best            | Average             | Worst               | Memory    | Stable    | Comments  |\n| --------------------- | :-------------: | :-----------------: | :-----------------: | :-------: | :-------: | :-------- |\n| **Heap sort**         | n&nbsp;log(n)   | n&nbsp;log(n)       | n&nbsp;log(n)       | 1         | No        |           |\n\n## References\n\n[Wikipedia](https://en.wikipedia.org/wiki/Heapsort)\n","filetype":".md","index":176},{"title":"Heap Sort","category":"heap-sort","id":"HeapSort_heap-sort","algorithm":"import Sort from '../Sort';\nimport MinHeap from '../../../data-structures/heap/MinHeap';\n\nexport default class HeapSort extends Sort {\n  sort(originalArray) {\n    const sortedArray = [];\n    const minHeap = new MinHeap(this.callbacks.compareCallback);\n\n    // Insert all array elements to the heap.\n    originalArray.forEach((element) => {\n      // Call visiting callback.\n      this.callbacks.visitingCallback(element);\n\n      minHeap.add(element);\n    });\n\n    // Now we have min heap with minimal element always on top.\n    // Let's poll that minimal element one by one and thus form the sorted array.\n    while (!minHeap.isEmpty()) {\n      const nextMinElement = minHeap.poll();\n\n      // Call visiting callback.\n      this.callbacks.visitingCallback(nextMinElement);\n\n      sortedArray.push(nextMinElement);\n    }\n\n    return sortedArray;\n  }\n}\n","filetype":".js","index":177},{"title":"Insertion-sort","category":"sorting","id":"insertion-sort","algorithm":"# Insertion Sort\n\nInsertion sort is a simple sorting algorithm that builds \nthe final sorted array (or list) one item at a time. \nIt is much less efficient on large lists than more \nadvanced algorithms such as quicksort, heapsort, or merge \nsort.\n\n![Algorithm Visualization](https://upload.wikimedia.org/wikipedia/commons/4/42/Insertion_sort.gif)\n\n![Algorithm Visualization](https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif)\n\n## Complexity\n\n| Name                  | Best            | Average             | Worst               | Memory    | Stable    | Comments  |\n| --------------------- | :-------------: | :-----------------: | :-----------------: | :-------: | :-------: | :-------- |\n| **Insertion sort**    | n               | n<sup>2</sup>       | n<sup>2</sup>       | 1         | Yes       |           |\n\n## References\n\n[Wikipedia](https://en.wikipedia.org/wiki/Insertion_sort)\n","filetype":".md","index":178},{"title":"Insertion Sort","category":"insertion-sort","id":"InsertionSort_insertion-sort","algorithm":"import Sort from '../Sort';\n\nexport default class InsertionSort extends Sort {\n  sort(originalArray) {\n    const array = [...originalArray];\n\n    // Go through all array elements...\n    for (let i = 1; i < array.length; i += 1) {\n      let currentIndex = i;\n\n      // Call visiting callback.\n      this.callbacks.visitingCallback(array[i]);\n\n      // Check if previous element is greater than current element.\n      // If so, swap the two elements.\n      while (\n        array[currentIndex - 1] !== undefined\n        && this.comparator.lessThan(array[currentIndex], array[currentIndex - 1])\n      ) {\n        // Call visiting callback.\n        this.callbacks.visitingCallback(array[currentIndex - 1]);\n\n        // Swap the elements.\n        [\n          array[currentIndex - 1],\n          array[currentIndex],\n        ] = [\n          array[currentIndex],\n          array[currentIndex - 1],\n        ];\n\n        // Shift current index left.\n        currentIndex -= 1;\n      }\n    }\n\n    return array;\n  }\n}\n","filetype":".js","index":179},{"title":"Merge-sort","category":"sorting","id":"merge-sort","algorithm":"# Merge Sort\n\nIn computer science, merge sort (also commonly spelled \nmergesort) is an efficient, general-purpose, \ncomparison-based sorting algorithm. Most implementations \nproduce a stable sort, which means that the implementation \npreserves the input order of equal elements in the sorted \noutput. Mergesort is a divide and conquer algorithm that \nwas invented by John von Neumann in 1945.\n\nAn example of merge sort. First divide the list into \nthe smallest unit (1 element), then compare each \nelement with the adjacent list to sort and merge the \ntwo adjacent lists. Finally all the elements are sorted \nand merged.\n\n![Merge Sort](https://upload.wikimedia.org/wikipedia/commons/c/cc/Merge-sort-example-300px.gif)\n\nA recursive merge sort algorithm used to sort an array of 7 \ninteger values. These are the steps a human would take to \nemulate merge sort (top-down).\n\n![Merge Sort](https://upload.wikimedia.org/wikipedia/commons/e/e6/Merge_sort_algorithm_diagram.svg)\n\n## Complexity\n\n| Name                  | Best            | Average             | Worst               | Memory    | Stable    | Comments  |\n| --------------------- | :-------------: | :-----------------: | :-----------------: | :-------: | :-------: | :-------- |\n| **Merge sort**        | n&nbsp;log(n)   | n&nbsp;log(n)       | n&nbsp;log(n)       | n         | Yes       |           |\n\n## References\n\n- [Wikipedia](https://en.wikipedia.org/wiki/Merge_sort)\n- [YouTube](https://www.youtube.com/watch?v=KF2j-9iSf4Q&index=27&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\n","filetype":".md","index":180},{"title":"Merge Sort","category":"merge-sort","id":"MergeSort_merge-sort","algorithm":"import Sort from '../Sort';\n\nexport default class MergeSort extends Sort {\n  sort(originalArray) {\n    // Call visiting callback.\n    this.callbacks.visitingCallback(null);\n\n    // If array is empty or consists of one element then return this array since it is sorted.\n    if (originalArray.length <= 1) {\n      return originalArray;\n    }\n\n    // Split array on two halves.\n    const middleIndex = Math.floor(originalArray.length / 2);\n    const leftArray = originalArray.slice(0, middleIndex);\n    const rightArray = originalArray.slice(middleIndex, originalArray.length);\n\n    // Sort two halves of split array\n    const leftSortedArray = this.sort(leftArray);\n    const rightSortedArray = this.sort(rightArray);\n\n    // Merge two sorted arrays into one.\n    return this.mergeSortedArrays(leftSortedArray, rightSortedArray);\n  }\n\n  mergeSortedArrays(leftArray, rightArray) {\n    const sortedArray = [];\n\n    // Use array pointers to exclude old elements after they have been added to the sorted array.\n    let leftIndex = 0;\n    let rightIndex = 0;\n\n    while (leftIndex < leftArray.length && rightIndex < rightArray.length) {\n      let minElement = null;\n\n      // Find the minimum element between the left and right array.\n      if (this.comparator.lessThanOrEqual(leftArray[leftIndex], rightArray[rightIndex])) {\n        minElement = leftArray[leftIndex];\n        // Increment index pointer to the right\n        leftIndex += 1;\n      } else {\n        minElement = rightArray[rightIndex];\n        // Increment index pointer to the right\n        rightIndex += 1;\n      }\n\n      // Add the minimum element to the sorted array.\n      sortedArray.push(minElement);\n\n      // Call visiting callback.\n      this.callbacks.visitingCallback(minElement);\n    }\n\n    // There will be elements remaining from either the left OR the right\n    // Concatenate the remaining elements into the sorted array\n    return sortedArray\n      .concat(leftArray.slice(leftIndex))\n      .concat(rightArray.slice(rightIndex));\n  }\n}\n","filetype":".js","index":181},{"title":"Quick-sort","category":"sorting","id":"quick-sort","algorithm":"# Quicksort\n\nQuicksort is a divide and conquer algorithm.\nQuicksort first divides a large array into two smaller \nsub-arrays: the low elements and the high elements.\nQuicksort can then recursively sort the sub-arrays\n\nThe steps are:\n\n1. Pick an element, called a pivot, from the array.\n2. Partitioning: reorder the array so that all elements with \nvalues less than the pivot come before the pivot, while all \nelements with values greater than the pivot come after it \n(equal values can go either way). After this partitioning, \nthe pivot is in its final position. This is called the \npartition operation.\n3. Recursively apply the above steps to the sub-array of \nelements with smaller values and separately to the \nsub-array of elements with greater values.\n\nAnimated visualization of the quicksort algorithm.\nThe horizontal lines are pivot values.\n\n![Quicksort](https://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif)\n\n## Complexity\n\n| Name                  | Best            | Average             | Worst               | Memory    | Stable    | Comments  |\n| --------------------- | :-------------: | :-----------------: | :-----------------: | :-------: | :-------: | :-------- |\n| **Quick sort**        | n&nbsp;log(n)   | n&nbsp;log(n)       | n<sup>2</sup>       | log(n)    | No        |  Quicksort is usually done in-place with O(log(n)) stack space |\n\n## References\n\n- [Wikipedia](https://en.wikipedia.org/wiki/Quicksort)\n- [YouTube](https://www.youtube.com/watch?v=SLauY6PpjW4&index=28&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\n","filetype":".md","index":182},{"title":"Quick Sort","category":"quick-sort","id":"QuickSort_quick-sort","algorithm":"import Sort from '../Sort';\n\nexport default class QuickSort extends Sort {\n  /**\n   * @param {*[]} originalArray\n   * @return {*[]}\n   */\n  sort(originalArray) {\n    // Clone original array to prevent it from modification.\n    const array = [...originalArray];\n\n    // If array has less than or equal to one elements then it is already sorted.\n    if (array.length <= 1) {\n      return array;\n    }\n\n    // Init left and right arrays.\n    const leftArray = [];\n    const rightArray = [];\n\n    // Take the first element of array as a pivot.\n    const pivotElement = array.shift();\n    const centerArray = [pivotElement];\n\n    // Split all array elements between left, center and right arrays.\n    while (array.length) {\n      const currentElement = array.shift();\n\n      // Call visiting callback.\n      this.callbacks.visitingCallback(currentElement);\n\n      if (this.comparator.equal(currentElement, pivotElement)) {\n        centerArray.push(currentElement);\n      } else if (this.comparator.lessThan(currentElement, pivotElement)) {\n        leftArray.push(currentElement);\n      } else {\n        rightArray.push(currentElement);\n      }\n    }\n\n    // Sort left and right arrays.\n    const leftArraySorted = this.sort(leftArray);\n    const rightArraySorted = this.sort(rightArray);\n\n    // Let's now join sorted left array with center array and with sorted right array.\n    return leftArraySorted.concat(centerArray, rightArraySorted);\n  }\n}\n","filetype":".js","index":183},{"title":"Quick Sort In Place","category":"quick-sort","id":"QuickSortInPlace_quick-sort","algorithm":"import Sort from '../Sort';\n\nexport default class QuickSortInPlace extends Sort {\n  /** Sorting in place avoids unnecessary use of additional memory, but modifies input array.\n   *\n   * This process is difficult to describe, but much clearer with a visualization:\n   * @see: http://www.algomation.com/algorithm/quick-sort-visualization\n   *\n   * @param {*[]} originalArray - Not sorted array.\n   * @param {number} inputLowIndex\n   * @param {number} inputHighIndex\n   * @param {boolean} recursiveCall\n   * @return {*[]} - Sorted array.\n   */\n  sort(\n    originalArray,\n    inputLowIndex = 0,\n    inputHighIndex = originalArray.length - 1,\n    recursiveCall = false,\n  ) {\n    // Copies array on initial call, and then sorts in place.\n    const array = recursiveCall ? originalArray : [...originalArray];\n\n    /**\n     * The partitionArray() operates on the subarray between lowIndex and highIndex, inclusive.\n     * It arbitrarily chooses the last element in the subarray as the pivot.\n     * Then, it partially sorts the subarray into elements than are less than the pivot,\n     * and elements that are greater than or equal to the pivot.\n     * Each time partitionArray() is executed, the pivot element is in its final sorted position.\n     *\n     * @param {number} lowIndex\n     * @param {number} highIndex\n     * @return {number}\n     */\n    const partitionArray = (lowIndex, highIndex) => {\n      /**\n       * Swaps two elements in array.\n       * @param {number} leftIndex\n       * @param {number} rightIndex\n       */\n      const swap = (leftIndex, rightIndex) => {\n        const temp = array[leftIndex];\n        array[leftIndex] = array[rightIndex];\n        array[rightIndex] = temp;\n      };\n\n      const pivot = array[highIndex];\n      // visitingCallback is used for time-complexity analysis.\n      this.callbacks.visitingCallback(pivot);\n\n      let partitionIndex = lowIndex;\n      for (let currentIndex = lowIndex; currentIndex < highIndex; currentIndex += 1) {\n        if (this.comparator.lessThan(array[currentIndex], pivot)) {\n          swap(partitionIndex, currentIndex);\n          partitionIndex += 1;\n        }\n      }\n\n      // The element at the partitionIndex is guaranteed to be greater than or equal to pivot.\n      // All elements to the left of partitionIndex are guaranteed to be less than pivot.\n      // Swapping the pivot with the partitionIndex therefore places the pivot in its\n      // final sorted position.\n      swap(partitionIndex, highIndex);\n\n      return partitionIndex;\n    };\n\n    // Base case is when low and high converge.\n    if (inputLowIndex < inputHighIndex) {\n      const partitionIndex = partitionArray(inputLowIndex, inputHighIndex);\n      const RECURSIVE_CALL = true;\n      this.sort(array, inputLowIndex, partitionIndex - 1, RECURSIVE_CALL);\n      this.sort(array, partitionIndex + 1, inputHighIndex, RECURSIVE_CALL);\n    }\n\n    return array;\n  }\n}\n","filetype":".js","index":184},{"title":"Radix-sort","category":"sorting","id":"radix-sort","algorithm":"# Radix Sort\n\nIn computer science, **radix sort** is a non-comparative integer sorting \nalgorithm that sorts data with integer keys by grouping keys by the individual \ndigits which share the same significant position and value. A positional notation\nis required, but because integers can represent strings of characters \n(e.g., names or dates) and specially formatted floating point numbers, radix \nsort is not limited to integers.\n\n*Where does the name come from?*\n\nIn mathematical numeral systems, the *radix* or base is the number of unique digits,\nincluding the digit zero, used to represent numbers in a positional numeral system. \nFor example, a binary system (using numbers 0 and 1) has a radix of 2 and a decimal \nsystem (using numbers 0 to 9) has a radix of 10.\n\n## Efficiency\n\nThe topic of the efficiency of radix sort compared to other sorting algorithms is \nsomewhat tricky and subject to quite a lot of misunderstandings. Whether radix \nsort is equally efficient, less efficient or more efficient than the best \ncomparison-based algorithms depends on the details of the assumptions made. \nRadix sort complexity is `O(wn)` for `n` keys which are integers of word size `w`. \nSometimes `w` is presented as a constant, which would make radix sort better \n(for sufficiently large `n`) than the best comparison-based sorting algorithms, \nwhich all perform `O(n log n)` comparisons to sort `n` keys. However, in \ngeneral `w` cannot be considered a constant: if all `n` keys are distinct, \nthen `w` has to be at least `log n` for a random-access machine to be able to \nstore them in memory, which gives at best a time complexity `O(n log n)`. That \nwould seem to make radix sort at most equally efficient as the best \ncomparison-based sorts (and worse if keys are much longer than `log n`).\n\n![Radix Sort](https://www.researchgate.net/publication/291086231/figure/fig1/AS:614214452404240@1523451545568/Simplistic-illustration-of-the-steps-performed-in-a-radix-sort-In-this-example-the.png)\n\n## Complexity\n\n| Name                  | Best            | Average             | Worst               | Memory    | Stable    | Comments  |\n| --------------------- | :-------------: | :-----------------: | :-----------------: | :-------: | :-------: | :-------- |\n| **Radix sort**        | n * k           | n * k               | n * k               | n + k     | Yes       | k - length of longest key |\n\n## References\n\n- [Wikipedia](https://en.wikipedia.org/wiki/Radix_sort)\n- [YouTube](https://www.youtube.com/watch?v=XiuSW_mEn7g&index=62&t=0s&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\n- [ResearchGate](https://www.researchgate.net/figure/Simplistic-illustration-of-the-steps-performed-in-a-radix-sort-In-this-example-the_fig1_291086231)\n","filetype":".md","index":185},{"title":"Radix Sort","category":"radix-sort","id":"RadixSort_radix-sort","algorithm":"import Sort from '../Sort';\n\n// Using charCode (a = 97, b = 98, etc), we can map characters to buckets from 0 - 25\nconst BASE_CHAR_CODE = 97;\nconst NUMBER_OF_POSSIBLE_DIGITS = 10;\nconst ENGLISH_ALPHABET_LENGTH = 26;\n\nexport default class RadixSort extends Sort {\n  /**\n   * @param {*[]} originalArray\n   * @return {*[]}\n   */\n  sort(originalArray) {\n    // Assumes all elements of array are of the same type\n    const isArrayOfNumbers = this.isArrayOfNumbers(originalArray);\n\n    let sortedArray = [...originalArray];\n    const numPasses = this.determineNumPasses(sortedArray);\n\n    for (let currentIndex = 0; currentIndex < numPasses; currentIndex += 1) {\n      const buckets = isArrayOfNumbers\n        ? this.placeElementsInNumberBuckets(sortedArray, currentIndex)\n        : this.placeElementsInCharacterBuckets(sortedArray, currentIndex, numPasses);\n\n      // Flatten buckets into sortedArray, and repeat at next index\n      sortedArray = buckets.reduce((acc, val) => {\n        return [...acc, ...val];\n      }, []);\n    }\n\n    return sortedArray;\n  }\n\n  /**\n   * @param {*[]} array\n   * @param {number} index\n   * @return {*[]}\n   */\n  placeElementsInNumberBuckets(array, index) {\n    // See below. These are used to determine which digit to use for bucket allocation\n    const modded = 10 ** (index + 1);\n    const divided = 10 ** index;\n    const buckets = this.createBuckets(NUMBER_OF_POSSIBLE_DIGITS);\n\n    array.forEach((element) => {\n      this.callbacks.visitingCallback(element);\n      if (element < divided) {\n        buckets[0].push(element);\n      } else {\n        /**\n         * Say we have element of 1,052 and are currently on index 1 (starting from 0). This means\n         * we want to use '5' as the bucket. `modded` would be 10 ** (1 + 1), which\n         * is 100. So we take 1,052 % 100 (52) and divide it by 10 (5.2) and floor it (5).\n         */\n        const currentDigit = Math.floor((element % modded) / divided);\n        buckets[currentDigit].push(element);\n      }\n    });\n\n    return buckets;\n  }\n\n  /**\n   * @param {*[]} array\n   * @param {number} index\n   * @param {number} numPasses\n   * @return {*[]}\n   */\n  placeElementsInCharacterBuckets(array, index, numPasses) {\n    const buckets = this.createBuckets(ENGLISH_ALPHABET_LENGTH);\n\n    array.forEach((element) => {\n      this.callbacks.visitingCallback(element);\n      const currentBucket = this.getCharCodeOfElementAtIndex(element, index, numPasses);\n      buckets[currentBucket].push(element);\n    });\n\n    return buckets;\n  }\n\n  /**\n   * @param {string} element\n   * @param {number} index\n   * @param {number} numPasses\n   * @return {number}\n   */\n  getCharCodeOfElementAtIndex(element, index, numPasses) {\n    // Place element in last bucket if not ready to organize\n    if ((numPasses - index) > element.length) {\n      return ENGLISH_ALPHABET_LENGTH - 1;\n    }\n\n    /**\n     * If each character has been organized, use first character to determine bucket,\n     * otherwise iterate backwards through element\n     */\n    const charPos = index > element.length - 1 ? 0 : element.length - index - 1;\n\n    return element.toLowerCase().charCodeAt(charPos) - BASE_CHAR_CODE;\n  }\n\n  /**\n   * Number of passes is determined by the length of the longest element in the array.\n   * For integers, this log10(num), and for strings, this would be the length of the string.\n   */\n  determineNumPasses(array) {\n    return this.getLengthOfLongestElement(array);\n  }\n\n  /**\n   * @param {*[]} array\n   * @return {number}\n   */\n  getLengthOfLongestElement(array) {\n    if (this.isArrayOfNumbers(array)) {\n      return Math.floor(Math.log10(Math.max(...array))) + 1;\n    }\n\n    return array.reduce((acc, val) => {\n      return val.length > acc ? val.length : acc;\n    }, -Infinity);\n  }\n\n  /**\n   * @param {*[]} array\n   * @return {boolean}\n   */\n  isArrayOfNumbers(array) {\n    // Assumes all elements of array are of the same type\n    return this.isNumber(array[0]);\n  }\n\n  /**\n   * @param {number} numBuckets\n   * @return {*[]}\n   */\n  createBuckets(numBuckets) {\n    /**\n     * Mapping buckets to an array instead of filling them with\n     * an array prevents each bucket from containing a reference to the same array\n     */\n    return new Array(numBuckets).fill(null).map(() => []);\n  }\n\n  /**\n   * @param {*} element\n   * @return {boolean}\n   */\n  isNumber(element) {\n    return Number.isInteger(element);\n  }\n}\n","filetype":".js","index":186},{"title":"Selection-sort","category":"sorting","id":"selection-sort","algorithm":"# Selection Sort\n\nSelection sort is a sorting algorithm, specifically an \nin-place comparison sort. It has O(n2) time complexity, \nmaking it inefficient on large lists, and generally \nperforms worse than the similar insertion sort. \nSelection sort is noted for its simplicity, and it has \nperformance advantages over more complicated algorithms \nin certain situations, particularly where auxiliary \nmemory is limited.\n\n![Algorithm Visualization](https://upload.wikimedia.org/wikipedia/commons/b/b0/Selection_sort_animation.gif)\n\n![Algorithm Visualization](https://upload.wikimedia.org/wikipedia/commons/9/94/Selection-Sort-Animation.gif)\n\n## Complexity\n\n| Name                  | Best            | Average             | Worst               | Memory    | Stable    | Comments  |\n| --------------------- | :-------------: | :-----------------: | :-----------------: | :-------: | :-------: | :-------- |\n| **Selection sort**    | n<sup>2</sup>   | n<sup>2</sup>       | n<sup>2</sup>       | 1         | No        |           |\n\n## References\n\n[Wikipedia](https://en.wikipedia.org/wiki/Selection_sort)\n","filetype":".md","index":187},{"title":"Selection Sort","category":"selection-sort","id":"SelectionSort_selection-sort","algorithm":"import Sort from '../Sort';\n\nexport default class SelectionSort extends Sort {\n  sort(originalArray) {\n    // Clone original array to prevent its modification.\n    const array = [...originalArray];\n\n    for (let i = 0; i < array.length - 1; i += 1) {\n      let minIndex = i;\n\n      // Call visiting callback.\n      this.callbacks.visitingCallback(array[i]);\n\n      // Find minimum element in the rest of array.\n      for (let j = i + 1; j < array.length; j += 1) {\n        // Call visiting callback.\n        this.callbacks.visitingCallback(array[j]);\n\n        if (this.comparator.lessThan(array[j], array[minIndex])) {\n          minIndex = j;\n        }\n      }\n\n      // If new minimum element has been found then swap it with current i-th element.\n      if (minIndex !== i) {\n        [array[i], array[minIndex]] = [array[minIndex], array[i]];\n      }\n    }\n\n    return array;\n  }\n}\n","filetype":".js","index":188},{"title":"Shell-sort","category":"sorting","id":"shell-sort","algorithm":"# Shellsort\n\nShellsort, also known as Shell sort or Shell's method, \nis an in-place comparison sort. It can be seen as either a \ngeneralization of sorting by exchange (bubble sort) or sorting \nby insertion (insertion sort). The method starts by sorting \npairs of elements far apart from each other, then progressively \nreducing the gap between elements to be compared. Starting \nwith far apart elements, it can move some out-of-place \nelements into position faster than a simple nearest neighbor \nexchange\n\n![Shellsort](https://upload.wikimedia.org/wikipedia/commons/d/d8/Sorting_shellsort_anim.gif)\n\n## How Shell Sort Works\n\nFor our example and ease of understanding, we take the interval \nof `4`. Make a virtual sub-list of all values located at the \ninterval of 4 positions. Here these values are \n`{35, 14}`, `{33, 19}`, `{42, 27}` and `{10, 44}`\n\n![Shellsort](https://www.tutorialspoint.com/data_structures_algorithms/images/shell_sort_gap_4.jpg)\n\nWe compare values in each sub-list and swap them (if necessary)\nin the original array. After this step, the new array should\nlook like this\n\n![Shellsort](https://www.tutorialspoint.com/data_structures_algorithms/images/shell_sort_step_1.jpg)\n\nThen, we take interval of 2 and this gap generates two sub-lists \n- `{14, 27, 35, 42}`, `{19, 10, 33, 44}`\n\n![Shellsort](https://www.tutorialspoint.com/data_structures_algorithms/images/shell_sort_gap_2.jpg)\n\nWe compare and swap the values, if required, in the original array.\nAfter this step, the array should look like this\n\n![Shellsort](https://www.tutorialspoint.com/data_structures_algorithms/images/shell_sort_step_2.jpg)\n\n> UPD: On the picture below there is a typo and result array is supposed to be `[14, 10, 27, 19, 35, 33, 42, 44]`.\n\nFinally, we sort the rest of the array using interval of value 1. \nShell sort uses insertion sort to sort the array.\n\n![Shellsort](https://www.tutorialspoint.com/data_structures_algorithms/images/shell_sort.jpg)\n\n## Complexity\n\n| Name                  | Best            | Average             | Worst               | Memory    | Stable    | Comments  |\n| --------------------- | :-------------: | :-----------------: | :-----------------: | :-------: | :-------: | :-------- |\n| **Shell sort**        | n&nbsp;log(n)   | depends on gap sequence   | n&nbsp;(log(n))<sup>2</sup>  | 1         | No         |           |\n\n## References\n\n- [Tutorials Point](https://www.tutorialspoint.com/data_structures_algorithms/shell_sort_algorithm.htm)\n- [Wikipedia](https://en.wikipedia.org/wiki/Shellsort)\n- [YouTube by Rob Edwards](https://www.youtube.com/watch?v=ddeLSDsYVp8&index=79&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\n","filetype":".md","index":189},{"title":"Shell Sort","category":"shell-sort","id":"ShellSort_shell-sort","algorithm":"import Sort from '../Sort';\n\nexport default class ShellSort extends Sort {\n  sort(originalArray) {\n    // Prevent original array from mutations.\n    const array = [...originalArray];\n\n    // Define a gap distance.\n    let gap = Math.floor(array.length / 2);\n\n    // Until gap is bigger then zero do elements comparisons and swaps.\n    while (gap > 0) {\n      // Go and compare all distant element pairs.\n      for (let i = 0; i < (array.length - gap); i += 1) {\n        let currentIndex = i;\n        let gapShiftedIndex = i + gap;\n\n        while (currentIndex >= 0) {\n          // Call visiting callback.\n          this.callbacks.visitingCallback(array[currentIndex]);\n\n          // Compare and swap array elements if needed.\n          if (this.comparator.lessThan(array[gapShiftedIndex], array[currentIndex])) {\n            const tmp = array[currentIndex];\n            array[currentIndex] = array[gapShiftedIndex];\n            array[gapShiftedIndex] = tmp;\n          }\n\n          gapShiftedIndex = currentIndex;\n          currentIndex -= gap;\n        }\n      }\n\n      // Shrink the gap.\n      gap = Math.floor(gap / 2);\n    }\n\n    // Return sorted copy of an original array.\n    return array;\n  }\n}\n","filetype":".js","index":190},{"title":"String","category":"algorithms","id":"string","index":191},{"title":"Hamming-distance","category":"string","id":"hamming-distance","algorithm":"# Hamming Distance\n\nthe Hamming distance between two strings of equal length is the \nnumber of positions at which the corresponding symbols are \ndifferent. In other words, it measures the minimum number of\nsubstitutions required to change one string into the other, or \nthe minimum number of errors that could have transformed one \nstring into the other. In a more general context, the Hamming \ndistance is one of several string metrics for measuring the \nedit distance between two sequences.\n\n## Examples\n\nThe Hamming distance between:\n\n- \"ka**rol**in\" and \"ka**thr**in\" is **3**.\n- \"k**a**r**ol**in\" and \"k**e**r**st**in\" is **3**.\n- 10**1**1**1**01 and 10**0**1**0**01 is **2**.\n- 2**17**3**8**96 and 2**23**3**7**96 is **3**.\n\n## References\n\n[Wikipedia](https://en.wikipedia.org/wiki/Hamming_distance)\n","filetype":".md","index":192},{"title":"Hamming Distance","category":"hamming-distance","id":"hammingDistance_hamming-distance","algorithm":"/**\n * @param {string} a\n * @param {string} b\n * @return {number}\n */\nexport default function hammingDistance(a, b) {\n  if (a.length !== b.length) {\n    throw new Error('Strings must be of the same length');\n  }\n\n  let distance = 0;\n\n  for (let i = 0; i < a.length; i += 1) {\n    if (a[i] !== b[i]) {\n      distance += 1;\n    }\n  }\n\n  return distance;\n}\n","filetype":".js","index":193},{"title":"Knuth-morris-pratt","category":"string","id":"knuth-morris-pratt","algorithm":"# Knuth–Morris–Pratt Algorithm\n\nThe Knuth–Morris–Pratt string searching algorithm (or \nKMP algorithm) searches for occurrences of a \"word\" `W` \nwithin a main \"text string\" `T` by employing the \nobservation that when a mismatch occurs, the word itself \nembodies sufficient information to determine where the \nnext match could begin, thus bypassing re-examination \nof previously matched characters.\n\n## Complexity\n\n- **Time:** `O(|W| + |T|)` (much faster comparing to trivial `O(|W| * |T|)`)\n- **Space:** `O(|W|)`\n\n## References\n\n- [Wikipedia](https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm)\n- [YouTube](https://www.youtube.com/watch?v=GTJr8OvyEVQ&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\n","filetype":".md","index":194},{"title":"Knuth Morris Pratt","category":"knuth-morris-pratt","id":"knuthMorrisPratt_knuth-morris-pratt","algorithm":"/**\n * @see https://www.youtube.com/watch?v=GTJr8OvyEVQ\n * @param {string} word\n * @return {number[]}\n */\nfunction buildPatternTable(word) {\n  const patternTable = [0];\n  let prefixIndex = 0;\n  let suffixIndex = 1;\n\n  while (suffixIndex < word.length) {\n    if (word[prefixIndex] === word[suffixIndex]) {\n      patternTable[suffixIndex] = prefixIndex + 1;\n      suffixIndex += 1;\n      prefixIndex += 1;\n    } else if (prefixIndex === 0) {\n      patternTable[suffixIndex] = 0;\n      suffixIndex += 1;\n    } else {\n      prefixIndex = patternTable[prefixIndex - 1];\n    }\n  }\n\n  return patternTable;\n}\n\n/**\n * @param {string} text\n * @param {string} word\n * @return {number}\n */\nexport default function knuthMorrisPratt(text, word) {\n  if (word.length === 0) {\n    return 0;\n  }\n\n  let textIndex = 0;\n  let wordIndex = 0;\n\n  const patternTable = buildPatternTable(word);\n\n  while (textIndex < text.length) {\n    if (text[textIndex] === word[wordIndex]) {\n      // We've found a match.\n      if (wordIndex === word.length - 1) {\n        return (textIndex - word.length) + 1;\n      }\n      wordIndex += 1;\n      textIndex += 1;\n    } else if (wordIndex > 0) {\n      wordIndex = patternTable[wordIndex - 1];\n    } else {\n      wordIndex = 0;\n      textIndex += 1;\n    }\n  }\n\n  return -1;\n}\n","filetype":".js","index":195},{"title":"Levenshtein-distance","category":"string","id":"levenshtein-distance","algorithm":"# Levenshtein Distance\n\nThe Levenshtein distance is a string metric for measuring the \ndifference between two sequences. Informally, the Levenshtein \ndistance between two words is the minimum number of \nsingle-character edits (insertions, deletions or substitutions) \nrequired to change one word into the other.\n\n## Definition\n\nMathematically, the Levenshtein distance between two strings\n`a` and `b` (of length `|a|` and `|b|` respectively) is given by\n![Levenshtein](https://wikimedia.org/api/rest_v1/media/math/render/svg/4cf357d8f2135035207088d2c7b890fb4b64e410)\nwhere\n\n![Levenshtein](https://wikimedia.org/api/rest_v1/media/math/render/svg/f0a48ecfc9852c042382fdc33c19e11a16948e85)\n\nwhere \n![Levenshtein](https://wikimedia.org/api/rest_v1/media/math/render/svg/52512ede08444b13838c570ba4a3fc71d54dbce9)\nis the indicator function equal to `0` when\n![Levenshtein](https://wikimedia.org/api/rest_v1/media/math/render/svg/231fda9ee578f0328c5ca28088d01928bb0aaaec)\nand equal to 1 otherwise, and\n![Levenshtein](https://wikimedia.org/api/rest_v1/media/math/render/svg/bdc0315678caad28648aafedb6ebafb16bd1655c)\nis the distance between the first `i` characters of `a` and the first \n`j` characters of `b`.\n\nNote that the first element in the minimum corresponds to \ndeletion (from `a` to `b`), the second to insertion and \nthe third to match or mismatch, depending on whether the \nrespective symbols are the same.\n\n## Example\n\nFor example, the Levenshtein distance between `kitten` and \n`sitting` is `3`, since the following three edits change one \ninto the other, and there is no way to do it with fewer than \nthree edits:\n\n1. **k**itten → **s**itten (substitution of \"s\" for \"k\")\n2. sitt**e**n → sitt**i**n (substitution of \"i\" for \"e\")\n3. sittin → sittin**g** (insertion of \"g\" at the end).\n\n## Applications\n\nThis has a wide range of applications, for instance, spell checkers, correction \nsystems for optical character recognition, fuzzy string searching, and software \nto assist natural language translation based on translation memory.\n\n## Dynamic Programming Approach Explanation\n\nLet’s take a simple example of finding minimum edit distance between \nstrings `ME` and `MY`. Intuitively you already know that minimum edit distance \nhere is `1` operation, which is replacing `E` with `Y`. But \nlet’s try to formalize it in a form of the algorithm in order to be able to \ndo more complex examples like transforming `Saturday` into `Sunday`.\n\nTo apply the mathematical formula mentioned above to `ME → MY` transformation \nwe need to know minimum edit distances of `ME → M`, `M → MY` and `M → M` transformations\nin prior. Then we will need to pick the minimum one and add _one_ operation to \ntransform last letters `E → Y`. So minimum edit distance of `ME → MY` transformation \nis being calculated based on three previously possible transformations.\n\nTo explain this further let’s draw the following matrix:\n\n![Levenshtein Matrix](https://cdn-images-1.medium.com/max/1600/1*aTunSUoy0BJyYBVn4tWGrA.png)\n\n- Cell `(0:1)` contains red number 1. It means that we need 1 operation to \ntransform `M` to an empty string. And it is by deleting `M`. This is why this number is red.\n- Cell `(0:2)` contains red number 2. It means that we need 2 operations \nto transform `ME` to an empty string. And it is by deleting `E` and `M`.\n- Cell `(1:0)` contains green number 1. It means that we need 1 operation \nto transform an empty string to `M`. And it is by inserting `M`. This is why this number is green.\n- Cell `(2:0)` contains green number 2. It means that we need 2 operations \nto transform an empty string to `MY`. And it is by inserting `Y` and  `M`.\n- Cell `(1:1)` contains number 0. It means that it costs nothing \nto transform `M` into `M`.\n- Cell `(1:2)` contains red number 1. It means that we need 1 operation \nto transform `ME` to `M`. And it is by deleting `E`.\n- And so on...\n\nThis looks easy for such small matrix as ours (it is only `3x3`). But here you\nmay find basic concepts that may be applied to calculate all those numbers for\nbigger matrices (let’s say a `9x7` matrix for `Saturday → Sunday` transformation).\n\nAccording to the formula you only need three adjacent cells `(i-1:j)`, `(i-1:j-1)`, and `(i:j-1)` to\ncalculate the number for current cell `(i:j)`. All we need to do is to find the \nminimum of those three cells and then add `1` in case if we have different \nletters in `i`'s row and `j`'s column.\n\nYou may clearly see the recursive nature of the problem.\n\n![Levenshtein Matrix](https://cdn-images-1.medium.com/max/1600/1*w8UB4DSvBnAK6mBXRGQDjw.png)\n\nLet's draw a decision graph for this problem.\n\n![Minimum Edit Distance Decision Graph](https://cdn-images-1.medium.com/max/1600/1*8jD0qvr5B9PwRFM_9z7q9A.png)\n\nYou may see a number of overlapping sub-problems on the picture that are marked \nwith red. Also there is no way to reduce the number of operations and make it \nless than a minimum of those three adjacent cells from the formula. \n\nAlso you may notice that each cell number in the matrix is being calculated \nbased on previous ones. Thus the tabulation technique (filling the cache in \nbottom-up direction) is being applied here.\n\nApplying this principle further we may solve more complicated cases like \nwith `Saturday → Sunday` transformation.\n\n![Levenshtein distance](https://cdn-images-1.medium.com/max/2600/1*497gMaFErzJpCXG7kS_7dw.png)\n\n## References\n\n- [Wikipedia](https://en.wikipedia.org/wiki/Levenshtein_distance)\n- [YouTube](https://www.youtube.com/watch?v=We3YDTzNXEk&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\n- [ITNext](https://itnext.io/dynamic-programming-vs-divide-and-conquer-2fea680becbe)\n","filetype":".md","index":196},{"title":"Levenshtein Distance","category":"levenshtein-distance","id":"levenshteinDistance_levenshtein-distance","algorithm":"/**\n * @param {string} a\n * @param {string} b\n * @return {number}\n */\nexport default function levenshteinDistance(a, b) {\n  // Create empty edit distance matrix for all possible modifications of\n  // substrings of a to substrings of b.\n  const distanceMatrix = Array(b.length + 1).fill(null).map(() => Array(a.length + 1).fill(null));\n\n  // Fill the first row of the matrix.\n  // If this is first row then we're transforming empty string to a.\n  // In this case the number of transformations equals to size of a substring.\n  for (let i = 0; i <= a.length; i += 1) {\n    distanceMatrix[0][i] = i;\n  }\n\n  // Fill the first column of the matrix.\n  // If this is first column then we're transforming empty string to b.\n  // In this case the number of transformations equals to size of b substring.\n  for (let j = 0; j <= b.length; j += 1) {\n    distanceMatrix[j][0] = j;\n  }\n\n  for (let j = 1; j <= b.length; j += 1) {\n    for (let i = 1; i <= a.length; i += 1) {\n      const indicator = a[i - 1] === b[j - 1] ? 0 : 1;\n      distanceMatrix[j][i] = Math.min(\n        distanceMatrix[j][i - 1] + 1, // deletion\n        distanceMatrix[j - 1][i] + 1, // insertion\n        distanceMatrix[j - 1][i - 1] + indicator, // substitution\n      );\n    }\n  }\n\n  return distanceMatrix[b.length][a.length];\n}\n","filetype":".js","index":197},{"title":"Longest-common-substring","category":"string","id":"longest-common-substring","algorithm":"# Longest Common Substring Problem\n\nThe longest common substring problem is to find the longest string \n(or strings) that is a substring (or are substrings) of two or more \nstrings.\n\n## Example\n\nThe longest common substring of the strings `ABABC`, `BABCA` and \n`ABCBA` is string `ABC` of length 3. Other common substrings are\n`A`, `AB`, `B`, `BA`, `BC` and `C`.\n\n```\nABABC\n  |||\n BABCA\n  |||\n  ABCBA\n```\n\n## References\n\n- [Wikipedia](https://en.wikipedia.org/wiki/Longest_common_substring_problem)\n- [YouTube](https://www.youtube.com/watch?v=BysNXJHzCEs&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\n","filetype":".md","index":198},{"title":"Longest Common Substring","category":"longest-common-substring","id":"longestCommonSubstring_longest-common-substring","algorithm":"/**\n * @param {string} string1\n * @param {string} string2\n * @return {string}\n */\nexport default function longestCommonSubstring(string1, string2) {\n  // Convert strings to arrays to treat unicode symbols length correctly.\n  // For example:\n  // '𐌵'.length === 2\n  // [...'𐌵'].length === 1\n  const s1 = [...string1];\n  const s2 = [...string2];\n\n  // Init the matrix of all substring lengths to use Dynamic Programming approach.\n  const substringMatrix = Array(s2.length + 1).fill(null).map(() => {\n    return Array(s1.length + 1).fill(null);\n  });\n\n  // Fill the first row and first column with zeros to provide initial values.\n  for (let columnIndex = 0; columnIndex <= s1.length; columnIndex += 1) {\n    substringMatrix[0][columnIndex] = 0;\n  }\n\n  for (let rowIndex = 0; rowIndex <= s2.length; rowIndex += 1) {\n    substringMatrix[rowIndex][0] = 0;\n  }\n\n  // Build the matrix of all substring lengths to use Dynamic Programming approach.\n  let longestSubstringLength = 0;\n  let longestSubstringColumn = 0;\n  let longestSubstringRow = 0;\n\n  for (let rowIndex = 1; rowIndex <= s2.length; rowIndex += 1) {\n    for (let columnIndex = 1; columnIndex <= s1.length; columnIndex += 1) {\n      if (s1[columnIndex - 1] === s2[rowIndex - 1]) {\n        substringMatrix[rowIndex][columnIndex] = substringMatrix[rowIndex - 1][columnIndex - 1] + 1;\n      } else {\n        substringMatrix[rowIndex][columnIndex] = 0;\n      }\n\n      // Try to find the biggest length of all common substring lengths\n      // and to memorize its last character position (indices)\n      if (substringMatrix[rowIndex][columnIndex] > longestSubstringLength) {\n        longestSubstringLength = substringMatrix[rowIndex][columnIndex];\n        longestSubstringColumn = columnIndex;\n        longestSubstringRow = rowIndex;\n      }\n    }\n  }\n\n  if (longestSubstringLength === 0) {\n    // Longest common substring has not been found.\n    return '';\n  }\n\n  // Detect the longest substring from the matrix.\n  let longestSubstring = '';\n\n  while (substringMatrix[longestSubstringRow][longestSubstringColumn] > 0) {\n    longestSubstring = s1[longestSubstringColumn - 1] + longestSubstring;\n    longestSubstringRow -= 1;\n    longestSubstringColumn -= 1;\n  }\n\n  return longestSubstring;\n}\n","filetype":".js","index":199},{"title":"Rabin-karp","category":"string","id":"rabin-karp","algorithm":"# Rabin Karp Algorithm\n\nIn computer science, the Rabin–Karp algorithm or Karp–Rabin algorithm \nis a string searching algorithm created by Richard M. Karp and \nMichael O. Rabin (1987) that uses hashing to find any one of a set \nof pattern strings in a text. \n\n## Algorithm\n\nThe Rabin–Karp algorithm seeks to speed up the testing of equality of \nthe pattern to the substrings in the text by using a hash function. A \nhash function is a function which converts every string into a numeric \nvalue, called its hash value; for example, we might \nhave `hash('hello') = 5`. The algorithm exploits the fact \nthat if two strings are equal, their hash values are also equal. Thus,\nstring matching is reduced (almost) to computing the hash value of the\nsearch pattern and then looking for substrings of the input string with\nthat hash value.\n\nHowever, there are two problems with this approach. First, because there\nare so many different strings and so few hash values, some differing\nstrings will have the same hash value. If the hash values match, the\npattern and the substring may not match; consequently, the potential\nmatch of search pattern and the substring must be confirmed by comparing\nthem; that comparison can take a long time for long substrings.\nLuckily, a good hash function on reasonable strings usually does not\nhave many collisions, so the expected search time will be acceptable.\n\n## Hash Function Used\n\nThe key to the Rabin–Karp algorithm's performance is the efficient computation \nof hash values of the successive substrings of the text.\nThe **Rabin fingerprint** is a popular and effective rolling hash function.\n\nThe **polynomial hash function** described in this example is not a Rabin \nfingerprint, but it works equally well. It treats every substring as a \nnumber in some base, the base being usually a large prime.\n\n## Complexity\n\nFor text of length `n` and `p` patterns of combined length `m`, its average \nand best case running time is `O(n + m)` in space `O(p)`, but its \nworst-case time is `O(n * m)`. \n\n## Application\n\nA practical application of the algorithm is detecting plagiarism. \nGiven source material, the algorithm can rapidly search through a paper \nfor instances of sentences from the source material, ignoring details \nsuch as case and punctuation. Because of the abundance of the sought \nstrings, single-string searching algorithms are impractical.\n\n## References\n\n- [Wikipedia](https://en.wikipedia.org/wiki/Rabin%E2%80%93Karp_algorithm)\n- [YouTube](https://www.youtube.com/watch?v=H4VrKHVG5qI&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\n","filetype":".md","index":200},{"title":"Rabin Karp","category":"rabin-karp","id":"rabinKarp_rabin-karp","algorithm":"import PolynomialHash from '../../cryptography/polynomial-hash/PolynomialHash';\n\n/**\n * @param {string} text - Text that may contain the searchable word.\n * @param {string} word - Word that is being searched in text.\n * @return {number} - Position of the word in text.\n */\nexport default function rabinKarp(text, word) {\n  const hasher = new PolynomialHash();\n\n  // Calculate word hash that we will use for comparison with other substring hashes.\n  const wordHash = hasher.hash(word);\n\n  let prevFrame = null;\n  let currentFrameHash = null;\n\n  // Go through all substring of the text that may match.\n  for (let charIndex = 0; charIndex <= (text.length - word.length); charIndex += 1) {\n    const currentFrame = text.substring(charIndex, charIndex + word.length);\n\n    // Calculate the hash of current substring.\n    if (currentFrameHash === null) {\n      currentFrameHash = hasher.hash(currentFrame);\n    } else {\n      currentFrameHash = hasher.roll(currentFrameHash, prevFrame, currentFrame);\n    }\n\n    prevFrame = currentFrame;\n\n    // Compare the hash of current substring and seeking string.\n    // In case if hashes match let's make sure that substrings are equal.\n    // In case of hash collision the strings may not be equal.\n    if (\n      wordHash === currentFrameHash\n      && text.substr(charIndex, word.length) === word\n    ) {\n      return charIndex;\n    }\n  }\n\n  return -1;\n}\n","filetype":".js","index":201},{"title":"Regular-expression-matching","category":"string","id":"regular-expression-matching","algorithm":"# Regular Expression Matching\n\nGiven an input string `s` and a pattern `p`, implement regular \nexpression matching with support for `.` and `*`.\n\n- `.` Matches any single character.\n- `*` Matches zero or more of the preceding element.\n\nThe matching should cover the **entire** input string (not partial).\n\n**Note**\n\n- `s` could be empty and contains only lowercase letters `a-z`.\n- `p` could be empty and contains only lowercase letters `a-z`, and characters like `.` or `*`.\n\n## Examples\n\n**Example #1**\n\nInput:\n```\ns = 'aa'\np = 'a'\n```\n\nOutput: `false`\n\nExplanation: `a` does not match the entire string `aa`.\n\n**Example #2**\n\nInput:\n```\ns = 'aa'\np = 'a*'\n```\n\nOutput: `true`\n\nExplanation: `*` means zero or more of the preceding element, `a`. \nTherefore, by repeating `a` once, it becomes `aa`.\n\n**Example #3**\n\nInput:\n\n```\ns = 'ab'\np = '.*'\n```\n\nOutput: `true`\n\nExplanation: `.*` means \"zero or more (`*`) of any character (`.`)\".\n\n**Example #4**\n\nInput:\n\n```\ns = 'aab'\np = 'c*a*b'\n```\n\nOutput: `true`\n\nExplanation: `c` can be repeated 0 times, `a` can be repeated \n1 time. Therefore it matches `aab`.\n\n## References\n\n- [YouTube](https://www.youtube.com/watch?v=l3hda49XcDE&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8&index=71&t=0s)\n- [LeetCode](https://leetcode.com/problems/regular-expression-matching/description/)\n","filetype":".md","index":202},{"title":"Regular Expression Matching","category":"regular-expression-matching","id":"regularExpressionMatching_regular-expression-matching","algorithm":"const ZERO_OR_MORE_CHARS = '*';\nconst ANY_CHAR = '.';\n\n/**\n * Dynamic programming approach.\n *\n * @param {string} string\n * @param {string} pattern\n * @return {boolean}\n */\nexport default function regularExpressionMatching(string, pattern) {\n  /*\n    * Let's initiate dynamic programming matrix for this string and pattern.\n    * We will have pattern characters on top (as columns) and string characters\n    * will be placed to the left of the table (as rows).\n    *\n    * Example:\n    *\n    *     a * b . b\n    *   - - - - - -\n    * a - - - - - -\n    * a - - - - - -\n    * b - - - - - -\n    * y - - - - - -\n    * b - - - - - -\n   */\n  const matchMatrix = Array(string.length + 1).fill(null).map(() => {\n    return Array(pattern.length + 1).fill(null);\n  });\n\n  // Let's fill the top-left cell with true. This would mean that empty\n  // string '' matches to empty pattern ''.\n  matchMatrix[0][0] = true;\n\n  // Let's fill the first row of the matrix with false. That would mean that\n  // empty string can't match any non-empty pattern.\n  //\n  // Example:\n  // string: ''\n  // pattern: 'a.z'\n  //\n  // The one exception here is patterns like a*b* that matches the empty string.\n  for (let columnIndex = 1; columnIndex <= pattern.length; columnIndex += 1) {\n    const patternIndex = columnIndex - 1;\n\n    if (pattern[patternIndex] === ZERO_OR_MORE_CHARS) {\n      matchMatrix[0][columnIndex] = matchMatrix[0][columnIndex - 2];\n    } else {\n      matchMatrix[0][columnIndex] = false;\n    }\n  }\n\n  // Let's fill the first column with false. That would mean that empty pattern\n  // can't match any non-empty string.\n  //\n  // Example:\n  // string: 'ab'\n  // pattern: ''\n  for (let rowIndex = 1; rowIndex <= string.length; rowIndex += 1) {\n    matchMatrix[rowIndex][0] = false;\n  }\n\n  // Not let's go through every letter of the pattern and every letter of\n  // the string and compare them one by one.\n  for (let rowIndex = 1; rowIndex <= string.length; rowIndex += 1) {\n    for (let columnIndex = 1; columnIndex <= pattern.length; columnIndex += 1) {\n      // Take into account that fact that matrix contain one extra column and row.\n      const stringIndex = rowIndex - 1;\n      const patternIndex = columnIndex - 1;\n\n      if (pattern[patternIndex] === ZERO_OR_MORE_CHARS) {\n        /*\n         * In case if current pattern character is special '*' character we have\n         * two options:\n         *\n         * 1. Since * char allows it previous char to not be presented in a string we\n         * need to check if string matches the pattern without '*' char and without the\n         * char that goes before '*'. That would mean to go two positions left on the\n         * same row.\n         *\n         * 2. Since * char allows it previous char to be presented in a string many times we\n         * need to check if char before * is the same as current string char. If they are the\n         * same that would mean that current string matches the current pattern in case if\n         * the string WITHOUT current char matches the same pattern. This would mean to go\n         * one position up in the same row.\n         */\n        if (matchMatrix[rowIndex][columnIndex - 2] === true) {\n          matchMatrix[rowIndex][columnIndex] = true;\n        } else if (\n          (\n            pattern[patternIndex - 1] === string[stringIndex]\n            || pattern[patternIndex - 1] === ANY_CHAR\n          )\n          && matchMatrix[rowIndex - 1][columnIndex] === true\n        ) {\n          matchMatrix[rowIndex][columnIndex] = true;\n        } else {\n          matchMatrix[rowIndex][columnIndex] = false;\n        }\n      } else if (\n        pattern[patternIndex] === string[stringIndex]\n        || pattern[patternIndex] === ANY_CHAR\n      ) {\n        /*\n         * In case if current pattern char is the same as current string char\n         * or it may be any character (in case if pattern contains '.' char)\n         * we need to check if there was a match for the pattern and for the\n         * string by WITHOUT current char. This would mean that we may copy\n         * left-top diagonal value.\n         *\n         * Example:\n         *\n         *   a b\n         * a 1 -\n         * b - 1\n         */\n        matchMatrix[rowIndex][columnIndex] = matchMatrix[rowIndex - 1][columnIndex - 1];\n      } else {\n        /*\n         * In case if pattern char and string char are different we may\n         * treat this case as \"no-match\".\n         *\n         * Example:\n         *\n         *   a b\n         * a - -\n         * c - 0\n         */\n        matchMatrix[rowIndex][columnIndex] = false;\n      }\n    }\n  }\n\n  return matchMatrix[string.length][pattern.length];\n}\n","filetype":".js","index":203},{"title":"Z-algorithm","category":"string","id":"z-algorithm","algorithm":"# Z Algorithm\n\nThe Z-algorithm finds occurrences of a \"word\" `W` \nwithin a main \"text string\" `T` in linear time `O(|W| + |T|)`.\n\nGiven a string `S` of length `n`, the algorithm produces \nan array, `Z` where `Z[i]` represents the longest substring \nstarting from `S[i]` which is also a prefix of `S`. Finding\n`Z` for the string obtained by concatenating the word, `W` \nwith a nonce character, say `$` followed by the text, `T`,\nhelps with pattern matching, for if there is some index `i`\nsuch that `Z[i]` equals the pattern length, then the pattern\nmust be present at that point.\n\nWhile the `Z` array can be computed with two nested loops in `O(|W| * |T|)` time, the\nfollowing strategy shows how to obtain it in linear time, based \non the idea that as we iterate over the letters in the string \n(index `i` from `1` to `n - 1`), we maintain an interval `[L, R]`\nwhich is the interval with maximum `R` such that `1 ≤ L ≤ i ≤ R` \nand `S[L...R]` is a prefix that is also a substring (if no such \ninterval exists, just let `L = R =  - 1`). For `i = 1`, we can \nsimply compute `L` and `R` by comparing `S[0...]` to `S[1...]`.\n\n**Example of Z array**\n\n```\nIndex            0   1   2   3   4   5   6   7   8   9  10  11 \nText             a   a   b   c   a   a   b   x   a   a   a   z\nZ values         X   1   0   0   3   1   0   0   2   2   1   0 \n```\n\nOther examples\n\n```\nstr =  a a a a a a\nZ[] =  x 5 4 3 2 1\n```\n\n```\nstr =  a a b a a c d\nZ[] =  x 1 0 2 1 0 0\n```\n\n```\nstr =  a b a b a b a b\nZ[] =  x 0 6 0 4 0 2 0\n```\n\n**Example of Z box**\n\n![z-box](https://ivanyu.me/wp-content/uploads/2014/09/zalg1.png)\n\n## Complexity\n\n- **Time:** `O(|W| + |T|)`\n- **Space:** `O(|W|)`\n\n## References\n\n- [GeeksForGeeks](https://www.geeksforgeeks.org/z-algorithm-linear-time-pattern-searching-algorithm/)\n- [YouTube](https://www.youtube.com/watch?v=CpZh4eF8QBw&t=0s&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8&index=70)\n- [Z Algorithm by Ivan Yurchenko](https://ivanyu.me/blog/2013/10/15/z-algorithm/)\n","filetype":".md","index":204},{"title":"Z Algorithm","category":"z-algorithm","id":"zAlgorithm_z-algorithm","algorithm":"// The string separator that is being used for \"word\" and \"text\" concatenation.\nconst SEPARATOR = '$';\n\n/**\n * @param {string} zString\n * @return {number[]}\n */\nfunction buildZArray(zString) {\n  // Initiate zArray and fill it with zeros.\n  const zArray = new Array(zString.length).fill(null).map(() => 0);\n\n  // Z box boundaries.\n  let zBoxLeftIndex = 0;\n  let zBoxRightIndex = 0;\n\n  // Position of current zBox character that is also a position of\n  // the same character in prefix.\n  // For example:\n  // Z string: ab$xxabxx\n  // Indices:  012345678\n  // Prefix:   ab.......\n  // Z box:    .....ab..\n  // Z box shift for 'a' would be 0 (0-position in prefix and 0-position in Z box)\n  // Z box shift for 'b' would be 1 (1-position in prefix and 1-position in Z box)\n  let zBoxShift = 0;\n\n  // Go through all characters of the zString.\n  for (let charIndex = 1; charIndex < zString.length; charIndex += 1) {\n    if (charIndex > zBoxRightIndex) {\n      // We're OUTSIDE of Z box. In other words this is a case when we're\n      // starting from Z box of size 1.\n\n      // In this case let's make current character to be a Z box of length 1.\n      zBoxLeftIndex = charIndex;\n      zBoxRightIndex = charIndex;\n\n      // Now let's go and check current and the following characters to see if\n      // they are the same as a prefix. By doing this we will also expand our\n      // Z box. For example if starting from current position we will find 3\n      // more characters that are equal to the ones in the prefix we will expand\n      // right Z box boundary by 3.\n      while (\n        zBoxRightIndex < zString.length\n        && zString[zBoxRightIndex - zBoxLeftIndex] === zString[zBoxRightIndex]\n      ) {\n        // Expanding Z box right boundary.\n        zBoxRightIndex += 1;\n      }\n\n      // Now we may calculate how many characters starting from current position\n      // are are the same as the prefix. We may calculate it by difference between\n      // right and left Z box boundaries.\n      zArray[charIndex] = zBoxRightIndex - zBoxLeftIndex;\n\n      // Move right Z box boundary left by one position just because we've used\n      // [zBoxRightIndex - zBoxLeftIndex] index calculation above.\n      zBoxRightIndex -= 1;\n    } else {\n      // We're INSIDE of Z box.\n\n      // Calculate corresponding Z box shift. Because we want to copy the values\n      // from zArray that have been calculated before.\n      zBoxShift = charIndex - zBoxLeftIndex;\n\n      // Check if the value that has been already calculated before\n      // leaves us inside of Z box or it goes beyond the checkbox\n      // right boundary.\n      if (zArray[zBoxShift] < (zBoxRightIndex - charIndex) + 1) {\n        // If calculated value don't force us to go outside Z box\n        // then we're safe and we may simply use previously calculated value.\n        zArray[charIndex] = zArray[zBoxShift];\n      } else {\n        // In case if previously calculated values forces us to go outside of Z box\n        // we can't safely copy previously calculated zArray value. It is because\n        // we are sure that there is no further prefix matches outside of Z box.\n        // Thus such values must be re-calculated and reduced to certain point.\n\n        // To do so we need to shift left boundary of Z box to current position.\n        zBoxLeftIndex = charIndex;\n\n        // And start comparing characters one by one as we normally do for the case\n        // when we are outside of checkbox.\n        while (\n          zBoxRightIndex < zString.length\n          && zString[zBoxRightIndex - zBoxLeftIndex] === zString[zBoxRightIndex]\n        ) {\n          zBoxRightIndex += 1;\n        }\n\n        zArray[charIndex] = zBoxRightIndex - zBoxLeftIndex;\n\n        zBoxRightIndex -= 1;\n      }\n    }\n  }\n\n  // Return generated zArray.\n  return zArray;\n}\n\n/**\n * @param {string} text\n * @param {string} word\n * @return {number[]}\n */\nexport default function zAlgorithm(text, word) {\n  // The list of word's positions in text. Word may be found in the same text\n  // in several different positions. Thus it is an array.\n  const wordPositions = [];\n\n  // Concatenate word and string. Word will be a prefix to a string.\n  const zString = `${word}${SEPARATOR}${text}`;\n\n  // Generate Z-array for concatenated string.\n  const zArray = buildZArray(zString);\n\n  // Based on Z-array properties each cell will tell us the length of the match between\n  // the string prefix and current sub-text. Thus we're may find all positions in zArray\n  // with the number that equals to the length of the word (zString prefix) and based on\n  // that positions we'll be able to calculate word positions in text.\n  for (let charIndex = 1; charIndex < zArray.length; charIndex += 1) {\n    if (zArray[charIndex] === word.length) {\n      // Since we did concatenation to form zString we need to subtract prefix\n      // and separator lengths.\n      const wordPosition = charIndex - word.length - SEPARATOR.length;\n      wordPositions.push(wordPosition);\n    }\n  }\n\n  // Return the list of word positions.\n  return wordPositions;\n}\n","filetype":".js","index":205},{"title":"Tree","category":"algorithms","id":"tree","index":206},{"title":"Breadth-first-search","category":"tree","id":"breadth-first-search","algorithm":"# Breadth-First Search (BFS)\n\nBreadth-first search (BFS) is an algorithm for traversing \nor searching tree or graph data structures. It starts at\nthe tree root (or some arbitrary node of a graph, sometimes \nreferred to as a 'search key') and explores the neighbor\nnodes first, before moving to the next level neighbors.\n\n![Algorithm Visualization](https://upload.wikimedia.org/wikipedia/commons/5/5d/Breadth-First-Search-Algorithm.gif)\n\n## Pseudocode\n\n```text\nBFS(root)\n  Pre: root is the node of the BST\n  Post: the nodes in the BST have been visited in breadth first order\n  q ← queue\n  while root = ø\n    yield root.value\n    if root.left = ø\n      q.enqueue(root.left)\n    end if\n    if root.right = ø\n      q.enqueue(root.right)\n    end if\n    if !q.isEmpty()\n      root ← q.dequeue()\n    else\n      root ← ø\n    end if\n  end while\nend BFS\n```\n\n## References\n\n- [Wikipedia](https://en.wikipedia.org/wiki/Breadth-first_search)\n- [Tree Traversals (Inorder, Preorder and Postorder)](https://www.geeksforgeeks.org/tree-traversals-inorder-preorder-and-postorder/)\n- [BFS vs DFS](https://www.geeksforgeeks.org/bfs-vs-dfs-binary-tree/)\n","filetype":".md","index":207},{"title":"Breadth First Search","category":"breadth-first-search","id":"breadthFirstSearch_breadth-first-search","algorithm":"import Queue from '../../../data-structures/queue/Queue';\n\n/**\n * @typedef {Object} Callbacks\n * @property {function(node: BinaryTreeNode, child: BinaryTreeNode): boolean} allowTraversal -\n *   Determines whether DFS should traverse from the node to its child.\n * @property {function(node: BinaryTreeNode)} enterNode - Called when DFS enters the node.\n * @property {function(node: BinaryTreeNode)} leaveNode - Called when DFS leaves the node.\n */\n\n/**\n * @param {Callbacks} [callbacks]\n * @returns {Callbacks}\n */\nfunction initCallbacks(callbacks = {}) {\n  const initiatedCallback = callbacks;\n\n  const stubCallback = () => {};\n  const defaultAllowTraversal = () => true;\n\n  initiatedCallback.allowTraversal = callbacks.allowTraversal || defaultAllowTraversal;\n  initiatedCallback.enterNode = callbacks.enterNode || stubCallback;\n  initiatedCallback.leaveNode = callbacks.leaveNode || stubCallback;\n\n  return initiatedCallback;\n}\n\n/**\n * @param {BinaryTreeNode} rootNode\n * @param {Callbacks} [originalCallbacks]\n */\nexport default function breadthFirstSearch(rootNode, originalCallbacks) {\n  const callbacks = initCallbacks(originalCallbacks);\n  const nodeQueue = new Queue();\n\n  // Do initial queue setup.\n  nodeQueue.enqueue(rootNode);\n\n  while (!nodeQueue.isEmpty()) {\n    const currentNode = nodeQueue.dequeue();\n\n    callbacks.enterNode(currentNode);\n\n    // Add all children to the queue for future traversals.\n\n    // Traverse left branch.\n    if (currentNode.left && callbacks.allowTraversal(currentNode, currentNode.left)) {\n      nodeQueue.enqueue(currentNode.left);\n    }\n\n    // Traverse right branch.\n    if (currentNode.right && callbacks.allowTraversal(currentNode, currentNode.right)) {\n      nodeQueue.enqueue(currentNode.right);\n    }\n\n    callbacks.leaveNode(currentNode);\n  }\n}\n","filetype":".js","index":208},{"title":"Depth-first-search","category":"tree","id":"depth-first-search","algorithm":"# Depth-First Search (DFS)\n\nDepth-first search (DFS) is an algorithm for traversing or \nsearching tree or graph data structures. One starts at \nthe root (selecting some arbitrary node as the root in \nthe case of a graph) and explores as far as possible \nalong each branch before backtracking.\n\n![Algorithm Visualization](https://upload.wikimedia.org/wikipedia/commons/7/7f/Depth-First-Search.gif)\n\n## References\n\n- [Wikipedia](https://en.wikipedia.org/wiki/Depth-first_search)\n- [Tree Traversals (Inorder, Preorder and Postorder)](https://www.geeksforgeeks.org/tree-traversals-inorder-preorder-and-postorder/)\n- [BFS vs DFS](https://www.geeksforgeeks.org/bfs-vs-dfs-binary-tree/)\n","filetype":".md","index":209},{"title":"Depth First Search","category":"depth-first-search","id":"depthFirstSearch_depth-first-search","algorithm":"/**\n * @typedef {Object} TraversalCallbacks\n *\n * @property {function(node: BinaryTreeNode, child: BinaryTreeNode): boolean} allowTraversal\n * - Determines whether DFS should traverse from the node to its child.\n *\n * @property {function(node: BinaryTreeNode)} enterNode - Called when DFS enters the node.\n *\n * @property {function(node: BinaryTreeNode)} leaveNode - Called when DFS leaves the node.\n */\n\n/**\n * Extend missing traversal callbacks with default callbacks.\n *\n * @param {TraversalCallbacks} [callbacks] - The object that contains traversal callbacks.\n * @returns {TraversalCallbacks} - Traversal callbacks extended with defaults callbacks.\n */\nfunction initCallbacks(callbacks = {}) {\n  // Init empty callbacks object.\n  const initiatedCallbacks = {};\n\n  // Empty callback that we will use in case if user didn't provide real callback function.\n  const stubCallback = () => {};\n  // By default we will allow traversal of every node\n  // in case if user didn't provide a callback for that.\n  const defaultAllowTraversalCallback = () => true;\n\n  // Copy original callbacks to our initiatedCallbacks object or use default callbacks instead.\n  initiatedCallbacks.allowTraversal = callbacks.allowTraversal || defaultAllowTraversalCallback;\n  initiatedCallbacks.enterNode = callbacks.enterNode || stubCallback;\n  initiatedCallbacks.leaveNode = callbacks.leaveNode || stubCallback;\n\n  // Returned processed list of callbacks.\n  return initiatedCallbacks;\n}\n\n/**\n * Recursive depth-first-search traversal for binary.\n *\n * @param {BinaryTreeNode} node - binary tree node that we will start traversal from.\n * @param {TraversalCallbacks} callbacks - the object that contains traversal callbacks.\n */\nexport function depthFirstSearchRecursive(node, callbacks) {\n  // Call the \"enterNode\" callback to notify that the node is going to be entered.\n  callbacks.enterNode(node);\n\n  // Traverse left branch only if case if traversal of the left node is allowed.\n  if (node.left && callbacks.allowTraversal(node, node.left)) {\n    depthFirstSearchRecursive(node.left, callbacks);\n  }\n\n  // Traverse right branch only if case if traversal of the right node is allowed.\n  if (node.right && callbacks.allowTraversal(node, node.right)) {\n    depthFirstSearchRecursive(node.right, callbacks);\n  }\n\n  // Call the \"leaveNode\" callback to notify that traversal\n  // of the current node and its children is finished.\n  callbacks.leaveNode(node);\n}\n\n/**\n * Perform depth-first-search traversal of the rootNode.\n * For every traversal step call \"allowTraversal\", \"enterNode\" and \"leaveNode\" callbacks.\n * See TraversalCallbacks type definition for more details about the shape of callbacks object.\n *\n * @param {BinaryTreeNode} rootNode - The node from which we start traversing.\n * @param {TraversalCallbacks} [callbacks] - Traversal callbacks.\n */\nexport default function depthFirstSearch(rootNode, callbacks) {\n  // In case if user didn't provide some callback we need to replace them with default ones.\n  const processedCallbacks = initCallbacks(callbacks);\n\n  // Now, when we have all necessary callbacks we may proceed to recursive traversal.\n  depthFirstSearchRecursive(rootNode, processedCallbacks);\n}\n","filetype":".js","index":210},{"title":"Uncategorized","category":"algorithms","id":"uncategorized","index":211},{"title":"Best-time-to-buy-sell-stocks","category":"uncategorized","id":"best-time-to-buy-sell-stocks","algorithm":"# Best Time to Buy and Sell Stock\n\n## Task Description\n\nSay you have an array prices for which the `i`-th element is the price of a given stock on day `i`.\n\nFind the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).\n\n> Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).\n\n**Example #1**\n\n```\nInput: [7, 1, 5, 3, 6, 4]\nOutput: 7\n```\n\n_Explanation:_ Buy on day `2` (`price = 1`) and sell on day `3` (`price = 5`), `profit = 5-1 = 4`. Then buy on day `4` (`price = 3`) and sell on day `5` (`price = 6`), `profit = 6-3 = 3`.\n\n**Example #2**\n\n```\nInput: [1, 2, 3, 4, 5]\nOutput: 4\n```\n\n_Explanation:_ Buy on day `1` (`price = 1`) and sell on day `5` (`price = 5`), `profit = 5-1 = 4`. Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.\n\n**Example #3**\n\n```\nInput: [7, 6, 4, 3, 1]\nOutput: 0\n```\n\n_Explanation:_ In this case, no transaction is done, i.e. max `profit = 0`.\n\n## Possible Solutions\n\n### Divide and conquer approach `O(2^n)`\n\nWe may try **all** combinations of buying and selling and find out the most profitable one by applying _divide and conquer approach_.\n\nLet's say we have an array of prices `[7, 6, 4, 3, 1]` and we're on the _1st_ day of trading (at the very beginning of the array). At this point we may say that the overall maximum profit would be the _maximum_ of two following values:\n\n1. _Option 1: Keep the money_ → profit would equal to the profit from buying/selling the rest of the stocks → `keepProfit = profit([6, 4, 3, 1])`.\n2. _Option 2: Buy/sell at current price_ → profit in this case would equal to the profit from buying/selling the rest of the stocks plus (or minus, depending on whether we're selling or buying) the current stock price → `buySellProfit = -7 + profit([6, 4, 3, 1])`.\n\nThe overall profit would be equal to → `overalProfit = Max(keepProfit, buySellProfit)`.\n\nAs you can see the `profit([6, 4, 3, 1])` task is being solved in the same recursive manner.\n\n> See the full code example in [dqBestTimeToBuySellStocks.js](dqBestTimeToBuySellStocks.js)\n\n#### Time Complexity\n\nAs you may see, every recursive call will produce _2_ more recursive branches. The depth of the recursion will be `n` (size of prices array) and thus, the time complexity will equal to `O(2^n)`.\n\nAs you may see, this is very inefficient. For example for just `20` prices the number of recursive calls will be somewhere close to `2M`!\n\n#### Additional Space Complexity\n\nIf we avoid cloning the prices array between recursive function calls and will use the array pointer then additional space complexity will be proportional to the depth of the recursion: `O(n)`\n\n## Peak Valley Approach `O(n)`\n\nIf we plot the prices array (i.e. `[7, 1, 5, 3, 6, 4]`) we may notice that the points of interest are the consecutive valleys and peaks\n\n![Peak Valley Approach](https://leetcode.com/media/original_images/122_maxprofit_1.PNG)\n\n_Image source: [LeetCode](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/solution/)_\n\nSo, if we will track the growing price and will sell the stocks immediately _before_ the price goes down we'll get the maximum profit (remember, we bought the stock in the valley at its low price).\n\n> See the full code example in [peakvalleyBestTimeToBuySellStocks.js](peakvalleyBestTimeToBuySellStocks.js)\n\n#### Time Complexity\n\nSince the algorithm requires only one pass through the prices array, the time complexity would equal `O(n)`.\n\n#### Additional Space Complexity\n\nExcept of the prices array itself the algorithm consumes the constant amount of memory. Thus, additional space complexity is `O(1)`.\n\n## Accumulator Approach `O(n)`\n\nThere is even simpler approach exists. Let's say we have the prices array which looks like this `[1, 7, 2, 3, 6, 7, 6, 7]`:\n\n![Simple One Pass](https://leetcode.com/media/original_images/122_maxprofit_2.PNG)\n\n_Image source: [LeetCode](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/solution/)_\n\nYou may notice, that we don't even need to keep tracking of a constantly growing price. Instead, we may simply add the price difference for _all growing segments_ of the chart which eventually sums up to the highest possible profit,\n\n> See the full code example in [accumulatorBestTimeToBuySellStocks.js](accumulatorBestTimeToBuySellStocks.js)\n\n#### Time Complexity\n\nSince the algorithm requires only one pass through the prices array, the time complexity would equal `O(n)`.\n\n#### Additional Space Complexity\n\nExcept of the prices array itself the algorithm consumes the constant amount of memory. Thus, additional space complexity is `O(1)`.\n\n## References\n\n- [Best Time to Buy and Sell Stock on LeetCode](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/)\n","filetype":".md","index":212},{"title":"__tests__","category":"best-time-to-buy-sell-stocks","id":"__tests__","index":213},{"title":"Accumulator Best Time To Buy Sell Stocks.test","category":"__tests__","id":"accumulatorBestTimeToBuySellStocks.test___tests__","algorithm":"import accumulatorBestTimeToBuySellStocks from '../accumulatorBestTimeToBuySellStocks';\n\ndescribe('accumulatorBestTimeToBuySellStocks', () => {\n  it('should find the best time to buy and sell stocks', () => {\n    let visit;\n\n    expect(accumulatorBestTimeToBuySellStocks([1, 5])).toEqual(4);\n\n    visit = jest.fn();\n    expect(accumulatorBestTimeToBuySellStocks([1], visit)).toEqual(0);\n    expect(visit).toHaveBeenCalledTimes(1);\n\n    visit = jest.fn();\n    expect(accumulatorBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);\n    expect(visit).toHaveBeenCalledTimes(2);\n\n    visit = jest.fn();\n    expect(accumulatorBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);\n    expect(visit).toHaveBeenCalledTimes(2);\n\n    visit = jest.fn();\n    expect(accumulatorBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);\n    expect(visit).toHaveBeenCalledTimes(3);\n\n    visit = jest.fn();\n    expect(accumulatorBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);\n    expect(visit).toHaveBeenCalledTimes(6);\n\n    visit = jest.fn();\n    expect(accumulatorBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);\n    expect(visit).toHaveBeenCalledTimes(6);\n\n    visit = jest.fn();\n    expect(accumulatorBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);\n    expect(visit).toHaveBeenCalledTimes(5);\n\n    visit = jest.fn();\n    expect(accumulatorBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);\n    expect(visit).toHaveBeenCalledTimes(5);\n\n    visit = jest.fn();\n    expect(accumulatorBestTimeToBuySellStocks(\n      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],\n      visit,\n    )).toEqual(19);\n    expect(visit).toHaveBeenCalledTimes(20);\n  });\n});\n","filetype":".js","index":214},{"title":"Dp Best Time To Buy Sell Stocks.test","category":"__tests__","id":"dpBestTimeToBuySellStocks.test___tests__","algorithm":"import dpBestTimeToBuySellStocks from '../dpBestTimeToBuySellStocks';\n\ndescribe('dpBestTimeToBuySellStocks', () => {\n  it('should find the best time to buy and sell stocks', () => {\n    let visit;\n\n    expect(dpBestTimeToBuySellStocks([1, 5])).toEqual(4);\n\n    visit = jest.fn();\n    expect(dpBestTimeToBuySellStocks([1], visit)).toEqual(0);\n    expect(visit).toHaveBeenCalledTimes(1);\n\n    visit = jest.fn();\n    expect(dpBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);\n    expect(visit).toHaveBeenCalledTimes(2);\n\n    visit = jest.fn();\n    expect(dpBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);\n    expect(visit).toHaveBeenCalledTimes(2);\n\n    visit = jest.fn();\n    expect(dpBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);\n    expect(visit).toHaveBeenCalledTimes(3);\n\n    visit = jest.fn();\n    expect(dpBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);\n    expect(visit).toHaveBeenCalledTimes(6);\n\n    visit = jest.fn();\n    expect(dpBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);\n    expect(visit).toHaveBeenCalledTimes(6);\n\n    visit = jest.fn();\n    expect(dpBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);\n    expect(visit).toHaveBeenCalledTimes(5);\n\n    visit = jest.fn();\n    expect(dpBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);\n    expect(visit).toHaveBeenCalledTimes(5);\n\n    visit = jest.fn();\n    expect(dpBestTimeToBuySellStocks(\n      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],\n      visit,\n    )).toEqual(19);\n    expect(visit).toHaveBeenCalledTimes(20);\n  });\n});\n","filetype":".js","index":215},{"title":"Dq Best Time To Buy Sell Stocks.test","category":"__tests__","id":"dqBestTimeToBuySellStocks.test___tests__","algorithm":"import dqBestTimeToBuySellStocks from '../dqBestTimeToBuySellStocks';\n\ndescribe('dqBestTimeToBuySellStocks', () => {\n  it('should find the best time to buy and sell stocks', () => {\n    let visit;\n\n    expect(dqBestTimeToBuySellStocks([1, 5])).toEqual(4);\n\n    visit = jest.fn();\n    expect(dqBestTimeToBuySellStocks([1], visit)).toEqual(0);\n    expect(visit).toHaveBeenCalledTimes(3);\n\n    visit = jest.fn();\n    expect(dqBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);\n    expect(visit).toHaveBeenCalledTimes(7);\n\n    visit = jest.fn();\n    expect(dqBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);\n    expect(visit).toHaveBeenCalledTimes(7);\n\n    visit = jest.fn();\n    expect(dqBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);\n    expect(visit).toHaveBeenCalledTimes(15);\n\n    visit = jest.fn();\n    expect(dqBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);\n    expect(visit).toHaveBeenCalledTimes(127);\n\n    visit = jest.fn();\n    expect(dqBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);\n    expect(visit).toHaveBeenCalledTimes(127);\n\n    visit = jest.fn();\n    expect(dqBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);\n    expect(visit).toHaveBeenCalledTimes(63);\n\n    visit = jest.fn();\n    expect(dqBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);\n    expect(visit).toHaveBeenCalledTimes(63);\n\n    visit = jest.fn();\n    expect(dqBestTimeToBuySellStocks(\n      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],\n      visit,\n    )).toEqual(19);\n    expect(visit).toHaveBeenCalledTimes(2097151);\n  });\n});\n","filetype":".js","index":216},{"title":"Peakvalley Best Time To Buy Sell Stocks.test","category":"__tests__","id":"peakvalleyBestTimeToBuySellStocks.test___tests__","algorithm":"import peakvalleyBestTimeToBuySellStocks from '../peakvalleyBestTimeToBuySellStocks';\n\ndescribe('peakvalleyBestTimeToBuySellStocks', () => {\n  it('should find the best time to buy and sell stocks', () => {\n    let visit;\n\n    expect(peakvalleyBestTimeToBuySellStocks([1, 5])).toEqual(4);\n\n    visit = jest.fn();\n    expect(peakvalleyBestTimeToBuySellStocks([1], visit)).toEqual(0);\n    expect(visit).toHaveBeenCalledTimes(1);\n\n    visit = jest.fn();\n    expect(peakvalleyBestTimeToBuySellStocks([1, 5], visit)).toEqual(4);\n    expect(visit).toHaveBeenCalledTimes(2);\n\n    visit = jest.fn();\n    expect(peakvalleyBestTimeToBuySellStocks([5, 1], visit)).toEqual(0);\n    expect(visit).toHaveBeenCalledTimes(2);\n\n    visit = jest.fn();\n    expect(peakvalleyBestTimeToBuySellStocks([1, 5, 10], visit)).toEqual(9);\n    expect(visit).toHaveBeenCalledTimes(3);\n\n    visit = jest.fn();\n    expect(peakvalleyBestTimeToBuySellStocks([10, 1, 5, 20, 15, 21], visit)).toEqual(25);\n    expect(visit).toHaveBeenCalledTimes(6);\n\n    visit = jest.fn();\n    expect(peakvalleyBestTimeToBuySellStocks([7, 1, 5, 3, 6, 4], visit)).toEqual(7);\n    expect(visit).toHaveBeenCalledTimes(6);\n\n    visit = jest.fn();\n    expect(peakvalleyBestTimeToBuySellStocks([1, 2, 3, 4, 5], visit)).toEqual(4);\n    expect(visit).toHaveBeenCalledTimes(5);\n\n    visit = jest.fn();\n    expect(peakvalleyBestTimeToBuySellStocks([7, 6, 4, 3, 1], visit)).toEqual(0);\n    expect(visit).toHaveBeenCalledTimes(5);\n\n    visit = jest.fn();\n    expect(peakvalleyBestTimeToBuySellStocks(\n      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],\n      visit,\n    )).toEqual(19);\n    expect(visit).toHaveBeenCalledTimes(20);\n  });\n});\n","filetype":".js","index":217},{"title":"Accumulator Best Time To Buy Sell Stocks","category":"best-time-to-buy-sell-stocks","id":"accumulatorBestTimeToBuySellStocks_best-time-to-buy-sell-stocks","algorithm":"/**\n * Finds the maximum profit from selling and buying the stocks.\n * ACCUMULATOR APPROACH.\n *\n * @param {number[]} prices - Array of stock prices, i.e. [7, 6, 4, 3, 1]\n * @param {function(): void} visit - Visiting callback to calculate the number of iterations.\n * @return {number} - The maximum profit\n */\nconst accumulatorBestTimeToBuySellStocks = (prices, visit = () => {}) => {\n  visit();\n  let profit = 0;\n  for (let day = 1; day < prices.length; day += 1) {\n    visit();\n    // Add the increase of the price from yesterday till today (if there was any) to the profit.\n    profit += Math.max(prices[day] - prices[day - 1], 0);\n  }\n  return profit;\n};\n\nexport default accumulatorBestTimeToBuySellStocks;\n","filetype":".js","index":218},{"title":"Dp Best Time To Buy Sell Stocks","category":"best-time-to-buy-sell-stocks","id":"dpBestTimeToBuySellStocks_best-time-to-buy-sell-stocks","algorithm":"/**\n * Finds the maximum profit from selling and buying the stocks.\n * DYNAMIC PROGRAMMING APPROACH.\n *\n * @param {number[]} prices - Array of stock prices, i.e. [7, 6, 4, 3, 1]\n * @param {function(): void} visit - Visiting callback to calculate the number of iterations.\n * @return {number} - The maximum profit\n */\nconst dpBestTimeToBuySellStocks = (prices, visit = () => {}) => {\n  visit();\n  let lastBuy = -prices[0];\n  let lastSold = 0;\n\n  for (let day = 1; day < prices.length; day += 1) {\n    visit();\n    const curBuy = Math.max(lastBuy, lastSold - prices[day]);\n    const curSold = Math.max(lastSold, lastBuy + prices[day]);\n    lastBuy = curBuy;\n    lastSold = curSold;\n  }\n\n  return lastSold;\n};\n\nexport default dpBestTimeToBuySellStocks;\n","filetype":".js","index":219},{"title":"Dq Best Time To Buy Sell Stocks","category":"best-time-to-buy-sell-stocks","id":"dqBestTimeToBuySellStocks_best-time-to-buy-sell-stocks","algorithm":"/**\n * Finds the maximum profit from selling and buying the stocks.\n * DIVIDE & CONQUER APPROACH.\n *\n * @param {number[]} prices - Array of stock prices, i.e. [7, 6, 4, 3, 1]\n * @param {function(): void} visit - Visiting callback to calculate the number of iterations.\n * @return {number} - The maximum profit\n */\nconst dqBestTimeToBuySellStocks = (prices, visit = () => {}) => {\n  /**\n   * Recursive implementation of the main function. It is hidden from the users.\n   *\n   * @param {boolean} buy - Whether we're allow to sell or to buy now\n   * @param {number} day - Current day of trading (current index of prices array)\n   * @returns {number} - Max profit from buying/selling\n   */\n  const recursiveBuyerSeller = (buy, day) => {\n    // Registering the recursive call visit to calculate the complexity.\n    visit();\n\n    // Quitting the recursion if this is the last day of trading (prices array ended).\n    if (day === prices.length) {\n      return 0;\n    }\n\n    // If we're buying - we're loosing money (-1), if we're selling we're getting money (+1).\n    const operationSign = buy ? -1 : +1;\n    return Math.max(\n      // Option 1: Don't do anything.\n      recursiveBuyerSeller(buy, day + 1),\n      // Option 2: Sell or Buy at the current price.\n      operationSign * prices[day] + recursiveBuyerSeller(!buy, day + 1),\n    );\n  };\n\n  const buy = true;\n  const day = 0;\n\n  return recursiveBuyerSeller(buy, day);\n};\n\nexport default dqBestTimeToBuySellStocks;\n","filetype":".js","index":220},{"title":"Peakvalley Best Time To Buy Sell Stocks","category":"best-time-to-buy-sell-stocks","id":"peakvalleyBestTimeToBuySellStocks_best-time-to-buy-sell-stocks","algorithm":"/**\n * Finds the maximum profit from selling and buying the stocks.\n * PEAK VALLEY APPROACH.\n *\n * @param {number[]} prices - Array of stock prices, i.e. [7, 6, 4, 3, 1]\n * @param {function(): void} visit - Visiting callback to calculate the number of iterations.\n * @return {number} - The maximum profit\n */\nconst peakvalleyBestTimeToBuySellStocks = (prices, visit = () => {}) => {\n  visit();\n  let profit = 0;\n  let low = prices[0];\n  let high = prices[0];\n\n  prices.slice(1).forEach((currentPrice) => {\n    visit();\n    if (currentPrice < high) {\n      // If price went down, we need to sell.\n      profit += high - low;\n      low = currentPrice;\n      high = currentPrice;\n    } else {\n      // If price went up, we don't need to do anything but increase a high record.\n      high = currentPrice;\n    }\n  });\n\n  // In case if price went up during the last day\n  // and we didn't have chance to sell inside the forEach loop.\n  profit += high - low;\n\n  return profit;\n};\n\nexport default peakvalleyBestTimeToBuySellStocks;\n","filetype":".js","index":221},{"title":"Hanoi-tower","category":"uncategorized","id":"hanoi-tower","algorithm":"# Tower of Hanoi\n\nThe Tower of Hanoi (also called the Tower of Brahma or Lucas'\nTower and sometimes pluralized) is a mathematical game or puzzle. \nIt consists of three rods and a number of disks of different sizes,\nwhich can slide onto any rod. The puzzle starts with the disks in \na neat stack in ascending order of size on one rod, the smallest \nat the top, thus making a conical shape.\n\nThe objective of the puzzle is to move the entire stack to another \nrod, obeying the following simple rules:\n\n- Only one disk can be moved at a time.\n- Each move consists of taking the upper disk from one of the \nstacks and placing it on top of another stack or on an empty rod.\n- No disk may be placed on top of a smaller disk.\n\n![Hanoi Tower](https://upload.wikimedia.org/wikipedia/commons/8/8d/Iterative_algorithm_solving_a_6_disks_Tower_of_Hanoi.gif)\n\nAnimation of an iterative algorithm solving 6-disk problem\n\nWith `3` disks, the puzzle can be solved in `7` moves. The minimal \nnumber of moves required to solve a Tower of Hanoi puzzle \nis `2^n − 1`, where `n` is the number of disks.\n\n## References\n\n- [Wikipedia](https://en.wikipedia.org/wiki/Tower_of_Hanoi)\n- [HackerEarth](https://www.hackerearth.com/blog/algorithms/tower-hanoi-recursion-game-algorithm-explained/)\n","filetype":".md","index":222},{"title":"Hanoi Tower","category":"hanoi-tower","id":"hanoiTower_hanoi-tower","algorithm":"import Stack from '../../../data-structures/stack/Stack';\n\n/**\n * @param {number} numberOfDiscs\n * @param {Stack} fromPole\n * @param {Stack} withPole\n * @param {Stack} toPole\n * @param {function(disc: number, fromPole: number[], toPole: number[])} moveCallback\n */\nfunction hanoiTowerRecursive({\n  numberOfDiscs,\n  fromPole,\n  withPole,\n  toPole,\n  moveCallback,\n}) {\n  if (numberOfDiscs === 1) {\n    // Base case with just one disc.\n    moveCallback(fromPole.peek(), fromPole.toArray(), toPole.toArray());\n    const disc = fromPole.pop();\n    toPole.push(disc);\n  } else {\n    // In case if there are more discs then move them recursively.\n\n    // Expose the bottom disc on fromPole stack.\n    hanoiTowerRecursive({\n      numberOfDiscs: numberOfDiscs - 1,\n      fromPole,\n      withPole: toPole,\n      toPole: withPole,\n      moveCallback,\n    });\n\n    // Move the disc that was exposed to its final destination.\n    hanoiTowerRecursive({\n      numberOfDiscs: 1,\n      fromPole,\n      withPole,\n      toPole,\n      moveCallback,\n    });\n\n    // Move temporary tower from auxiliary pole to its final destination.\n    hanoiTowerRecursive({\n      numberOfDiscs: numberOfDiscs - 1,\n      fromPole: withPole,\n      withPole: fromPole,\n      toPole,\n      moveCallback,\n    });\n  }\n}\n\n/**\n * @param {number} numberOfDiscs\n * @param {function(disc: number, fromPole: number[], toPole: number[])} moveCallback\n * @param {Stack} [fromPole]\n * @param {Stack} [withPole]\n * @param {Stack} [toPole]\n */\nexport default function hanoiTower({\n  numberOfDiscs,\n  moveCallback,\n  fromPole = new Stack(),\n  withPole = new Stack(),\n  toPole = new Stack(),\n}) {\n  // Each of three poles of Tower of Hanoi puzzle is represented as a stack\n  // that might contain elements (discs). Each disc is represented as a number.\n  // Larger discs have bigger number equivalent.\n\n  // Let's create the discs and put them to the fromPole.\n  for (let discSize = numberOfDiscs; discSize > 0; discSize -= 1) {\n    fromPole.push(discSize);\n  }\n\n  hanoiTowerRecursive({\n    numberOfDiscs,\n    fromPole,\n    withPole,\n    toPole,\n    moveCallback,\n  });\n}\n","filetype":".js","index":223},{"title":"Jump-game","category":"uncategorized","id":"jump-game","algorithm":"# Jump Game\n\n## The Problem\n\nGiven an array of non-negative integers, you are initially positioned at \nthe first index of the array. Each element in the array represents your maximum \njump length at that position.\n\nDetermine if you are able to reach the last index.\n\n**Example #1**\n\n```\nInput: [2,3,1,1,4]\nOutput: true\nExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.\n```\n\n**Example #2**\n\n```\nInput: [3,2,1,0,4]\nOutput: false\nExplanation: You will always arrive at index 3 no matter what. Its maximum\n             jump length is 0, which makes it impossible to reach the last index.\n```\n\n## Naming\n\nWe call a position in the array a **\"good index\"** if starting at that position,\nwe can reach the last index. Otherwise, that index is called a **\"bad index\"**.\nThe problem then reduces to whether or not index 0 is a \"good index\".\n\n## Solutions\n\n### Approach 1: Backtracking\n\nThis is the inefficient solution where we try every single jump pattern that \ntakes us from the first position to the last. We start from the first position \nand jump to every index that is reachable. We repeat the process until last \nindex is reached. When stuck, backtrack.\n\n> See [backtrackingJumpGame.js](backtrackingJumpGame.js) file\n\n**Time complexity:**: `O(2^n)`.\nThere are 2<sup>n</sup> (upper bound) ways of jumping from \nthe first position to the last, where `n` is the length of \narray `nums`.\n\n**Auxiliary Space Complexity**: `O(n)`.\nRecursion requires additional memory for the stack frames.\n\n### Approach 2: Dynamic Programming Top-down\n\nTop-down Dynamic Programming can be thought of as optimized \nbacktracking. It relies on the observation that once we determine \nthat a certain index is good / bad, this result will never change.\nThis means that we can store the result and not need to recompute\nit every time.\n\nTherefore, for each position in the array, we remember whether the \nindex is good or bad. Let's call this array memo and let its values\nbe either one of: GOOD, BAD, UNKNOWN. This technique is \ncalled memoization.\n\n> See [dpTopDownJumpGame.js](dpTopDownJumpGame.js) file\n\n**Time complexity:**: `O(n^2)`.\nFor every element in the array, say `i`, we are looking at the \nnext `nums[i]` elements to its right aiming to find a GOOD\nindex. `nums[i]` can be at most `n`, where `n` is the length \nof array `nums`.\n\n**Auxiliary Space Complexity**: `O(2 * n) = O(n)`.\nFirst `n` originates from recursion. Second `n` comes from the \nusage of the memo table.\n\n### Approach 3: Dynamic Programming Bottom-up\n\nTop-down to bottom-up conversion is done by eliminating recursion. \nIn practice, this achieves better performance as we no longer have the \nmethod stack overhead and might even benefit from some caching. More \nimportantly, this step opens up possibilities for future optimization.\nThe recursion is usually eliminated by trying to reverse the order of \nthe steps from the top-down approach.\n\nThe observation to make here is that we only ever jump to the right.\nThis means that if we start from the right of the array, every time \nwe will query a position to our right, that position has already be\ndetermined as being GOOD or BAD. This means we don't need to recurse\nanymore, as we will always hit the memo table.\n\n> See [dpBottomUpJumpGame.js](dpBottomUpJumpGame.js) file\n\n**Time complexity:**: `O(n^2)`.\nFor every element in the array, say `i`, we are looking at the \nnext `nums[i]` elements to its right aiming to find a GOOD\nindex. `nums[i]` can be at most `n`, where `n` is the length \nof array `nums`.\n\n**Auxiliary Space Complexity**: `O(n)`.\nThis comes from the usage of the memo table.\n \n### Approach 4: Greedy\n\nOnce we have our code in the bottom-up state, we can make one final,\nimportant observation. From a given position, when we try to see if\nwe can jump to a GOOD position, we only ever use one - the first one.\nIn other words, the left-most one. If we keep track of this left-most\nGOOD position as a separate variable, we can avoid searching for it in\nthe array. Not only that, but we can stop using the array altogether.\n\n> See [greedyJumpGame.js](greedyJumpGame.js) file\n\n**Time complexity:**: `O(n)`.\nWe are doing a single pass through the `nums` array, hence `n` steps,\nwhere `n` is the length of array `nums`.\n\n**Auxiliary Space Complexity**: `O(1)`.\nWe are not using any extra memory.\n\n## References\n\n- [Jump Game Fully Explained on LeetCode](https://leetcode.com/articles/jump-game/)\n- [Dynamic Programming vs Divide and Conquer](https://itnext.io/dynamic-programming-vs-divide-and-conquer-2fea680becbe)\n- [Dynamic Programming](https://en.wikipedia.org/wiki/Dynamic_programming)\n- [Memoization on Wikipedia](https://en.wikipedia.org/wiki/Memoization)\n- [Top-Down and Bottom-Up Design on Wikipedia](https://en.wikipedia.org/wiki/Top-down_and_bottom-up_design)\n","filetype":".md","index":224},{"title":"Backtracking Jump Game","category":"jump-game","id":"backtrackingJumpGame_jump-game","algorithm":"/**\n * BACKTRACKING approach of solving Jump Game.\n *\n * This is the inefficient solution where we try every single jump\n * pattern that takes us from the first position to the last.\n * We start from the first position and jump to every index that\n * is reachable. We repeat the process until last index is reached.\n * When stuck, backtrack.\n *\n * @param {number[]} numbers - array of possible jump length.\n * @param {number} startIndex - index from where we start jumping.\n * @param {number[]} currentJumps - current jumps path.\n * @return {boolean}\n */\nexport default function backtrackingJumpGame(numbers, startIndex = 0, currentJumps = []) {\n  if (startIndex === numbers.length - 1) {\n    // We've jumped directly to last cell. This situation is a solution.\n    return true;\n  }\n\n  // Check what the longest jump we could make from current position.\n  // We don't need to jump beyond the array.\n  const maxJumpLength = Math.min(\n    numbers[startIndex], // Jump is within array.\n    numbers.length - 1 - startIndex, // Jump goes beyond array.\n  );\n\n  // Let's start jumping from startIndex and see whether any\n  // jump is successful and has reached the end of the array.\n  for (let jumpLength = maxJumpLength; jumpLength > 0; jumpLength -= 1) {\n    // Try next jump.\n    const nextIndex = startIndex + jumpLength;\n    currentJumps.push(nextIndex);\n\n    const isJumpSuccessful = backtrackingJumpGame(numbers, nextIndex, currentJumps);\n\n    // Check if current jump was successful.\n    if (isJumpSuccessful) {\n      return true;\n    }\n\n    // BACKTRACKING.\n    // If previous jump wasn't successful then retreat and try the next one.\n    currentJumps.pop();\n  }\n\n  return false;\n}\n","filetype":".js","index":225},{"title":"Dp Bottom Up Jump Game","category":"jump-game","id":"dpBottomUpJumpGame_jump-game","algorithm":"/**\n * DYNAMIC PROGRAMMING BOTTOM-UP approach of solving Jump Game.\n *\n * This comes out as an optimisation of DYNAMIC PROGRAMMING TOP-DOWN approach.\n *\n * The observation to make here is that we only ever jump to the right.\n * This means that if we start from the right of the array, every time we\n * will query a position to our right, that position has already be\n * determined as being GOOD or BAD. This means we don't need to recurse\n * anymore, as we will always hit the memo table.\n *\n * We call a position in the array a \"good\" one if starting at that\n * position, we can reach the last index. Otherwise, that index\n * is called a \"bad\" one.\n *\n * @param {number[]} numbers - array of possible jump length.\n * @return {boolean}\n */\nexport default function dpBottomUpJumpGame(numbers) {\n  // Init cells goodness table.\n  const cellsGoodness = Array(numbers.length).fill(undefined);\n  // Mark the last cell as \"good\" one since it is where we ultimately want to get.\n  cellsGoodness[cellsGoodness.length - 1] = true;\n\n  // Go throw all cells starting from the one before the last\n  // one (since the last one is \"good\" already) and fill cellsGoodness table.\n  for (let cellIndex = numbers.length - 2; cellIndex >= 0; cellIndex -= 1) {\n    const maxJumpLength = Math.min(\n      numbers[cellIndex],\n      numbers.length - 1 - cellIndex,\n    );\n\n    for (let jumpLength = maxJumpLength; jumpLength > 0; jumpLength -= 1) {\n      const nextIndex = cellIndex + jumpLength;\n      if (cellsGoodness[nextIndex] === true) {\n        cellsGoodness[cellIndex] = true;\n        // Once we detected that current cell is good one we don't need to\n        // do further cells checking.\n        break;\n      }\n    }\n  }\n\n  // Now, if the zero's cell is good one then we can jump from it to the end of the array.\n  return cellsGoodness[0] === true;\n}\n","filetype":".js","index":226},{"title":"Dp Top Down Jump Game","category":"jump-game","id":"dpTopDownJumpGame_jump-game","algorithm":"/**\n * DYNAMIC PROGRAMMING TOP-DOWN approach of solving Jump Game.\n *\n * This comes out as an optimisation of BACKTRACKING approach.\n *\n * It relies on the observation that once we determine that a certain\n * index is good / bad, this result will never change. This means that\n * we can store the result and not need to recompute it every time.\n *\n * We call a position in the array a \"good\" one if starting at that\n * position, we can reach the last index. Otherwise, that index\n * is called a \"bad\" one.\n *\n * @param {number[]} numbers - array of possible jump length.\n * @param {number} startIndex - index from where we start jumping.\n * @param {number[]} currentJumps - current jumps path.\n * @param {boolean[]} cellsGoodness - holds information about whether cell is \"good\" or \"bad\"\n * @return {boolean}\n */\nexport default function dpTopDownJumpGame(\n  numbers,\n  startIndex = 0,\n  currentJumps = [],\n  cellsGoodness = [],\n) {\n  if (startIndex === numbers.length - 1) {\n    // We've jumped directly to last cell. This situation is a solution.\n    return true;\n  }\n\n  // Init cell goodness table if it is empty.\n  // This is DYNAMIC PROGRAMMING feature.\n  const currentCellsGoodness = [...cellsGoodness];\n  if (!currentCellsGoodness.length) {\n    numbers.forEach(() => currentCellsGoodness.push(undefined));\n    // Mark the last cell as \"good\" one since it is where we ultimately want to get.\n    currentCellsGoodness[cellsGoodness.length - 1] = true;\n  }\n\n  // Check what the longest jump we could make from current position.\n  // We don't need to jump beyond the array.\n  const maxJumpLength = Math.min(\n    numbers[startIndex], // Jump is within array.\n    numbers.length - 1 - startIndex, // Jump goes beyond array.\n  );\n\n  // Let's start jumping from startIndex and see whether any\n  // jump is successful and has reached the end of the array.\n  for (let jumpLength = maxJumpLength; jumpLength > 0; jumpLength -= 1) {\n    // Try next jump.\n    const nextIndex = startIndex + jumpLength;\n\n    // Jump only into \"good\" or \"unknown\" cells.\n    // This is top-down dynamic programming optimisation of backtracking algorithm.\n    if (currentCellsGoodness[nextIndex] !== false) {\n      currentJumps.push(nextIndex);\n\n      const isJumpSuccessful = dpTopDownJumpGame(\n        numbers,\n        nextIndex,\n        currentJumps,\n        currentCellsGoodness,\n      );\n\n      // Check if current jump was successful.\n      if (isJumpSuccessful) {\n        return true;\n      }\n\n      // BACKTRACKING.\n      // If previous jump wasn't successful then retreat and try the next one.\n      currentJumps.pop();\n\n      // Mark current cell as \"bad\" to avoid its deep visiting later.\n      currentCellsGoodness[nextIndex] = false;\n    }\n  }\n\n  return false;\n}\n","filetype":".js","index":227},{"title":"Greedy Jump Game","category":"jump-game","id":"greedyJumpGame_jump-game","algorithm":"/**\n * GREEDY approach of solving Jump Game.\n *\n * This comes out as an optimisation of DYNAMIC PROGRAMMING BOTTOM_UP approach.\n *\n * Once we have our code in the bottom-up state, we can make one final,\n * important observation. From a given position, when we try to see if\n * we can jump to a GOOD position, we only ever use one - the first one.\n * In other words, the left-most one. If we keep track of this left-most\n * GOOD position as a separate variable, we can avoid searching for it\n * in the array. Not only that, but we can stop using the array altogether.\n *\n * We call a position in the array a \"good\" one if starting at that\n * position, we can reach the last index. Otherwise, that index\n * is called a \"bad\" one.\n *\n * @param {number[]} numbers - array of possible jump length.\n * @return {boolean}\n */\nexport default function greedyJumpGame(numbers) {\n  // The \"good\" cell is a cell from which we may jump to the last cell of the numbers array.\n\n  // The last cell in numbers array is for sure the \"good\" one since it is our goal to reach.\n  let leftGoodPosition = numbers.length - 1;\n\n  // Go through all numbers from right to left.\n  for (let numberIndex = numbers.length - 2; numberIndex >= 0; numberIndex -= 1) {\n    // If we can reach the \"good\" cell from the current one then for sure the current\n    // one is also \"good\". Since after all we'll be able to reach the end of the array\n    // from it.\n    const maxCurrentJumpLength = numberIndex + numbers[numberIndex];\n    if (maxCurrentJumpLength >= leftGoodPosition) {\n      leftGoodPosition = numberIndex;\n    }\n  }\n\n  // If the most left \"good\" position is the zero's one then we may say that it IS\n  // possible jump to the end of the array from the first cell;\n  return leftGoodPosition === 0;\n}\n","filetype":".js","index":228},{"title":"Knight-tour","category":"uncategorized","id":"knight-tour","algorithm":"# Knight's Tour\n\nA **knight's tour** is a sequence of moves of a knight on a chessboard \nsuch that the knight visits every square only once. If the knight \nends on a square that is one knight's move from the beginning \nsquare (so that it could tour the board again immediately, \nfollowing the same path), the tour is **closed**, otherwise it \nis **open**.\n\nThe **knight's tour problem** is the mathematical problem of \nfinding a knight's tour. Creating a program to find a knight's \ntour is a common problem given to computer science students.\nVariations of the knight's tour problem involve chessboards of \ndifferent sizes than the usual `8×8`, as well as irregular \n(non-rectangular) boards.\n\nThe knight's tour problem is an instance of the more \ngeneral **Hamiltonian path problem** in graph theory. The problem of finding \na closed knight's tour is similarly an instance of the Hamiltonian \ncycle problem.\n\n![Knight's Tour](https://upload.wikimedia.org/wikipedia/commons/d/da/Knight%27s_tour_anim_2.gif)\n\nAn open knight's tour of a chessboard.\n\n![Knight's Tour](https://upload.wikimedia.org/wikipedia/commons/c/ca/Knights-Tour-Animation.gif)\n\nAn animation of an open knight's tour on a 5 by 5 board.\n\n## References\n\n- [Wikipedia](https://en.wikipedia.org/wiki/Knight%27s_tour)\n- [GeeksForGeeks](https://www.geeksforgeeks.org/backtracking-set-1-the-knights-tour-problem/)\n","filetype":".md","index":229},{"title":"Knight Tour","category":"knight-tour","id":"knightTour_knight-tour","algorithm":"/**\n * @param {number[][]} chessboard\n * @param {number[]} position\n * @return {number[][]}\n */\nfunction getPossibleMoves(chessboard, position) {\n  // Generate all knight moves (even those that go beyond the board).\n  const possibleMoves = [\n    [position[0] - 1, position[1] - 2],\n    [position[0] - 2, position[1] - 1],\n    [position[0] + 1, position[1] - 2],\n    [position[0] + 2, position[1] - 1],\n    [position[0] - 2, position[1] + 1],\n    [position[0] - 1, position[1] + 2],\n    [position[0] + 1, position[1] + 2],\n    [position[0] + 2, position[1] + 1],\n  ];\n\n  // Filter out all moves that go beyond the board.\n  return possibleMoves.filter((move) => {\n    const boardSize = chessboard.length;\n    return move[0] >= 0 && move[1] >= 0 && move[0] < boardSize && move[1] < boardSize;\n  });\n}\n\n/**\n * @param {number[][]} chessboard\n * @param {number[]} move\n * @return {boolean}\n */\nfunction isMoveAllowed(chessboard, move) {\n  return chessboard[move[0]][move[1]] !== 1;\n}\n\n/**\n * @param {number[][]} chessboard\n * @param {number[][]} moves\n * @return {boolean}\n */\nfunction isBoardCompletelyVisited(chessboard, moves) {\n  const totalPossibleMovesCount = chessboard.length ** 2;\n  const existingMovesCount = moves.length;\n\n  return totalPossibleMovesCount === existingMovesCount;\n}\n\n/**\n * @param {number[][]} chessboard\n * @param {number[][]} moves\n * @return {boolean}\n */\nfunction knightTourRecursive(chessboard, moves) {\n  const currentChessboard = chessboard;\n\n  // If board has been completely visited then we've found a solution.\n  if (isBoardCompletelyVisited(currentChessboard, moves)) {\n    return true;\n  }\n\n  // Get next possible knight moves.\n  const lastMove = moves[moves.length - 1];\n  const possibleMoves = getPossibleMoves(currentChessboard, lastMove);\n\n  // Try to do next possible moves.\n  for (let moveIndex = 0; moveIndex < possibleMoves.length; moveIndex += 1) {\n    const currentMove = possibleMoves[moveIndex];\n\n    // Check if current move is allowed. We aren't allowed to go to\n    // the same cells twice.\n    if (isMoveAllowed(currentChessboard, currentMove)) {\n      // Actually do the move.\n      moves.push(currentMove);\n      currentChessboard[currentMove[0]][currentMove[1]] = 1;\n\n      // If further moves starting from current are successful then\n      // return true meaning the solution is found.\n      if (knightTourRecursive(currentChessboard, moves)) {\n        return true;\n      }\n\n      // BACKTRACKING.\n      // If current move was unsuccessful then step back and try to do another move.\n      moves.pop();\n      currentChessboard[currentMove[0]][currentMove[1]] = 0;\n    }\n  }\n\n  // Return false if we haven't found solution.\n  return false;\n}\n\n/**\n * @param {number} chessboardSize\n * @return {number[][]}\n */\nexport default function knightTour(chessboardSize) {\n  // Init chessboard.\n  const chessboard = Array(chessboardSize).fill(null).map(() => Array(chessboardSize).fill(0));\n\n  // Init moves array.\n  const moves = [];\n\n  // Do first move and place the knight to the 0x0 cell.\n  const firstMove = [0, 0];\n  moves.push(firstMove);\n  chessboard[firstMove[0]][firstMove[0]] = 1;\n\n  // Recursively try to do the next move.\n  const solutionWasFound = knightTourRecursive(chessboard, moves);\n\n  return solutionWasFound ? moves : [];\n}\n","filetype":".js","index":230},{"title":"N-queens","category":"uncategorized","id":"n-queens","algorithm":"# N-Queens Problem\n\nThe **eight queens puzzle** is the problem of placing eight chess queens \non an `8×8` chessboard so that no two queens threaten each other. \nThus, a solution requires that no two queens share the same row, \ncolumn, or diagonal. The eight queens puzzle is an example of the \nmore general *n queens problem* of placing n non-attacking queens \non an `n×n` chessboard, for which solutions exist for all natural \nnumbers `n` with the exception of `n=2` and `n=3`.\n\nFor example, following is a solution for 4 Queen problem.\n\n![N Queens](https://cdncontribute.geeksforgeeks.org/wp-content/uploads/N_Queen_Problem.jpg)\n\nThe expected output is a binary matrix which has 1s for the blocks \nwhere queens are placed. For example following is the output matrix \nfor above 4 queen solution.\n\n```\n{ 0,  1,  0,  0}\n{ 0,  0,  0,  1}\n{ 1,  0,  0,  0}\n{ 0,  0,  1,  0}\n```\n\n## Naive Algorithm\n\nGenerate all possible configurations of queens on board and print a \nconfiguration that satisfies the given constraints.\n\n```\nwhile there are untried configurations\n{\n   generate the next configuration\n   if queens don't attack in this configuration then\n   {\n      print this configuration;\n   }\n}\n```\n\n## Backtracking Algorithm\n\nThe idea is to place queens one by one in different columns, \nstarting from the leftmost column. When we place a queen in a \ncolumn, we check for clashes with already placed queens. In \nthe current column, if we find a row for which there is no \nclash, we mark this row and column as part of the solution. \nIf we do not find such a row due to clashes then we backtrack \nand return false.\n\n```\n1) Start in the leftmost column\n2) If all queens are placed\n    return true\n3) Try all rows in the current column.  Do following for every tried row.\n    a) If the queen can be placed safely in this row then mark this [row, \n        column] as part of the solution and recursively check if placing  \n        queen here leads to a solution.\n    b) If placing queen in [row, column] leads to a solution then return \n        true.\n    c) If placing queen doesn't lead to a solution then umark this [row, \n        column] (Backtrack) and go to step (a) to try other rows.\n3) If all rows have been tried and nothing worked, return false to trigger \n    backtracking.\n```\n\n## Bitwise Solution\n\nBitwise algorithm basically approaches the problem like this:\n\n- Queens can attack diagonally, vertically, or horizontally. As a result, there \ncan only be one queen in each row, one in each column, and at most one on each \ndiagonal.\n- Since we know there can only one queen per row, we will start at the first row,\nplace a queen, then move to the second row, place a second queen, and so on until\neither a) we reach a valid solution or b) we reach a dead end (ie. we can't place\na queen such that it is \"safe\" from the other queens).\n- Since we are only placing one queen per row, we don't need to worry about\nhorizontal attacks, since no queen will ever be on the same row as another queen.\n- That means we only need to check three things before placing a queen on a\ncertain square: 1) The square's column doesn't have any other queens on it, 2)\nthe square's left diagonal doesn't have any other queens on it, and 3) the\nsquare's right diagonal doesn't have any other queens on it.\n- If we ever reach a point where there is nowhere safe to place a queen, we can\ngive up on our current attempt and immediately test out the next possibility.\n\nFirst let's talk about the recursive function. You'll notice that it accepts \n3 parameters: `leftDiagonal`, `column`, and `rightDiagonal`. Each of these is \ntechnically an integer, but the algorithm takes advantage of the fact that an \ninteger is represented by a sequence of bits. So, think of each of these \nparameters as a sequence of `N` bits.\n\nEach bit in each of the parameters represents whether the corresponding location\non the current row is \"available\".\n\nFor example:\n- For `N=4`, column having a value of `0010` would mean that the 3rd column is \nalready occupied by a queen.\n- For `N=8`, ld having a value of `00011000` at row 5 would mean that the \ntop-left-to-bottom-right diagonals that pass through columns 4 and 5 of that \nrow are already occupied by queens.\n\nBelow is a visual aid for `leftDiagonal`, `column`, and `rightDiagonal`.\n\n![](http://gregtrowbridge.com/content/images/2014/Jul/Screenshot-from-2014-06-17-19-46-20.png)\n\n## References\n\n- [Wikipedia](https://en.wikipedia.org/wiki/Eight_queens_puzzle)\n- [GeeksForGeeks](https://www.geeksforgeeks.org/backtracking-set-3-n-queen-problem/)\n- [On YouTube by Abdul Bari](https://www.youtube.com/watch?v=xFv_Hl4B83A&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\n- [On YouTube by Tushar Roy](https://www.youtube.com/watch?v=xouin83ebxE&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\n- Bitwise Solution\n  - [Wikipedia](https://en.wikipedia.org/wiki/Eight_queens_puzzle)\n  - [Solution by Greg Trowbridge](http://gregtrowbridge.com/a-bitwise-solution-to-the-n-queens-problem-in-javascript/)\n  \n","filetype":".md","index":231},{"title":"Queen Position","category":"n-queens","id":"QueenPosition_n-queens","algorithm":"/**\n * Class that represents queen position on the chessboard.\n */\nexport default class QueenPosition {\n  /**\n   * @param {number} rowIndex\n   * @param {number} columnIndex\n   */\n  constructor(rowIndex, columnIndex) {\n    this.rowIndex = rowIndex;\n    this.columnIndex = columnIndex;\n  }\n\n  /**\n   * @return {number}\n   */\n  get leftDiagonal() {\n    // Each position on the same left (\\) diagonal has the same difference of\n    // rowIndex and columnIndex. This fact may be used to quickly check if two\n    // positions (queens) are on the same left diagonal.\n    // @see https://youtu.be/xouin83ebxE?t=1m59s\n    return this.rowIndex - this.columnIndex;\n  }\n\n  /**\n   * @return {number}\n   */\n  get rightDiagonal() {\n    // Each position on the same right diagonal (/) has the same\n    // sum of rowIndex and columnIndex. This fact may be used to quickly\n    // check if two positions (queens) are on the same right diagonal.\n    // @see https://youtu.be/xouin83ebxE?t=1m59s\n    return this.rowIndex + this.columnIndex;\n  }\n\n  toString() {\n    return `${this.rowIndex},${this.columnIndex}`;\n  }\n}\n","filetype":".js","index":232},{"title":"N Queens","category":"n-queens","id":"nQueens_n-queens","algorithm":"import QueenPosition from './QueenPosition';\n\n/**\n * @param {QueenPosition[]} queensPositions\n * @param {number} rowIndex\n * @param {number} columnIndex\n * @return {boolean}\n */\nfunction isSafe(queensPositions, rowIndex, columnIndex) {\n  // New position to which the Queen is going to be placed.\n  const newQueenPosition = new QueenPosition(rowIndex, columnIndex);\n\n  // Check if new queen position conflicts with any other queens.\n  for (let queenIndex = 0; queenIndex < queensPositions.length; queenIndex += 1) {\n    const currentQueenPosition = queensPositions[queenIndex];\n\n    if (\n      // Check if queen has been already placed.\n      currentQueenPosition\n      && (\n        // Check if there are any queen on the same column.\n        newQueenPosition.columnIndex === currentQueenPosition.columnIndex\n        // Check if there are any queen on the same row.\n        || newQueenPosition.rowIndex === currentQueenPosition.rowIndex\n        // Check if there are any queen on the same left diagonal.\n        || newQueenPosition.leftDiagonal === currentQueenPosition.leftDiagonal\n        // Check if there are any queen on the same right diagonal.\n        || newQueenPosition.rightDiagonal === currentQueenPosition.rightDiagonal\n      )\n    ) {\n      // Can't place queen into current position since there are other queens that\n      // are threatening it.\n      return false;\n    }\n  }\n\n  // Looks like we're safe.\n  return true;\n}\n\n/**\n * @param {QueenPosition[][]} solutions\n * @param {QueenPosition[]} previousQueensPositions\n * @param {number} queensCount\n * @param {number} rowIndex\n * @return {boolean}\n */\nfunction nQueensRecursive(solutions, previousQueensPositions, queensCount, rowIndex) {\n  // Clone positions array.\n  const queensPositions = [...previousQueensPositions].map((queenPosition) => {\n    return !queenPosition ? queenPosition : new QueenPosition(\n      queenPosition.rowIndex,\n      queenPosition.columnIndex,\n    );\n  });\n\n  if (rowIndex === queensCount) {\n    // We've successfully reached the end of the board.\n    // Store solution to the list of solutions.\n    solutions.push(queensPositions);\n\n    // Solution found.\n    return true;\n  }\n\n  // Let's try to put queen at row rowIndex into its safe column position.\n  for (let columnIndex = 0; columnIndex < queensCount; columnIndex += 1) {\n    if (isSafe(queensPositions, rowIndex, columnIndex)) {\n      // Place current queen to its current position.\n      queensPositions[rowIndex] = new QueenPosition(rowIndex, columnIndex);\n\n      // Try to place all other queens as well.\n      nQueensRecursive(solutions, queensPositions, queensCount, rowIndex + 1);\n\n      // BACKTRACKING.\n      // Remove the queen from the row to avoid isSafe() returning false.\n      queensPositions[rowIndex] = null;\n    }\n  }\n\n  return false;\n}\n\n/**\n * @param {number} queensCount\n * @return {QueenPosition[][]}\n */\nexport default function nQueens(queensCount) {\n  // Init NxN chessboard with zeros.\n  // const chessboard = Array(queensCount).fill(null).map(() => Array(queensCount).fill(0));\n\n  // This array will hold positions or coordinates of each of\n  // N queens in form of [rowIndex, columnIndex].\n  const queensPositions = Array(queensCount).fill(null);\n\n  /** @var {QueenPosition[][]} solutions */\n  const solutions = [];\n\n  // Solve problem recursively.\n  nQueensRecursive(solutions, queensPositions, queensCount, 0);\n\n  return solutions;\n}\n","filetype":".js","index":233},{"title":"N Queens Bitwise","category":"n-queens","id":"nQueensBitwise_n-queens","algorithm":"/**\n * Checks all possible board configurations.\n *\n * @param {number} boardSize - Size of the squared chess board.\n * @param {number} leftDiagonal - Sequence of N bits that show whether the corresponding location\n * on the current row is \"available\" (no other queens are threatening from left diagonal).\n * @param {number} column - Sequence of N bits that show whether the corresponding location\n * on the current row is \"available\" (no other queens are threatening from columns).\n * @param {number} rightDiagonal - Sequence of N bits that show whether the corresponding location\n * on the current row is \"available\" (no other queens are threatening from right diagonal).\n * @param {number} solutionsCount - Keeps track of the number of valid solutions.\n * @return {number} - Number of possible solutions.\n */\nfunction nQueensBitwiseRecursive(\n  boardSize,\n  leftDiagonal = 0,\n  column = 0,\n  rightDiagonal = 0,\n  solutionsCount = 0,\n) {\n  // Keeps track of the number of valid solutions.\n  let currentSolutionsCount = solutionsCount;\n\n  // Helps to identify valid solutions.\n  // isDone simply has a bit sequence with 1 for every entry up to the Nth. For example,\n  // when N=5, done will equal 11111. The \"isDone\" variable simply allows us to not worry about any\n  // bits beyond the Nth.\n  const isDone = (2 ** boardSize) - 1;\n\n  // All columns are occupied (i.e. 0b1111 for boardSize = 4), so the solution must be complete.\n  // Since the algorithm never places a queen illegally (ie. when it can attack or be attacked),\n  // we know that if all the columns have been filled, we must have a valid solution.\n  if (column === isDone) {\n    return currentSolutionsCount + 1;\n  }\n\n  // Gets a bit sequence with \"1\"s wherever there is an open \"slot\".\n  // All that's happening here is we're taking col, ld, and rd, and if any of the columns are\n  // \"under attack\", we mark that column as 0 in poss, basically meaning \"we can't put a queen in\n  // this column\". Thus all bits position in poss that are '1's are available for placing\n  // queen there.\n  let availablePositions = ~(leftDiagonal | rightDiagonal | column);\n\n  // Loops as long as there is a valid place to put another queen.\n  // For N=4 the isDone=0b1111. Then if availablePositions=0b0000 (which would mean that all places\n  // are under threatening) we must stop trying to place a queen.\n  while (availablePositions & isDone) {\n    // firstAvailablePosition just stores the first non-zero bit (ie. the first available location).\n    // So if firstAvailablePosition was 0010, it would mean the 3rd column of the current row.\n    // And that would be the position will be placing our next queen.\n    //\n    // For example:\n    // availablePositions = 0b01100\n    // firstAvailablePosition = 100\n    const firstAvailablePosition = availablePositions & -availablePositions;\n\n    // This line just marks that position in the current row as being \"taken\" by flipping that\n    // column in availablePositions to zero. This way, when the while loop continues, we'll know\n    // not to try that location again.\n    //\n    // For example:\n    // availablePositions = 0b0100\n    // firstAvailablePosition = 0b10\n    // 0b0110 - 0b10 = 0b0100\n    availablePositions -= firstAvailablePosition;\n\n    /*\n     * The operators >> 1 and 1 << simply move all the bits in a bit sequence one digit to the\n     * right or left, respectively. So calling (rd|bit)<<1 simply says: combine rd and bit with\n     * an OR operation, then move everything in the result to the left by one digit.\n     *\n     * More specifically, if rd is 0001 (meaning that the top-right-to-bottom-left diagonal through\n     * column 4 of the current row is occupied), and bit is 0100 (meaning that we are planning to\n     * place a queen in column 2 of the current row), (rd|bit) results in 0101 (meaning that after\n     * we place a queen in column 2 of the current row, the second and the fourth\n     * top-right-to-bottom-left diagonals will be occupied).\n     *\n     * Now, if add in the << operator, we get (rd|bit)<<1, which takes the 0101 we worked out in\n     * our previous bullet point, and moves everything to the left by one. The result, therefore,\n     * is 1010.\n     */\n    currentSolutionsCount += nQueensBitwiseRecursive(\n      boardSize,\n      (leftDiagonal | firstAvailablePosition) >> 1,\n      column | firstAvailablePosition,\n      (rightDiagonal | firstAvailablePosition) << 1,\n      solutionsCount,\n    );\n  }\n\n  return currentSolutionsCount;\n}\n\n/**\n * @param {number} boardSize - Size of the squared chess board.\n * @return {number} - Number of possible solutions.\n * @see http://gregtrowbridge.com/a-bitwise-solution-to-the-n-queens-problem-in-javascript/\n */\nexport default function nQueensBitwise(boardSize) {\n  return nQueensBitwiseRecursive(boardSize);\n}\n","filetype":".js","index":234},{"title":"Rain-terraces","category":"uncategorized","id":"rain-terraces","algorithm":"# Rain Terraces (Trapping Rain Water) Problem\n\nGiven an array of non-negative integers representing terraces in an elevation map \nwhere the width of each bar is `1`, compute how much water it is able to trap \nafter raining.\n\n![Rain Terraces](https://www.geeksforgeeks.org/wp-content/uploads/watertrap.png)\n\n## Examples\n\n**Example #1**\n\n```\nInput: arr[] = [2, 0, 2]\nOutput: 2\nStructure is like below:\n\n| |\n|_|\n\nWe can trap 2 units of water in the middle gap.\n```\n\n**Example #2**\n\n```\nInput: arr[] = [3, 0, 0, 2, 0, 4]\nOutput: 10\nStructure is like below:\n\n     |\n|    |\n|  | |\n|__|_| \n\nWe can trap \"3*2 units\" of water between 3 an 2,\n\"1 unit\" on top of bar 2 and \"3 units\" between 2 \nand 4. See below diagram also.\n```\n\n**Example #3**\n\n```\nInput: arr[] = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]\nOutput: 6\nStructure is like below:\n\n       | \n   |   || |\n_|_||_||||||\n\nTrap \"1 unit\" between first 1 and 2, \"4 units\" between\nfirst 2 and 3 and \"1 unit\" between second last 1 and last 2.\n```\n\n## The Algorithm\n\nAn element of array can store water if there are higher bars on left and right. \nWe can find amount of water to be stored in every element by finding the heights \nof bars on left and right sides. The idea is to compute amount of water that can\nbe stored in every element of array. For example, consider the array\n`[3, 0, 0, 2, 0, 4]`, We can trap \"3*2 units\" of water between 3 an 2, \"1 unit\" \non top of bar 2 and \"3 units\" between 2 and 4. See below diagram also.\n\n### Approach 1: Brute force\n\n**Intuition**\n\nFor each element in the array, we find the maximum level of water it can trap \nafter the rain, which is equal to the minimum of maximum height of bars on both \nthe sides minus its own height.\n\n**Steps**\n\n- Initialize `answer = 0`\n- Iterate the array from left to right:\n  - Initialize `max_left = 0`  and `max_right = 0`\n  - Iterate from the current element to the beginning of array updating: `max_left = max(max_left, height[j])`\n  - Iterate from the current element to the end of array updating: `max_right = max(max_right, height[j])`\n  - Add `min(max_left, max_right) − height[i]` to `answer`\n\n**Complexity Analysis**\n\nTime complexity: `O(n^2)`. For each element of array, we iterate the left and right parts.\n\nAuxiliary space complexity: `O(1)` extra space.\n\n### Approach 2: Dynamic Programming\n\n**Intuition**\n\nIn brute force, we iterate over the left and right parts again and again just to \nfind the highest bar size up to that index. But, this could be stored. Voila, \ndynamic programming.\n\nSo we may pre-compute highest bar on left and right of every bar in `O(n)` time.\nThen use these pre-computed values to find the amount of water in every array element.\n\nThe concept is illustrated as shown:\n\n![DP Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/Figures/42/trapping_rain_water.png)\n\n**Steps**\n\n- Find maximum height of bar from the left end up to an index `i` in the array `left_max`.\n- Find maximum height of bar from the right end up to an index `i` in the array `right_max`.\n- Iterate over the `height` array and update `answer`:\n  - Add `min(max_left[i], max_right[i]) − height[i]` to `answer`.\n\n**Complexity Analysis**\n\nTime complexity: `O(n)`. We store the maximum heights upto a point using 2 \niterations of `O(n)` each. We finally update `answer` using the stored \nvalues in `O(n)`.\n\nAuxiliary space complexity: `O(n)` extra space. Additional space \nfor `left_max` and `right_max` arrays than in Approach 1.\n\n## References\n\n- [GeeksForGeeks](https://www.geeksforgeeks.org/trapping-rain-water/)\n- [LeetCode](https://leetcode.com/problems/trapping-rain-water/solution/)\n","filetype":".md","index":235},{"title":"Bf Rain Terraces","category":"rain-terraces","id":"bfRainTerraces_rain-terraces","algorithm":"/**\n * BRUTE FORCE approach of solving Trapping Rain Water problem.\n *\n * @param {number[]} terraces\n * @return {number}\n */\nexport default function bfRainTerraces(terraces) {\n  let waterAmount = 0;\n\n  for (let terraceIndex = 0; terraceIndex < terraces.length; terraceIndex += 1) {\n    // Get left most high terrace.\n    let leftHighestLevel = 0;\n    for (let leftIndex = terraceIndex - 1; leftIndex >= 0; leftIndex -= 1) {\n      leftHighestLevel = Math.max(leftHighestLevel, terraces[leftIndex]);\n    }\n\n    // Get right most high terrace.\n    let rightHighestLevel = 0;\n    for (let rightIndex = terraceIndex + 1; rightIndex < terraces.length; rightIndex += 1) {\n      rightHighestLevel = Math.max(rightHighestLevel, terraces[rightIndex]);\n    }\n\n    // Add current terrace water amount.\n    const terraceBoundaryLevel = Math.min(leftHighestLevel, rightHighestLevel);\n    if (terraceBoundaryLevel > terraces[terraceIndex]) {\n      // Terrace will be able to store the water if the lowest of two left and right highest\n      // terraces are still higher than the current one.\n      waterAmount += terraceBoundaryLevel - terraces[terraceIndex];\n    }\n  }\n\n  return waterAmount;\n}\n","filetype":".js","index":236},{"title":"Dp Rain Terraces","category":"rain-terraces","id":"dpRainTerraces_rain-terraces","algorithm":"/**\n * DYNAMIC PROGRAMMING approach of solving Trapping Rain Water problem.\n *\n * @param {number[]} terraces\n * @return {number}\n */\nexport default function dpRainTerraces(terraces) {\n  let waterAmount = 0;\n\n  // Init arrays that will keep the list of left and right maximum levels for specific positions.\n  const leftMaxLevels = new Array(terraces.length).fill(0);\n  const rightMaxLevels = new Array(terraces.length).fill(0);\n\n  // Calculate the highest terrace level from the LEFT relative to the current terrace.\n  [leftMaxLevels[0]] = terraces;\n  for (let terraceIndex = 1; terraceIndex < terraces.length; terraceIndex += 1) {\n    leftMaxLevels[terraceIndex] = Math.max(\n      terraces[terraceIndex],\n      leftMaxLevels[terraceIndex - 1],\n    );\n  }\n\n  // Calculate the highest terrace level from the RIGHT relative to the current terrace.\n  rightMaxLevels[terraces.length - 1] = terraces[terraces.length - 1];\n  for (let terraceIndex = terraces.length - 2; terraceIndex >= 0; terraceIndex -= 1) {\n    rightMaxLevels[terraceIndex] = Math.max(\n      terraces[terraceIndex],\n      rightMaxLevels[terraceIndex + 1],\n    );\n  }\n\n  // Not let's go through all terraces one by one and calculate how much water\n  // each terrace may accumulate based on previously calculated values.\n  for (let terraceIndex = 0; terraceIndex < terraces.length; terraceIndex += 1) {\n    // Pick the lowest from the left/right highest terraces.\n    const currentTerraceBoundary = Math.min(\n      leftMaxLevels[terraceIndex],\n      rightMaxLevels[terraceIndex],\n    );\n\n    if (currentTerraceBoundary > terraces[terraceIndex]) {\n      waterAmount += currentTerraceBoundary - terraces[terraceIndex];\n    }\n  }\n\n  return waterAmount;\n}\n","filetype":".js","index":237},{"title":"Recursive-staircase","category":"uncategorized","id":"recursive-staircase","algorithm":"# Recursive Staircase Problem\n\n## The Problem\n\nThere are `n` stairs, a person standing at the bottom wants to reach the top. The person can climb either `1` or `2` stairs at a time. _Count the number of ways, the person can reach the top._\n\n![](https://cdncontribute.geeksforgeeks.org/wp-content/uploads/nth-stair.png)\n\n## The Solution\n\nThis is an interesting problem because there are several ways of how it may be solved that illustrate different programming paradigms.\n\n- [Brute Force Recursive Solution](./recursiveStaircaseBF.js) - Time: `O(2^n)`; Space: `O(1)`\n- [Recursive Solution With Memoization](./recursiveStaircaseMEM.js) - Time: `O(n)`; Space: `O(n)`\n- [Dynamic Programming Solution](./recursiveStaircaseDP.js) - Time: `O(n)`; Space: `O(n)`\n- [Iterative Solution](./recursiveStaircaseIT.js) - Time: `O(n)`; Space: `O(1)` \n\n## References\n\n- [On YouTube by Gayle Laakmann McDowell](https://www.youtube.com/watch?v=eREiwuvzaUM&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8&index=81&t=0s)\n- [GeeksForGeeks](https://www.geeksforgeeks.org/count-ways-reach-nth-stair/)\n","filetype":".md","index":238},{"title":"Recursive Staircase B F","category":"recursive-staircase","id":"recursiveStaircaseBF_recursive-staircase","algorithm":"/**\n * Recursive Staircase Problem (Brute Force Solution).\n *\n * @param {number} stairsNum - Number of stairs to climb on.\n * @return {number} - Number of ways to climb a staircase.\n */\nexport default function recursiveStaircaseBF(stairsNum) {\n  if (stairsNum <= 0) {\n    // There is no way to go down - you climb the stairs only upwards.\n    // Also if you're standing on the ground floor that you don't need to do any further steps.\n    return 0;\n  }\n\n  if (stairsNum === 1) {\n    // There is only one way to go to the first step.\n    return 1;\n  }\n\n  if (stairsNum === 2) {\n    // There are two ways to get to the second steps: (1 + 1) or (2).\n    return 2;\n  }\n\n  // Sum up how many steps we need to take after doing one step up with the number of\n  // steps we need to take after doing two steps up.\n  return recursiveStaircaseBF(stairsNum - 1) + recursiveStaircaseBF(stairsNum - 2);\n}\n","filetype":".js","index":239},{"title":"Recursive Staircase D P","category":"recursive-staircase","id":"recursiveStaircaseDP_recursive-staircase","algorithm":"/**\n * Recursive Staircase Problem (Dynamic Programming Solution).\n *\n * @param {number} stairsNum - Number of stairs to climb on.\n * @return {number} - Number of ways to climb a staircase.\n */\nexport default function recursiveStaircaseDP(stairsNum) {\n  if (stairsNum < 0) {\n    // There is no way to go down - you climb the stairs only upwards.\n    return 0;\n  }\n\n  // Init the steps vector that will hold all possible ways to get to the corresponding step.\n  const steps = new Array(stairsNum + 1).fill(0);\n\n  // Init the number of ways to get to the 0th, 1st and 2nd steps.\n  steps[0] = 0;\n  steps[1] = 1;\n  steps[2] = 2;\n\n  if (stairsNum <= 2) {\n    // Return the number of ways to get to the 0th or 1st or 2nd steps.\n    return steps[stairsNum];\n  }\n\n  // Calculate every next step based on two previous ones.\n  for (let currentStep = 3; currentStep <= stairsNum; currentStep += 1) {\n    steps[currentStep] = steps[currentStep - 1] + steps[currentStep - 2];\n  }\n\n  // Return possible ways to get to the requested step.\n  return steps[stairsNum];\n}\n","filetype":".js","index":240},{"title":"Recursive Staircase I T","category":"recursive-staircase","id":"recursiveStaircaseIT_recursive-staircase","algorithm":"/**\n * Recursive Staircase Problem (Iterative Solution).\n *\n * @param {number} stairsNum - Number of stairs to climb on.\n * @return {number} - Number of ways to climb a staircase.\n */\nexport default function recursiveStaircaseIT(stairsNum) {\n  if (stairsNum <= 0) {\n    // There is no way to go down - you climb the stairs only upwards.\n    // Also you don't need to do anything to stay on the 0th step.\n    return 0;\n  }\n\n  // Init the number of ways to get to the 0th, 1st and 2nd steps.\n  const steps = [1, 2];\n\n  if (stairsNum <= 2) {\n    // Return the number of possible ways of how to get to the 1st or 2nd steps.\n    return steps[stairsNum - 1];\n  }\n\n  // Calculate the number of ways to get to the n'th step based on previous ones.\n  // Comparing to Dynamic Programming solution we don't store info for all the steps but\n  // rather for two previous ones only.\n  for (let currentStep = 3; currentStep <= stairsNum; currentStep += 1) {\n    [steps[0], steps[1]] = [steps[1], steps[0] + steps[1]];\n  }\n\n  // Return possible ways to get to the requested step.\n  return steps[1];\n}\n","filetype":".js","index":241},{"title":"Recursive Staircase M E M","category":"recursive-staircase","id":"recursiveStaircaseMEM_recursive-staircase","algorithm":"/**\n * Recursive Staircase Problem (Recursive Solution With Memoization).\n *\n * @param {number} totalStairs - Number of stairs to climb on.\n * @return {number} - Number of ways to climb a staircase.\n */\nexport default function recursiveStaircaseMEM(totalStairs) {\n  // Memo table that will hold all recursively calculated results to avoid calculating them\n  // over and over again.\n  const memo = [];\n\n  // Recursive closure.\n  const getSteps = (stairsNum) => {\n    if (stairsNum <= 0) {\n      // There is no way to go down - you climb the stairs only upwards.\n      // Also if you're standing on the ground floor that you don't need to do any further steps.\n      return 0;\n    }\n\n    if (stairsNum === 1) {\n      // There is only one way to go to the first step.\n      return 1;\n    }\n\n    if (stairsNum === 2) {\n      // There are two ways to get to the second steps: (1 + 1) or (2).\n      return 2;\n    }\n\n    // Avoid recursion for the steps that we've calculated recently.\n    if (memo[stairsNum]) {\n      return memo[stairsNum];\n    }\n\n    // Sum up how many steps we need to take after doing one step up with the number of\n    // steps we need to take after doing two steps up.\n    memo[stairsNum] = getSteps(stairsNum - 1) + getSteps(stairsNum - 2);\n\n    return memo[stairsNum];\n  };\n\n  // Return possible ways to get to the requested step.\n  return getSteps(totalStairs);\n}\n","filetype":".js","index":242},{"title":"Square-matrix-rotation","category":"uncategorized","id":"square-matrix-rotation","algorithm":"# Square Matrix In-Place Rotation\n\n## The Problem\n\nYou are given an `n x n` 2D matrix (representing an image). \nRotate the matrix by `90` degrees (clockwise).\n\n**Note**\n\nYou have to rotate the image **in-place**, which means you \nhave to modify the input 2D matrix directly. **DO NOT** allocate\nanother 2D matrix and do the rotation.\n\n## Examples\n\n**Example #1**\n\nGiven input matrix:\n\n```\n[\n  [1, 2, 3],\n  [4, 5, 6],\n  [7, 8, 9],\n]\n```\n\nRotate the input matrix in-place such that it becomes:\n\n```\n[\n  [7, 4, 1],\n  [8, 5, 2],\n  [9, 6, 3],\n]\n```\n\n**Example #2**\n\nGiven input matrix:\n\n```\n[\n  [5, 1, 9, 11],\n  [2, 4, 8, 10],\n  [13, 3, 6, 7],\n  [15, 14, 12, 16],\n]\n```\n\nRotate the input matrix in-place such that it becomes:\n\n```\n[\n  [15, 13, 2, 5],\n  [14, 3, 4, 1],\n  [12, 6, 8, 9],\n  [16, 7, 10, 11],\n]\n```\n\n## Algorithm\n\nWe would need to do two reflections of the matrix: \n\n- reflect vertically\n- reflect diagonally from bottom-left to top-right\n\nOr we also could Furthermore, you can reflect diagonally \ntop-left/bottom-right and reflect horizontally.\n\nA common question is how do you even figure out what kind \nof reflections to do? Simply rip a square piece of paper,\nwrite a random word on it so you know its rotation. Then,\nflip the square piece of paper around until you figure out\nhow to come to the solution.\n \nHere is an example of how first line may be rotated using\ndiagonal top-right/bottom-left rotation along with horizontal\nrotation.\n\n```\nLet's say we have a string at the top of the matrix:\n\nA B C\n• • •\n• • •\n\nLet's do top-right/bottom-left diagonal reflection:\n\nA B C\n/ / •\n/ • •  \n\nAnd now let's do horizontal reflection:\n\nA → →\nB → →\nC → →\n\nThe string has been rotated to 90 degree:\n\n• • A\n• • B\n• • C\n```\n\n## References\n\n- [LeetCode](https://leetcode.com/problems/rotate-image/description/)\n","filetype":".md","index":243},{"title":"Square Matrix Rotation","category":"square-matrix-rotation","id":"squareMatrixRotation_square-matrix-rotation","algorithm":"/**\n * @param {*[][]} originalMatrix\n * @return {*[][]}\n */\nexport default function squareMatrixRotation(originalMatrix) {\n  const matrix = originalMatrix.slice();\n\n  // Do top-right/bottom-left diagonal reflection of the matrix.\n  for (let rowIndex = 0; rowIndex < matrix.length; rowIndex += 1) {\n    for (let columnIndex = rowIndex + 1; columnIndex < matrix.length; columnIndex += 1) {\n      // Swap elements.\n      [\n        matrix[columnIndex][rowIndex],\n        matrix[rowIndex][columnIndex],\n      ] = [\n        matrix[rowIndex][columnIndex],\n        matrix[columnIndex][rowIndex],\n      ];\n    }\n  }\n\n  // Do horizontal reflection of the matrix.\n  for (let rowIndex = 0; rowIndex < matrix.length; rowIndex += 1) {\n    for (let columnIndex = 0; columnIndex < matrix.length / 2; columnIndex += 1) {\n      // Swap elements.\n      [\n        matrix[rowIndex][matrix.length - columnIndex - 1],\n        matrix[rowIndex][columnIndex],\n      ] = [\n        matrix[rowIndex][columnIndex],\n        matrix[rowIndex][matrix.length - columnIndex - 1],\n      ];\n    }\n  }\n\n  return matrix;\n}\n","filetype":".js","index":244},{"title":"Unique-paths","category":"uncategorized","id":"unique-paths","algorithm":"# Unique Paths Problem\n\nA robot is located at the top-left corner of a `m x n` grid \n(marked 'Start' in the diagram below).\n\nThe robot can only move either down or right at any point in \ntime. The robot is trying to reach the bottom-right corner \nof the grid (marked 'Finish' in the diagram below).\n\nHow many possible unique paths are there?\n\n![Unique Paths](https://leetcode.com/static/images/problemset/robot_maze.png)\n\n## Examples\n\n**Example #1**\n\n```\nInput: m = 3, n = 2\nOutput: 3\nExplanation:\nFrom the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\n1. Right -> Right -> Down\n2. Right -> Down -> Right\n3. Down -> Right -> Right\n```\n\n**Example #2**\n\n```\nInput: m = 7, n = 3\nOutput: 28\n```\n\n## Algorithms\n\n### Backtracking\n\nFirst thought that might came to mind is that we need to build a decision tree \nwhere `D` means moving down and `R` means moving right. For example in case\nof boars `width = 3` and `height = 2` we will have the following decision tree:\n\n```\n                START\n                /   \\\n               D     R\n             /     /   \\\n           R      D      R\n         /      /         \\\n        R      R            D\n\n       END    END          END\n```\n\nWe can see three unique branches here that is the answer to our problem.\n\n**Time Complexity**: `O(2 ^ n)` - roughly in worst case with square board\nof size `n`.\n\n**Auxiliary Space Complexity**: `O(m + n)` - since we need to store current path with\npositions.\n\n### Dynamic Programming\n\nLet's treat `BOARD[i][j]` as our sub-problem.\n\nSince we have restriction of moving only to the right\nand down we might say that number of unique paths to the current\ncell is a sum of numbers of unique paths to the cell above the\ncurrent one and to the cell to the left of current one.\n\n```\nBOARD[i][j] = BOARD[i - 1][j] + BOARD[i][j - 1]; // since we can only move down or right.\n```\n\nBase cases are:\n\n```\nBOARD[0][any] = 1; // only one way to reach any top slot.\nBOARD[any][0] = 1; // only one way to reach any slot in the leftmost column.\n```\n\nFor the board `3 x 2` our dynamic programming matrix will look like:\n\n|     | 0   | 1   | 1   |\n|:---:|:---:|:---:|:---:|\n|**0**| 0   | 1   | 1   |\n|**1**| 1   | 2   | 3   |\n\nEach cell contains the number of unique paths to it. We need \nthe bottom right one with number `3`.\n\n**Time Complexity**: `O(m * n)` - since we're going through each cell of the DP matrix.\n\n**Auxiliary Space Complexity**: `O(m * n)` - since we need to have DP matrix.\n\n### Pascal's Triangle Based\n\nThis question is actually another form of Pascal Triangle.\n\nThe corner of this rectangle is at `m + n - 2` line, and \nat `min(m, n) - 1` position of the Pascal's Triangle.\n\n## References\n\n- [LeetCode](https://leetcode.com/problems/unique-paths/description/)\n","filetype":".md","index":245},{"title":"Bt Unique Paths","category":"unique-paths","id":"btUniquePaths_unique-paths","algorithm":"/**\n * BACKTRACKING approach of solving Unique Paths problem.\n *\n * @param {number} width - Width of the board.\n * @param {number} height - Height of the board.\n * @param {number[][]} steps - The steps that have been already made.\n * @param {number} uniqueSteps - Total number of unique steps.\n * @return {number} - Number of unique paths.\n */\nexport default function btUniquePaths(width, height, steps = [[0, 0]], uniqueSteps = 0) {\n  // Fetch current position on board.\n  const currentPos = steps[steps.length - 1];\n\n  // Check if we've reached the end.\n  if (currentPos[0] === width - 1 && currentPos[1] === height - 1) {\n    // In case if we've reached the end let's increase total\n    // number of unique steps.\n    return uniqueSteps + 1;\n  }\n\n  // Let's calculate how many unique path we will have\n  // by going right and by going down.\n  let rightUniqueSteps = 0;\n  let downUniqueSteps = 0;\n\n  // Do right step if possible.\n  if (currentPos[0] < width - 1) {\n    steps.push([\n      currentPos[0] + 1,\n      currentPos[1],\n    ]);\n\n    // Calculate how many unique paths we'll get by moving right.\n    rightUniqueSteps = btUniquePaths(width, height, steps, uniqueSteps);\n\n    // BACKTRACK and try another move.\n    steps.pop();\n  }\n\n  // Do down step if possible.\n  if (currentPos[1] < height - 1) {\n    steps.push([\n      currentPos[0],\n      currentPos[1] + 1,\n    ]);\n\n    // Calculate how many unique paths we'll get by moving down.\n    downUniqueSteps = btUniquePaths(width, height, steps, uniqueSteps);\n\n    // BACKTRACK and try another move.\n    steps.pop();\n  }\n\n  // Total amount of unique steps will be equal to total amount of\n  // unique steps by going right plus total amount of unique steps\n  // by going down.\n  return rightUniqueSteps + downUniqueSteps;\n}\n","filetype":".js","index":246},{"title":"Dp Unique Paths","category":"unique-paths","id":"dpUniquePaths_unique-paths","algorithm":"/**\n * DYNAMIC PROGRAMMING approach of solving Unique Paths problem.\n *\n * @param {number} width - Width of the board.\n * @param {number} height - Height of the board.\n * @return {number} - Number of unique paths.\n */\nexport default function dpUniquePaths(width, height) {\n  // Init board.\n  const board = Array(height).fill(null).map(() => {\n    return Array(width).fill(0);\n  });\n\n  // Base case.\n  // There is only one way of getting to board[0][any] and\n  // there is also only one way of getting to board[any][0].\n  // This is because we have a restriction of moving right\n  // and down only.\n  for (let rowIndex = 0; rowIndex < height; rowIndex += 1) {\n    for (let columnIndex = 0; columnIndex < width; columnIndex += 1) {\n      if (rowIndex === 0 || columnIndex === 0) {\n        board[rowIndex][columnIndex] = 1;\n      }\n    }\n  }\n\n  // Now, since we have this restriction of moving only to the right\n  // and down we might say that number of unique paths to the current\n  // cell is a sum of numbers of unique paths to the cell above the\n  // current one and to the cell to the left of current one.\n  for (let rowIndex = 1; rowIndex < height; rowIndex += 1) {\n    for (let columnIndex = 1; columnIndex < width; columnIndex += 1) {\n      const uniquesFromTop = board[rowIndex - 1][columnIndex];\n      const uniquesFromLeft = board[rowIndex][columnIndex - 1];\n      board[rowIndex][columnIndex] = uniquesFromTop + uniquesFromLeft;\n    }\n  }\n\n  return board[height - 1][width - 1];\n}\n","filetype":".js","index":247},{"title":"Unique Paths","category":"unique-paths","id":"uniquePaths_unique-paths","algorithm":"import pascalTriangle from '../../math/pascal-triangle/pascalTriangle';\n\n/**\n * @param {number} width\n * @param {number} height\n * @return {number}\n */\nexport default function uniquePaths(width, height) {\n  const pascalLine = width + height - 2;\n  const pascalLinePosition = Math.min(width, height) - 1;\n\n  return pascalTriangle(pascalLine)[pascalLinePosition];\n}\n","filetype":".js","index":248},{"title":"Data-structures","category":null,"id":"data-structures","index":249},{"title":"Bloom-filter","category":"data-structures","id":"bloom-filter","algorithm":"# Bloom Filter\n\n_Read this in other languages:_\n[_Русский_](README.ru-RU.md),\n[_Português_](README.pt-BR.md)\n\nA **bloom filter** is a space-efficient probabilistic \ndata structure designed to test whether an element \nis present in a set. It is designed to be blazingly \nfast and use minimal memory at the cost of potential\nfalse positives. False positive matches are possible,\nbut false negatives are not – in other words, a query\nreturns either \"possibly in set\" or \"definitely not in set\".\n\nBloom proposed the technique for applications where the \namount of source data would require an impractically large\namount of memory if \"conventional\" error-free hashing \ntechniques were applied.\n\n## Algorithm description\n\nAn empty Bloom filter is a bit array of `m` bits, all \nset to `0`. There must also be `k` different hash functions\ndefined, each of which maps or hashes some set element to \none of the `m` array positions, generating a uniform random \ndistribution. Typically, `k` is a constant, much smaller \nthan `m`, which is proportional to the number of elements \nto be added; the precise choice of `k` and the constant of \nproportionality of `m` are determined by the intended \nfalse positive rate of the filter.\n\nHere is an example of a Bloom filter, representing the \nset `{x, y, z}`. The colored arrows show the positions \nin the bit array that each set element is mapped to. The \nelement `w` is not in the set `{x, y, z}`, because it \nhashes to one bit-array position containing `0`. For \nthis figure, `m = 18` and `k = 3`.\n\n![Bloom Filter](https://upload.wikimedia.org/wikipedia/commons/a/ac/Bloom_filter.svg)\n\n## Operations\n\nThere are two main operations a bloom filter can\nperform: _insertion_ and _search_. Search may result in\nfalse positives. Deletion is not possible.\n\nIn other words, the filter can take in items. When\nwe go to check if an item has previously been\ninserted, it can tell us either \"no\" or \"maybe\".\n\nBoth insertion and search are `O(1)` operations.\n\n## Making the filter\n\nA bloom filter is created by allotting a certain size.\nIn our example, we use `100` as a default length. All\nlocations are initialized to `false`.\n\n### Insertion\n\nDuring insertion, a number of hash functions,\nin our case `3` hash functions, are used to create\nhashes of the input. These hash functions output\nindexes. At every index received, we simply change\nthe value in our bloom filter to `true`.\n\n### Search\n\nDuring a search, the same hash functions are called\nand used to hash the input. We then check if the\nindexes received _all_ have a value of `true` inside\nour bloom filter. If they _all_ have a value of\n`true`, we know that the bloom filter may have had\nthe value previously inserted.\n\nHowever, it's not certain, because it's possible\nthat other values previously inserted flipped the\nvalues to `true`. The values aren't necessarily\n`true` due to the item currently being searched for.\nAbsolute certainty is impossible unless only a single\nitem has previously been inserted.\n\nWhile checking the bloom filter for the indexes\nreturned by our hash functions, if even one of them\nhas a value of `false`, we definitively know that the\nitem was not previously inserted.\n\n## False Positives\n\nThe probability of false positives is determined by\nthree factors: the size of the bloom filter, the\nnumber of hash functions we use, and the number\nof items that have been inserted into the filter.\n\nThe formula to calculate probablity of a false positive is:\n\n( 1 - e <sup>-kn/m</sup> ) <sup>k</sup>\n\n`k` = number of hash functions\n\n`m` = filter size\n\n`n` = number of items inserted\n\nThese variables, `k`, `m`, and `n`, should be picked based\non how acceptable false positives are. If the values\nare picked and the resulting probability is too high,\nthe values should be tweaked and the probability\nre-calculated.\n\n## Applications\n\nA bloom filter can be used on a blogging website. If\nthe goal is to show readers only articles that they\nhave never seen before, a bloom filter is perfect.\nIt can store hashed values based on the articles. After\na user reads a few articles, they can be inserted into\nthe filter. The next time the user visits the site,\nthose articles can be filtered out of the results.\n\nSome articles will inevitably be filtered out by mistake,\nbut the cost is acceptable. It's ok if a user never sees\na few articles as long as they have other, brand new ones\nto see every time they visit the site.\n\n## References\n\n- [Wikipedia](https://en.wikipedia.org/wiki/Bloom_filter)\n- [Bloom Filters by Example](http://llimllib.github.io/bloomfilter-tutorial/)\n- [Calculating False Positive Probability](https://hur.st/bloomfilter/?n=4&p=&m=18&k=3)\n- [Bloom Filters on Medium](https://blog.medium.com/what-are-bloom-filters-1ec2a50c68ff)\n- [Bloom Filters on YouTube](https://www.youtube.com/watch?v=bEmBh1HtYrw)\n","filetype":".md","index":250},{"title":"Bloom Filter","category":"bloom-filter","id":"BloomFilter_bloom-filter","algorithm":"export default class BloomFilter {\n  /**\n   * @param {number} size - the size of the storage.\n   */\n  constructor(size = 100) {\n    // Bloom filter size directly affects the likelihood of false positives.\n    // The bigger the size the lower the likelihood of false positives.\n    this.size = size;\n    this.storage = this.createStore(size);\n  }\n\n  /**\n   * @param {string} item\n   */\n  insert(item) {\n    const hashValues = this.getHashValues(item);\n\n    // Set each hashValue index to true.\n    hashValues.forEach((val) => this.storage.setValue(val));\n  }\n\n  /**\n   * @param {string} item\n   * @return {boolean}\n   */\n  mayContain(item) {\n    const hashValues = this.getHashValues(item);\n\n    for (let hashIndex = 0; hashIndex < hashValues.length; hashIndex += 1) {\n      if (!this.storage.getValue(hashValues[hashIndex])) {\n        // We know that the item was definitely not inserted.\n        return false;\n      }\n    }\n\n    // The item may or may not have been inserted.\n    return true;\n  }\n\n  /**\n   * Creates the data store for our filter.\n   * We use this method to generate the store in order to\n   * encapsulate the data itself and only provide access\n   * to the necessary methods.\n   *\n   * @param {number} size\n   * @return {Object}\n   */\n  createStore(size) {\n    const storage = [];\n\n    // Initialize all indexes to false\n    for (let storageCellIndex = 0; storageCellIndex < size; storageCellIndex += 1) {\n      storage.push(false);\n    }\n\n    const storageInterface = {\n      getValue(index) {\n        return storage[index];\n      },\n      setValue(index) {\n        storage[index] = true;\n      },\n    };\n\n    return storageInterface;\n  }\n\n  /**\n   * @param {string} item\n   * @return {number}\n   */\n  hash1(item) {\n    let hash = 0;\n\n    for (let charIndex = 0; charIndex < item.length; charIndex += 1) {\n      const char = item.charCodeAt(charIndex);\n      hash = (hash << 5) + hash + char;\n      hash &= hash; // Convert to 32bit integer\n      hash = Math.abs(hash);\n    }\n\n    return hash % this.size;\n  }\n\n  /**\n   * @param {string} item\n   * @return {number}\n   */\n  hash2(item) {\n    let hash = 5381;\n\n    for (let charIndex = 0; charIndex < item.length; charIndex += 1) {\n      const char = item.charCodeAt(charIndex);\n      hash = (hash << 5) + hash + char; /* hash * 33 + c */\n    }\n\n    return Math.abs(hash % this.size);\n  }\n\n  /**\n   * @param {string} item\n   * @return {number}\n   */\n  hash3(item) {\n    let hash = 0;\n\n    for (let charIndex = 0; charIndex < item.length; charIndex += 1) {\n      const char = item.charCodeAt(charIndex);\n      hash = (hash << 5) - hash;\n      hash += char;\n      hash &= hash; // Convert to 32bit integer\n    }\n\n    return Math.abs(hash % this.size);\n  }\n\n  /**\n   * Runs all 3 hash functions on the input and returns an array of results.\n   *\n   * @param {string} item\n   * @return {number[]}\n   */\n  getHashValues(item) {\n    return [\n      this.hash1(item),\n      this.hash2(item),\n      this.hash3(item),\n    ];\n  }\n}\n","filetype":".js","index":251},{"title":"Disjoint-set","category":"data-structures","id":"disjoint-set","algorithm":"# Disjoint Set\n\n_Read this in other languages:_\n[_Русский_](README.ru-RU.md),\n[_Português_](README.pt-BR.md)\n\n\n**Disjoint-set** data structure (also called a union–find data structure or merge–find set) is a data \nstructure that tracks a set of elements partitioned into a number of disjoint (non-overlapping) subsets. \nIt provides near-constant-time operations (bounded by the inverse Ackermann function) to *add new sets*, \nto *merge existing sets*, and to *determine whether elements are in the same set*. \nIn addition to many other uses (see the Applications section), disjoint-sets play a key role in Kruskal's algorithm for finding the minimum spanning tree of a graph.\n\n![disjoint set](https://upload.wikimedia.org/wikipedia/commons/6/67/Dsu_disjoint_sets_init.svg)\n\n*MakeSet* creates 8 singletons.\n\n![disjoint set](https://upload.wikimedia.org/wikipedia/commons/a/ac/Dsu_disjoint_sets_final.svg)\n\nAfter some operations of *Union*, some sets are grouped together.\n\n## References\n\n- [Wikipedia](https://en.wikipedia.org/wiki/Disjoint-set_data_structure)\n- [By Abdul Bari on YouTube](https://www.youtube.com/watch?v=wU6udHRIkcc&index=14&t=0s&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\n","filetype":".md","index":252},{"title":"Disjoint Set","category":"disjoint-set","id":"DisjointSet_disjoint-set","algorithm":"import DisjointSetItem from './DisjointSetItem';\n\nexport default class DisjointSet {\n  /**\n   * @param {function(value: *)} [keyCallback]\n   */\n  constructor(keyCallback) {\n    this.keyCallback = keyCallback;\n    this.items = {};\n  }\n\n  /**\n   * @param {*} itemValue\n   * @return {DisjointSet}\n   */\n  makeSet(itemValue) {\n    const disjointSetItem = new DisjointSetItem(itemValue, this.keyCallback);\n\n    if (!this.items[disjointSetItem.getKey()]) {\n      // Add new item only in case if it not presented yet.\n      this.items[disjointSetItem.getKey()] = disjointSetItem;\n    }\n\n    return this;\n  }\n\n  /**\n   * Find set representation node.\n   *\n   * @param {*} itemValue\n   * @return {(string|null)}\n   */\n  find(itemValue) {\n    const templateDisjointItem = new DisjointSetItem(itemValue, this.keyCallback);\n\n    // Try to find item itself;\n    const requiredDisjointItem = this.items[templateDisjointItem.getKey()];\n\n    if (!requiredDisjointItem) {\n      return null;\n    }\n\n    return requiredDisjointItem.getRoot().getKey();\n  }\n\n  /**\n   * Union by rank.\n   *\n   * @param {*} valueA\n   * @param {*} valueB\n   * @return {DisjointSet}\n   */\n  union(valueA, valueB) {\n    const rootKeyA = this.find(valueA);\n    const rootKeyB = this.find(valueB);\n\n    if (rootKeyA === null || rootKeyB === null) {\n      throw new Error('One or two values are not in sets');\n    }\n\n    if (rootKeyA === rootKeyB) {\n      // In case if both elements are already in the same set then just return its key.\n      return this;\n    }\n\n    const rootA = this.items[rootKeyA];\n    const rootB = this.items[rootKeyB];\n\n    if (rootA.getRank() < rootB.getRank()) {\n      // If rootB's tree is bigger then make rootB to be a new root.\n      rootB.addChild(rootA);\n\n      return this;\n    }\n\n    // If rootA's tree is bigger then make rootA to be a new root.\n    rootA.addChild(rootB);\n\n    return this;\n  }\n\n  /**\n   * @param {*} valueA\n   * @param {*} valueB\n   * @return {boolean}\n   */\n  inSameSet(valueA, valueB) {\n    const rootKeyA = this.find(valueA);\n    const rootKeyB = this.find(valueB);\n\n    if (rootKeyA === null || rootKeyB === null) {\n      throw new Error('One or two values are not in sets');\n    }\n\n    return rootKeyA === rootKeyB;\n  }\n}\n","filetype":".js","index":253},{"title":"Disjoint Set Item","category":"disjoint-set","id":"DisjointSetItem_disjoint-set","algorithm":"export default class DisjointSetItem {\n  /**\n   * @param {*} value\n   * @param {function(value: *)} [keyCallback]\n   */\n  constructor(value, keyCallback) {\n    this.value = value;\n    this.keyCallback = keyCallback;\n    /** @var {DisjointSetItem} this.parent */\n    this.parent = null;\n    this.children = {};\n  }\n\n  /**\n   * @return {*}\n   */\n  getKey() {\n    // Allow user to define custom key generator.\n    if (this.keyCallback) {\n      return this.keyCallback(this.value);\n    }\n\n    // Otherwise use value as a key by default.\n    return this.value;\n  }\n\n  /**\n   * @return {DisjointSetItem}\n   */\n  getRoot() {\n    return this.isRoot() ? this : this.parent.getRoot();\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isRoot() {\n    return this.parent === null;\n  }\n\n  /**\n   * Rank basically means the number of all ancestors.\n   *\n   * @return {number}\n   */\n  getRank() {\n    if (this.getChildren().length === 0) {\n      return 0;\n    }\n\n    let rank = 0;\n\n    /** @var {DisjointSetItem} child */\n    this.getChildren().forEach((child) => {\n      // Count child itself.\n      rank += 1;\n\n      // Also add all children of current child.\n      rank += child.getRank();\n    });\n\n    return rank;\n  }\n\n  /**\n   * @return {DisjointSetItem[]}\n   */\n  getChildren() {\n    return Object.values(this.children);\n  }\n\n  /**\n   * @param {DisjointSetItem} parentItem\n   * @param {boolean} forceSettingParentChild\n   * @return {DisjointSetItem}\n   */\n  setParent(parentItem, forceSettingParentChild = true) {\n    this.parent = parentItem;\n    if (forceSettingParentChild) {\n      parentItem.addChild(this);\n    }\n\n    return this;\n  }\n\n  /**\n   * @param {DisjointSetItem} childItem\n   * @return {DisjointSetItem}\n   */\n  addChild(childItem) {\n    this.children[childItem.getKey()] = childItem;\n    childItem.setParent(this, false);\n\n    return this;\n  }\n}\n","filetype":".js","index":254},{"title":"Doubly-linked-list","category":"data-structures","id":"doubly-linked-list","algorithm":"# Doubly Linked List\n\n_Read this in other languages:_\n[_Русский_](README.ru-RU.md),\n[_简体中文_](README.zh-CN.md),\n[_日本語_](README.ja-JP.md),\n[_Português_](README.pt-BR.md),\n[_한국어_](README.ko-KR.md),\n[_Español_](README.es-ES.md),\n\nIn computer science, a **doubly linked list** is a linked data structure that\nconsists of a set of sequentially linked records called nodes. Each node contains\ntwo fields, called links, that are references to the previous and to the next\nnode in the sequence of nodes. The beginning and ending nodes' previous and next\nlinks, respectively, point to some kind of terminator, typically a sentinel\nnode or null, to facilitate the traversal of the list. If there is only one\nsentinel node, then the list is circularly linked via the sentinel node. It can\nbe conceptualized as two singly linked lists formed from the same data items,\nbut in opposite sequential orders.\n\n![Doubly Linked List](https://upload.wikimedia.org/wikipedia/commons/5/5e/Doubly-linked-list.svg)\n\nThe two node links allow traversal of the list in either direction. While adding\nor removing a node in a doubly linked list requires changing more links than the\nsame operations on a singly linked list, the operations are simpler and\npotentially more efficient (for nodes other than first nodes) because there\nis no need to keep track of the previous node during traversal or no need\nto traverse the list to find the previous node, so that its link can be modified.\n\n## Pseudocode for Basic Operations\n\n### Insert\n\n```text\nAdd(value)\n  Pre: value is the value to add to the list\n  Post: value has been placed at the tail of the list\n  n ← node(value)\n  if head = ø\n    head ← n\n    tail ← n\n  else\n    n.previous ← tail\n    tail.next ← n\n    tail ← n\n  end if\nend Add\n```\n\n### Delete\n\n```text\nRemove(head, value)\n  Pre: head is the head node in the list\n       value is the value to remove from the list\n  Post: value is removed from the list, true; otherwise false\n  if head = ø\n    return false\n  end if\n  if value = head.value\n    if head = tail\n      head ← ø\n      tail ← ø\n    else\n      head ← head.next\n      head.previous ← ø\n    end if\n    return true\n  end if\n  n ← head.next\n  while n != ø and value !== n.value\n    n ← n.next\n  end while\n  if n = tail\n    tail ← tail.previous\n    tail.next ← ø\n    return true\n  else if n != ø\n    n.previous.next ← n.next\n    n.next.previous ← n.previous\n    return true\n  end if\n  return false\nend Remove\n```\n\n### Reverse Traversal\n\n```text\nReverseTraversal(tail)\n  Pre: tail is the node of the list to traverse\n  Post: the list has been traversed in reverse order\n  n ← tail\n  while n != ø\n    yield n.value\n    n ← n.previous\n  end while\nend Reverse Traversal\n```\n\n## Complexities\n\n## Time Complexity\n\n| Access    | Search    | Insertion | Deletion  |\n| :-------: | :-------: | :-------: | :-------: |\n| O(n)      | O(n)      | O(1)      | O(n)      |\n\n### Space Complexity\n\nO(n)\n\n## References\n\n- [Wikipedia](https://en.wikipedia.org/wiki/Doubly_linked_list)\n- [YouTube](https://www.youtube.com/watch?v=JdQeNxWCguQ&t=7s&index=72&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\n","filetype":".md","index":255},{"title":"Doubly Linked List","category":"doubly-linked-list","id":"DoublyLinkedList_doubly-linked-list","algorithm":"import DoublyLinkedListNode from './DoublyLinkedListNode';\nimport Comparator from '../../utils/comparator/Comparator';\n\nexport default class DoublyLinkedList {\n  /**\n   * @param {Function} [comparatorFunction]\n   */\n  constructor(comparatorFunction) {\n    /** @var DoublyLinkedListNode */\n    this.head = null;\n\n    /** @var DoublyLinkedListNode */\n    this.tail = null;\n\n    this.compare = new Comparator(comparatorFunction);\n  }\n\n  /**\n   * @param {*} value\n   * @return {DoublyLinkedList}\n   */\n  prepend(value) {\n    // Make new node to be a head.\n    const newNode = new DoublyLinkedListNode(value, this.head);\n\n    // If there is head, then it won't be head anymore.\n    // Therefore, make its previous reference to be new node (new head).\n    // Then mark the new node as head.\n    if (this.head) {\n      this.head.previous = newNode;\n    }\n    this.head = newNode;\n\n    // If there is no tail yet let's make new node a tail.\n    if (!this.tail) {\n      this.tail = newNode;\n    }\n\n    return this;\n  }\n\n  /**\n   * @param {*} value\n   * @return {DoublyLinkedList}\n   */\n  append(value) {\n    const newNode = new DoublyLinkedListNode(value);\n\n    // If there is no head yet let's make new node a head.\n    if (!this.head) {\n      this.head = newNode;\n      this.tail = newNode;\n\n      return this;\n    }\n\n    // Attach new node to the end of linked list.\n    this.tail.next = newNode;\n\n    // Attach current tail to the new node's previous reference.\n    newNode.previous = this.tail;\n\n    // Set new node to be the tail of linked list.\n    this.tail = newNode;\n\n    return this;\n  }\n\n  /**\n   * @param {*} value\n   * @return {DoublyLinkedListNode}\n   */\n  delete(value) {\n    if (!this.head) {\n      return null;\n    }\n\n    let deletedNode = null;\n    let currentNode = this.head;\n\n    while (currentNode) {\n      if (this.compare.equal(currentNode.value, value)) {\n        deletedNode = currentNode;\n\n        if (deletedNode === this.head) {\n          // If HEAD is going to be deleted...\n\n          // Set head to second node, which will become new head.\n          this.head = deletedNode.next;\n\n          // Set new head's previous to null.\n          if (this.head) {\n            this.head.previous = null;\n          }\n\n          // If all the nodes in list has same value that is passed as argument\n          // then all nodes will get deleted, therefore tail needs to be updated.\n          if (deletedNode === this.tail) {\n            this.tail = null;\n          }\n        } else if (deletedNode === this.tail) {\n          // If TAIL is going to be deleted...\n\n          // Set tail to second last node, which will become new tail.\n          this.tail = deletedNode.previous;\n          this.tail.next = null;\n        } else {\n          // If MIDDLE node is going to be deleted...\n          const previousNode = deletedNode.previous;\n          const nextNode = deletedNode.next;\n\n          previousNode.next = nextNode;\n          nextNode.previous = previousNode;\n        }\n      }\n\n      currentNode = currentNode.next;\n    }\n\n    return deletedNode;\n  }\n\n  /**\n   * @param {Object} findParams\n   * @param {*} findParams.value\n   * @param {function} [findParams.callback]\n   * @return {DoublyLinkedListNode}\n   */\n  find({ value = undefined, callback = undefined }) {\n    if (!this.head) {\n      return null;\n    }\n\n    let currentNode = this.head;\n\n    while (currentNode) {\n      // If callback is specified then try to find node by callback.\n      if (callback && callback(currentNode.value)) {\n        return currentNode;\n      }\n\n      // If value is specified then try to compare by value..\n      if (value !== undefined && this.compare.equal(currentNode.value, value)) {\n        return currentNode;\n      }\n\n      currentNode = currentNode.next;\n    }\n\n    return null;\n  }\n\n  /**\n   * @return {DoublyLinkedListNode}\n   */\n  deleteTail() {\n    if (!this.tail) {\n      // No tail to delete.\n      return null;\n    }\n\n    if (this.head === this.tail) {\n      // There is only one node in linked list.\n      const deletedTail = this.tail;\n      this.head = null;\n      this.tail = null;\n\n      return deletedTail;\n    }\n\n    // If there are many nodes in linked list...\n    const deletedTail = this.tail;\n\n    this.tail = this.tail.previous;\n    this.tail.next = null;\n\n    return deletedTail;\n  }\n\n  /**\n   * @return {DoublyLinkedListNode}\n   */\n  deleteHead() {\n    if (!this.head) {\n      return null;\n    }\n\n    const deletedHead = this.head;\n\n    if (this.head.next) {\n      this.head = this.head.next;\n      this.head.previous = null;\n    } else {\n      this.head = null;\n      this.tail = null;\n    }\n\n    return deletedHead;\n  }\n\n  /**\n   * @return {DoublyLinkedListNode[]}\n   */\n  toArray() {\n    const nodes = [];\n\n    let currentNode = this.head;\n    while (currentNode) {\n      nodes.push(currentNode);\n      currentNode = currentNode.next;\n    }\n\n    return nodes;\n  }\n\n  /**\n   * @param {*[]} values - Array of values that need to be converted to linked list.\n   * @return {DoublyLinkedList}\n   */\n  fromArray(values) {\n    values.forEach((value) => this.append(value));\n\n    return this;\n  }\n\n  /**\n   * @param {function} [callback]\n   * @return {string}\n   */\n  toString(callback) {\n    return this.toArray().map((node) => node.toString(callback)).toString();\n  }\n\n  /**\n   * Reverse a linked list.\n   * @returns {DoublyLinkedList}\n   */\n  reverse() {\n    let currNode = this.head;\n    let prevNode = null;\n    let nextNode = null;\n\n    while (currNode) {\n      // Store next node.\n      nextNode = currNode.next;\n      prevNode = currNode.previous;\n\n      // Change next node of the current node so it would link to previous node.\n      currNode.next = prevNode;\n      currNode.previous = nextNode;\n\n      // Move prevNode and currNode nodes one step forward.\n      prevNode = currNode;\n      currNode = nextNode;\n    }\n\n    // Reset head and tail.\n    this.tail = this.head;\n    this.head = prevNode;\n\n    return this;\n  }\n}\n","filetype":".js","index":256},{"title":"Doubly Linked List Node","category":"doubly-linked-list","id":"DoublyLinkedListNode_doubly-linked-list","algorithm":"export default class DoublyLinkedListNode {\n  constructor(value, next = null, previous = null) {\n    this.value = value;\n    this.next = next;\n    this.previous = previous;\n  }\n\n  toString(callback) {\n    return callback ? callback(this.value) : `${this.value}`;\n  }\n}\n","filetype":".js","index":257},{"title":"Graph","category":"data-structures","id":"graph","algorithm":"# Graph\n\n_Read this in other languages:_\n[_简体中文_](README.zh-CN.md),\n[_Русский_](README.ru-RU.md),\n[_Português_](README.pt-BR.md)\n\nIn computer science, a **graph** is an abstract data type \nthat is meant to implement the undirected graph and \ndirected graph concepts from mathematics, specifically\nthe field of graph theory\n\nA graph data structure consists of a finite (and possibly \nmutable) set of vertices or nodes or points, together \nwith a set of unordered pairs of these vertices for an \nundirected graph or a set of ordered pairs for a \ndirected graph. These pairs are known as edges, arcs, \nor lines for an undirected graph and as arrows, \ndirected edges, directed arcs, or directed lines \nfor a directed graph. The vertices may be part of \nthe graph structure, or may be external entities \nrepresented by integer indices or references.\n\n![Graph](https://www.tutorialspoint.com/data_structures_algorithms/images/graph.jpg)\n\n## References\n\n- [Wikipedia](https://en.wikipedia.org/wiki/Graph_(abstract_data_type))\n- [Introduction to Graphs on YouTube](https://www.youtube.com/watch?v=gXgEDyodOJU&index=9&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\n- [Graphs representation on YouTube](https://www.youtube.com/watch?v=k1wraWzqtvQ&index=10&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\n","filetype":".md","index":258},{"title":"Graph","category":"graph","id":"Graph_graph","algorithm":"export default class Graph {\n  /**\n   * @param {boolean} isDirected\n   */\n  constructor(isDirected = false) {\n    this.vertices = {};\n    this.edges = {};\n    this.isDirected = isDirected;\n  }\n\n  /**\n   * @param {GraphVertex} newVertex\n   * @returns {Graph}\n   */\n  addVertex(newVertex) {\n    this.vertices[newVertex.getKey()] = newVertex;\n\n    return this;\n  }\n\n  /**\n   * @param {string} vertexKey\n   * @returns GraphVertex\n   */\n  getVertexByKey(vertexKey) {\n    return this.vertices[vertexKey];\n  }\n\n  /**\n   * @param {GraphVertex} vertex\n   * @returns {GraphVertex[]}\n   */\n  getNeighbors(vertex) {\n    return vertex.getNeighbors();\n  }\n\n  /**\n   * @return {GraphVertex[]}\n   */\n  getAllVertices() {\n    return Object.values(this.vertices);\n  }\n\n  /**\n   * @return {GraphEdge[]}\n   */\n  getAllEdges() {\n    return Object.values(this.edges);\n  }\n\n  /**\n   * @param {GraphEdge} edge\n   * @returns {Graph}\n   */\n  addEdge(edge) {\n    // Try to find and end start vertices.\n    let startVertex = this.getVertexByKey(edge.startVertex.getKey());\n    let endVertex = this.getVertexByKey(edge.endVertex.getKey());\n\n    // Insert start vertex if it wasn't inserted.\n    if (!startVertex) {\n      this.addVertex(edge.startVertex);\n      startVertex = this.getVertexByKey(edge.startVertex.getKey());\n    }\n\n    // Insert end vertex if it wasn't inserted.\n    if (!endVertex) {\n      this.addVertex(edge.endVertex);\n      endVertex = this.getVertexByKey(edge.endVertex.getKey());\n    }\n\n    // Check if edge has been already added.\n    if (this.edges[edge.getKey()]) {\n      throw new Error('Edge has already been added before');\n    } else {\n      this.edges[edge.getKey()] = edge;\n    }\n\n    // Add edge to the vertices.\n    if (this.isDirected) {\n      // If graph IS directed then add the edge only to start vertex.\n      startVertex.addEdge(edge);\n    } else {\n      // If graph ISN'T directed then add the edge to both vertices.\n      startVertex.addEdge(edge);\n      endVertex.addEdge(edge);\n    }\n\n    return this;\n  }\n\n  /**\n   * @param {GraphEdge} edge\n   */\n  deleteEdge(edge) {\n    // Delete edge from the list of edges.\n    if (this.edges[edge.getKey()]) {\n      delete this.edges[edge.getKey()];\n    } else {\n      throw new Error('Edge not found in graph');\n    }\n\n    // Try to find and end start vertices and delete edge from them.\n    const startVertex = this.getVertexByKey(edge.startVertex.getKey());\n    const endVertex = this.getVertexByKey(edge.endVertex.getKey());\n\n    startVertex.deleteEdge(edge);\n    endVertex.deleteEdge(edge);\n  }\n\n  /**\n   * @param {GraphVertex} startVertex\n   * @param {GraphVertex} endVertex\n   * @return {(GraphEdge|null)}\n   */\n  findEdge(startVertex, endVertex) {\n    const vertex = this.getVertexByKey(startVertex.getKey());\n\n    if (!vertex) {\n      return null;\n    }\n\n    return vertex.findEdge(endVertex);\n  }\n\n  /**\n   * @return {number}\n   */\n  getWeight() {\n    return this.getAllEdges().reduce((weight, graphEdge) => {\n      return weight + graphEdge.weight;\n    }, 0);\n  }\n\n  /**\n   * Reverse all the edges in directed graph.\n   * @return {Graph}\n   */\n  reverse() {\n    /** @param {GraphEdge} edge */\n    this.getAllEdges().forEach((edge) => {\n      // Delete straight edge from graph and from vertices.\n      this.deleteEdge(edge);\n\n      // Reverse the edge.\n      edge.reverse();\n\n      // Add reversed edge back to the graph and its vertices.\n      this.addEdge(edge);\n    });\n\n    return this;\n  }\n\n  /**\n   * @return {object}\n   */\n  getVerticesIndices() {\n    const verticesIndices = {};\n    this.getAllVertices().forEach((vertex, index) => {\n      verticesIndices[vertex.getKey()] = index;\n    });\n\n    return verticesIndices;\n  }\n\n  /**\n   * @return {*[][]}\n   */\n  getAdjacencyMatrix() {\n    const vertices = this.getAllVertices();\n    const verticesIndices = this.getVerticesIndices();\n\n    // Init matrix with infinities meaning that there is no ways of\n    // getting from one vertex to another yet.\n    const adjacencyMatrix = Array(vertices.length).fill(null).map(() => {\n      return Array(vertices.length).fill(Infinity);\n    });\n\n    // Fill the columns.\n    vertices.forEach((vertex, vertexIndex) => {\n      vertex.getNeighbors().forEach((neighbor) => {\n        const neighborIndex = verticesIndices[neighbor.getKey()];\n        adjacencyMatrix[vertexIndex][neighborIndex] = this.findEdge(vertex, neighbor).weight;\n      });\n    });\n\n    return adjacencyMatrix;\n  }\n\n  /**\n   * @return {string}\n   */\n  toString() {\n    return Object.keys(this.vertices).toString();\n  }\n}\n","filetype":".js","index":259},{"title":"Graph Edge","category":"graph","id":"GraphEdge_graph","algorithm":"export default class GraphEdge {\n  /**\n   * @param {GraphVertex} startVertex\n   * @param {GraphVertex} endVertex\n   * @param {number} [weight=1]\n   */\n  constructor(startVertex, endVertex, weight = 0) {\n    this.startVertex = startVertex;\n    this.endVertex = endVertex;\n    this.weight = weight;\n  }\n\n  /**\n   * @return {string}\n   */\n  getKey() {\n    const startVertexKey = this.startVertex.getKey();\n    const endVertexKey = this.endVertex.getKey();\n\n    return `${startVertexKey}_${endVertexKey}`;\n  }\n\n  /**\n   * @return {GraphEdge}\n   */\n  reverse() {\n    const tmp = this.startVertex;\n    this.startVertex = this.endVertex;\n    this.endVertex = tmp;\n\n    return this;\n  }\n\n  /**\n   * @return {string}\n   */\n  toString() {\n    return this.getKey();\n  }\n}\n","filetype":".js","index":260},{"title":"Graph Vertex","category":"graph","id":"GraphVertex_graph","algorithm":"import LinkedList from '../linked-list/LinkedList';\n\nexport default class GraphVertex {\n  /**\n   * @param {*} value\n   */\n  constructor(value) {\n    if (value === undefined) {\n      throw new Error('Graph vertex must have a value');\n    }\n\n    /**\n     * @param {GraphEdge} edgeA\n     * @param {GraphEdge} edgeB\n     */\n    const edgeComparator = (edgeA, edgeB) => {\n      if (edgeA.getKey() === edgeB.getKey()) {\n        return 0;\n      }\n\n      return edgeA.getKey() < edgeB.getKey() ? -1 : 1;\n    };\n\n    // Normally you would store string value like vertex name.\n    // But generally it may be any object as well\n    this.value = value;\n    this.edges = new LinkedList(edgeComparator);\n  }\n\n  /**\n   * @param {GraphEdge} edge\n   * @returns {GraphVertex}\n   */\n  addEdge(edge) {\n    this.edges.append(edge);\n\n    return this;\n  }\n\n  /**\n   * @param {GraphEdge} edge\n   */\n  deleteEdge(edge) {\n    this.edges.delete(edge);\n  }\n\n  /**\n   * @returns {GraphVertex[]}\n   */\n  getNeighbors() {\n    const edges = this.edges.toArray();\n\n    /** @param {LinkedListNode} node */\n    const neighborsConverter = (node) => {\n      return node.value.startVertex === this ? node.value.endVertex : node.value.startVertex;\n    };\n\n    // Return either start or end vertex.\n    // For undirected graphs it is possible that current vertex will be the end one.\n    return edges.map(neighborsConverter);\n  }\n\n  /**\n   * @return {GraphEdge[]}\n   */\n  getEdges() {\n    return this.edges.toArray().map((linkedListNode) => linkedListNode.value);\n  }\n\n  /**\n   * @return {number}\n   */\n  getDegree() {\n    return this.edges.toArray().length;\n  }\n\n  /**\n   * @param {GraphEdge} requiredEdge\n   * @returns {boolean}\n   */\n  hasEdge(requiredEdge) {\n    const edgeNode = this.edges.find({\n      callback: (edge) => edge === requiredEdge,\n    });\n\n    return !!edgeNode;\n  }\n\n  /**\n   * @param {GraphVertex} vertex\n   * @returns {boolean}\n   */\n  hasNeighbor(vertex) {\n    const vertexNode = this.edges.find({\n      callback: (edge) => edge.startVertex === vertex || edge.endVertex === vertex,\n    });\n\n    return !!vertexNode;\n  }\n\n  /**\n   * @param {GraphVertex} vertex\n   * @returns {(GraphEdge|null)}\n   */\n  findEdge(vertex) {\n    const edgeFinder = (edge) => {\n      return edge.startVertex === vertex || edge.endVertex === vertex;\n    };\n\n    const edge = this.edges.find({ callback: edgeFinder });\n\n    return edge ? edge.value : null;\n  }\n\n  /**\n   * @returns {string}\n   */\n  getKey() {\n    return this.value;\n  }\n\n  /**\n   * @return {GraphVertex}\n   */\n  deleteAllEdges() {\n    this.getEdges().forEach((edge) => this.deleteEdge(edge));\n\n    return this;\n  }\n\n  /**\n   * @param {function} [callback]\n   * @returns {string}\n   */\n  toString(callback) {\n    return callback ? callback(this.value) : `${this.value}`;\n  }\n}\n","filetype":".js","index":261},{"title":"Hash-table","category":"data-structures","id":"hash-table","algorithm":"# Hash Table\n\n_Read this in other languages:_\n[_简体中文_](README.zh-CN.md),\n[_Русский_](README.ru-RU.md),\n[_日本語_](README.ja-JP.md),\n[_Français_](README.fr-FR.md),\n[_Português_](README.pt-BR.md)\n \nIn computing, a **hash table** (hash map) is a data \nstructure which implements an *associative array* \nabstract data type, a structure that can *map keys \nto values*. A hash table uses a *hash function* to \ncompute an index into an array of buckets or slots, \nfrom which the desired value can be found\n\nIdeally, the hash function will assign each key to a \nunique bucket, but most hash table designs employ an \nimperfect hash function, which might cause hash \ncollisions where the hash function generates the same\nindex for more than one key. Such collisions must be\naccommodated in some way.\n\n![Hash Table](https://upload.wikimedia.org/wikipedia/commons/7/7d/Hash_table_3_1_1_0_1_0_0_SP.svg)\n\nHash collision resolved by separate chaining.\n\n![Hash Collision](https://upload.wikimedia.org/wikipedia/commons/d/d0/Hash_table_5_0_1_1_1_1_1_LL.svg)\n\n## References\n\n- [Wikipedia](https://en.wikipedia.org/wiki/Hash_table)\n- [YouTube](https://www.youtube.com/watch?v=shs0KM3wKv8&index=4&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\n","filetype":".md","index":262},{"title":"Hash Table","category":"hash-table","id":"HashTable_hash-table","algorithm":"import LinkedList from '../linked-list/LinkedList';\n\n// Hash table size directly affects on the number of collisions.\n// The bigger the hash table size the less collisions you'll get.\n// For demonstrating purposes hash table size is small to show how collisions\n// are being handled.\nconst defaultHashTableSize = 32;\n\nexport default class HashTable {\n  /**\n   * @param {number} hashTableSize\n   */\n  constructor(hashTableSize = defaultHashTableSize) {\n    // Create hash table of certain size and fill each bucket with empty linked list.\n    this.buckets = Array(hashTableSize).fill(null).map(() => new LinkedList());\n\n    // Just to keep track of all actual keys in a fast way.\n    this.keys = {};\n  }\n\n  /**\n   * Converts key string to hash number.\n   *\n   * @param {string} key\n   * @return {number}\n   */\n  hash(key) {\n    // For simplicity reasons we will just use character codes sum of all characters of the key\n    // to calculate the hash.\n    //\n    // But you may also use more sophisticated approaches like polynomial string hash to reduce the\n    // number of collisions:\n    //\n    // hash = charCodeAt(0) * PRIME^(n-1) + charCodeAt(1) * PRIME^(n-2) + ... + charCodeAt(n-1)\n    //\n    // where charCodeAt(i) is the i-th character code of the key, n is the length of the key and\n    // PRIME is just any prime number like 31.\n    const hash = Array.from(key).reduce(\n      (hashAccumulator, keySymbol) => (hashAccumulator + keySymbol.charCodeAt(0)),\n      0,\n    );\n\n    // Reduce hash number so it would fit hash table size.\n    return hash % this.buckets.length;\n  }\n\n  /**\n   * @param {string} key\n   * @param {*} value\n   */\n  set(key, value) {\n    const keyHash = this.hash(key);\n    this.keys[key] = keyHash;\n    const bucketLinkedList = this.buckets[keyHash];\n    const node = bucketLinkedList.find({ callback: (nodeValue) => nodeValue.key === key });\n\n    if (!node) {\n      // Insert new node.\n      bucketLinkedList.append({ key, value });\n    } else {\n      // Update value of existing node.\n      node.value.value = value;\n    }\n  }\n\n  /**\n   * @param {string} key\n   * @return {*}\n   */\n  delete(key) {\n    const keyHash = this.hash(key);\n    delete this.keys[key];\n    const bucketLinkedList = this.buckets[keyHash];\n    const node = bucketLinkedList.find({ callback: (nodeValue) => nodeValue.key === key });\n\n    if (node) {\n      return bucketLinkedList.delete(node.value);\n    }\n\n    return null;\n  }\n\n  /**\n   * @param {string} key\n   * @return {*}\n   */\n  get(key) {\n    const bucketLinkedList = this.buckets[this.hash(key)];\n    const node = bucketLinkedList.find({ callback: (nodeValue) => nodeValue.key === key });\n\n    return node ? node.value.value : undefined;\n  }\n\n  /**\n   * @param {string} key\n   * @return {boolean}\n   */\n  has(key) {\n    return Object.hasOwnProperty.call(this.keys, key);\n  }\n\n  /**\n   * @return {string[]}\n   */\n  getKeys() {\n    return Object.keys(this.keys);\n  }\n\n  /**\n   * Gets the list of all the stored values in the hash table.\n   *\n   * @return {*[]}\n   */\n  getValues() {\n    return this.buckets.reduce((values, bucket) => {\n      const bucketValues = bucket.toArray()\n        .map((linkedListNode) => linkedListNode.value.value);\n      return values.concat(bucketValues);\n    }, []);\n  }\n}\n","filetype":".js","index":263},{"title":"Heap","category":"data-structures","id":"heap","algorithm":"# Heap (data-structure)\n\n_Read this in other languages:_\n[_简体中文_](README.zh-CN.md),\n[_Русский_](README.ru-RU.md),\n[_日本語_](README.ja-JP.md),\n[_Français_](README.fr-FR.md),\n[_Português_](README.pt-BR.md)\n\nIn computer science, a **heap** is a specialized tree-based \ndata structure that satisfies the heap property described\nbelow.\n\nIn a *min heap*, if `P` is a parent node of `C`, then the\nkey (the value) of `P` is less than or equal to the\nkey of `C`.\n\n![MinHeap](https://upload.wikimedia.org/wikipedia/commons/6/69/Min-heap.png)\n\nIn a *max heap*, the key of `P` is greater than or equal\nto the key of `C`\n\n![Heap](https://upload.wikimedia.org/wikipedia/commons/3/38/Max-Heap.svg)\n\nThe node at the \"top\" of the heap with no parents is \ncalled the root node.\n\n## References\n\n- [Wikipedia](https://en.wikipedia.org/wiki/Heap_(data_structure))\n- [YouTube](https://www.youtube.com/watch?v=t0Cq6tVNRBA&index=5&t=0s&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\n","filetype":".md","index":264},{"title":"Heap","category":"heap","id":"Heap_heap","algorithm":"import Comparator from '../../utils/comparator/Comparator';\n\n/**\n * Parent class for Min and Max Heaps.\n */\nexport default class Heap {\n  /**\n   * @constructs Heap\n   * @param {Function} [comparatorFunction]\n   */\n  constructor(comparatorFunction) {\n    if (new.target === Heap) {\n      throw new TypeError('Cannot construct Heap instance directly');\n    }\n\n    // Array representation of the heap.\n    this.heapContainer = [];\n    this.compare = new Comparator(comparatorFunction);\n  }\n\n  /**\n   * @param {number} parentIndex\n   * @return {number}\n   */\n  getLeftChildIndex(parentIndex) {\n    return (2 * parentIndex) + 1;\n  }\n\n  /**\n   * @param {number} parentIndex\n   * @return {number}\n   */\n  getRightChildIndex(parentIndex) {\n    return (2 * parentIndex) + 2;\n  }\n\n  /**\n   * @param {number} childIndex\n   * @return {number}\n   */\n  getParentIndex(childIndex) {\n    return Math.floor((childIndex - 1) / 2);\n  }\n\n  /**\n   * @param {number} childIndex\n   * @return {boolean}\n   */\n  hasParent(childIndex) {\n    return this.getParentIndex(childIndex) >= 0;\n  }\n\n  /**\n   * @param {number} parentIndex\n   * @return {boolean}\n   */\n  hasLeftChild(parentIndex) {\n    return this.getLeftChildIndex(parentIndex) < this.heapContainer.length;\n  }\n\n  /**\n   * @param {number} parentIndex\n   * @return {boolean}\n   */\n  hasRightChild(parentIndex) {\n    return this.getRightChildIndex(parentIndex) < this.heapContainer.length;\n  }\n\n  /**\n   * @param {number} parentIndex\n   * @return {*}\n   */\n  leftChild(parentIndex) {\n    return this.heapContainer[this.getLeftChildIndex(parentIndex)];\n  }\n\n  /**\n   * @param {number} parentIndex\n   * @return {*}\n   */\n  rightChild(parentIndex) {\n    return this.heapContainer[this.getRightChildIndex(parentIndex)];\n  }\n\n  /**\n   * @param {number} childIndex\n   * @return {*}\n   */\n  parent(childIndex) {\n    return this.heapContainer[this.getParentIndex(childIndex)];\n  }\n\n  /**\n   * @param {number} indexOne\n   * @param {number} indexTwo\n   */\n  swap(indexOne, indexTwo) {\n    const tmp = this.heapContainer[indexTwo];\n    this.heapContainer[indexTwo] = this.heapContainer[indexOne];\n    this.heapContainer[indexOne] = tmp;\n  }\n\n  /**\n   * @return {*}\n   */\n  peek() {\n    if (this.heapContainer.length === 0) {\n      return null;\n    }\n\n    return this.heapContainer[0];\n  }\n\n  /**\n   * @return {*}\n   */\n  poll() {\n    if (this.heapContainer.length === 0) {\n      return null;\n    }\n\n    if (this.heapContainer.length === 1) {\n      return this.heapContainer.pop();\n    }\n\n    const item = this.heapContainer[0];\n\n    // Move the last element from the end to the head.\n    this.heapContainer[0] = this.heapContainer.pop();\n    this.heapifyDown();\n\n    return item;\n  }\n\n  /**\n   * @param {*} item\n   * @return {Heap}\n   */\n  add(item) {\n    this.heapContainer.push(item);\n    this.heapifyUp();\n    return this;\n  }\n\n  /**\n   * @param {*} item\n   * @param {Comparator} [comparator]\n   * @return {Heap}\n   */\n  remove(item, comparator = this.compare) {\n    // Find number of items to remove.\n    const numberOfItemsToRemove = this.find(item, comparator).length;\n\n    for (let iteration = 0; iteration < numberOfItemsToRemove; iteration += 1) {\n      // We need to find item index to remove each time after removal since\n      // indices are being changed after each heapify process.\n      const indexToRemove = this.find(item, comparator).pop();\n\n      // If we need to remove last child in the heap then just remove it.\n      // There is no need to heapify the heap afterwards.\n      if (indexToRemove === (this.heapContainer.length - 1)) {\n        this.heapContainer.pop();\n      } else {\n        // Move last element in heap to the vacant (removed) position.\n        this.heapContainer[indexToRemove] = this.heapContainer.pop();\n\n        // Get parent.\n        const parentItem = this.parent(indexToRemove);\n\n        // If there is no parent or parent is in correct order with the node\n        // we're going to delete then heapify down. Otherwise heapify up.\n        if (\n          this.hasLeftChild(indexToRemove)\n          && (\n            !parentItem\n            || this.pairIsInCorrectOrder(parentItem, this.heapContainer[indexToRemove])\n          )\n        ) {\n          this.heapifyDown(indexToRemove);\n        } else {\n          this.heapifyUp(indexToRemove);\n        }\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * @param {*} item\n   * @param {Comparator} [comparator]\n   * @return {Number[]}\n   */\n  find(item, comparator = this.compare) {\n    const foundItemIndices = [];\n\n    for (let itemIndex = 0; itemIndex < this.heapContainer.length; itemIndex += 1) {\n      if (comparator.equal(item, this.heapContainer[itemIndex])) {\n        foundItemIndices.push(itemIndex);\n      }\n    }\n\n    return foundItemIndices;\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isEmpty() {\n    return !this.heapContainer.length;\n  }\n\n  /**\n   * @return {string}\n   */\n  toString() {\n    return this.heapContainer.toString();\n  }\n\n  /**\n   * @param {number} [customStartIndex]\n   */\n  heapifyUp(customStartIndex) {\n    // Take the last element (last in array or the bottom left in a tree)\n    // in the heap container and lift it up until it is in the correct\n    // order with respect to its parent element.\n    let currentIndex = customStartIndex || this.heapContainer.length - 1;\n\n    while (\n      this.hasParent(currentIndex)\n      && !this.pairIsInCorrectOrder(this.parent(currentIndex), this.heapContainer[currentIndex])\n    ) {\n      this.swap(currentIndex, this.getParentIndex(currentIndex));\n      currentIndex = this.getParentIndex(currentIndex);\n    }\n  }\n\n  /**\n   * @param {number} [customStartIndex]\n   */\n  heapifyDown(customStartIndex = 0) {\n    // Compare the parent element to its children and swap parent with the appropriate\n    // child (smallest child for MinHeap, largest child for MaxHeap).\n    // Do the same for next children after swap.\n    let currentIndex = customStartIndex;\n    let nextIndex = null;\n\n    while (this.hasLeftChild(currentIndex)) {\n      if (\n        this.hasRightChild(currentIndex)\n        && this.pairIsInCorrectOrder(this.rightChild(currentIndex), this.leftChild(currentIndex))\n      ) {\n        nextIndex = this.getRightChildIndex(currentIndex);\n      } else {\n        nextIndex = this.getLeftChildIndex(currentIndex);\n      }\n\n      if (this.pairIsInCorrectOrder(\n        this.heapContainer[currentIndex],\n        this.heapContainer[nextIndex],\n      )) {\n        break;\n      }\n\n      this.swap(currentIndex, nextIndex);\n      currentIndex = nextIndex;\n    }\n  }\n\n  /**\n   * Checks if pair of heap elements is in correct order.\n   * For MinHeap the first element must be always smaller or equal.\n   * For MaxHeap the first element must be always bigger or equal.\n   *\n   * @param {*} firstElement\n   * @param {*} secondElement\n   * @return {boolean}\n   */\n  /* istanbul ignore next */\n  pairIsInCorrectOrder(firstElement, secondElement) {\n    throw new Error(`\n      You have to implement heap pair comparision method\n      for ${firstElement} and ${secondElement} values.\n    `);\n  }\n}\n","filetype":".js","index":265},{"title":"Max Heap","category":"heap","id":"MaxHeap_heap","algorithm":"import Heap from './Heap';\n\nexport default class MaxHeap extends Heap {\n  /**\n   * Checks if pair of heap elements is in correct order.\n   * For MinHeap the first element must be always smaller or equal.\n   * For MaxHeap the first element must be always bigger or equal.\n   *\n   * @param {*} firstElement\n   * @param {*} secondElement\n   * @return {boolean}\n   */\n  pairIsInCorrectOrder(firstElement, secondElement) {\n    return this.compare.greaterThanOrEqual(firstElement, secondElement);\n  }\n}\n","filetype":".js","index":266},{"title":"Min Heap","category":"heap","id":"MinHeap_heap","algorithm":"import Heap from './Heap';\n\nexport default class MinHeap extends Heap {\n  /**\n   * Checks if pair of heap elements is in correct order.\n   * For MinHeap the first element must be always smaller or equal.\n   * For MaxHeap the first element must be always bigger or equal.\n   *\n   * @param {*} firstElement\n   * @param {*} secondElement\n   * @return {boolean}\n   */\n  pairIsInCorrectOrder(firstElement, secondElement) {\n    return this.compare.lessThanOrEqual(firstElement, secondElement);\n  }\n}\n","filetype":".js","index":267},{"title":"Linked-list","category":"data-structures","id":"linked-list","algorithm":"# Linked List\n\n_Read this in other languages:_\n[_简体中文_](README.zh-CN.md),\n[_Русский_](README.ru-RU.md),\n[_日本語_](README.ja-JP.md),\n[_Português_](README.pt-BR.md),\n[_한국어_](README.ko-KR.md),\n[_Español_](README.es-ES.md),\n\nIn computer science, a **linked list** is a linear collection\nof data elements, in which linear order is not given by\ntheir physical placement in memory. Instead, each\nelement points to the next. It is a data structure\nconsisting of a group of nodes which together represent\na sequence. Under the simplest form, each node is\ncomposed of data and a reference (in other words,\na link) to the next node in the sequence. This structure\nallows for efficient insertion or removal of elements\nfrom any position in the sequence during iteration.\nMore complex variants add additional links, allowing\nefficient insertion or removal from arbitrary element\nreferences. A drawback of linked lists is that access\ntime is linear (and difficult to pipeline). Faster\naccess, such as random access, is not feasible. Arrays\nhave better cache locality as compared to linked lists.\n\n![Linked List](https://upload.wikimedia.org/wikipedia/commons/6/6d/Singly-linked-list.svg)\n\n## Pseudocode for Basic Operations\n\n### Insert\n\n```text\nAdd(value)\n  Pre: value is the value to add to the list\n  Post: value has been placed at the tail of the list\n  n ← node(value)\n  if head = ø\n    head ← n\n    tail ← n\n  else\n    tail.next ← n\n    tail ← n\n  end if\nend Add\n```\n\n```text\nPrepend(value)\n Pre: value is the value to add to the list\n Post: value has been placed at the head of the list\n n ← node(value)\n n.next ← head\n head ← n\n if tail = ø\n   tail ← n\n end\nend Prepend\n```\n\n### Search\n\n```text\nContains(head, value)\n  Pre: head is the head node in the list\n       value is the value to search for\n  Post: the item is either in the linked list, true; otherwise false\n  n ← head\n  while n != ø and n.value != value\n    n ← n.next\n  end while\n  if n = ø\n    return false\n  end if\n  return true\nend Contains\n```\n\n### Delete\n\n```text\nRemove(head, value)\n  Pre: head is the head node in the list\n       value is the value to remove from the list\n  Post: value is removed from the list, true, otherwise false\n  if head = ø\n    return false\n  end if\n  n ← head\n  if n.value = value\n    if head = tail\n      head ← ø\n      tail ← ø\n    else\n      head ← head.next\n    end if\n    return true\n  end if\n  while n.next != ø and n.next.value != value\n    n ← n.next\n  end while\n  if n.next != ø\n    if n.next = tail\n      tail ← n\n      tail.next = null\n    end if\n    n.next ← n.next.next\n    return true\n  end if\n  return false\nend Remove\n```\n\n### Traverse\n\n```text\nTraverse(head)\n  Pre: head is the head node in the list\n  Post: the items in the list have been traversed\n  n ← head\n  while n != ø\n    yield n.value\n    n ← n.next\n  end while\nend Traverse\n```\n\n### Traverse in Reverse\n\n```text\nReverseTraversal(head, tail)\n  Pre: head and tail belong to the same list\n  Post: the items in the list have been traversed in reverse order\n  if tail != ø\n    curr ← tail\n    while curr != head\n      prev ← head\n      while prev.next != curr\n        prev ← prev.next\n      end while\n      yield curr.value\n      curr ← prev\n    end while\n   yield curr.value\n  end if\nend ReverseTraversal\n```\n\n## Complexities\n\n### Time Complexity\n\n| Access    | Search    | Insertion | Deletion  |\n| :-------: | :-------: | :-------: | :-------: |\n| O(n)      | O(n)      | O(1)      | O(n)      |\n\n### Space Complexity\n\nO(n)\n\n## References\n\n- [Wikipedia](https://en.wikipedia.org/wiki/Linked_list)\n- [YouTube](https://www.youtube.com/watch?v=njTh_OwMljA&index=2&t=1s&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\n","filetype":".md","index":268},{"title":"Linked List","category":"linked-list","id":"LinkedList_linked-list","algorithm":"import LinkedListNode from './LinkedListNode';\nimport Comparator from '../../utils/comparator/Comparator';\n\nexport default class LinkedList {\n  /**\n   * @param {Function} [comparatorFunction]\n   */\n  constructor(comparatorFunction) {\n    /** @var LinkedListNode */\n    this.head = null;\n\n    /** @var LinkedListNode */\n    this.tail = null;\n\n    this.compare = new Comparator(comparatorFunction);\n  }\n\n  /**\n   * @param {*} value\n   * @return {LinkedList}\n   */\n  prepend(value) {\n    // Make new node to be a head.\n    const newNode = new LinkedListNode(value, this.head);\n    this.head = newNode;\n\n    // If there is no tail yet let's make new node a tail.\n    if (!this.tail) {\n      this.tail = newNode;\n    }\n\n    return this;\n  }\n\n  /**\n   * @param {*} value\n   * @return {LinkedList}\n   */\n  append(value) {\n    const newNode = new LinkedListNode(value);\n\n    // If there is no head yet let's make new node a head.\n    if (!this.head) {\n      this.head = newNode;\n      this.tail = newNode;\n\n      return this;\n    }\n\n    // Attach new node to the end of linked list.\n    this.tail.next = newNode;\n    this.tail = newNode;\n\n    return this;\n  }\n\n  /**\n   * @param {*} value\n   * @return {LinkedListNode}\n   */\n  delete(value) {\n    if (!this.head) {\n      return null;\n    }\n\n    let deletedNode = null;\n\n    // If the head must be deleted then make next node that is different\n    // from the head to be a new head.\n    while (this.head && this.compare.equal(this.head.value, value)) {\n      deletedNode = this.head;\n      this.head = this.head.next;\n    }\n\n    let currentNode = this.head;\n\n    if (currentNode !== null) {\n      // If next node must be deleted then make next node to be a next next one.\n      while (currentNode.next) {\n        if (this.compare.equal(currentNode.next.value, value)) {\n          deletedNode = currentNode.next;\n          currentNode.next = currentNode.next.next;\n        } else {\n          currentNode = currentNode.next;\n        }\n      }\n    }\n\n    // Check if tail must be deleted.\n    if (this.compare.equal(this.tail.value, value)) {\n      this.tail = currentNode;\n    }\n\n    return deletedNode;\n  }\n\n  /**\n   * @param {Object} findParams\n   * @param {*} findParams.value\n   * @param {function} [findParams.callback]\n   * @return {LinkedListNode}\n   */\n  find({ value = undefined, callback = undefined }) {\n    if (!this.head) {\n      return null;\n    }\n\n    let currentNode = this.head;\n\n    while (currentNode) {\n      // If callback is specified then try to find node by callback.\n      if (callback && callback(currentNode.value)) {\n        return currentNode;\n      }\n\n      // If value is specified then try to compare by value..\n      if (value !== undefined && this.compare.equal(currentNode.value, value)) {\n        return currentNode;\n      }\n\n      currentNode = currentNode.next;\n    }\n\n    return null;\n  }\n\n  /**\n   * @return {LinkedListNode}\n   */\n  deleteTail() {\n    const deletedTail = this.tail;\n\n    if (this.head === this.tail) {\n      // There is only one node in linked list.\n      this.head = null;\n      this.tail = null;\n\n      return deletedTail;\n    }\n\n    // If there are many nodes in linked list...\n\n    // Rewind to the last node and delete \"next\" link for the node before the last one.\n    let currentNode = this.head;\n    while (currentNode.next) {\n      if (!currentNode.next.next) {\n        currentNode.next = null;\n      } else {\n        currentNode = currentNode.next;\n      }\n    }\n\n    this.tail = currentNode;\n\n    return deletedTail;\n  }\n\n  /**\n   * @return {LinkedListNode}\n   */\n  deleteHead() {\n    if (!this.head) {\n      return null;\n    }\n\n    const deletedHead = this.head;\n\n    if (this.head.next) {\n      this.head = this.head.next;\n    } else {\n      this.head = null;\n      this.tail = null;\n    }\n\n    return deletedHead;\n  }\n\n  /**\n   * @param {*[]} values - Array of values that need to be converted to linked list.\n   * @return {LinkedList}\n   */\n  fromArray(values) {\n    values.forEach((value) => this.append(value));\n\n    return this;\n  }\n\n  /**\n   * @return {LinkedListNode[]}\n   */\n  toArray() {\n    const nodes = [];\n\n    let currentNode = this.head;\n    while (currentNode) {\n      nodes.push(currentNode);\n      currentNode = currentNode.next;\n    }\n\n    return nodes;\n  }\n\n  /**\n   * @param {function} [callback]\n   * @return {string}\n   */\n  toString(callback) {\n    return this.toArray().map((node) => node.toString(callback)).toString();\n  }\n\n  /**\n   * Reverse a linked list.\n   * @returns {LinkedList}\n   */\n  reverse() {\n    let currNode = this.head;\n    let prevNode = null;\n    let nextNode = null;\n\n    while (currNode) {\n      // Store next node.\n      nextNode = currNode.next;\n\n      // Change next node of the current node so it would link to previous node.\n      currNode.next = prevNode;\n\n      // Move prevNode and currNode nodes one step forward.\n      prevNode = currNode;\n      currNode = nextNode;\n    }\n\n    // Reset head and tail.\n    this.tail = this.head;\n    this.head = prevNode;\n\n    return this;\n  }\n}\n","filetype":".js","index":269},{"title":"Linked List Node","category":"linked-list","id":"LinkedListNode_linked-list","algorithm":"export default class LinkedListNode {\n  constructor(value, next = null) {\n    this.value = value;\n    this.next = next;\n  }\n\n  toString(callback) {\n    return callback ? callback(this.value) : `${this.value}`;\n  }\n}\n","filetype":".js","index":270},{"title":"Priority-queue","category":"data-structures","id":"priority-queue","algorithm":"# Priority Queue\n\n_Read this in other languages:_\n[_简体中文_](README.zh-CN.md),\n[_Русский_](README.ru-RU.md),\n[_日本語_](README.ja-JP.md),\n[_Français_](README.fr-FR.md),\n[_Português_](README.pt-BR.md)\n\nIn computer science, a **priority queue** is an abstract data type \nwhich is like a regular queue or stack data structure, but where \nadditionally each element has a \"priority\" associated with it. \nIn a priority queue, an element with high priority is served before \nan element with low priority. If two elements have the same \npriority, they are served according to their order in the queue.\n\nWhile priority queues are often implemented with heaps, they are \nconceptually distinct from heaps. A priority queue is an abstract \nconcept like \"a list\" or \"a map\"; just as a list can be implemented\nwith a linked list or an array, a priority queue can be implemented\nwith a heap or a variety of other methods such as an unordered \narray.\n\n## References\n\n- [Wikipedia](https://en.wikipedia.org/wiki/Priority_queue)\n- [YouTube](https://www.youtube.com/watch?v=wptevk0bshY&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8&index=6)\n","filetype":".md","index":271},{"title":"Priority Queue","category":"priority-queue","id":"PriorityQueue_priority-queue","algorithm":"import MinHeap from '../heap/MinHeap';\nimport Comparator from '../../utils/comparator/Comparator';\n\n// It is the same as min heap except that when comparing two elements\n// we take into account its priority instead of the element's value.\nexport default class PriorityQueue extends MinHeap {\n  constructor() {\n    // Call MinHip constructor first.\n    super();\n\n    // Setup priorities map.\n    this.priorities = new Map();\n\n    // Use custom comparator for heap elements that will take element priority\n    // instead of element value into account.\n    this.compare = new Comparator(this.comparePriority.bind(this));\n  }\n\n  /**\n   * Add item to the priority queue.\n   * @param {*} item - item we're going to add to the queue.\n   * @param {number} [priority] - items priority.\n   * @return {PriorityQueue}\n   */\n  add(item, priority = 0) {\n    this.priorities.set(item, priority);\n    super.add(item);\n    return this;\n  }\n\n  /**\n   * Remove item from priority queue.\n   * @param {*} item - item we're going to remove.\n   * @param {Comparator} [customFindingComparator] - custom function for finding the item to remove\n   * @return {PriorityQueue}\n   */\n  remove(item, customFindingComparator) {\n    super.remove(item, customFindingComparator);\n    this.priorities.delete(item);\n    return this;\n  }\n\n  /**\n   * Change priority of the item in a queue.\n   * @param {*} item - item we're going to re-prioritize.\n   * @param {number} priority - new item's priority.\n   * @return {PriorityQueue}\n   */\n  changePriority(item, priority) {\n    this.remove(item, new Comparator(this.compareValue));\n    this.add(item, priority);\n    return this;\n  }\n\n  /**\n   * Find item by ite value.\n   * @param {*} item\n   * @return {Number[]}\n   */\n  findByValue(item) {\n    return this.find(item, new Comparator(this.compareValue));\n  }\n\n  /**\n   * Check if item already exists in a queue.\n   * @param {*} item\n   * @return {boolean}\n   */\n  hasValue(item) {\n    return this.findByValue(item).length > 0;\n  }\n\n  /**\n   * Compares priorities of two items.\n   * @param {*} a\n   * @param {*} b\n   * @return {number}\n   */\n  comparePriority(a, b) {\n    if (this.priorities.get(a) === this.priorities.get(b)) {\n      return 0;\n    }\n    return this.priorities.get(a) < this.priorities.get(b) ? -1 : 1;\n  }\n\n  /**\n   * Compares values of two items.\n   * @param {*} a\n   * @param {*} b\n   * @return {number}\n   */\n  compareValue(a, b) {\n    if (a === b) {\n      return 0;\n    }\n    return a < b ? -1 : 1;\n  }\n}\n","filetype":".js","index":272},{"title":"Queue","category":"data-structures","id":"queue","algorithm":"# Queue\n\n_Read this in other languages:_\n[_简体中文_](README.zh-CN.md),\n[_Русский_](README.ru-RU.md),\n[_日本語_](README.ja-JP.md),\n[_Français_](README.fr-FR.md),\n[_Português_](README.pt-BR.md)\n\nIn computer science, a **queue** is a particular kind of abstract data \ntype or collection in which the entities in the collection are \nkept in order and the principle (or only) operations on the \ncollection are the addition of entities to the rear terminal \nposition, known as enqueue, and removal of entities from the \nfront terminal position, known as dequeue. This makes the queue \na First-In-First-Out (FIFO) data structure. In a FIFO data \nstructure, the first element added to the queue will be the \nfirst one to be removed. This is equivalent to the requirement \nthat once a new element is added, all elements that were added \nbefore have to be removed before the new element can be removed. \nOften a peek or front operation is also entered, returning the \nvalue of the front element without dequeuing it. A queue is an \nexample of a linear data structure, or more abstractly a \nsequential collection.\n\nRepresentation of a FIFO (first in, first out) queue\n\n![Queue](https://upload.wikimedia.org/wikipedia/commons/5/52/Data_Queue.svg)\n\n## References\n\n- [Wikipedia](https://en.wikipedia.org/wiki/Queue_(abstract_data_type))\n- [YouTube](https://www.youtube.com/watch?v=wjI1WNcIntg&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8&index=3&)\n","filetype":".md","index":273},{"title":"Queue","category":"queue","id":"Queue_queue","algorithm":"import LinkedList from '../linked-list/LinkedList';\n\nexport default class Queue {\n  constructor() {\n    // We're going to implement Queue based on LinkedList since the two\n    // structures are quite similar. Namely, they both operate mostly on\n    // the elements at the beginning and the end. Compare enqueue/dequeue\n    // operations of Queue with append/deleteHead operations of LinkedList.\n    this.linkedList = new LinkedList();\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isEmpty() {\n    return !this.linkedList.head;\n  }\n\n  /**\n   * Read the element at the front of the queue without removing it.\n   * @return {*}\n   */\n  peek() {\n    if (!this.linkedList.head) {\n      return null;\n    }\n\n    return this.linkedList.head.value;\n  }\n\n  /**\n   * Add a new element to the end of the queue (the tail of the linked list).\n   * This element will be processed after all elements ahead of it.\n   * @param {*} value\n   */\n  enqueue(value) {\n    this.linkedList.append(value);\n  }\n\n  /**\n   * Remove the element at the front of the queue (the head of the linked list).\n   * If the queue is empty, return null.\n   * @return {*}\n   */\n  dequeue() {\n    const removedHead = this.linkedList.deleteHead();\n    return removedHead ? removedHead.value : null;\n  }\n\n  /**\n   * @param [callback]\n   * @return {string}\n   */\n  toString(callback) {\n    // Return string representation of the queue's linked list.\n    return this.linkedList.toString(callback);\n  }\n}\n","filetype":".js","index":274},{"title":"Stack","category":"data-structures","id":"stack","algorithm":"# Stack\n\n_Read this in other languages:_\n[_简体中文_](README.zh-CN.md),\n[_Русский_](README.ru-RU.md),\n[_日本語_](README.ja-JP.md),\n[_Français_](README.fr-FR.md),\n[_Português_](README.pt-BR.md)\n\nIn computer science, a **stack** is an abstract data type that serves \nas a collection of elements, with two principal operations:\n\n* **push**, which adds an element to the collection, and\n* **pop**, which removes the most recently added element that was not yet removed.\n\nThe order in which elements come off a stack gives rise to its \nalternative name, LIFO (last in, first out). Additionally, a \npeek operation may give access to the top without modifying \nthe stack. The name \"stack\" for this type of structure comes \nfrom the analogy to a set of physical items stacked on top of \neach other, which makes it easy to take an item off the top \nof the stack, while getting to an item deeper in the stack \nmay require taking off multiple other items first.\n\nSimple representation of a stack runtime with push and pop operations.\n\n![Stack](https://upload.wikimedia.org/wikipedia/commons/b/b4/Lifo_stack.png)\n\n## References\n\n- [Wikipedia](https://en.wikipedia.org/wiki/Stack_(abstract_data_type))\n- [YouTube](https://www.youtube.com/watch?v=wjI1WNcIntg&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8&index=3&)\n","filetype":".md","index":275},{"title":"Stack","category":"stack","id":"Stack_stack","algorithm":"import LinkedList from '../linked-list/LinkedList';\n\nexport default class Stack {\n  constructor() {\n    // We're going to implement Stack based on LinkedList since these\n    // structures are quite similar. Compare push/pop operations of the Stack\n    // with prepend/deleteHead operations of LinkedList.\n    this.linkedList = new LinkedList();\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isEmpty() {\n    // The stack is empty if its linked list doesn't have a head.\n    return !this.linkedList.head;\n  }\n\n  /**\n   * @return {*}\n   */\n  peek() {\n    if (this.isEmpty()) {\n      // If the linked list is empty then there is nothing to peek from.\n      return null;\n    }\n\n    // Just read the value from the start of linked list without deleting it.\n    return this.linkedList.head.value;\n  }\n\n  /**\n   * @param {*} value\n   */\n  push(value) {\n    // Pushing means to lay the value on top of the stack. Therefore let's just add\n    // the new value at the start of the linked list.\n    this.linkedList.prepend(value);\n  }\n\n  /**\n   * @return {*}\n   */\n  pop() {\n    // Let's try to delete the first node (the head) from the linked list.\n    // If there is no head (the linked list is empty) just return null.\n    const removedHead = this.linkedList.deleteHead();\n    return removedHead ? removedHead.value : null;\n  }\n\n  /**\n   * @return {*[]}\n   */\n  toArray() {\n    return this.linkedList\n      .toArray()\n      .map((linkedListNode) => linkedListNode.value);\n  }\n\n  /**\n   * @param {function} [callback]\n   * @return {string}\n   */\n  toString(callback) {\n    return this.linkedList.toString(callback);\n  }\n}\n","filetype":".js","index":276},{"title":"Tree","category":"data-structures","id":"tree","algorithm":"# Tree\n\n_Read this in other languages:_\n[_简体中文_](README.zh-CN.md),\n[_Português_](README.pt-BR.md)\n\n* [Binary Search Tree](binary-search-tree)\n* [AVL Tree](avl-tree)\n* [Red-Black Tree](red-black-tree)\n* [Segment Tree](segment-tree) - with min/max/sum range queries examples\n* [Fenwick Tree](fenwick-tree) (Binary Indexed Tree)\n\nIn computer science, a **tree** is a widely used abstract data \ntype (ADT) — or data structure implementing this ADT—that \nsimulates a hierarchical tree structure, with a root value \nand subtrees of children with a parent node, represented as \na set of linked nodes.\n\nA tree data structure can be defined recursively (locally) \nas a collection of nodes (starting at a root node), where \neach node is a data structure consisting of a value, \ntogether with a list of references to nodes (the \"children\"), \nwith the constraints that no reference is duplicated, and none \npoints to the root.\n\nA simple unordered tree; in this diagram, the node labeled 7 has\ntwo children, labeled 2 and 6, and one parent, labeled 2. The\nroot node, at the top, has no parent.\n\n![Tree](https://upload.wikimedia.org/wikipedia/commons/f/f7/Binary_tree.svg)\n\n## References\n\n- [Wikipedia](https://en.wikipedia.org/wiki/Tree_(data_structure))\n- [YouTube](https://www.youtube.com/watch?v=oSWTXtMglKE&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8&index=8)\n","filetype":".md","index":277},{"title":"Binary Tree Node","category":"tree","id":"BinaryTreeNode_tree","algorithm":"import Comparator from '../../utils/comparator/Comparator';\nimport HashTable from '../hash-table/HashTable';\n\nexport default class BinaryTreeNode {\n  /**\n   * @param {*} [value] - node value.\n   */\n  constructor(value = null) {\n    this.left = null;\n    this.right = null;\n    this.parent = null;\n    this.value = value;\n\n    // Any node related meta information may be stored here.\n    this.meta = new HashTable();\n\n    // This comparator is used to compare binary tree nodes with each other.\n    this.nodeComparator = new Comparator();\n  }\n\n  /**\n   * @return {number}\n   */\n  get leftHeight() {\n    if (!this.left) {\n      return 0;\n    }\n\n    return this.left.height + 1;\n  }\n\n  /**\n   * @return {number}\n   */\n  get rightHeight() {\n    if (!this.right) {\n      return 0;\n    }\n\n    return this.right.height + 1;\n  }\n\n  /**\n   * @return {number}\n   */\n  get height() {\n    return Math.max(this.leftHeight, this.rightHeight);\n  }\n\n  /**\n   * @return {number}\n   */\n  get balanceFactor() {\n    return this.leftHeight - this.rightHeight;\n  }\n\n  /**\n   * Get parent's sibling if it exists.\n   * @return {BinaryTreeNode}\n   */\n  get uncle() {\n    // Check if current node has parent.\n    if (!this.parent) {\n      return undefined;\n    }\n\n    // Check if current node has grand-parent.\n    if (!this.parent.parent) {\n      return undefined;\n    }\n\n    // Check if grand-parent has two children.\n    if (!this.parent.parent.left || !this.parent.parent.right) {\n      return undefined;\n    }\n\n    // So for now we know that current node has grand-parent and this\n    // grand-parent has two children. Let's find out who is the uncle.\n    if (this.nodeComparator.equal(this.parent, this.parent.parent.left)) {\n      // Right one is an uncle.\n      return this.parent.parent.right;\n    }\n\n    // Left one is an uncle.\n    return this.parent.parent.left;\n  }\n\n  /**\n   * @param {*} value\n   * @return {BinaryTreeNode}\n   */\n  setValue(value) {\n    this.value = value;\n\n    return this;\n  }\n\n  /**\n   * @param {BinaryTreeNode} node\n   * @return {BinaryTreeNode}\n   */\n  setLeft(node) {\n    // Reset parent for left node since it is going to be detached.\n    if (this.left) {\n      this.left.parent = null;\n    }\n\n    // Attach new node to the left.\n    this.left = node;\n\n    // Make current node to be a parent for new left one.\n    if (this.left) {\n      this.left.parent = this;\n    }\n\n    return this;\n  }\n\n  /**\n   * @param {BinaryTreeNode} node\n   * @return {BinaryTreeNode}\n   */\n  setRight(node) {\n    // Reset parent for right node since it is going to be detached.\n    if (this.right) {\n      this.right.parent = null;\n    }\n\n    // Attach new node to the right.\n    this.right = node;\n\n    // Make current node to be a parent for new right one.\n    if (node) {\n      this.right.parent = this;\n    }\n\n    return this;\n  }\n\n  /**\n   * @param {BinaryTreeNode} nodeToRemove\n   * @return {boolean}\n   */\n  removeChild(nodeToRemove) {\n    if (this.left && this.nodeComparator.equal(this.left, nodeToRemove)) {\n      this.left = null;\n      return true;\n    }\n\n    if (this.right && this.nodeComparator.equal(this.right, nodeToRemove)) {\n      this.right = null;\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * @param {BinaryTreeNode} nodeToReplace\n   * @param {BinaryTreeNode} replacementNode\n   * @return {boolean}\n   */\n  replaceChild(nodeToReplace, replacementNode) {\n    if (!nodeToReplace || !replacementNode) {\n      return false;\n    }\n\n    if (this.left && this.nodeComparator.equal(this.left, nodeToReplace)) {\n      this.left = replacementNode;\n      return true;\n    }\n\n    if (this.right && this.nodeComparator.equal(this.right, nodeToReplace)) {\n      this.right = replacementNode;\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * @param {BinaryTreeNode} sourceNode\n   * @param {BinaryTreeNode} targetNode\n   */\n  static copyNode(sourceNode, targetNode) {\n    targetNode.setValue(sourceNode.value);\n    targetNode.setLeft(sourceNode.left);\n    targetNode.setRight(sourceNode.right);\n  }\n\n  /**\n   * @return {*[]}\n   */\n  traverseInOrder() {\n    let traverse = [];\n\n    // Add left node.\n    if (this.left) {\n      traverse = traverse.concat(this.left.traverseInOrder());\n    }\n\n    // Add root.\n    traverse.push(this.value);\n\n    // Add right node.\n    if (this.right) {\n      traverse = traverse.concat(this.right.traverseInOrder());\n    }\n\n    return traverse;\n  }\n\n  /**\n   * @return {string}\n   */\n  toString() {\n    return this.traverseInOrder().toString();\n  }\n}\n","filetype":".js","index":278},{"title":"Avl-tree","category":"tree","id":"avl-tree","algorithm":"# AVL Tree\n\n_Read this in other languages:_\n[_Português_](README.pt-BR.md)\n\nIn computer science, an **AVL tree** (named after inventors \nAdelson-Velsky and Landis) is a self-balancing binary search \ntree. It was the first such data structure to be invented. \nIn an AVL tree, the heights of the two child subtrees of any\nnode differ by at most one; if at any time they differ by \nmore than one, rebalancing is done to restore this property.\nLookup, insertion, and deletion all take `O(log n)` time in \nboth the average and worst cases, where n is the number of \nnodes in the tree prior to the operation. Insertions and \ndeletions may require the tree to be rebalanced by one or \nmore tree rotations.\n\nAnimation showing the insertion of several elements into an AVL \ntree. It includes left, right, left-right and right-left rotations.\n\n![AVL Tree](https://upload.wikimedia.org/wikipedia/commons/f/fd/AVL_Tree_Example.gif)\n\nAVL tree with balance factors (green)\n\n![AVL Tree](https://upload.wikimedia.org/wikipedia/commons/a/ad/AVL-tree-wBalance_K.svg)\n\n### AVL Tree Rotations\n\n**Left-Left Rotation**\n\n![Left-Left Rotation](http://btechsmartclass.com/data_structures/ds_images/LL%20Rotation.png)\n\n**Right-Right Rotation**\n\n![Right-Right Rotation](http://btechsmartclass.com/data_structures/ds_images/RR%20Rotation.png)\n\n**Left-Right Rotation**\n\n![Left-Right Rotation](http://btechsmartclass.com/data_structures/ds_images/LR%20Rotation.png)\n\n**Right-Left Rotation**\n\n![Right-Right Rotation](http://btechsmartclass.com/data_structures/ds_images/RL%20Rotation.png)\n\n## References\n\n* [Wikipedia](https://en.wikipedia.org/wiki/AVL_tree)\n* [Tutorials Point](https://www.tutorialspoint.com/data_structures_algorithms/avl_tree_algorithm.htm)\n* [BTech](http://btechsmartclass.com/data_structures/avl-trees.html)\n* [AVL Tree Insertion on YouTube](https://www.youtube.com/watch?v=rbg7Qf8GkQ4&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8&index=12&)\n* [AVL Tree Interactive Visualisations](https://www.cs.usfca.edu/~galles/visualization/AVLtree.html)\n","filetype":".md","index":279},{"title":"Avl Tree","category":"avl-tree","id":"AvlTree_avl-tree","algorithm":"import BinarySearchTree from '../binary-search-tree/BinarySearchTree';\n\nexport default class AvlTree extends BinarySearchTree {\n  /**\n   * @param {*} value\n   */\n  insert(value) {\n    // Do the normal BST insert.\n    super.insert(value);\n\n    // Let's move up to the root and check balance factors along the way.\n    let currentNode = this.root.find(value);\n    while (currentNode) {\n      this.balance(currentNode);\n      currentNode = currentNode.parent;\n    }\n  }\n\n  /**\n   * @param {*} value\n   * @return {boolean}\n   */\n  remove(value) {\n    // Do standard BST removal.\n    super.remove(value);\n\n    // Balance the tree starting from the root node.\n    this.balance(this.root);\n  }\n\n  /**\n   * @param {BinarySearchTreeNode} node\n   */\n  balance(node) {\n    // If balance factor is not OK then try to balance the node.\n    if (node.balanceFactor > 1) {\n      // Left rotation.\n      if (node.left.balanceFactor > 0) {\n        // Left-Left rotation\n        this.rotateLeftLeft(node);\n      } else if (node.left.balanceFactor < 0) {\n        // Left-Right rotation.\n        this.rotateLeftRight(node);\n      }\n    } else if (node.balanceFactor < -1) {\n      // Right rotation.\n      if (node.right.balanceFactor < 0) {\n        // Right-Right rotation\n        this.rotateRightRight(node);\n      } else if (node.right.balanceFactor > 0) {\n        // Right-Left rotation.\n        this.rotateRightLeft(node);\n      }\n    }\n  }\n\n  /**\n   * @param {BinarySearchTreeNode} rootNode\n   */\n  rotateLeftLeft(rootNode) {\n    // Detach left node from root node.\n    const leftNode = rootNode.left;\n    rootNode.setLeft(null);\n\n    // Make left node to be a child of rootNode's parent.\n    if (rootNode.parent) {\n      rootNode.parent.setLeft(leftNode);\n    } else if (rootNode === this.root) {\n      // If root node is root then make left node to be a new root.\n      this.root = leftNode;\n    }\n\n    // If left node has a right child then detach it and\n    // attach it as a left child for rootNode.\n    if (leftNode.right) {\n      rootNode.setLeft(leftNode.right);\n    }\n\n    // Attach rootNode to the right of leftNode.\n    leftNode.setRight(rootNode);\n  }\n\n  /**\n   * @param {BinarySearchTreeNode} rootNode\n   */\n  rotateLeftRight(rootNode) {\n    // Detach left node from rootNode since it is going to be replaced.\n    const leftNode = rootNode.left;\n    rootNode.setLeft(null);\n\n    // Detach right node from leftNode.\n    const leftRightNode = leftNode.right;\n    leftNode.setRight(null);\n\n    // Preserve leftRightNode's left subtree.\n    if (leftRightNode.left) {\n      leftNode.setRight(leftRightNode.left);\n      leftRightNode.setLeft(null);\n    }\n\n    // Attach leftRightNode to the rootNode.\n    rootNode.setLeft(leftRightNode);\n\n    // Attach leftNode as left node for leftRight node.\n    leftRightNode.setLeft(leftNode);\n\n    // Do left-left rotation.\n    this.rotateLeftLeft(rootNode);\n  }\n\n  /**\n   * @param {BinarySearchTreeNode} rootNode\n   */\n  rotateRightLeft(rootNode) {\n    // Detach right node from rootNode since it is going to be replaced.\n    const rightNode = rootNode.right;\n    rootNode.setRight(null);\n\n    // Detach left node from rightNode.\n    const rightLeftNode = rightNode.left;\n    rightNode.setLeft(null);\n\n    if (rightLeftNode.right) {\n      rightNode.setLeft(rightLeftNode.right);\n      rightLeftNode.setRight(null);\n    }\n\n    // Attach rightLeftNode to the rootNode.\n    rootNode.setRight(rightLeftNode);\n\n    // Attach rightNode as right node for rightLeft node.\n    rightLeftNode.setRight(rightNode);\n\n    // Do right-right rotation.\n    this.rotateRightRight(rootNode);\n  }\n\n  /**\n   * @param {BinarySearchTreeNode} rootNode\n   */\n  rotateRightRight(rootNode) {\n    // Detach right node from root node.\n    const rightNode = rootNode.right;\n    rootNode.setRight(null);\n\n    // Make right node to be a child of rootNode's parent.\n    if (rootNode.parent) {\n      rootNode.parent.setRight(rightNode);\n    } else if (rootNode === this.root) {\n      // If root node is root then make right node to be a new root.\n      this.root = rightNode;\n    }\n\n    // If right node has a left child then detach it and\n    // attach it as a right child for rootNode.\n    if (rightNode.left) {\n      rootNode.setRight(rightNode.left);\n    }\n\n    // Attach rootNode to the left of rightNode.\n    rightNode.setLeft(rootNode);\n  }\n}\n","filetype":".js","index":280},{"title":"Binary-search-tree","category":"tree","id":"binary-search-tree","algorithm":"# Binary Search Tree\n\n_Read this in other languages:_\n[_Português_](README.pt-BR.md)\n\nIn computer science, **binary search trees** (BST), sometimes called \nordered or sorted binary trees, are a particular type of container: \ndata structures that store \"items\" (such as numbers, names etc.) \nin memory. They allow fast lookup, addition and removal of \nitems, and can be used to implement either dynamic sets of \nitems, or lookup tables that allow finding an item by its key \n(e.g., finding the phone number of a person by name).\n\nBinary search trees keep their keys in sorted order, so that lookup \nand other operations can use the principle of binary search: \nwhen looking for a key in a tree (or a place to insert a new key), \nthey traverse the tree from root to leaf, making comparisons to \nkeys stored in the nodes of the tree and deciding, on the basis \nof the comparison, to continue searching in the left or right \nsubtrees. On average, this means that each comparison allows \nthe operations to skip about half of the tree, so that each \nlookup, insertion or deletion takes time proportional to the \nlogarithm of the number of items stored in the tree. This is \nmuch better than the linear time required to find items by key \nin an (unsorted) array, but slower than the corresponding \noperations on hash tables.\n\nA binary search tree of size 9 and depth 3, with 8 at the root.\nThe leaves are not drawn.\n\n![Binary Search Tree](https://upload.wikimedia.org/wikipedia/commons/d/da/Binary_search_tree.svg)\n\n## Pseudocode for Basic Operations\n\n### Insertion\n\n```text\ninsert(value)\n  Pre: value has passed custom type checks for type T\n  Post: value has been placed in the correct location in the tree\n  if root = ø\n    root ← node(value)\n  else\n    insertNode(root, value)\n  end if\nend insert\n```\n    \n```text\ninsertNode(current, value)\n  Pre: current is the node to start from\n  Post: value has been placed in the correct location in the tree\n  if value < current.value\n    if current.left = ø\n      current.left ← node(value)\n    else\n      InsertNode(current.left, value)\n    end if\n  else\n    if current.right = ø\n      current.right ← node(value)\n    else\n      InsertNode(current.right, value)\n    end if\n  end if\nend insertNode\n```\n\n### Searching\n\n```text\ncontains(root, value)\n  Pre: root is the root node of the tree, value is what we would like to locate\n  Post: value is either located or not\n  if root = ø\n    return false\n  end if\n  if root.value = value\n    return true\n  else if value < root.value\n    return contains(root.left, value)\n  else\n    return contains(root.right, value)\n  end if\nend contains\n```\n    \n     \n### Deletion\n\n```text\nremove(value)\n  Pre: value is the value of the node to remove, root is the node of the BST\n      count is the number of items in the BST\n  Post: node with value is removed if found in which case yields true, otherwise false\n  nodeToRemove ← findNode(value)\n  if nodeToRemove = ø\n    return false\n  end if\n  parent ← findParent(value)\n  if count = 1\n    root ← ø\n  else if nodeToRemove.left = ø and nodeToRemove.right = ø\n    if nodeToRemove.value < parent.value\n      parent.left ←  nodeToRemove.right\n    else\n      parent.right ← nodeToRemove.right\n    end if\n  else if nodeToRemove.left != ø and nodeToRemove.right != ø\n    next ← nodeToRemove.right\n    while next.left != ø\n      next ← next.left\n    end while\n    if next != nodeToRemove.right\n      remove(next.value)\n      nodeToRemove.value ← next.value\n    else\n      nodeToRemove.value ← next.value\n      nodeToRemove.right ← nodeToRemove.right.right\n    end if\n  else\n    if nodeToRemove.left = ø\n      next ← nodeToRemove.right\n    else\n      next ← nodeToRemove.left\n    end if\n    if root = nodeToRemove\n      root = next\n    else if parent.left = nodeToRemove\n      parent.left = next\n    else if parent.right = nodeToRemove\n      parent.right = next\n    end if\n  end if\n  count ← count - 1\n  return true\nend remove\n```\n\n### Find Parent of Node\n\n```text\nfindParent(value, root)\n  Pre: value is the value of the node we want to find the parent of\n       root is the root node of the BST and is != ø\n  Post: a reference to the prent node of value if found; otherwise ø\n  if value = root.value\n    return ø\n  end if\n  if value < root.value\n    if root.left = ø\n      return ø\n    else if root.left.value = value\n      return root\n    else\n      return findParent(value, root.left)\n    end if\n  else\n    if root.right = ø\n      return ø\n    else if root.right.value = value\n      return root\n    else\n      return findParent(value, root.right)\n    end if\n  end if\nend findParent\n```\n\n### Find Node\n\n```text\nfindNode(root, value)\n  Pre: value is the value of the node we want to find the parent of\n       root is the root node of the BST\n  Post: a reference to the node of value if found; otherwise ø\n  if root = ø\n    return ø\n  end if\n  if root.value = value\n    return root\n  else if value < root.value\n    return findNode(root.left, value)\n  else\n    return findNode(root.right, value)\n  end if\nend findNode\n```\n    \n### Find Minimum\n\n```text\nfindMin(root)\n  Pre: root is the root node of the BST\n    root = ø\n  Post: the smallest value in the BST is located\n  if root.left = ø\n    return root.value\n  end if\n  findMin(root.left)\nend findMin\n```\n    \n### Find Maximum\n\n```text\nfindMax(root)\n  Pre: root is the root node of the BST\n    root = ø\n  Post: the largest value in the BST is located\n  if root.right = ø\n    return root.value\n  end if\n  findMax(root.right)\nend findMax\n```\n    \n### Traversal\n\n#### InOrder Traversal\n\n```text\ninorder(root)\n  Pre: root is the root node of the BST\n  Post: the nodes in the BST have been visited in inorder\n  if root != ø\n    inorder(root.left)\n    yield root.value\n    inorder(root.right)\n  end if\nend inorder\n```\n\n#### PreOrder Traversal\n\n```text\npreorder(root)\n  Pre: root is the root node of the BST\n  Post: the nodes in the BST have been visited in preorder\n  if root != ø\n    yield root.value\n    preorder(root.left)\n    preorder(root.right)\n  end if\nend preorder\n```\n   \n#### PostOrder Traversal\n\n```text\npostorder(root)\n  Pre: root is the root node of the BST\n  Post: the nodes in the BST have been visited in postorder\n  if root != ø\n    postorder(root.left)\n    postorder(root.right)\n    yield root.value\n  end if\nend postorder\n```\n     \n## Complexities\n\n### Time Complexity\n\n| Access    | Search    | Insertion | Deletion  |\n| :-------: | :-------: | :-------: | :-------: |\n| O(log(n)) | O(log(n)) | O(log(n)) | O(log(n)) |\n\n### Space Complexity\n\nO(n)\n\n## References\n\n- [Wikipedia](https://en.wikipedia.org/wiki/Binary_search_tree)\n- [Inserting to BST on YouTube](https://www.youtube.com/watch?v=wcIRPqTR3Kc&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8&index=9&t=0s)\n- [BST Interactive Visualisations](https://www.cs.usfca.edu/~galles/visualization/BST.html)\n","filetype":".md","index":281},{"title":"Binary Search Tree","category":"binary-search-tree","id":"BinarySearchTree_binary-search-tree","algorithm":"import BinarySearchTreeNode from './BinarySearchTreeNode';\n\nexport default class BinarySearchTree {\n  /**\n   * @param {function} [nodeValueCompareFunction]\n   */\n  constructor(nodeValueCompareFunction) {\n    this.root = new BinarySearchTreeNode(null, nodeValueCompareFunction);\n\n    // Steal node comparator from the root.\n    this.nodeComparator = this.root.nodeComparator;\n  }\n\n  /**\n   * @param {*} value\n   * @return {BinarySearchTreeNode}\n   */\n  insert(value) {\n    return this.root.insert(value);\n  }\n\n  /**\n   * @param {*} value\n   * @return {boolean}\n   */\n  contains(value) {\n    return this.root.contains(value);\n  }\n\n  /**\n   * @param {*} value\n   * @return {boolean}\n   */\n  remove(value) {\n    return this.root.remove(value);\n  }\n\n  /**\n   * @return {string}\n   */\n  toString() {\n    return this.root.toString();\n  }\n}\n","filetype":".js","index":282},{"title":"Binary Search Tree Node","category":"binary-search-tree","id":"BinarySearchTreeNode_binary-search-tree","algorithm":"import BinaryTreeNode from '../BinaryTreeNode';\nimport Comparator from '../../../utils/comparator/Comparator';\n\nexport default class BinarySearchTreeNode extends BinaryTreeNode {\n  /**\n   * @param {*} [value] - node value.\n   * @param {function} [compareFunction] - comparator function for node values.\n   */\n  constructor(value = null, compareFunction = undefined) {\n    super(value);\n\n    // This comparator is used to compare node values with each other.\n    this.compareFunction = compareFunction;\n    this.nodeValueComparator = new Comparator(compareFunction);\n  }\n\n  /**\n   * @param {*} value\n   * @return {BinarySearchTreeNode}\n   */\n  insert(value) {\n    if (this.nodeValueComparator.equal(this.value, null)) {\n      this.value = value;\n\n      return this;\n    }\n\n    if (this.nodeValueComparator.lessThan(value, this.value)) {\n      // Insert to the left.\n      if (this.left) {\n        return this.left.insert(value);\n      }\n\n      const newNode = new BinarySearchTreeNode(value, this.compareFunction);\n      this.setLeft(newNode);\n\n      return newNode;\n    }\n\n    if (this.nodeValueComparator.greaterThan(value, this.value)) {\n      // Insert to the right.\n      if (this.right) {\n        return this.right.insert(value);\n      }\n\n      const newNode = new BinarySearchTreeNode(value, this.compareFunction);\n      this.setRight(newNode);\n\n      return newNode;\n    }\n\n    return this;\n  }\n\n  /**\n   * @param {*} value\n   * @return {BinarySearchTreeNode}\n   */\n  find(value) {\n    // Check the root.\n    if (this.nodeValueComparator.equal(this.value, value)) {\n      return this;\n    }\n\n    if (this.nodeValueComparator.lessThan(value, this.value) && this.left) {\n      // Check left nodes.\n      return this.left.find(value);\n    }\n\n    if (this.nodeValueComparator.greaterThan(value, this.value) && this.right) {\n      // Check right nodes.\n      return this.right.find(value);\n    }\n\n    return null;\n  }\n\n  /**\n   * @param {*} value\n   * @return {boolean}\n   */\n  contains(value) {\n    return !!this.find(value);\n  }\n\n  /**\n   * @param {*} value\n   * @return {boolean}\n   */\n  remove(value) {\n    const nodeToRemove = this.find(value);\n\n    if (!nodeToRemove) {\n      throw new Error('Item not found in the tree');\n    }\n\n    const { parent } = nodeToRemove;\n\n    if (!nodeToRemove.left && !nodeToRemove.right) {\n      // Node is a leaf and thus has no children.\n      if (parent) {\n        // Node has a parent. Just remove the pointer to this node from the parent.\n        parent.removeChild(nodeToRemove);\n      } else {\n        // Node has no parent. Just erase current node value.\n        nodeToRemove.setValue(undefined);\n      }\n    } else if (nodeToRemove.left && nodeToRemove.right) {\n      // Node has two children.\n      // Find the next biggest value (minimum value in the right branch)\n      // and replace current value node with that next biggest value.\n      const nextBiggerNode = nodeToRemove.right.findMin();\n      if (!this.nodeComparator.equal(nextBiggerNode, nodeToRemove.right)) {\n        this.remove(nextBiggerNode.value);\n        nodeToRemove.setValue(nextBiggerNode.value);\n      } else {\n        // In case if next right value is the next bigger one and it doesn't have left child\n        // then just replace node that is going to be deleted with the right node.\n        nodeToRemove.setValue(nodeToRemove.right.value);\n        nodeToRemove.setRight(nodeToRemove.right.right);\n      }\n    } else {\n      // Node has only one child.\n      // Make this child to be a direct child of current node's parent.\n      /** @var BinarySearchTreeNode */\n      const childNode = nodeToRemove.left || nodeToRemove.right;\n\n      if (parent) {\n        parent.replaceChild(nodeToRemove, childNode);\n      } else {\n        BinaryTreeNode.copyNode(childNode, nodeToRemove);\n      }\n    }\n\n    // Clear the parent of removed node.\n    nodeToRemove.parent = null;\n\n    return true;\n  }\n\n  /**\n   * @return {BinarySearchTreeNode}\n   */\n  findMin() {\n    if (!this.left) {\n      return this;\n    }\n\n    return this.left.findMin();\n  }\n}\n","filetype":".js","index":283},{"title":"Fenwick-tree","category":"tree","id":"fenwick-tree","algorithm":"# Fenwick Tree / Binary Indexed Tree\n\n_Read this in other languages:_\n[_Português_](README.pt-BR.md) \n\nA **Fenwick tree** or **binary indexed tree** is a data \nstructure that can efficiently update elements and \ncalculate prefix sums in a table of numbers.\n\nWhen compared with a flat array of numbers, the Fenwick tree achieves a \nmuch better balance between two operations: element update and prefix sum \ncalculation. In a flat array of `n` numbers, you can either store the elements, \nor the prefix sums. In the first case, computing prefix sums requires linear \ntime; in the second case, updating the array elements requires linear time \n(in both cases, the other operation can be performed in constant time). \nFenwick trees allow both operations to be performed in `O(log n)` time. \nThis is achieved by representing the numbers as a tree, where the value of \neach node is the sum of the numbers in that subtree. The tree structure allows \noperations to be performed using only `O(log n)` node accesses.\n\n## Implementation Notes\n\nBinary Indexed Tree is represented as an array. Each node of Binary Indexed Tree \nstores sum of some elements of given array. Size of Binary Indexed Tree is equal \nto `n` where `n` is size of input array. In current implementation we have used \nsize as `n+1` for ease of implementation. All the indexes are 1-based.\n\n![Binary Indexed Tree](https://www.geeksforgeeks.org/wp-content/uploads/BITSum.png)\n\nOn the picture below you may see animated example of \ncreation of binary indexed tree for the \narray `[1, 2, 3, 4, 5]` by inserting one by one.\n\n![Fenwick Tree](https://upload.wikimedia.org/wikipedia/commons/d/dc/BITDemo.gif)\n\n## References\n\n- [Wikipedia](https://en.wikipedia.org/wiki/Fenwick_tree)\n- [GeeksForGeeks](https://www.geeksforgeeks.org/binary-indexed-tree-or-fenwick-tree-2/)\n- [YouTube](https://www.youtube.com/watch?v=CWDQJGaN1gY&index=18&t=0s&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\n","filetype":".md","index":284},{"title":"Fenwick Tree","category":"fenwick-tree","id":"FenwickTree_fenwick-tree","algorithm":"export default class FenwickTree {\n  /**\n   * Constructor creates empty fenwick tree of size 'arraySize',\n   * however, array size is size+1, because index is 1-based.\n   *\n   * @param  {number} arraySize\n   */\n  constructor(arraySize) {\n    this.arraySize = arraySize;\n\n    // Fill tree array with zeros.\n    this.treeArray = Array(this.arraySize + 1).fill(0);\n  }\n\n  /**\n   * Adds value to existing value at position.\n   *\n   * @param  {number} position\n   * @param  {number} value\n   * @return {FenwickTree}\n   */\n  increase(position, value) {\n    if (position < 1 || position > this.arraySize) {\n      throw new Error('Position is out of allowed range');\n    }\n\n    for (let i = position; i <= this.arraySize; i += (i & -i)) {\n      this.treeArray[i] += value;\n    }\n\n    return this;\n  }\n\n  /**\n   * Query sum from index 1 to position.\n   *\n   * @param  {number} position\n   * @return {number}\n   */\n  query(position) {\n    if (position < 1 || position > this.arraySize) {\n      throw new Error('Position is out of allowed range');\n    }\n\n    let sum = 0;\n\n    for (let i = position; i > 0; i -= (i & -i)) {\n      sum += this.treeArray[i];\n    }\n\n    return sum;\n  }\n\n  /**\n   * Query sum from index leftIndex to rightIndex.\n   *\n   * @param  {number} leftIndex\n   * @param  {number} rightIndex\n   * @return {number}\n   */\n  queryRange(leftIndex, rightIndex) {\n    if (leftIndex > rightIndex) {\n      throw new Error('Left index can not be greater than right one');\n    }\n\n    if (leftIndex === 1) {\n      return this.query(rightIndex);\n    }\n\n    return this.query(rightIndex) - this.query(leftIndex - 1);\n  }\n}\n","filetype":".js","index":285},{"title":"Red-black-tree","category":"tree","id":"red-black-tree","algorithm":"# Red–Black Tree\n\n_Read this in other languages:_\n[_Português_](README.pt-BR.md) \n\nA **red–black tree** is a kind of self-balancing binary search \ntree in computer science. Each node of the binary tree has \nan extra bit, and that bit is often interpreted as the \ncolor (red or black) of the node. These color bits are used \nto ensure the tree remains approximately balanced during \ninsertions and deletions.\n\nBalance is preserved by painting each node of the tree with \none of two colors in a way that satisfies certain properties,\nwhich collectively constrain how unbalanced the tree can \nbecome in the worst case. When the tree is modified, the \nnew tree is subsequently rearranged and repainted to \nrestore the coloring properties. The properties are \ndesigned in such a way that this rearranging and recoloring \ncan be performed efficiently.\n\nThe balancing of the tree is not perfect, but it is good \nenough to allow it to guarantee searching in `O(log n)` time,\nwhere `n` is the total number of elements in the tree. \nThe insertion and deletion operations, along with the tree \nrearrangement and recoloring, are also performed \nin `O(log n)` time.\n\nAn example of a red–black tree:\n\n![red-black tree](https://upload.wikimedia.org/wikipedia/commons/6/66/Red-black_tree_example.svg)\n\n## Properties\n\nIn addition to the requirements imposed on a binary search \ntree the following must be satisfied by a red–black tree:\n\n- Each node is either red or black.\n- The root is black. This rule is sometimes omitted. \nSince the root can always be changed from red to black, \nbut not necessarily vice versa, this rule has little \neffect on analysis.\n- All leaves (NIL) are black.\n- If a node is red, then both its children are black.\n- Every path from a given node to any of its descendant \nNIL nodes contains the same number of black nodes.\n\nSome definitions: the number of black nodes from the root \nto a node is the node's **black depth**; the uniform \nnumber of black nodes in all paths from root to the leaves \nis called the **black-height** of the red–black tree.\n\nThese constraints enforce a critical property of red–black \ntrees: _the path from the root to the farthest leaf is no more than twice as long as the path from the root to the nearest leaf_. \nThe result is that the tree is roughly height-balanced. \nSince operations such as inserting, deleting, and finding \nvalues require worst-case time proportional to the height \nof the tree, this theoretical upper bound on the height \nallows red–black trees to be efficient in the worst case, \nunlike ordinary binary search trees.\n\n## Balancing during insertion\n\n### If uncle is RED\n![Red Black Tree Balancing](https://www.geeksforgeeks.org/wp-content/uploads/redBlackCase2.png)\n\n### If uncle is BLACK\n\n- Left Left Case (`p` is left child of `g` and `x` is left child of `p`)\n- Left Right Case (`p` is left child of `g` and `x` is right child of `p`)\n- Right Right Case (`p` is right child of `g` and `x` is right child of `p`)\n- Right Left Case (`p` is right child of `g` and `x` is left child of `p`)\n\n#### Left Left Case (See g, p and x)\n\n![Red Black Tree Balancing](https://www.geeksforgeeks.org/wp-content/uploads/redBlackCase3a1.png)\n\n#### Left Right Case (See g, p and x)\n\n![Red Black Tree Balancing](https://www.geeksforgeeks.org/wp-content/uploads/redBlackCase3b.png)\n\n#### Right Right Case (See g, p and x)\n\n![Red Black Tree Balancing](https://www.geeksforgeeks.org/wp-content/uploads/redBlackCase3c.png)\n\n#### Right Left Case (See g, p and x)\n\n![Red Black Tree Balancing](https://www.geeksforgeeks.org/wp-content/uploads/redBlackCase3d.png)\n\n## References\n\n- [Wikipedia](https://en.wikipedia.org/wiki/Red%E2%80%93black_tree)\n- [Red Black Tree Insertion by Tushar Roy (YouTube)](https://www.youtube.com/watch?v=UaLIHuR1t8Q&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8&index=63)\n- [Red Black Tree Deletion by Tushar Roy (YouTube)](https://www.youtube.com/watch?v=CTvfzU_uNKE&t=0s&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8&index=64)\n- [Red Black Tree Insertion on GeeksForGeeks](https://www.geeksforgeeks.org/red-black-tree-set-2-insert/)\n- [Red Black Tree Interactive Visualisations](https://www.cs.usfca.edu/~galles/visualization/RedBlack.html)\n","filetype":".md","index":286},{"title":"Red Black Tree","category":"red-black-tree","id":"RedBlackTree_red-black-tree","algorithm":"import BinarySearchTree from '../binary-search-tree/BinarySearchTree';\n\n// Possible colors of red-black tree nodes.\nconst RED_BLACK_TREE_COLORS = {\n  red: 'red',\n  black: 'black',\n};\n\n// Color property name in meta information of the nodes.\nconst COLOR_PROP_NAME = 'color';\n\nexport default class RedBlackTree extends BinarySearchTree {\n  /**\n   * @param {*} value\n   * @return {BinarySearchTreeNode}\n   */\n  insert(value) {\n    const insertedNode = super.insert(value);\n\n    // if (!this.root.left && !this.root.right) {\n    if (this.nodeComparator.equal(insertedNode, this.root)) {\n      // Make root to always be black.\n      this.makeNodeBlack(insertedNode);\n    } else {\n      // Make all newly inserted nodes to be red.\n      this.makeNodeRed(insertedNode);\n    }\n\n    // Check all conditions and balance the node.\n    this.balance(insertedNode);\n\n    return insertedNode;\n  }\n\n  /**\n   * @param {*} value\n   * @return {boolean}\n   */\n  remove(value) {\n    throw new Error(`Can't remove ${value}. Remove method is not implemented yet`);\n  }\n\n  /**\n   * @param {BinarySearchTreeNode} node\n   */\n  balance(node) {\n    // If it is a root node then nothing to balance here.\n    if (this.nodeComparator.equal(node, this.root)) {\n      return;\n    }\n\n    // If the parent is black then done. Nothing to balance here.\n    if (this.isNodeBlack(node.parent)) {\n      return;\n    }\n\n    const grandParent = node.parent.parent;\n\n    if (node.uncle && this.isNodeRed(node.uncle)) {\n      // If node has red uncle then we need to do RECOLORING.\n\n      // Recolor parent and uncle to black.\n      this.makeNodeBlack(node.uncle);\n      this.makeNodeBlack(node.parent);\n\n      if (!this.nodeComparator.equal(grandParent, this.root)) {\n        // Recolor grand-parent to red if it is not root.\n        this.makeNodeRed(grandParent);\n      } else {\n        // If grand-parent is black root don't do anything.\n        // Since root already has two black sibling that we've just recolored.\n        return;\n      }\n\n      // Now do further checking for recolored grand-parent.\n      this.balance(grandParent);\n    } else if (!node.uncle || this.isNodeBlack(node.uncle)) {\n      // If node uncle is black or absent then we need to do ROTATIONS.\n\n      if (grandParent) {\n        // Grand parent that we will receive after rotations.\n        let newGrandParent;\n\n        if (this.nodeComparator.equal(grandParent.left, node.parent)) {\n          // Left case.\n          if (this.nodeComparator.equal(node.parent.left, node)) {\n            // Left-left case.\n            newGrandParent = this.leftLeftRotation(grandParent);\n          } else {\n            // Left-right case.\n            newGrandParent = this.leftRightRotation(grandParent);\n          }\n        } else {\n          // Right case.\n          if (this.nodeComparator.equal(node.parent.right, node)) {\n            // Right-right case.\n            newGrandParent = this.rightRightRotation(grandParent);\n          } else {\n            // Right-left case.\n            newGrandParent = this.rightLeftRotation(grandParent);\n          }\n        }\n\n        // Set newGrandParent as a root if it doesn't have parent.\n        if (newGrandParent && newGrandParent.parent === null) {\n          this.root = newGrandParent;\n\n          // Recolor root into black.\n          this.makeNodeBlack(this.root);\n        }\n\n        // Check if new grand parent don't violate red-black-tree rules.\n        this.balance(newGrandParent);\n      }\n    }\n  }\n\n  /**\n   * Left Left Case (p is left child of g and x is left child of p)\n   * @param {BinarySearchTreeNode|BinaryTreeNode} grandParentNode\n   * @return {BinarySearchTreeNode}\n   */\n  leftLeftRotation(grandParentNode) {\n    // Memorize the parent of grand-parent node.\n    const grandGrandParent = grandParentNode.parent;\n\n    // Check what type of sibling is our grandParentNode is (left or right).\n    let grandParentNodeIsLeft;\n    if (grandGrandParent) {\n      grandParentNodeIsLeft = this.nodeComparator.equal(grandGrandParent.left, grandParentNode);\n    }\n\n    // Memorize grandParentNode's left node.\n    const parentNode = grandParentNode.left;\n\n    // Memorize parent's right node since we're going to transfer it to\n    // grand parent's left subtree.\n    const parentRightNode = parentNode.right;\n\n    // Make grandParentNode to be right child of parentNode.\n    parentNode.setRight(grandParentNode);\n\n    // Move child's right subtree to grandParentNode's left subtree.\n    grandParentNode.setLeft(parentRightNode);\n\n    // Put parentNode node in place of grandParentNode.\n    if (grandGrandParent) {\n      if (grandParentNodeIsLeft) {\n        grandGrandParent.setLeft(parentNode);\n      } else {\n        grandGrandParent.setRight(parentNode);\n      }\n    } else {\n      // Make parent node a root\n      parentNode.parent = null;\n    }\n\n    // Swap colors of grandParentNode and parentNode.\n    this.swapNodeColors(parentNode, grandParentNode);\n\n    // Return new root node.\n    return parentNode;\n  }\n\n  /**\n   * Left Right Case (p is left child of g and x is right child of p)\n   * @param {BinarySearchTreeNode|BinaryTreeNode} grandParentNode\n   * @return {BinarySearchTreeNode}\n   */\n  leftRightRotation(grandParentNode) {\n    // Memorize left and left-right nodes.\n    const parentNode = grandParentNode.left;\n    const childNode = parentNode.right;\n\n    // We need to memorize child left node to prevent losing\n    // left child subtree. Later it will be re-assigned to\n    // parent's right sub-tree.\n    const childLeftNode = childNode.left;\n\n    // Make parentNode to be a left child of childNode node.\n    childNode.setLeft(parentNode);\n\n    // Move child's left subtree to parent's right subtree.\n    parentNode.setRight(childLeftNode);\n\n    // Put left-right node in place of left node.\n    grandParentNode.setLeft(childNode);\n\n    // Now we're ready to do left-left rotation.\n    return this.leftLeftRotation(grandParentNode);\n  }\n\n  /**\n   * Right Right Case (p is right child of g and x is right child of p)\n   * @param {BinarySearchTreeNode|BinaryTreeNode} grandParentNode\n   * @return {BinarySearchTreeNode}\n   */\n  rightRightRotation(grandParentNode) {\n    // Memorize the parent of grand-parent node.\n    const grandGrandParent = grandParentNode.parent;\n\n    // Check what type of sibling is our grandParentNode is (left or right).\n    let grandParentNodeIsLeft;\n    if (grandGrandParent) {\n      grandParentNodeIsLeft = this.nodeComparator.equal(grandGrandParent.left, grandParentNode);\n    }\n\n    // Memorize grandParentNode's right node.\n    const parentNode = grandParentNode.right;\n\n    // Memorize parent's left node since we're going to transfer it to\n    // grand parent's right subtree.\n    const parentLeftNode = parentNode.left;\n\n    // Make grandParentNode to be left child of parentNode.\n    parentNode.setLeft(grandParentNode);\n\n    // Transfer all left nodes from parent to right sub-tree of grandparent.\n    grandParentNode.setRight(parentLeftNode);\n\n    // Put parentNode node in place of grandParentNode.\n    if (grandGrandParent) {\n      if (grandParentNodeIsLeft) {\n        grandGrandParent.setLeft(parentNode);\n      } else {\n        grandGrandParent.setRight(parentNode);\n      }\n    } else {\n      // Make parent node a root.\n      parentNode.parent = null;\n    }\n\n    // Swap colors of granParent and parent nodes.\n    this.swapNodeColors(parentNode, grandParentNode);\n\n    // Return new root node.\n    return parentNode;\n  }\n\n  /**\n   * Right Left Case (p is right child of g and x is left child of p)\n   * @param {BinarySearchTreeNode|BinaryTreeNode} grandParentNode\n   * @return {BinarySearchTreeNode}\n   */\n  rightLeftRotation(grandParentNode) {\n    // Memorize right and right-left nodes.\n    const parentNode = grandParentNode.right;\n    const childNode = parentNode.left;\n\n    // We need to memorize child right node to prevent losing\n    // right child subtree. Later it will be re-assigned to\n    // parent's left sub-tree.\n    const childRightNode = childNode.right;\n\n    // Make parentNode to be a right child of childNode.\n    childNode.setRight(parentNode);\n\n    // Move child's right subtree to parent's left subtree.\n    parentNode.setLeft(childRightNode);\n\n    // Put childNode node in place of parentNode.\n    grandParentNode.setRight(childNode);\n\n    // Now we're ready to do right-right rotation.\n    return this.rightRightRotation(grandParentNode);\n  }\n\n  /**\n   * @param {BinarySearchTreeNode|BinaryTreeNode} node\n   * @return {BinarySearchTreeNode}\n   */\n  makeNodeRed(node) {\n    node.meta.set(COLOR_PROP_NAME, RED_BLACK_TREE_COLORS.red);\n\n    return node;\n  }\n\n  /**\n   * @param {BinarySearchTreeNode|BinaryTreeNode} node\n   * @return {BinarySearchTreeNode}\n   */\n  makeNodeBlack(node) {\n    node.meta.set(COLOR_PROP_NAME, RED_BLACK_TREE_COLORS.black);\n\n    return node;\n  }\n\n  /**\n   * @param {BinarySearchTreeNode|BinaryTreeNode} node\n   * @return {boolean}\n   */\n  isNodeRed(node) {\n    return node.meta.get(COLOR_PROP_NAME) === RED_BLACK_TREE_COLORS.red;\n  }\n\n  /**\n   * @param {BinarySearchTreeNode|BinaryTreeNode} node\n   * @return {boolean}\n   */\n  isNodeBlack(node) {\n    return node.meta.get(COLOR_PROP_NAME) === RED_BLACK_TREE_COLORS.black;\n  }\n\n  /**\n   * @param {BinarySearchTreeNode|BinaryTreeNode} node\n   * @return {boolean}\n   */\n  isNodeColored(node) {\n    return this.isNodeRed(node) || this.isNodeBlack(node);\n  }\n\n  /**\n   * @param {BinarySearchTreeNode|BinaryTreeNode} firstNode\n   * @param {BinarySearchTreeNode|BinaryTreeNode} secondNode\n   */\n  swapNodeColors(firstNode, secondNode) {\n    const firstColor = firstNode.meta.get(COLOR_PROP_NAME);\n    const secondColor = secondNode.meta.get(COLOR_PROP_NAME);\n\n    firstNode.meta.set(COLOR_PROP_NAME, secondColor);\n    secondNode.meta.set(COLOR_PROP_NAME, firstColor);\n  }\n}\n","filetype":".js","index":287},{"title":"Segment-tree","category":"tree","id":"segment-tree","algorithm":"# Segment Tree\n\n_Read this in other languages:_\n[_Português_](README.pt-BR.md) \n\nIn computer science, a **segment tree** also known as a statistic tree \nis a tree data structure used for storing information about intervals, \nor segments. It allows querying which of the stored segments contain \na given point. It is, in principle, a static structure; that is, \nit's a structure that cannot be modified once it's built. A similar \ndata structure is the interval tree.\n\nA segment tree is a binary tree. The root of the tree represents the \nwhole array. The two children of the root represent the \nfirst and second halves of the array. Similarly, the \nchildren of each node corresponds to the two halves of \nthe array corresponding to the node.\n\nWe build the tree bottom up, with the value of each node \nbeing the \"minimum\" (or any other function) of its children's values. This will \ntake `O(n log n)` time. The number \nof operations done is the height of the tree, which \nis `O(log n)`. To do range queries, each node splits the \nquery into two parts, one sub-query for each child. \nIf a query contains the whole subarray of a node, we \ncan use the precomputed value at the node. Using this \noptimisation, we can prove that only `O(log n)` minimum \noperations are done.\n\n![Min Segment Tree](https://www.geeksforgeeks.org/wp-content/uploads/RangeMinimumQuery.png)\n\n![Sum Segment Tree](https://www.geeksforgeeks.org/wp-content/uploads/segment-tree1.png)\n\n## Application\n\nA segment tree is a data structure designed to perform \ncertain array operations efficiently - especially those \ninvolving range queries.\n\nApplications of the segment tree are in the areas of computational geometry, \nand geographic information systems.\n\nCurrent implementation of Segment Tree implies that you may\npass any binary (with two input params) function to it and \nthus you're able to do range query for variety of functions.\nIn tests you may find examples of doing `min`, `max` and `sum` range\nqueries on SegmentTree.\n \n## References\n\n- [Wikipedia](https://en.wikipedia.org/wiki/Segment_tree)\n- [YouTube](https://www.youtube.com/watch?v=ZBHKZF5w4YU&index=65&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8)\n- [GeeksForGeeks](https://www.geeksforgeeks.org/segment-tree-set-1-sum-of-given-range/)\n","filetype":".md","index":288},{"title":"Segment Tree","category":"segment-tree","id":"SegmentTree_segment-tree","algorithm":"import isPowerOfTwo from '../../../algorithms/math/is-power-of-two/isPowerOfTwo';\n\nexport default class SegmentTree {\n  /**\n   * @param {number[]} inputArray\n   * @param {function} operation - binary function (i.e. sum, min)\n   * @param {number} operationFallback - operation fallback value (i.e. 0 for sum, Infinity for min)\n   */\n  constructor(inputArray, operation, operationFallback) {\n    this.inputArray = inputArray;\n    this.operation = operation;\n    this.operationFallback = operationFallback;\n\n    // Init array representation of segment tree.\n    this.segmentTree = this.initSegmentTree(this.inputArray);\n\n    this.buildSegmentTree();\n  }\n\n  /**\n   * @param {number[]} inputArray\n   * @return {number[]}\n   */\n  initSegmentTree(inputArray) {\n    let segmentTreeArrayLength;\n    const inputArrayLength = inputArray.length;\n\n    if (isPowerOfTwo(inputArrayLength)) {\n      // If original array length is a power of two.\n      segmentTreeArrayLength = (2 * inputArrayLength) - 1;\n    } else {\n      // If original array length is not a power of two then we need to find\n      // next number that is a power of two and use it to calculate\n      // tree array size. This is happens because we need to fill empty children\n      // in perfect binary tree with nulls.And those nulls need extra space.\n      const currentPower = Math.floor(Math.log2(inputArrayLength));\n      const nextPower = currentPower + 1;\n      const nextPowerOfTwoNumber = 2 ** nextPower;\n      segmentTreeArrayLength = (2 * nextPowerOfTwoNumber) - 1;\n    }\n\n    return new Array(segmentTreeArrayLength).fill(null);\n  }\n\n  /**\n   * Build segment tree.\n   */\n  buildSegmentTree() {\n    const leftIndex = 0;\n    const rightIndex = this.inputArray.length - 1;\n    const position = 0;\n    this.buildTreeRecursively(leftIndex, rightIndex, position);\n  }\n\n  /**\n   * Build segment tree recursively.\n   *\n   * @param {number} leftInputIndex\n   * @param {number} rightInputIndex\n   * @param {number} position\n   */\n  buildTreeRecursively(leftInputIndex, rightInputIndex, position) {\n    // If low input index and high input index are equal that would mean\n    // the we have finished splitting and we are already came to the leaf\n    // of the segment tree. We need to copy this leaf value from input\n    // array to segment tree.\n    if (leftInputIndex === rightInputIndex) {\n      this.segmentTree[position] = this.inputArray[leftInputIndex];\n      return;\n    }\n\n    // Split input array on two halves and process them recursively.\n    const middleIndex = Math.floor((leftInputIndex + rightInputIndex) / 2);\n    // Process left half of the input array.\n    this.buildTreeRecursively(leftInputIndex, middleIndex, this.getLeftChildIndex(position));\n    // Process right half of the input array.\n    this.buildTreeRecursively(middleIndex + 1, rightInputIndex, this.getRightChildIndex(position));\n\n    // Once every tree leaf is not empty we're able to build tree bottom up using\n    // provided operation function.\n    this.segmentTree[position] = this.operation(\n      this.segmentTree[this.getLeftChildIndex(position)],\n      this.segmentTree[this.getRightChildIndex(position)],\n    );\n  }\n\n  /**\n   * Do range query on segment tree in context of this.operation function.\n   *\n   * @param {number} queryLeftIndex\n   * @param {number} queryRightIndex\n   * @return {number}\n   */\n  rangeQuery(queryLeftIndex, queryRightIndex) {\n    const leftIndex = 0;\n    const rightIndex = this.inputArray.length - 1;\n    const position = 0;\n\n    return this.rangeQueryRecursive(\n      queryLeftIndex,\n      queryRightIndex,\n      leftIndex,\n      rightIndex,\n      position,\n    );\n  }\n\n  /**\n   * Do range query on segment tree recursively in context of this.operation function.\n   *\n   * @param {number} queryLeftIndex - left index of the query\n   * @param {number} queryRightIndex - right index of the query\n   * @param {number} leftIndex - left index of input array segment\n   * @param {number} rightIndex - right index of input array segment\n   * @param {number} position - root position in binary tree\n   * @return {number}\n   */\n  rangeQueryRecursive(queryLeftIndex, queryRightIndex, leftIndex, rightIndex, position) {\n    if (queryLeftIndex <= leftIndex && queryRightIndex >= rightIndex) {\n      // Total overlap.\n      return this.segmentTree[position];\n    }\n\n    if (queryLeftIndex > rightIndex || queryRightIndex < leftIndex) {\n      // No overlap.\n      return this.operationFallback;\n    }\n\n    // Partial overlap.\n    const middleIndex = Math.floor((leftIndex + rightIndex) / 2);\n\n    const leftOperationResult = this.rangeQueryRecursive(\n      queryLeftIndex,\n      queryRightIndex,\n      leftIndex,\n      middleIndex,\n      this.getLeftChildIndex(position),\n    );\n\n    const rightOperationResult = this.rangeQueryRecursive(\n      queryLeftIndex,\n      queryRightIndex,\n      middleIndex + 1,\n      rightIndex,\n      this.getRightChildIndex(position),\n    );\n\n    return this.operation(leftOperationResult, rightOperationResult);\n  }\n\n  /**\n   * Left child index.\n   * @param {number} parentIndex\n   * @return {number}\n   */\n  getLeftChildIndex(parentIndex) {\n    return (2 * parentIndex) + 1;\n  }\n\n  /**\n   * Right child index.\n   * @param {number} parentIndex\n   * @return {number}\n   */\n  getRightChildIndex(parentIndex) {\n    return (2 * parentIndex) + 2;\n  }\n}\n","filetype":".js","index":289},{"title":"Trie","category":"data-structures","id":"trie","algorithm":"# Trie\n\n_Read this in other languages:_\n[_简体中文_](README.zh-CN.md),\n[_Русский_](README.ru-RU.md),\n[_Português_](README.pt-BR.md)\n\nIn computer science, a **trie**, also called digital tree and sometimes \nradix tree or prefix tree (as they can be searched by prefixes), \nis a kind of search tree—an ordered tree data structure that is \nused to store a dynamic set or associative array where the keys \nare usually strings. Unlike a binary search tree, no node in the \ntree stores the key associated with that node; instead, its \nposition in the tree defines the key with which it is associated.\nAll the descendants of a node have a common prefix of the string\nassociated with that node, and the root is associated with the \nempty string. Values are not necessarily associated with every \nnode. Rather, values tend only to be associated with leaves, \nand with some inner nodes that correspond to keys of interest. \nFor the space-optimized presentation of prefix tree, see compact \nprefix tree.\n\n![Trie](https://upload.wikimedia.org/wikipedia/commons/b/be/Trie_example.svg)\n\n## References\n\n- [Wikipedia](https://en.wikipedia.org/wiki/Trie)\n- [YouTube](https://www.youtube.com/watch?v=zIjfhVPRZCg&list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8&index=7&t=0s)\n","filetype":".md","index":290},{"title":"Trie","category":"trie","id":"Trie_trie","algorithm":"import TrieNode from './TrieNode';\n\n// Character that we will use for trie tree root.\nconst HEAD_CHARACTER = '*';\n\nexport default class Trie {\n  constructor() {\n    this.head = new TrieNode(HEAD_CHARACTER);\n  }\n\n  /**\n   * @param {string} word\n   * @return {Trie}\n   */\n  addWord(word) {\n    const characters = Array.from(word);\n    let currentNode = this.head;\n\n    for (let charIndex = 0; charIndex < characters.length; charIndex += 1) {\n      const isComplete = charIndex === characters.length - 1;\n      currentNode = currentNode.addChild(characters[charIndex], isComplete);\n    }\n\n    return this;\n  }\n\n  /**\n   * @param {string} word\n   * @return {Trie}\n   */\n  deleteWord(word) {\n    const depthFirstDelete = (currentNode, charIndex = 0) => {\n      if (charIndex >= word.length) {\n        // Return if we're trying to delete the character that is out of word's scope.\n        return;\n      }\n\n      const character = word[charIndex];\n      const nextNode = currentNode.getChild(character);\n\n      if (nextNode == null) {\n        // Return if we're trying to delete a word that has not been added to the Trie.\n        return;\n      }\n\n      // Go deeper.\n      depthFirstDelete(nextNode, charIndex + 1);\n\n      // Since we're going to delete a word let's un-mark its last character isCompleteWord flag.\n      if (charIndex === (word.length - 1)) {\n        nextNode.isCompleteWord = false;\n      }\n\n      // childNode is deleted only if:\n      // - childNode has NO children\n      // - childNode.isCompleteWord === false\n      currentNode.removeChild(character);\n    };\n\n    // Start depth-first deletion from the head node.\n    depthFirstDelete(this.head);\n\n    return this;\n  }\n\n  /**\n   * @param {string} word\n   * @return {string[]}\n   */\n  suggestNextCharacters(word) {\n    const lastCharacter = this.getLastCharacterNode(word);\n\n    if (!lastCharacter) {\n      return null;\n    }\n\n    return lastCharacter.suggestChildren();\n  }\n\n  /**\n   * Check if complete word exists in Trie.\n   *\n   * @param {string} word\n   * @return {boolean}\n   */\n  doesWordExist(word) {\n    const lastCharacter = this.getLastCharacterNode(word);\n\n    return !!lastCharacter && lastCharacter.isCompleteWord;\n  }\n\n  /**\n   * @param {string} word\n   * @return {TrieNode}\n   */\n  getLastCharacterNode(word) {\n    const characters = Array.from(word);\n    let currentNode = this.head;\n\n    for (let charIndex = 0; charIndex < characters.length; charIndex += 1) {\n      if (!currentNode.hasChild(characters[charIndex])) {\n        return null;\n      }\n\n      currentNode = currentNode.getChild(characters[charIndex]);\n    }\n\n    return currentNode;\n  }\n}\n","filetype":".js","index":291},{"title":"Trie Node","category":"trie","id":"TrieNode_trie","algorithm":"import HashTable from '../hash-table/HashTable';\n\nexport default class TrieNode {\n  /**\n   * @param {string} character\n   * @param {boolean} isCompleteWord\n   */\n  constructor(character, isCompleteWord = false) {\n    this.character = character;\n    this.isCompleteWord = isCompleteWord;\n    this.children = new HashTable();\n  }\n\n  /**\n   * @param {string} character\n   * @return {TrieNode}\n   */\n  getChild(character) {\n    return this.children.get(character);\n  }\n\n  /**\n   * @param {string} character\n   * @param {boolean} isCompleteWord\n   * @return {TrieNode}\n   */\n  addChild(character, isCompleteWord = false) {\n    if (!this.children.has(character)) {\n      this.children.set(character, new TrieNode(character, isCompleteWord));\n    }\n\n    const childNode = this.children.get(character);\n\n    // In cases similar to adding \"car\" after \"carpet\" we need to mark \"r\" character as complete.\n    childNode.isCompleteWord = childNode.isCompleteWord || isCompleteWord;\n\n    return childNode;\n  }\n\n  /**\n   * @param {string} character\n   * @return {TrieNode}\n   */\n  removeChild(character) {\n    const childNode = this.getChild(character);\n\n    // Delete childNode only if:\n    // - childNode has NO children,\n    // - childNode.isCompleteWord === false.\n    if (\n      childNode\n      && !childNode.isCompleteWord\n      && !childNode.hasChildren()\n    ) {\n      this.children.delete(character);\n    }\n\n    return this;\n  }\n\n  /**\n   * @param {string} character\n   * @return {boolean}\n   */\n  hasChild(character) {\n    return this.children.has(character);\n  }\n\n  /**\n   * Check whether current TrieNode has children or not.\n   * @return {boolean}\n   */\n  hasChildren() {\n    return this.children.getKeys().length !== 0;\n  }\n\n  /**\n   * @return {string[]}\n   */\n  suggestChildren() {\n    return [...this.children.getKeys()];\n  }\n\n  /**\n   * @return {string}\n   */\n  toString() {\n    let childrenAsString = this.suggestChildren().toString();\n    childrenAsString = childrenAsString ? `:${childrenAsString}` : '';\n    const isCompleteString = this.isCompleteWord ? '*' : '';\n\n    return `${this.character}${isCompleteString}${childrenAsString}`;\n  }\n}\n","filetype":".js","index":292},{"title":"Utils","category":null,"id":"utils","index":293},{"title":"Comparator","category":"utils","id":"comparator","index":294},{"title":"Comparator","category":"comparator","id":"Comparator_comparator","algorithm":"export default class Comparator {\n  /**\n   * Constructor.\n   * @param {function(a: *, b: *)} [compareFunction] - It may be custom compare function that, let's\n   * say may compare custom objects together.\n   */\n  constructor(compareFunction) {\n    this.compare = compareFunction || Comparator.defaultCompareFunction;\n  }\n\n  /**\n   * Default comparison function. It just assumes that \"a\" and \"b\" are strings or numbers.\n   * @param {(string|number)} a\n   * @param {(string|number)} b\n   * @returns {number}\n   */\n  static defaultCompareFunction(a, b) {\n    if (a === b) {\n      return 0;\n    }\n\n    return a < b ? -1 : 1;\n  }\n\n  /**\n   * Checks if two variables are equal.\n   * @param {*} a\n   * @param {*} b\n   * @return {boolean}\n   */\n  equal(a, b) {\n    return this.compare(a, b) === 0;\n  }\n\n  /**\n   * Checks if variable \"a\" is less than \"b\".\n   * @param {*} a\n   * @param {*} b\n   * @return {boolean}\n   */\n  lessThan(a, b) {\n    return this.compare(a, b) < 0;\n  }\n\n  /**\n   * Checks if variable \"a\" is greater than \"b\".\n   * @param {*} a\n   * @param {*} b\n   * @return {boolean}\n   */\n  greaterThan(a, b) {\n    return this.compare(a, b) > 0;\n  }\n\n  /**\n   * Checks if variable \"a\" is less than or equal to \"b\".\n   * @param {*} a\n   * @param {*} b\n   * @return {boolean}\n   */\n  lessThanOrEqual(a, b) {\n    return this.lessThan(a, b) || this.equal(a, b);\n  }\n\n  /**\n   * Checks if variable \"a\" is greater than or equal to \"b\".\n   * @param {*} a\n   * @param {*} b\n   * @return {boolean}\n   */\n  greaterThanOrEqual(a, b) {\n    return this.greaterThan(a, b) || this.equal(a, b);\n  }\n\n  /**\n   * Reverses the comparison order.\n   */\n  reverse() {\n    const compareOriginal = this.compare;\n    this.compare = (a, b) => compareOriginal(b, a);\n  }\n}\n","filetype":".js","index":295}]