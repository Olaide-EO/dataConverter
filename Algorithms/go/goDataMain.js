[{"title":"Go-master","category":".","id":"Go-master"},{"title":"Ciphers","category":null,"id":"ciphers","index":0},{"title":"Caesar","category":"ciphers","id":"caesar","index":1},{"title":"CaesarCipher","category":"caesar","id":"CaesarCipher_caesar","algorithm":"package main\n\nimport (\n\t\"bytes\"\n\t\"flag\"\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc main() {\n\tcipherKey := flag.Int(\"c\", 0, \"Cipher shift amount (-26 - 26)\")\n\tinput := flag.String(\"i\", \"\", \"Input\")\n\tflag.Parse()\n\n\tif *cipherKey > 26 || *cipherKey < -26 {\n\t\tflag.PrintDefaults()\n\t} else {\n\t\tfmt.Println(caesarCipher(*input, *cipherKey))\n\t}\n\n}\n\nfunc caesarCipher(input string, key int) string {\n\tvar outputBuffer bytes.Buffer\n\tfor _, r := range strings.ToLower(input) {\n\t\tnewByte := int(r)\n\n\t\tif newByte >= 'a' && newByte <= 'z' {\n\t\t\tnewByte += key\n\n\t\t\tif newByte > 'z' {\n\t\t\t\tnewByte -= 26\n\t\t\t} else if newByte < 'a' {\n\t\t\t\tnewByte += 26\n\t\t\t}\n\t\t}\n\n\t\toutputBuffer.WriteString(string(newByte))\n\t}\n\treturn outputBuffer.String()\n}\n","index":2},{"title":"Caesar Test","category":"caesar","id":"caesar_test_caesar","algorithm":"package main\n\nimport (\n\t\"testing\"\n)\n\nvar caesarTestData = []struct {\n\tdescription string\n\tinput       string\n\tkey         int\n\texpected    string\n}{\n\t{\n\t\t\"Basic caesar encryption with letter 'a'\",\n\t\t\"a\",\n\t\t3,\n\t\t\"d\",\n\t},\n\t{\n\t\t\"Basic caesar encryption wrap around alphabet on letter 'z'\",\n\t\t\"z\",\n\t\t3,\n\t\t\"c\",\n\t},\n\t{\n\t\t\"Encrypt a simple string with ceasar encryiption\",\n\t\t\"hello\",\n\t\t3,\n\t\t\"khoor\",\n\t},\n\t{\n\t\t\"Encrypt a simple string with key 13\",\n\t\t\"hello\",\n\t\t13,\n\t\t\"uryyb\",\n\t},\n\t{\n\t\t\"Encrypt a simple string with key -13\",\n\t\t\"hello\",\n\t\t-13,\n\t\t\"uryyb\",\n\t},\n\t{\n\t\t\"With key of 26 output should be the same as the input\",\n\t\t\"no change\",\n\t\t26,\n\t\t\"no change\",\n\t},\n\t{\n\t\t\"Encrpyt sentence with key 10\",\n\t\t\"the quick brown fox jumps over the lazy dog.\",\n\t\t10,\n\t\t\"dro aesmu lbygx pyh tewzc yfob dro vkji nyq.\",\n\t},\n}\n\nfunc TestCeasarCipher(t *testing.T) {\n\tfor _, test := range caesarTestData {\n\t\tt.Run(test.description, func(t *testing.T) {\n\t\t\tactual := caesarCipher(test.input, test.key)\n\t\t\tif actual != test.expected {\n\t\t\t\tt.Logf(\"FAIL: %s\", test.description)\n\t\t\t\tt.Fatalf(\"With input string '%s' and key '%d' was expecting '%s' but actual was '%s'\",\n\t\t\t\t\ttest.input, test.key, test.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}\n","index":3},{"title":"DiffieHellmanKeyExchange","category":"ciphers","id":"diffieHellmanKeyExchange_ciphers","algorithm":"package main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n)\n\nfunc main() {\n\tbit := 30\n\t/*\n\t\tp and g are pre-agreed constants\n\t\tthat can be communicated over an insecure channel\n\t\tp should ideally be a large prime number but any integer works\n\t\tg should be a small integer, 2,3 works fine\n\t\tPS: Note that the secret keys are never send over\n\t\tthe network\n\t*/\n\n\tp := 2 + rand.Intn(1<<bit)\n\tg := 2 + rand.Intn(5)\n\n\t//Both parties choose a secret key\n\n\tAliceSecret := 1 + rand.Intn(1<<bit)\n\tBobSecret := 1 + rand.Intn(1<<bit)\n\n\tfmt.Printf(\"Alice's secret key is: %v\", AliceSecret)\n\tfmt.Printf(\"Bob's secret key is: %v\", BobSecret)\n\n\t//Both parties send ((g^secret_key)%p)\n\t//It's not possible to determine the secretkey from the value sent\n\n\tAliceSends := modularExponentiation(g, AliceSecret, p)\n\tBobSends := modularExponentiation(g, BobSecret, p)\n\n\t//Both parties calculate the shared secret key from the value send\n\t//(value_sent^secret_key)%p\n\t//Both calculations end up with same value despite the different inputs\n\tAliceComputes := modularExponentiation(BobSends, AliceSecret, p)\n\tBobComputes := modularExponentiation(AliceSends, BobSecret, p)\n\n\tfmt.Printf(\"Alice Computes the shared secret key as: %v\", AliceComputes)\n\tfmt.Printf(\"Bob Computes the shared secret key as: %v\", BobComputes)\n\n\t// simply confirms that the values are equal\n\tif AliceComputes == BobComputes {\n\t\tsharedKey := AliceComputes\n\t\tfmt.Println(\" Voila, shared key is\", sharedKey)\n\t}\n}\n\nfunc modularExponentiation(b, e, mod int) int {\n\n\t//runs in O(log(n)) where n = e\n\t//uses exponentiation by squaring to speed up the process\n\tif mod == 1 {\n\t\treturn 0\n\t}\n\tr := 1\n\tb = b % mod\n\tfor e > 0 {\n\t\tif e%2 == 1 {\n\t\t\tr = (r * b) % mod\n\t\t}\n\t\te = e >> 1\n\t\tb = (b * b) % mod\n\t}\n\treturn r\n}\n","index":4},{"title":"Rot13","category":"ciphers","id":"rot13","index":5},{"title":"Rot13","category":"rot13","id":"rot13_rot13","algorithm":"package rot13\n\nimport (\n\t\"bytes\"\n\t\"strings\"\n)\n\nfunc rot13(input string) string {\n\tvar outputBuffer bytes.Buffer\n\tfor _, r := range strings.ToLower(input) {\n\t\tnewByte := int(r)\n\n\t\tif newByte >= 'a' && newByte <= 'z' {\n\t\t\tnewByte += 13\n\n\t\t\tif newByte > 'z' {\n\t\t\t\tnewByte -= 26\n\t\t\t} else if newByte < 'a' {\n\t\t\t\tnewByte += 26\n\t\t\t}\n\t\t}\n\n\t\toutputBuffer.WriteString(string(newByte))\n\t}\n\treturn outputBuffer.String()\n}\n","index":6},{"title":"Rot13 Test","category":"rot13","id":"rot13_test_rot13","algorithm":"package rot13\n\nimport (\n\t\"testing\"\n)\n\nvar rot13TestData = []struct {\n\tdescription string\n\tinput       string\n\texpected    string\n}{\n\t{\n\t\t\"Basic rotation with letter 'a' gives 'n\",\n\t\t\"a\",\n\t\t\"n\",\n\t},\n\t{\n\t\t\"Rotation with wrapping around alphabet on letter 'z' gives 'm'\",\n\t\t\"z\",\n\t\t\"m\",\n\t},\n\t{\n\t\t\"Rotation on 'hello world'\",\n\t\t\"hello world\",\n\t\t\"uryyb jbeyq\",\n\t},\n\t{\n\t\t\"Rotation on the rotation of 'hello world' gives 'hello world' back\",\n\t\t\"uryyb jbeyq\",\n\t\t\"hello world\",\n\t},\n\t{\n\t\t\"Full sentence rotation\",\n\t\t\"the quick brown fox jumps over the lazy dog.\",\n\t\t\"gur dhvpx oebja sbk whzcf bire gur ynml qbt.\",\n\t},\n\t{\n\t\t\"Sentence from Rot13.go main function\",\n\t\t\"we'll just make him an offer he can't refuse... tell me you get the pop culture reference\",\n\t\t\"jr'yy whfg znxr uvz na bssre ur pna'g ershfr... gryy zr lbh trg gur cbc phygher ersrerapr\",\n\t},\n}\n\nfunc TestRot13Encrypt(t *testing.T) {\n\tfor _, test := range rot13TestData {\n\t\tt.Run(test.description, func(t *testing.T) {\n\t\t\tinput := test.input\n\t\t\texpected := test.expected\n\t\t\tassertRot13Output(t, input, expected)\n\t\t})\n\t}\n}\n\nfunc TestRot13Decrypt(t *testing.T) {\n\tfor _, test := range rot13TestData {\n\t\tt.Run(test.description, func(t *testing.T) {\n\t\t\tinput := test.expected\n\t\t\texpected := test.input\n\t\t\tassertRot13Output(t, input, expected)\n\t\t})\n\t}\n}\n\nfunc assertRot13Output(t *testing.T, input, expected string) {\n\tactual := rot13(input)\n\tif actual != expected {\n\t\tt.Fatalf(\"With input string '%s' was expecting '%s' but actual was '%s'\",\n\t\t\tinput, expected, actual)\n\t}\n}\n","index":7},{"title":"Rsa","category":"ciphers","id":"rsa","index":8},{"title":"RSAcipher","category":"rsa","id":"RSAcipher_rsa","algorithm":"package main\n\nimport (\n\t//\"math/big\"\n\t\"fmt\"\n\t\"math\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc generatePrimes(limit int) int {\n\t/*\n\t\tgenerate primes by factoring\n\t\trelies on the 30k+i, though better formulae exist\n\t\twhere k >=0 and i = (1,7,11,13,17,13,19,23,29)\n\t*/\n\tprimes := prime(limit)\n\tvar choice []int\n\tchoice = append(choice, 1, 7, 11, 13, 17, 19, 23, 29)\n\tfor {\n\t\tk := rand.Intn(int(limit / 30))\n\t\ti := choice[rand.Intn(len(choice))]\n\t\tc := 30*k + i\n\t\tfound := true\n\t\tfor _, v := range primes {\n\t\t\tif c%v == 0 {\n\t\t\t\tfound = false\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif found {\n\t\t\treturn c\n\t\t}\n\t}\n}\nfunc prime(limit int) (primes []int) {\n\tsqrtLimit := int(math.Ceil(math.Sqrt(float64(limit))))\n\texit := false\n\tprimes = append(primes, 2, 3, 5)\n\tlastIndex := 2\n\tfor primes[lastIndex] < sqrtLimit {\n\t\tif exit == true {\n\t\t\tbreak\n\t\t}\n\t\tfor i := primes[lastIndex] + 2; i < primes[lastIndex]*primes[lastIndex]; i += 2 {\n\t\t\tfound := true\n\t\t\tfor _, v := range primes {\n\t\t\t\tif i%v == 0 {\n\t\t\t\t\tfound = false\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif found {\n\t\t\t\tprimes = append(primes, i)\n\t\t\t\tlastIndex++\n\t\t\t\tif i >= sqrtLimit {\n\t\t\t\t\texit = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\treturn\n}\nfunc lcm(a, b int) int {\n\t//complexity depends on gcd\n\treturn int((a * b) / gcd(a, b))\n\n}\nfunc gcd(a, b int) int {\n\t//complexity not clear\n\tfor b != 0 {\n\t\tt := b\n\t\tb = a % b\n\t\ta = t\n\t}\n\treturn a\n}\nfunc modularMultiplicativeInverse(e, delta int) int {\n\t//runs in O(n) where n = delta\n\te = e % delta\n\tfor i := 1; i < delta; i++ {\n\t\tif (i*e)%delta == 1 {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn 0\n}\n\nfunc modularExponentiation(b, e, mod int) int {\n\t//runs in O(log(n)) where n = e\n\tif mod == 1 {\n\t\treturn 0\n\t}\n\tr := 1\n\tb = b % mod\n\tfor e > 0 {\n\t\tif e%2 == 1 {\n\t\t\tr = (r * b) % mod\n\t\t}\n\t\te = e >> 1\n\t\tb = (b * b) % mod\n\t}\n\treturn r\n}\n\nfunc encryptRSA(message []int, e, n int) []int {\n\t//runs in O(k*log(n)) where k = len(message) and n = e\n\tvar ciphertext []int\n\tfor _, v := range message {\n\t\tciphertext = append(ciphertext, modularExponentiation(v, e, n))\n\t}\n\treturn ciphertext\n}\nfunc decryptRSA(ciphertext []int, d, n int) []int {\n\t//runs in O(k*log(n)) where k = len(ciphertext) and n = d\n\tvar message []int\n\tfor _, v := range ciphertext {\n\t\tmessage = append(message, modularExponentiation(v, d, n))\n\t}\n\treturn message\n}\nfunc toASCII(slice []rune) []int {\n\t//runs in O(n) where n = len(slice)\n\tvar converted []int\n\tfor _, v := range slice {\n\t\tconverted = append(converted, int(v))\n\t}\n\treturn converted\n}\n\nfunc toRune(slice []int) string {\n\t//runs in O(n) where n = len(slice)\n\tvar str string\n\tfor _, v := range slice {\n\t\tstr += string(v)\n\t}\n\treturn str\n}\n\nfunc main() {\n\trand.Seed(time.Now().UTC().UnixNano())\n\tbits := 17\n\n\tp := generatePrimes(1 << bits)\n\tq := generatePrimes(1 << bits)\n\tfor p == q {\n\t\tq = generatePrimes(1 << bits)\n\t}\n\n\tn := p * q\n\n\tdelta := lcm(p-1, q-1)\n\n\te := generatePrimes(delta)\n\td := modularMultiplicativeInverse(e, delta)\n\n\tfmt.Printf(\"%v \\n%v \\n%v \\n%v\\n\", p, q, e, d)\n\n\tstr := \"I think RSA is really great\"\n\tmessage := []rune(str)\n\tasciiSlice := toASCII(message)\n\n\tfmt.Printf(\"asciiSlice : %v \\n\", asciiSlice)\n\tencrypted := encryptRSA(asciiSlice, e, n)\n\tfmt.Printf(\"encrypted : %v \\n\", encrypted)\n\tdecrypted := decryptRSA(encrypted, d, n)\n\tfmt.Printf(\"decrypted : %v \\n\", decrypted)\n\tfmt.Printf(\"cleartext : %v \\n\", toRune(decrypted))\n\t//switched to atom\n\n}\n","index":9},{"title":"Rsa Cipher Test","category":"rsa","id":"rsa_cipher_test_rsa","algorithm":"package main\n\nimport (\n\t\"math/rand\"\n\t\"reflect\"\n\t\"testing\"\n\t\"time\"\n)\n\nvar rsaTestData = []struct {\n\tdescription string\n\tinput       string\n}{\n\t{\n\t\t\"Encrypt letter 'a'\",\n\t\t\"a\",\n\t},\n\t{\n\t\t\"Encrypt 'hello world'\",\n\t\t\"hello world\",\n\t},\n\t{\n\t\t\"Encrypt full sentence\",\n\t\t\"the quick brown fox jumps over the lazy dog.\",\n\t},\n\t{\n\t\t\"Encrypt full sentence from RSAcipher.go main function\",\n\t\t\"I think RSA is really great\",\n\t},\n}\n\nfunc TestRSACipher(t *testing.T) {\n\trand.Seed(time.Now().UTC().UnixNano())\n\tbits := 17\n\n\tp := generatePrimes(1 << bits)\n\tq := generatePrimes(1 << bits)\n\tfor p == q {\n\t\tq = generatePrimes(1 << bits)\n\t}\n\tn := p * q\n\n\tdelta := lcm(p-1, q-1)\n\n\te := generatePrimes(delta)\n\td := modularMultiplicativeInverse(e, delta)\n\n\tfor _, test := range rsaTestData {\n\t\tt.Run(test.description, func(t *testing.T) {\n\n\t\t\tmessage := []rune(test.input)\n\t\t\texpected := toASCII(message)\n\n\t\t\tencrypted := encryptRSA(expected, e, n)\n\t\t\tdecrypted := decryptRSA(encrypted, d, n)\n\n\t\t\tif actual := decrypted; !reflect.DeepEqual(actual, expected) {\n\t\t\t\tt.Logf(\"FAIL: %s\", test.description)\n\t\t\t\tt.Fatalf(\"Expecting %v, actual %v\", expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}\n","index":10},{"title":"RsaBig","category":"ciphers","id":"rsaBig","index":11},{"title":"RSAcipher(Big)","category":"rsaBig","id":"RSAcipher(Big)_rsaBig","algorithm":"package main\n\nimport (\n\tcrypto \"crypto/rand\"\n\t\"fmt\"\n\t\"math/big\"\n\t\"strconv\"\n)\n\n/*\nCare has been taken to uses cryptographic secure functions\nThe primes numbers are 1024 bits which is as secure as u can get really\ncrypto/rand library has been imported as crypto and not rand\nThis import style will make it easier to spot all the cryptographic secure functions\n*/\nfunc main() {\n\tp, _ := crypto.Prime(crypto.Reader, 1024)\n\tq, _ := crypto.Prime(crypto.Reader, 1024)\n\tif !(primeCheck(p) || primeCheck(q)) {\n\t\t//they are always prime, no worries\n\t\tfmt.Println(\"These numbers ain't prime\")\n\t}\n\tn := new(big.Int).Mul(p, q)\n\n\tone := big.NewInt(1)\n\n\tdelta := lcmBig(p.Sub(p, one), q.Sub(q, one))\n\n\te, _ := crypto.Prime(crypto.Reader, delta.BitLen())\n\td := big.NewInt(0)\n\td.ModInverse(e, delta)\n\n\tcleartext := \"Black Lives Matter, all lives can't matter until Black lives matter\"\n\trunes := []rune(cleartext)\n\tASCIIs := toASCII(runes)\n\tstringEncoded := stringEncode(ASCIIs)\n\tbigNum, _ := new(big.Int).SetString(stringEncoded, 0)\n\t/*\n\t\tTODO: check that bigNum is not larger than N if larger break\n\t\tinto two or more strings and encrypt separately\n\t*/\n\tfmt.Printf(\"Message to be encrypted: %v \\n\", cleartext)\n\tfmt.Printf(\"ASCII encoded: %v\\n\", bigNum)\n\tencrypted := encryptBig(bigNum, e, n)\n\tfmt.Printf(\"ciphertext: %v \\n\", encrypted)\n\tdecrypted := decryptBig(encrypted, d, n)\n\tfmt.Printf(\"Decrypted but still ASCII encoded: %v \\n\", decrypted)\n\tdecryptASCIIs := stringDecode(decrypted)\n\tfmt.Printf(\"Plaintext (original message) :%v\", toRune(decryptASCIIs))\n}\n\nfunc encryptBig(num *big.Int, privateExponent *big.Int, modulus *big.Int) *big.Int {\n\t//encrypts by modular exponentiation\n\tencrypted := new(big.Int).Exp(num, privateExponent, modulus)\n\treturn encrypted\n}\n\nfunc decryptBig(num *big.Int, publicExponent *big.Int, modulus *big.Int) *big.Int {\n\t//decrypts by modular exponentiation\n\tdecrypted := new(big.Int).Exp(num, publicExponent, modulus)\n\treturn decrypted\n}\n\nfunc lcmBig(x *big.Int, y *big.Int) *big.Int {\n\t//an lcm implementation for big.Int numbers\n\tgcd := new(big.Int).GCD(nil, nil, x, y)\n\ttemp := new(big.Int).Mul(x, y)\n\tlcm := new(big.Int).Div(temp, gcd)\n\treturn lcm\n}\n\nfunc primeCheck(prime *big.Int) bool {\n\t//primality test\n\treturn prime.ProbablyPrime(256)\n}\n\nfunc toASCII(slice []rune) []int {\n\t//runs in O(n) where n = len(slice)\n\tvar converted []int\n\tfor _, v := range slice {\n\t\tconverted = append(converted, int(v))\n\t}\n\treturn converted\n}\n\nfunc toRune(slice []int) string {\n\t//runs in O(n) where n = len(slice)\n\tvar str string\n\tfor _, v := range slice {\n\t\tstr += string(v)\n\t}\n\treturn str\n}\n\nfunc stringEncode(slice []int) string {\n\t//encodes the ASCII to a string\n\tvar out []string\n\tfor _, v := range slice {\n\t\tif v < 100 {\n\t\t\tout = append(out, \"0\"+strconv.Itoa(v))\n\t\t\tcontinue\n\t\t}\n\t\tout = append(out, strconv.Itoa(v))\n\t}\n\tvar str string\n\tfor _, v := range out {\n\t\tstr += v\n\t}\n\t//strips leading 0 if present to avoid conversion errors\n\tif str[0] == '0' {\n\t\tstr = str[1:]\n\t}\n\treturn str\n}\n\nfunc stringDecode(decryptedBig *big.Int) []int {\n\t//decodes the number to string then ASCII values\n\tstr := decryptedBig.String()\n\tif len(str)%3 != 0 {\n\t\tstr = \"0\" + str\n\t}\n\tvar ASCII []int\n\tfor i := 0; i < len(str); i += 3 {\n\t\ttemp, _ := strconv.Atoi(str[i : i+3])\n\t\tASCII = append(ASCII, temp)\n\t}\n\treturn ASCII\n}\n","index":12},{"title":"Rsa Cipher Big Test","category":"rsaBig","id":"rsa_cipher_big_test_rsaBig","algorithm":"package main\n\nimport (\n\tcrypto \"crypto/rand\"\n\t\"math/big\"\n\t\"testing\"\n)\n\nvar rsaTestData = []struct {\n\tdescription string\n\tinput       string\n}{\n\t{\n\t\t\"Encrypt letter 'a'\",\n\t\t\"a\",\n\t},\n\t{\n\t\t\"Encrypt 'hello world'\",\n\t\t\"hello world\",\n\t},\n\t{\n\t\t\"Encrypt full sentence\",\n\t\t\"the quick brown fox jumps over the lazy dog.\",\n\t},\n\t{\n\t\t\"Encrypt full sentence from RSAcipher(Big).go main function\",\n\t\t\"Black Lives Matter, all lives can't matter until Black lives matter\",\n\t},\n}\n\nfunc TestRSABigCipher(t *testing.T) {\n\tp, _ := crypto.Prime(crypto.Reader, 1024)\n\tq, _ := crypto.Prime(crypto.Reader, 1024)\n\tn := new(big.Int).Mul(p, q)\n\n\tone := big.NewInt(1)\n\n\tdelta := lcmBig(p.Sub(p, one), q.Sub(q, one))\n\n\te, _ := crypto.Prime(crypto.Reader, delta.BitLen())\n\td := big.NewInt(0)\n\td.ModInverse(e, delta)\n\n\tfor _, test := range rsaTestData {\n\t\tt.Run(test.description, func(t *testing.T) {\n\n\t\t\trunes := []rune(test.input)\n\t\t\tASCIIs := toASCII(runes)\n\t\t\tstringEncoded := stringEncode(ASCIIs)\n\t\t\tbigNum, _ := new(big.Int).SetString(stringEncoded, 0)\n\n\t\t\tencrypted := encryptBig(bigNum, e, n)\n\t\t\tdecrypted := decryptBig(encrypted, d, n)\n\t\t\tdecryptASCIIs := stringDecode(decrypted)\n\n\t\t\tif actual := toRune(decryptASCIIs); actual != test.input {\n\t\t\t\tt.Logf(\"FAIL: %s\", test.description)\n\t\t\t\tt.Fatalf(\"Expecting %s, actual %s\", test.input, actual)\n\t\t\t}\n\t\t})\n\t}\n}\n","index":13},{"title":"Xor","category":"ciphers","id":"xor","index":14},{"title":"XorCipher","category":"xor","id":"xorCipher_xor","algorithm":"package main\n\nimport \"fmt\"\n\nfunc encrypt(key int, plaintext []int) (ciphertext []int) {\n\tfor _, char := range plaintext {\n\t\tciphertext = append(ciphertext, xor(char, key))\n\t}\n\treturn\n}\nfunc xor(char int, key int) int {\n\treturn (char ^ key)\n}\n\nfunc decrypt(key int, ciphertext []int) (plaintext []int) {\n\tfor _, char := range ciphertext {\n\t\tplaintext = append(plaintext, xor(char, key))\n\t}\n\treturn\n}\n\nfunc decodeToString(slice []int) (str string) {\n\tfor _, v := range slice {\n\t\tstr += string(v)\n\t}\n\treturn\n}\nfunc toASCII(slice []rune) []int {\n\tvar converted []int\n\tfor _, v := range slice {\n\t\tconverted = append(converted, int(v))\n\t}\n\treturn converted\n}\nfunc main() {\n\tstr := \"hello world\"\n\tkey := 97\n\ttemp := []rune(str)\n\tmessage := toASCII(temp)\n\tencrypted := encrypt(key, message)\n\tdecrypted := decrypt(key, encrypted)\n\tplaintext := decodeToString(decrypted)\n\tfmt.Println(plaintext)\n}\n","index":15},{"title":"Xor Cipher Test","category":"xor","id":"xor_cipher_test_xor","algorithm":"package main\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nvar xorTestData = []struct {\n\tdescription string\n\tinput       string\n\tkey         int\n\tencrypted   string\n}{\n\t{\n\t\t\"Encrypt letter 'a' with key 0 makes no changes\",\n\t\t\"a\",\n\t\t0,\n\t\t\"a\",\n\t},\n\t{\n\t\t\"Encrypt letter 'a' with key 1\",\n\t\t\"a\",\n\t\t1,\n\t\t\"`\",\n\t},\n\t{\n\t\t\"Encrypt letter 'a' with key 10\",\n\t\t\"a\",\n\t\t10,\n\t\t\"k\",\n\t},\n\t{\n\t\t\"Encrypt 'hello world' with key 0 makes no changes\",\n\t\t\"hello world\",\n\t\t0,\n\t\t\"hello world\",\n\t},\n\t{\n\t\t\"Encrypt 'hello world' with key 1\",\n\t\t\"hello world\",\n\t\t1,\n\t\t\"idmmn!vnsme\",\n\t},\n\t{\n\t\t\"Encrypt 'hello world' with key 10\",\n\t\t\"hello world\",\n\t\t10,\n\t\t\"boffe*}exfn\",\n\t},\n\t{\n\t\t\"Encrypt full sentence with key 64\",\n\t\t\"the quick brown fox jumps over the lazy dog.\",\n\t\t64,\n\t\t\"4(%`15)#+`\\\"2/7.`&/8`*5-03`/6%2`4(%`,!:9`$/'n\",\n\t},\n\t{\n\t\t\"Encrypt a word with key 32 make the case swap\",\n\t\t\"abcdefghijklmNOPQRSTUVWXYZ\",\n\t\t32,\n\t\t\"ABCDEFGHIJKLMnopqrstuvwxyz\",\n\t},\n}\n\nfunc TestXorCipherEncrypt(t *testing.T) {\n\tfor _, test := range xorTestData {\n\t\tt.Run(test.description, func(t *testing.T) {\n\n\t\t\tmessage := toASCII([]rune(test.input))\n\t\t\tencrypted := encrypt(test.key, message)\n\n\t\t\tif actual := decodeToString(encrypted); !reflect.DeepEqual(actual, test.encrypted) {\n\t\t\t\tt.Logf(\"FAIL: %s\", test.description)\n\t\t\t\tt.Fatalf(\"Expecting %s, actual %s\", test.encrypted, actual)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestXorCipherDecrypt(t *testing.T) {\n\tfor _, test := range xorTestData {\n\t\tt.Run(test.description, func(t *testing.T) {\n\n\t\t\tmessage := toASCII([]rune(test.encrypted))\n\t\t\tdecrypted := decrypt(test.key, message)\n\n\t\t\tif actual := decodeToString(decrypted); !reflect.DeepEqual(actual, test.input) {\n\t\t\t\tt.Logf(\"FAIL: %s\", test.description)\n\t\t\t\tt.Fatalf(\"Expecting %s, actual %s\", test.input, actual)\n\t\t\t}\n\t\t})\n\t}\n}\n","index":16},{"title":"Conversions","category":null,"id":"conversions","index":17},{"title":"Roman-to-integer","category":"conversions","id":"roman-to-integer","index":18},{"title":"Roman To Integer","category":"roman-to-integer","id":"roman_to_integer_roman-to-integer","algorithm":"/*\nThis algorithm will convert a standard roman number to an integer\nhttps://en.wikipedia.org/wiki/Roman_numerals\nFunction receives a string as a roman number and outputs an integer\nMaximum output will be 3999\nOnly standard form is supported\n*/\npackage conversions\n\nvar romans = map[string]int{\"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\": 1000}\n\nfunc RomanToInteger(roman string) int {\n\ttotal := 0\n\tholder := 0\n\tfor holder < len(roman) {\n\t\tif holder+1 < len(roman) && (romans[string(roman[holder])] < romans[string(roman[holder+1])]) {\n\t\t\ttotal += romans[string(roman[holder+1])] - romans[string(roman[holder])]\n\t\t\tholder += 2\n\t\t} else {\n\t\t\ttotal += romans[string(roman[holder])]\n\t\t\tholder++\n\t\t}\n\t}\n\treturn total\n}\n","index":19},{"title":"Roman To Integer Test","category":"roman-to-integer","id":"roman_to_integer_test_roman-to-integer","algorithm":"package conversions\n\nimport \"testing\"\n\ntype romanToIntegerConversionTest struct {\n\tinput    string\n\texpected int\n\tname     string\n}\n\nvar romanToIntegerTests = []romanToIntegerConversionTest{\n\t{input: \"DCCLXXXIX\", expected: 789, name: \"DCCLXXXIX-789\"},\n\t{input: \"MLXVI\", expected: 1066, name: \"MLXVI-1066\"},\n\t{input: \"MCMXVIII\", expected: 1918, name: \"MCMXVIII-1918\"},\n\t{input: \"V\", expected: 5, name: \"V-5\"},\n}\n\nfunc TestRomanToInteger(t *testing.T) {\n\n\tfor _, test := range romanToIntegerTests {\n\t\tconvertedValue := RomanToInteger(test.input)\n\t\tif convertedValue != test.expected {\n\t\t\tt.Errorf(\n\t\t\t\t\"roman to integer test %s failed. expected '%d' but got '%d'\",\n\t\t\t\ttest.name, test.expected, convertedValue,\n\t\t\t)\n\t\t}\n\t}\n}\n","index":20},{"title":"Datastructures","category":null,"id":"datastructures","index":21},{"title":"Binary-tree","category":"datastructures","id":"binary-tree","index":22},{"title":"Binarysearchtree","category":"binary-tree","id":"binarysearchtree_binary-tree","algorithm":"// Binary search tree\n// https://en.wikipedia.org/wiki/Binary_search_tree\n\npackage binarySearchTree\n\n// package main\n\nimport \"fmt\"\n\ntype node struct {\n\tval   int\n\tleft  *node\n\tright *node\n}\n\ntype btree struct {\n\troot *node\n}\n\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc newNode(val int) *node {\n\treturn &node{val, nil, nil}\n}\n\nfunc inorder(n *node) {\n\tif n != nil {\n\t\tinorder(n.left)\n\t\tfmt.Print(n.val, \" \")\n\t\tinorder(n.right)\n\t}\n}\n\nfunc insert(root *node, val int) *node {\n\tif root == nil {\n\t\treturn newNode(val)\n\t}\n\tif val < root.val {\n\t\troot.left = insert(root.left, val)\n\t} else {\n\t\troot.right = insert(root.right, val)\n\t}\n\treturn root\n}\n\nfunc inorderSuccessor(root *node) *node {\n\tcur := root\n\tfor cur.left != nil {\n\t\tcur = cur.left\n\t}\n\treturn cur\n}\n\nfunc bst_delete(root *node, val int) *node {\n\tif root == nil {\n\t\treturn nil\n\t}\n\tif val < root.val {\n\t\troot.left = bst_delete(root.left, val)\n\t} else if val > root.val {\n\t\troot.right = bst_delete(root.right, val)\n\t} else {\n\t\t// this is the node to delete\n\t\t// node with one child\n\t\tif root.left == nil {\n\t\t\treturn root.right\n\t\t} else if root.right == nil {\n\t\t\treturn root.left\n\t\t} else {\n\t\t\tn := root.right\n\t\t\td := inorderSuccessor(n)\n\t\t\td.left = root.left\n\t\t\treturn root.right\n\t\t}\n\t}\n\treturn root\n}\n\n// helper function for t.depth\nfunc _calculate_depth(n *node, depth int) int {\n\tif n == nil {\n\t\treturn depth\n\t}\n\treturn max(_calculate_depth(n.left, depth+1), _calculate_depth(n.right, depth+1))\n}\n\nfunc (t *btree) depth() int {\n\treturn _calculate_depth(t.root, 0)\n}\n\n\nfunc main() {\n\tt := &btree{nil}\n\tinorder(t.root)\n\tt.root = insert(t.root, 30)\n\n\tt.root = insert(t.root, 20)\n\tt.root = insert(t.root, 15)\n\tt.root = insert(t.root, 10)\n\tt.root = insert(t.root, 12)\n\tt.root = insert(t.root, 9)\n\tt.root = insert(t.root, 11)\n\tt.root = insert(t.root, 17)\n\tfmt.Print(t.depth(), \"\\n\")\n\tinorder(t.root)\n\tfmt.Print(\"\\n\")\n\tt.root = bst_delete(t.root, 10)\n\tinorder(t.root)\n\tfmt.Print(\"\\n\")\n\tt.root = bst_delete(t.root, 30)\n\tinorder(t.root)\n\tfmt.Print(\"\\n\")\n\tt.root = bst_delete(t.root, 15)\n\tinorder(t.root)\n\tfmt.Print(\"\\n\")\n\tt.root = bst_delete(t.root, 20)\n\tinorder(t.root)\n\tfmt.Print(\"\\n\")\n\tfmt.Print(t.depth(), \"\\n\")\n}\n\n","index":23},{"title":"Binarytree","category":"binary-tree","id":"binarytree_binary-tree","algorithm":"// basic binary tree and related operations\n\npackage binarytree\n\n// package main\n\nimport \"fmt\"\n\ntype node struct {\n\tval   int\n\tleft  *node\n\tright *node\n}\n\ntype btree struct {\n\troot *node\n}\n\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc newNode(val int) *node {\n\tn := &node{val, nil, nil}\n\treturn n\n}\n\nfunc inorder(n *node) {\n\tif n == nil {\n\t\treturn\n\t}\n\tinorder(n.left)\n\tfmt.Print(n.val, \" \")\n\tinorder(n.right)\n}\n\nfunc preorder(n *node) {\n\tif n == nil {\n\t\treturn\n\t}\n\tfmt.Print(n.val, \" \")\n\tpreorder(n.left)\n\tpreorder(n.right)\n}\n\nfunc postorder(n *node) {\n\tif n == nil {\n\t\treturn\n\t}\n\tpostorder(n.left)\n\tpostorder(n.right)\n\tfmt.Print(n.val, \" \")\n}\n\nfunc levelorder(root *node) {\n\tvar q []*node // queue\n\tvar n *node   // temporary node\n\n\tq = append(q, root)\n\n\tfor len(q) != 0 {\n\t\tn, q = q[0], q[1:]\n\t\tfmt.Print(n.val, \" \")\n\t\tif n.left != nil {\n\t\t\tq = append(q, n.left)\n\t\t}\n\t\tif n.right != nil {\n\t\t\tq = append(q, n.right)\n\t\t}\n\t}\n}\n\n// helper function for t.depth\nfunc _calculate_depth(n *node, depth int) int {\n\tif n == nil {\n\t\treturn depth\n\t}\n\treturn max(_calculate_depth(n.left, depth+1), _calculate_depth(n.right, depth+1))\n}\n\nfunc (t *btree) depth() int {\n\treturn _calculate_depth(t.root, 0)\n}\n\n/*\nfunc main() {\n\tt := btree{nil}\n\tt.root = newNode(0)\n\tt.root.left = newNode(1)\n\tt.root.right = newNode(2)\n\tt.root.left.left = newNode(3)\n\tt.root.left.right = newNode(4)\n\tt.root.right.left = newNode(5)\n\tt.root.right.right = newNode(6)\n\tt.root.right.right.right = newNode(10)\n\n\tinorder(t.root)\n\tfmt.Print(\"\\n\")\n\tpreorder(t.root)\n\tfmt.Print(\"\\n\")\n\tpostorder(t.root)\n\tfmt.Print(\"\\n\")\n\tlevelorder(t.root)\n\tfmt.Print(\"\\n\")\n\tfmt.Print(t.depth(), \"\\n\")\n}\n*/\n","index":24},{"title":"Dynamic-array","category":"datastructures","id":"dynamic-array","index":25},{"title":"Dynamicarray","category":"dynamic-array","id":"dynamicarray_dynamic-array","algorithm":"package dynamic-array\n\nimport (\n\t\"errors\"\n)\n\nvar defaultCapacity = 10\n\ntype dynamicArray struct {\n\tsize        int\n\tcapacity    int\n\telementData []interface{}\n}\n\nfunc (da *dynamicArray) put(index int, element interface{}) error {\n\terr := da.checkRangeFromIndex(index)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tda.elementData[index] = element\n\n\treturn nil\n}\n\nfunc (da *dynamicArray) add(element interface{}) {\n\tif da.size == da.capacity {\n\t\tda.newCapacity()\n\t}\n\n\tda.elementData[da.size] = element\n\tda.size++\n}\n\nfunc (da *dynamicArray) remove(index int) error {\n\terr := da.checkRangeFromIndex(index)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcopy(da.elementData[index:], da.elementData[index+1:da.size])\n\tda.elementData[da.size-1] = nil\n\n\tda.size--\n\n\treturn nil\n}\n\nfunc (da *dynamicArray) get(index int) (interface{}, error) {\n\terr := da.checkRangeFromIndex(index)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn da.elementData[index], nil\n}\n\nfunc (da *dynamicArray) isEmpty() bool {\n\treturn da.size == 0\n}\n\nfunc (da *dynamicArray) getData() []interface{} {\n\treturn da.elementData[:da.size]\n}\n\nfunc (da *dynamicArray) checkRangeFromIndex(index int) error {\n\tif index >= da.size || index < 0 {\n\t\treturn errors.New(\"index out of range\")\n\t}\n\treturn nil\n}\n\nfunc (da *dynamicArray) newCapacity() {\n\tif da.capacity == 0 {\n\t\tda.capacity = defaultCapacity\n\t} else {\n\t\tda.capacity = da.capacity << 1\n\t}\n\n\tnewDataElement := make([]interface{}, da.capacity)\n\n\tcopy(newDataElement, da.elementData)\n\n\tda.elementData = newDataElement\n}\n\n// func main() {\n// \tnumbers := dynamicArray{}\n// \tfmt.Println(numbers.isEmpty())\n\n// \tnumbers.add(10)\n// \tnumbers.add(20)\n// \tnumbers.add(30)\n// \tnumbers.add(40)\n// \tnumbers.add(50)\n\n// \tfmt.Println(numbers.isEmpty())\n\n// \tfmt.Println(numbers.getData())\n\n// \tnumbers.remove(1)\n\n// \tfmt.Println(numbers.getData())\n\n// \tnumberFound, _ := numbers.get(1)\n// \tfmt.Println(numberFound)\n\n// \tnumbers.put(0, 100)\n// \tfmt.Println(numbers.getData())\n// }\n\n","index":26},{"title":"Hashmap","category":"datastructures","id":"hashmap","index":27},{"title":"Hashmap","category":"hashmap","id":"hashmap_hashmap","algorithm":"package hashmap\n\nimport (\n\t\"fmt\"\n\t\"hash/fnv\"\n)\n\nvar defaultCapacity uint64 = 1 << 10\n\ntype node struct {\n\tkey   interface{}\n\tvalue interface{}\n\tnext  *node\n}\n\n// HashMap is golang implementation of hashmap\ntype HashMap struct {\n\tcapacity uint64\n\tsize     uint64\n\ttable    []*node\n}\n\n// New return new HashMap instance\nfunc New() *HashMap {\n\treturn &HashMap{\n\t\tcapacity: defaultCapacity,\n\t\ttable:    make([]*node, defaultCapacity),\n\t}\n}\n\n// Get returns value associated with given key\nfunc (hm *HashMap) Get(key interface{}) interface{} {\n\tnode := hm.getNodeByHash(hm.hash(key))\n\n\tif node != nil {\n\t\treturn node.value\n\t}\n\n\treturn nil\n}\n\n// Put puts new key value in hashmap\nfunc (hm *HashMap) Put(key interface{}, value interface{}) interface{} {\n\treturn hm.putValue(hm.hash(key), key, value)\n}\n\n// Contains checks if given key is stored in hashmap\nfunc (hm *HashMap) Contains(key interface{}) bool {\n\tnode := hm.getNodeByHash(hm.hash(key))\n\treturn node != nil\n}\n\nfunc (hm *HashMap) putValue(hash uint64, key interface{}, value interface{}) interface{} {\n\tif hm.capacity == 0 {\n\t\thm.capacity = defaultCapacity\n\t\thm.table = make([]*node, defaultCapacity)\n\t}\n\n\tnode := hm.getNodeByHash(hash)\n\n\tif node == nil {\n\t\thm.table[hash] = newNode(key, value)\n\n\t} else if node.key == key {\n\t\thm.table[hash] = newNodeWithNext(key, value, node)\n\t\treturn value\n\n\t} else {\n\t\thm.resize()\n\t\treturn hm.putValue(hash, key, value)\n\t}\n\n\thm.size++\n\n\treturn value\n\n}\n\nfunc (hm *HashMap) getNodeByHash(hash uint64) *node {\n\treturn hm.table[hash]\n}\n\nfunc (hm *HashMap) resize() {\n\thm.capacity <<= 1\n\n\ttempTable := hm.table\n\n\thm.table = make([]*node, hm.capacity)\n\n\tfor i := 0; i < len(tempTable); i++ {\n\t\tnode := tempTable[i]\n\t\tif node == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\thm.table[hm.hash(node.key)] = node\n\t}\n}\n\nfunc newNode(key interface{}, value interface{}) *node {\n\treturn &node{\n\t\tkey:   key,\n\t\tvalue: value,\n\t}\n}\n\nfunc newNodeWithNext(key interface{}, value interface{}, next *node) *node {\n\treturn &node{\n\t\tkey:   key,\n\t\tvalue: value,\n\t\tnext:  next,\n\t}\n}\n\nfunc (hm *HashMap) hash(key interface{}) uint64 {\n\th := fnv.New64a()\n\t_, _ = h.Write([]byte(fmt.Sprintf(\"%v\", key)))\n\n\thashValue := h.Sum64()\n\n\treturn (hm.capacity - 1) & (hashValue ^ (hashValue >> 16))\n}\n","index":28},{"title":"Hashmap Test","category":"hashmap","id":"hashmap_test_hashmap","algorithm":"package hashmap_test\n\nimport (\n\t\"TheAlgorithms/Go/datastructures/hashmap\"\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestHashMap_Contains(t *testing.T) {\n\n\tmp := hashmap.New()\n\n\tmp.Put(\"test-1\", 10)\n\tfmt.Println(mp.Get(\"test-1\"))\n\n\tmp.Put(\"test-1\", 20)\n\tmp.Put(\"test-2\", 30)\n\tmp.Put(1, 40)\n\n\tfmt.Println(mp.Get(\"test-1\"))\n\tfmt.Println(mp.Get(\"test-2\"))\n\tfmt.Println(mp.Get(1))\n\n\tfmt.Println(mp.Contains(2))\n\tfmt.Println(mp.Contains(1))\n\tfmt.Println(mp.Contains(\"test-1\"))\n\n}\n","index":29},{"title":"Linkedlist","category":"datastructures","id":"linkedlist","index":30},{"title":"Doublylinkedlist","category":"linkedlist","id":"doublylinkedlist_linkedlist","algorithm":"// demonstration of doubly linked list in golang\n\npackage linkedlist\n\n// package main\n\nimport \"fmt\"\n\ntype node struct {\n\tval  int\n\tnext *node\n\tprev *node\n}\n\ntype doublelinkedlist struct {\n\thead *node\n}\n\n// to avoid mistakes when using pointer vs struct for new node creation\nfunc newNode(val int) *node {\n\tn := &node{}\n\tn.val = val\n\tn.next = nil\n\tn.prev = nil\n\treturn n\n}\n\nfunc (ll *doublelinkedlist) addAtBeg(val int) {\n\tn := newNode(val)\n\tn.next = ll.head\n\tll.head = n\n}\n\nfunc (ll *doublelinkedlist) addAtEnd(val int) {\n\tn := newNode(val)\n\n\tif ll.head == nil {\n\t\tll.head = n\n\t\treturn\n\t}\n\n\tcur := ll.head\n\tfor ; cur.next != nil; cur = cur.next {\n\t}\n\tcur.next = n\n\tn.prev = cur\n}\n\nfunc (ll *doublelinkedlist) delAtBeg() int {\n\tif ll.head == nil {\n\t\treturn -1\n\t}\n\n\tcur := ll.head\n\tll.head = cur.next\n\n\tif ll.head != nil {\n\t\tll.head.prev = nil\n\t}\n\n\treturn cur.val\n}\n\nfunc (ll *doublelinkedlist) delAtEnd() int {\n\t// no item\n\tif ll.head == nil {\n\t\treturn -1\n\t}\n\n\t// only one item\n\tif ll.head.next == nil {\n\t\treturn ll.delAtBeg()\n\t}\n\n\t// more than one, go to second last\n\tcur := ll.head\n\tfor ; cur.next.next != nil; cur = cur.next {\n\t}\n\n\tretval := cur.next.val\n\tcur.next = nil\n\treturn retval\n}\n\nfunc (ll *doublelinkedlist) count() int {\n\tvar ctr int = 0\n\n\tfor cur := ll.head; cur != nil; cur = cur.next {\n\t\tctr += 1\n\t}\n\n\treturn ctr\n}\n\nfunc (ll *doublelinkedlist) reverse() {\n\tvar prev, next *node\n\tcur := ll.head\n\n\tfor cur != nil {\n\t\tnext = cur.next\n\t\tcur.next = prev\n\t\tcur.prev = next\n\t\tprev = cur\n\t\tcur = next\n\t}\n\n\tll.head = prev\n}\n\nfunc (ll *doublelinkedlist) display() {\n\tfor cur := ll.head; cur != nil; cur = cur.next {\n\t\tfmt.Print(cur.val, \" \")\n\t}\n\n\tfmt.Print(\"\\n\")\n}\n\nfunc (ll *doublelinkedlist) displayReverse() {\n\tif ll.head == nil {\n\t\treturn\n\t}\n\tvar cur *node\n\tfor cur = ll.head; cur.next != nil; cur = cur.next {\n\t}\n\n\tfor ; cur != nil; cur = cur.prev {\n\t\tfmt.Print(cur.val, \" \")\n\t}\n\n\tfmt.Print(\"\\n\")\n}\n\n/*\nfunc main() {\n\tll := doublelinkedlist{}\n\n\tll.addAtBeg(10)\n\tll.addAtEnd(20)\n\tll.display()\n\tll.addAtBeg(30)\n\tll.display()\n\n\tll.reverse()\n\tll.display()\n\tll.displayReverse()\n\n\tfmt.Print(ll.delAtBeg(), \"\\n\")\n\tfmt.Print(ll.delAtEnd(), \"\\n\")\n\tfmt.Print(\"Display\")\n\tll.display()\n\tfmt.Print(ll.delAtBeg(), \"\\n\")\n\tll.display()\n\tfmt.Print(ll.delAtBeg(), \"\\n\")\n\tll.display()\n}\n*/\n","index":31},{"title":"Singlelinkedlist","category":"linkedlist","id":"singlelinkedlist","index":32},{"title":"Single-linkedlist","category":"singlelinkedlist","id":"single-linkedlist_singlelinkedlist","algorithm":"package singlelinkedlist\n\n// demonstration of singly linked list in golang\nimport \"fmt\"\n\ntype node struct {\n\tVal  interface{}\n\tNext *node\n}\n\ntype singlelinkedlist struct {\n\tlength int\n\tHead   *node\n}\n\n// CreateList returns a new instance of a linked list\nfunc CreateList() *singlelinkedlist {\n\treturn &singlelinkedlist{}\n}\n\n// to avoid mistakes when using pointer vs struct for new node creation\nfunc newNode(val interface{}) *node {\n\treturn &node{val, nil}\n}\n\n// AddAtBeg adds a new node with given value at the beginning of the list.\nfunc (ll *singlelinkedlist) AddAtBeg(val interface{}) {\n\tn := newNode(val)\n\tn.Next = ll.Head\n\tll.Head = n\n\tll.length++\n}\n\n// AddAtEnd adds a new node with given value at the end of the list.\nfunc (ll *singlelinkedlist) AddAtEnd(val int) {\n\tn := newNode(val)\n\n\tif ll.Head == nil {\n\t\tll.Head = n\n\t\tll.length++\n\t\treturn\n\t}\n\n\tcur := ll.Head\n\tfor ; cur.Next != nil; cur = cur.Next {\n\t}\n\tcur.Next = n\n\tll.length++\n}\n\n// DelAtBeg deletes the node at the head(beginning) of the list and returns its value. Returns -1 if the list is empty.\nfunc (ll *singlelinkedlist) DelAtBeg() interface{} {\n\tif ll.Head == nil {\n\t\treturn -1\n\t}\n\n\tcur := ll.Head\n\tll.Head = cur.Next\n\tll.length--\n\n\treturn cur.Val\n}\n\n// DelAtEnd deletes the node at the tail(end) of the list and returns its value. Returns -1 if the list is empty.\nfunc (ll *singlelinkedlist) DelAtEnd() interface{} {\n\tif ll.Head == nil {\n\t\treturn -1\n\t}\n\n\tif ll.Head.Next == nil {\n\t\treturn ll.DelAtBeg()\n\t}\n\n\tcur := ll.Head\n\n\tfor ; cur.Next.Next != nil; cur = cur.Next {\n\t}\n\n\tretval := cur.Next.Val\n\tcur.Next = nil\n\tll.length--\n\treturn retval\n\n}\n\n// Count returns the current size of the list.\nfunc (ll *singlelinkedlist) Count() int {\n\treturn ll.length\n}\n\n// Reverse reverses the list.\nfunc (ll *singlelinkedlist) Reverse() {\n\tvar prev, Next *node\n\tcur := ll.Head\n\n\tfor cur != nil {\n\t\tNext = cur.Next\n\t\tcur.Next = prev\n\t\tprev = cur\n\t\tcur = Next\n\t}\n\n\tll.Head = prev\n}\n\n// Display prints out the elements of the list.\nfunc (ll *singlelinkedlist) Display() {\n\tfor cur := ll.Head; cur != nil; cur = cur.Next {\n\t\tfmt.Print(cur.Val, \" \")\n\t}\n\n\tfmt.Print(\"\\n\")\n}\n","index":33},{"title":"Single-linkedlist Test","category":"singlelinkedlist","id":"single-linkedlist_test_singlelinkedlist","algorithm":"package singlelinkedlist\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestLinkedList(t *testing.T) {\n\tlist := CreateList()\n\tlist.AddAtBeg(1)\n\tlist.AddAtBeg(2)\n\tlist.AddAtBeg(3)\n\n\tt.Run(\"Test AddAtBeg()\", func(t *testing.T) {\n\t\twant := []interface{}{3, 2, 1}\n\t\tgot := []interface{}{}\n\t\tcurrent := list.Head\n\t\tgot = append(got, current.Val)\n\t\tfor current.Next != nil {\n\t\t\tcurrent = current.Next\n\t\t\tgot = append(got, current.Val)\n\t\t}\n\t\tif !reflect.DeepEqual(got, want) {\n\t\t\tt.Errorf(\"got: %v, want: %v\", got, want)\n\t\t}\n\t})\n\n\tlist.AddAtEnd(4)\n\n\tt.Run(\"Test AddAtEnd()\", func(t *testing.T) {\n\t\twant := []interface{}{3, 2, 1, 4}\n\t\tgot := []interface{}{}\n\t\tcurrent := list.Head\n\t\tgot = append(got, current.Val)\n\t\tfor current.Next != nil {\n\t\t\tcurrent = current.Next\n\t\t\tgot = append(got, current.Val)\n\t\t}\n\t\tif !reflect.DeepEqual(got, want) {\n\t\t\tt.Errorf(\"got: %v, want: %v\", got, want)\n\t\t}\n\t})\n\n\tt.Run(\"Test DelAtBeg()\", func(t *testing.T) {\n\t\twant := interface{}(3)\n\t\tgot := list.DelAtBeg()\n\t\tif got != want {\n\t\t\tt.Errorf(\"got: %v, want: %v\", got, want)\n\t\t}\n\t})\n\n\tt.Run(\"Test DelAtEnd()\", func(t *testing.T) {\n\t\twant := interface{}(4)\n\t\tgot := list.DelAtEnd()\n\t\tif got != want {\n\t\t\tt.Errorf(\"got: %v, want: %v\", got, want)\n\t\t}\n\t})\n\n\tt.Run(\"Test Count()\", func(t *testing.T) {\n\t\twant := 2\n\t\tgot := list.Count()\n\t\tif got != want {\n\t\t\tt.Errorf(\"got: %v, want: %v\", got, want)\n\t\t}\n\t})\n}\n","index":34},{"title":"Singlylinkedlist","category":"linkedlist","id":"singlylinkedlist_linkedlist","algorithm":"package linkedlist\n\nimport \"fmt\"\n\n/* v is the value of node; next is the pointer to next node */\ntype node struct {\n\tv    int\n\tnext *node\n}\n\n/* first node, called head. It points from first node to last node */\nvar head *node = nil\n\nfunc (l *node) pushFront(val int) *node {\n\t/* if there's no nodes, head points to l (first node) */\n\tif head == nil {\n\t\tl.v = val\n\t\tl.next = nil\n\t\thead = l\n\t\treturn l\n\t} else {\n\t\t/* create a new node equals to head */\n\t\tnnode := new(node)\n\t\tnnode = head\n\t\t/* create a second node with new value and `next -> nnode`\n\t\t*  is this way, nnode2 is before nnode\n\t\t */\n\t\tnnode2 := &node{\n\t\t\tv:    val,\n\t\t\tnext: nnode,\n\t\t}\n\t\t/* now head is equals nnode2 */\n\t\thead = nnode2\n\t\treturn head\n\t}\n}\n\nfunc (l *node) pushBack(val int) *node {\n\t/* if there's no nodes, head points to l (first node) */\n\tif head == nil {\n\t\tl.v = val\n\t\tl.next = nil\n\t\thead = l\n\t\treturn l\n\t} else {\n\t\t/* read all list to last node */\n\t\tfor l.next != nil {\n\t\t\tl = l.next\n\t\t}\n\t\t/* allocate a new portion of memory */\n\t\tl.next = new(node)\n\t\tl.next.v = val\n\t\tl.next.next = nil\n\t\treturn l\n\t}\n}\n\nfunc (l *node) popFront() *node {\n\tif head == nil {\n\t\treturn head\n\t}\n\t/* create a new node equals to first node pointed by head */\n\tcpnode := new(node)\n\tcpnode = head.next\n\n\t/* now head is equals cpnode (second node) */\n\thead = cpnode\n\n\treturn head\n}\n\nfunc (l *node) popBack() *node {\n\tif head == nil {\n\t\treturn head\n\t}\n\t/* create a new node equals to head */\n\tcpnode := new(node)\n\tcpnode = head\n\n\t/* read list to the penultimate node */\n\tfor cpnode.next.next != nil {\n\t\tcpnode = cpnode.next\n\t}\n\t/* the penultimate node points to null. In this way the last node is deleted */\n\tcpnode.next = nil\n\treturn head\n}\n\nfunc main() {\n\tlista := new(node)\n\tlista.pushBack(25).pushBack(24).pushBack(32) /* lista: 25 24 32 */\n\tlista.pushBack(56)                           /* lista: 25 24 32 56 */\n\tlista.pushFront(36)                          /* lista: 36 25 24 32 56 */\n\tlista.popFront()                             /* lista: 25 24 32 56 */\n\tlista.popBack()                              /* lista: 25 24 32 */\n\n\t/* read the list until head is not nil */\n\tfor head != nil {\n\t\tfmt.Printf(\"%d \", head.v)\n\t\thead = head.next /*head points to next node */\n\t}\n}\n","index":35},{"title":"Trie","category":"datastructures","id":"trie","index":36},{"title":"Trie","category":"trie","id":"trie_trie","algorithm":"// Package trie provides Trie data structures in golang.\n//\n// Wikipedia: https://en.wikipedia.org/wiki/Trie\npackage trie\n\n// Node represents each node in Trie.\ntype Node struct {\n\tchildren map[rune]*Node // map children nodes\n\tisLeaf   bool           // current node value\n}\n\n// NewNode creates a new Trie node with initialized\n// children map.\nfunc NewNode() *Node {\n\tn := &Node{}\n\tn.children = make(map[rune]*Node)\n\tn.isLeaf = false\n\treturn n\n}\n\n// Insert inserts words at a Trie node.\nfunc (n *Node) Insert(s string) {\n\tcurr := n\n\tfor _, c := range s {\n\t\tnext, ok := curr.children[c]\n\t\tif !ok {\n\t\t\tnext = NewNode()\n\t\t\tcurr.children[c] = next\n\t\t}\n\t\tcurr = next\n\t}\n\tcurr.isLeaf = true\n}\n\n// Find finds words at a Trie node.\nfunc (n *Node) Find(s string) bool {\n\tcurr := n\n\tfor _, c := range s {\n\t\tnext, ok := curr.children[c]\n\t\tif !ok {\n\t\t\treturn false\n\t\t}\n\t\tcurr = next\n\t}\n\treturn true\n}\n","index":37},{"title":"Trie Test","category":"trie","id":"trie_test_trie","algorithm":"package trie\n\nimport (\n\t\"testing\"\n)\n\nfunc TestTrie(t *testing.T) {\n\tn := NewNode()\n\n\tinsertWords := [...]string{\n\t\t\"nikola\",\n\t\t\"tesla\",\n\t}\n\tcheckWords := map[string]bool{\n\t\t\"thomas\": false,\n\t\t\"edison\": false,\n\t\t\"nikola\": true,\n\t}\n\n\tfor _, w := range insertWords {\n\t\tn.insert(w)\n\t\tt.Logf(\n\t\t\t\"added \\\"%s\\\" to the Trie.\",\n\t\t\tw,\n\t\t)\n\t}\n\n\tfor k, v := range checkWords {\n\t\tok := n.find(k)\n\t\tif ok != v {\n\t\t\tt.Fatalf(\n\t\t\t\t\"\\\"%s\\\" is supposed to be %sin the Trie.\",\n\t\t\t\tk,\n\t\t\t\tmap[bool]string{true: \"\", false: \"NOT \"}[v],\n\t\t\t)\n\t\t}\n\t\tt.Logf(\n\t\t\t\"\\\"%s\\\" is %sin the Trie.\",\n\t\t\tk,\n\t\t\tmap[bool]string{true: \"\", false: \"NOT \"}[ok],\n\t\t)\n\t}\n}\n\nfunc BenchmarkTrie(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tn := NewNode()\n\n\t\tn.insert(\"nikola\")\n\t\tn.insert(\"tesla\")\n\n\t\tn.find(\"thomas\")\n\t\tn.find(\"edison\")\n\t\tn.find(\"nikola\")\n\t}\n}\n\nfunc ExampleNode() {\n\t// creates a new node\n\tnode := NewNode()\n\n\t// adds words\n\tnode.insert(\"nikola\")\n\tnode.insert(\"tesla\")\n\n\t// finds words\n\tnode.find(\"thomas\") // false\n\tnode.find(\"edison\") // false\n\tnode.find(\"nikola\") // true\n}\n","index":38},{"title":"Dynamicprogramming","category":null,"id":"dynamicprogramming","index":39},{"title":"Binomialcoeffecient","category":"dynamicprogramming","id":"binomialcoeffecient_dynamicprogramming","algorithm":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\nfunc main() {\n\tmyArrayOfK := [4]int{5, 6, 7, 8}\n\tvar x int\n\n\tfmt.Println(\"\\nBinomial Coefficient Using Dynamic Programming:\", bin2(50, 5))\n\tfor _, element := range myArrayOfK {\n\t\tstart := time.Now()\n\t\tx = bin2(50, element)\n\t\telapsed := time.Since(start)\n\t\tfmt.Println(\"bin2 (50,\", element, \") = \", x, \"    took \", elapsed)\n\n\t}\n\n}\n\nfunc bin2(n int, k int) int {\n\tvar i, j int\n\tB := make([][]int, (n + 1))\n\tfor i := range B {\n\t\tB[i] = make([]int, k+1)\n\t}\n\n\tfor i = 0; i <= n; i++ {\n\t\tfor j = 0; j <= min(i, k); j++ {\n\t\t\tif j == 0 || j == i {\n\t\t\t\tB[i][j] = 1\n\t\t\t} else {\n\t\t\t\tB[i][j] = B[i-1][j-1] + B[i-1][j]\n\t\t\t}\n\t\t}\n\t}\n\treturn B[n][k]\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n","index":40},{"title":"Fibonacc Test","category":"dynamicprogramming","id":"fibonacc_test_dynamicprogramming","algorithm":"package dynamicprogramming\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc Test_NthFibonacci(t *testing.T) {\n\t// source: http://www.maths.surrey.ac.uk/hosted-sites/R.Knott/Fibonacci/fibtable.html\n\tvar fibonacciNumbers = []struct {\n\t\tnth       uint\n\t\tfibonacci uint\n\t}{\n\t\t{0, 0},\n\t\t{1, 1},\n\t\t{2, 1},\n\t\t{3, 2},\n\t\t{4, 3},\n\t\t{5, 5},\n\t\t{6, 8},\n\t\t{7, 13},\n\t\t{8, 21},\n\t\t{9, 34},\n\t\t{10, 55},\n\t\t{20, 6765},\n\t\t{30, 832040},\n\t\t{40, 102334155},\n\t\t{50, 12586269025},\n\t\t{60, 1548008755920},\n\t\t{70, 190392490709135},\n\t\t{80, 23416728348467685},\n\t\t{90, 2880067194370816120},\n\t}\n\tfor i := range fibonacciNumbers {\n\t\tt.Run(fmt.Sprintf(\"the %dth Fibonacci number\", fibonacciNumbers[i].nth), func(t *testing.T) {\n\t\t\tresult := NthFibonacci(fibonacciNumbers[i].nth)\n\t\t\tif result != fibonacciNumbers[i].fibonacci {\n\t\t\t\tt.Errorf(\"Expected the %dth Fibonacci number to be %d, got %d\", fibonacciNumbers[i].nth, fibonacciNumbers[i].fibonacci, result)\n\t\t\t}\n\t\t})\n\t}\n}\n","index":41},{"title":"Fibonacci","category":"dynamicprogramming","id":"fibonacci_dynamicprogramming","algorithm":"package dynamicprogramming\n\n// https://www.geeksforgeeks.org/program-for-nth-fibonacci-number/\n\n// NthFibonacci returns the nth Fibonacci Number\nfunc NthFibonacci(n uint) uint {\n\tif n == 0 {\n\t\treturn 0\n\t}\n\n\t// n1 and n2 are the (i-1)th and ith Fibonacci numbers, respectively\n\tvar n1, n2 uint = 0, 1\n\n\tfor i := uint(1); i < n; i++ {\n\t\tn3 := n1 + n2\n\t\tn1 = n2\n\t\tn2 = n3\n\t}\n\n\treturn n2\n}\n","index":42},{"title":"Knapsack","category":"dynamicprogramming","id":"knapsack_dynamicprogramming","algorithm":"// Knapsack Problem\n// https://www.geeksforgeeks.org/0-1-knapsack-problem-dp-10/\npackage Knapsack\n\n// package main\n\nimport (\n\t\"math\"\n)\n\nfunc max(a, b int) int {\n\treturn int(math.Max(float64(a), float64(b)))\n}\n\n// solve knapsack problem\n// return maxProfit\nfunc solve(maxWeight int, weights, values []int) int {\n\tn := len(weights)\n\tm := maxWeight\n\t// create dp data structure\n\tdp := make([][]int, n+1)\n\tfor i := range dp {\n\t\tdp[i] = make([]int, m+1)\n\t}\n\tfor i := 0; i < len(weights); i++ {\n\t\tfor j := 0; j <= maxWeight; j++ {\n\t\t\tif weights[i] > j {\n\t\t\t\tdp[i+1][j] = dp[i][j]\n\t\t\t} else {\n\t\t\t\tdp[i+1][j] = max(dp[i][j-weights[i]]+values[i], dp[i][j])\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[n][m]\n}\n\n/*\nfunc main() {\n\tmaxWeight := 50\n\tvalues := []int{\n\t\t60, 100, 120,\n\t}\n\tweights := []int{\n\t\t10, 20, 30,\n\t}\n\tmaxProfit := solve(maxWeight, weights, values)\n\tfmt.Println(maxProfit)\n}\n*/\n","index":43},{"title":"Longest-palindromic-subsequence","category":"dynamicprogramming","id":"longest-palindromic-subsequence_dynamicprogramming","algorithm":"// longest palindromic subsequence\n// http://www.geeksforgeeks.org/dynamic-programming-set-12-longest-palindromic-subsequence/\n\npackage longestPalindromicSubsequence\n\n// package main\n\nimport \"fmt\"\n\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc lpsRec(word string, i, j int) int {\n\tif i == j {\n\t\treturn 1\n\t}\n\tif i > j {\n\t\treturn 0\n\t}\n\tif word[i] == word[j] {\n\t\treturn 2 + lpsRec(word, i+1, j-1)\n\t}\n\treturn max(lpsRec(word, i, j-1), lpsRec(word, i+1, j))\n}\n\nfunc lpsDp(word string) int {\n\tN := len(word)\n\tdp := make([][]int, N)\n\n\tfor i := 0; i < N; i++ {\n\t\tdp[i] = make([]int, N)\n\t\tdp[i][i] = 1\n\t}\n\n\tfor l := 2; l <= N; l++ {\n\t\t// for length l\n\t\tfor i := 0; i < N-l+1; i++ {\n\t\t\tj := i + l - 1\n\t\t\tif word[i] == word[j] {\n\t\t\t\tif l == 2 {\n\t\t\t\t\tdp[i][j] = 2\n\t\t\t\t} else {\n\t\t\t\t\tdp[i][j] = 2 + dp[i+1][j-1]\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdp[i][j] = max(dp[i+1][j], dp[i][j-1])\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dp[1][N-1]\n}\n\n/*\nfunc main() {\n\t// word := \"aaabbbbababbabbabbabf\"\n\tword := \"aaaabbbba\"\n\tfmt.Printf(\"%d\\n\", lpsRec(word, 0, len(word)-1))\n\tfmt.Printf(\"%d\\n\", lpsDp(word))\n}\n*/\n","index":44},{"title":"LongestCommonSubsequence","category":"dynamicprogramming","id":"longestCommonSubsequence_dynamicprogramming","algorithm":"// LONGEST COMMON SUBSEQUENCE\n// DP - 4\n// https://www.geeksforgeeks.org/longest-common-subsequence-dp-4/\n\npackage longestcommonsubsequence\n\n// package main\n\n// import \"fmt\"\n\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc longestCommonSubsequence(a string, b string, m int, n int) int {\n\t// m is the length of string a and n is the length of string b\n\n\t// here we are making a 2d slice of size (m+1)*(n+1)\n\tlcs := make([][]int, m+1)\n\tfor i := 0; i <= m; i++ {\n\t\tlcs[i] = make([]int, n+1)\n\t}\n\n\t// block that implements LCS\n\tfor i := 0; i <= m; i++ {\n\t\tfor j := 0; j <= n; j++ {\n\t\t\tif i == 0 || j == 0 {\n\t\t\t\tlcs[i][j] = 0\n\t\t\t} else if a[i-1] == b[j-1] {\n\t\t\t\tlcs[i][j] = lcs[i-1][j-1] + 1\n\t\t\t} else {\n\t\t\t\tlcs[i][j] = max(lcs[i-1][j], lcs[i][j-1])\n\t\t\t}\n\t\t}\n\t}\n\t// returning the length of longest common subsequence\n\treturn lcs[m][n]\n}\n\n// func main(){\n// \t// declaring two strings and asking for input\n\n// \tvar a,b string\n// \tfmt.Scan(&a, &b)\n// \t// calling the LCS function\n// \tfmt.Println(\"The length of longest common subsequence is:\", longestCommonSubsequence(a,b, len(a), len(b)))\n// }\n","index":45},{"title":"Matrix-multiplication","category":"dynamicprogramming","id":"matrix-multiplication_dynamicprogramming","algorithm":"// matrix chain multiplication problem\n// https://en.wikipedia.org/wiki/Matrix_chain_multiplication\n// www.geeksforgeeks.org/dynamicprogramming-set-8-matrix-chain-multiplication/\n\n// package main\npackage matrixChainMultiplication\n\nimport \"fmt\"\n\nfunc min(a, b int) int {\n\tif a > b {\n\t\treturn b\n\t} else {\n\t\treturn a\n\t}\n}\n\nfunc matrixChainRec(D []int, i, j int) int {\n\t// d[i-1] x d[i] : dimension of matrix i\n\tif i == j {\n\t\treturn 0\n\t}\n\tq := 1 << 32\n\tfor k := i; k < j; k++ {\n\t\tprod := matrixChainRec(D, i, k) + matrixChainRec(D, k+1, j) + D[i-1]*D[k]*D[j]\n\t\tq = min(prod, q)\n\t}\n\treturn q\n}\n\nfunc matrixChainDp(D []int) int {\n\t// d[i-1] x d[i] : dimension of matrix i\n\tN := len(D)\n\n\tdp := make([][]int, N) // dp[i][j] = matrixChainRec(D, i, j)\n\tfor i := 0; i < N; i++ {\n\t\tdp[i] = make([]int, N)\n\t\tdp[i][i] = 0\n\t}\n\n\tfor l := 2; l < N; l++ {\n\t\tfor i := 1; i < N-l+1; i++ {\n\t\t\tj := i + l - 1\n\t\t\tdp[i][j] = 1 << 31\n\t\t\tfor k := i; k < j; k++ {\n\t\t\t\tprod := dp[i][k] + dp[k+1][j] + D[i-1]*D[k]*D[j]\n\t\t\t\tdp[i][j] = min(prod, dp[i][j])\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dp[1][N-1]\n}\n\n/*\nfunc main() {\n\tD := []int{2, 2, 2, 2, 2} // 4 matrices\n\tfmt.Print(matrixChainRec(D, 1, 4), \"\\n\")\n\tfmt.Print(matrixChainDp(D), \"\\n\")\n}\n*/\n","index":46},{"title":"Rod-cutting","category":"dynamicprogramming","id":"rod-cutting_dynamicprogramming","algorithm":"// Solution to Rod cutting problem\n// https://en.wikipedia.org/wiki/Cutting_stock_problem\n// http://www.geeksforgeeks.org/dynamic-programming-set-13-cutting-a-rod/\n\npackage dpRodCutting\n\n// package main\n\nimport \"fmt\"\n\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t} else {\n\t\treturn b\n\t}\n\n}\n\n// solve the problem recursively: initial approach\nfunc cutRodRec(price []int, length int) int {\n\tif length == 0 {\n\t\treturn 0\n\t}\n\n\tq := -1\n\tfor i := 1; i <= length; i++ {\n\t\tq = max(q, price[i]+cutRodRec(price, length-i))\n\t}\n\treturn q\n}\n\n// solve the same problem using dynamic programming\nfunc cutRodDp(price []int, length int) int {\n\tr := make([]int, length+1) // a.k.a the memoization array\n\tr[0] = 0                   // cost of 0 length rod is 0\n\n\tfor j := 1; j <= length; j++ { // for each length (subproblem)\n\t\tq := -1\n\t\tfor i := 1; i <= j; i++ {\n\t\t\tq = max(q, price[i]+r[j-i]) // avoiding recursive call\n\t\t}\n\t\tr[j] = q\n\t}\n\n\treturn r[length]\n}\n\n/*\nfunc main() {\n\tlength := 10\n\tprice := []int{0, 1, 5, 8, 9, 17, 17, 17, 20, 24, 30}\n\t// price := []int{0, 10, 5, 8, 9, 17, 17, 17, 20, 24, 30}\n\n\t// fmt.Print(price[5]+price[length-5], \"\\n\")\n\n\tfmt.Print(cutRodRec(price, length), \"\\n\")\n\tfmt.Print(cutRodDp(price, length), \"\\n\")\n}\n*/\n","index":47},{"title":"Graphs","category":null,"id":"graphs","index":48},{"title":"Breathfirstsearch","category":"graphs","id":"breathfirstsearch_graphs","algorithm":"package graphs\n\nimport \"fmt\"\n\nfunc getIdx(target int, nodes []int) int {\n\tfor i := 0; i < len(nodes); i++ {\n\t\tif nodes[i] == target {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\n\nfunc notExist(target int, slice []int) bool {\n\tfor i := 0; i < len(slice); i++ {\n\t\tif slice[i] == target {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc breadthFirstSearch(start, end int, nodes []int, edges [][]bool) bool {\n\tvar route []int\n\tvar queue []int\n\tstartIdx := getIdx(start, nodes)\n\tqueue = append(queue, startIdx)\n\tfor len(queue) > 0 {\n\t\tnow := queue[0]\n\t\troute = append(route, nodes[now])\n\t\tif len(queue) > 1 {\n\t\t\tqueue = queue[1:]\n\t\t} else {\n\t\t\tqueue = queue[0:]\n\t\t}\n\t\tfor i := 0; i < len(edges[now]); i++ {\n\t\t\tif edges[now][i] && notExist(i, queue) {\n\t\t\t\tqueue = append(queue, i)\n\t\t\t}\n\t\t\tedges[now][i] = false\n\t\t\tedges[i][now] = false\n\t\t}\n\t\tif route[len(route)-1] == end {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc main() {\n\tnodes := []int{\n\t\t1, 2, 3, 4, 5, 6,\n\t}\n\t/*\n\t\tsample graph\n\t\t①-②\n\t\t|  |\n\t\t③-④-⑤-⑥\n\t*/\n\tedges := [][]bool{\n\t\t{false, true, true, false, false, false},\n\t\t{true, false, false, true, false, false},\n\t\t{true, false, false, true, false, false},\n\t\t{false, true, true, false, true, false},\n\t\t{false, false, false, true, false, true},\n\t\t{false, false, false, false, true, false},\n\t}\n\tstart := 1\n\tend := 6\n\tresult := breadthFirstSearch(start, end, nodes, edges)\n\tfmt.Println(result)\n}\n","index":49},{"title":"Depthfirstsearch","category":"graphs","id":"depthfirstsearch_graphs","algorithm":"package graphs\n\nimport \"fmt\"\n\nfunc getIdx(target int, nodes []int) int {\n\tfor i := 0; i < len(nodes); i++ {\n\t\tif nodes[i] == target {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\n\nfunc notExist(target int, slice []int) bool {\n\tfor i := 0; i < len(slice); i++ {\n\t\tif slice[i] == target {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc dfs(start, end int, nodes []int, edges [][]bool) ([]int, bool) {\n\tvar route []int\n\tvar stack []int\n\tstartIdx := getIdx(start, nodes)\n\tstack = append(stack, startIdx)\n\tfor len(stack) > 0 {\n\t\tnow := stack[len(stack)-1]\n\t\troute = append(route, nodes[now])\n\t\tif len(stack) > 1 {\n\t\t\tstack = stack[:len(stack)-1]\n\t\t} else {\n\t\t\tstack = stack[:len(stack)-1]\n\t\t}\n\t\tfor i := 0; i < len(edges[now]); i++ {\n\t\t\tif edges[now][i] && notExist(i, stack) {\n\t\t\t\tstack = append(stack, i)\n\t\t\t}\n\t\t\tedges[now][i] = false\n\t\t\tedges[i][now] = false\n\t\t}\n\t\tif route[len(route)-1] == end {\n\t\t\treturn route, true\n\t\t}\n\t}\n\treturn nil, false\n}\n\nfunc main() {\n\tnodes := []int{\n\t\t1, 2, 3, 4, 5, 6,\n\t}\n\t/*\n\t\tsample graph\n\t\t①-②\n\t\t|  |\n\t\t③-④-⑤-⑥\n\t*/\n\tedges := [][]bool{\n\t\t{false, true, true, false, false, false},\n\t\t{true, false, false, true, false, false},\n\t\t{true, false, false, true, false, false},\n\t\t{false, true, true, false, true, false},\n\t\t{false, false, false, true, false, true},\n\t\t{false, false, false, false, true, false},\n\t}\n\tstart := 1\n\tend := 6\n\troute, _ := dfs(start, end, nodes, edges)\n\tfmt.Println(route)\n}\n","index":50},{"title":"Floydwarshall","category":"graphs","id":"floydwarshall_graphs","algorithm":"// Floyd-Warshall algorithm\n// https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm\n\npackage graphs\n\nimport (\n\t\"math\"\n\t\"fmt\"\n)\n\n// Defining matrix to use 2d array easier\ntype Matrix [][]float64\n\n// Defining maximum value. If two vertices share this value, it means they are not connected\nvar maxValue = math.Inf(1)\n\n// Returns all pair's shortest path using Floyd Warshall algorithm\nfunc FloydWarshall(graph Matrix) Matrix {\n\t// If graph is empty or width != height, returns nil\n\tif len(graph) == 0 || len(graph) != len(graph[0]) {\n\t\treturn nil\n\t}\n\n\tnumVertecies := len(graph)\n\n\t// Initializing result matrix and filling it up with same values as given graph\n\tresult := make(Matrix, numVertecies)\n\n\tfor i := 0; i < numVertecies; i++ {\n\t\tresult[i] = make([]float64, numVertecies)\n\t\tfor j := 0; j < numVertecies; j++ {\n\t\t\tresult[i][j] = graph[i][j]\n\t\t}\n\t}\n\n\t// Running over the result matrix and following the algorithm\n\tfor k := 0; k < numVertecies; k++ {\n\t\tfor i := 0; i < numVertecies; i++ {\n\t\t\tfor j := 0; j < numVertecies; j++ {\n\t\t\t\t// If there is a less costly path from i to j node, remembering it\n\t\t\t\tif result[i][j] > result[i][k]+result[k][j] {\n\t\t\t\t\tresult[i][j] = result[i][k] + result[k][j]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result\n}\n\nfunc main() {\n \tvar graph Matrix\n \tgraph = Matrix{{0, maxValue, -2, maxValue},\n \t\t{4, 0, 3, maxValue},\n \t\t{maxValue, maxValue, 0, 2},\n \t\t{maxValue, -1, maxValue, 0}}\n\n \tresult := FloydWarshall(graph)\n\n \t//Print result\n \tfor i := 0; i < len(result); i++ {\n \t\tfmt.Printf(\"%4g\\n\", result[i])\n \t}\n }\n","index":51},{"title":"Math","category":null,"id":"math","index":52},{"title":"Gcd","category":"math","id":"gcd","index":53},{"title":"Gcd","category":"gcd","id":"gcd_gcd","algorithm":"package gcd\n\n// Gcd finds and returns the greatest common divisor of a given integer.\nfunc Gcd(a, b int) int {\n\tif b == 0 {\n\t\treturn a\n\t}\n\treturn Gcd(b, a%b)\n}\n","index":54},{"title":"Gcd Test","category":"gcd","id":"gcd_test_gcd","algorithm":"package gcd\n\nimport \"testing\"\n\nvar testCases = []struct {\n\tname   string\n\ta      int\n\tb      int\n\toutput int\n}{\n\t{\"gcd of 10 and 0\", 10, 0, 10},\n\t{\"gcd of 98 and 56\", 98, 56, 14},\n\t{\"gcd of 0 and 10\", 0, 10, 10},\n}\n\nfunc TestGCD(t *testing.T) {\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual := Gcd(tc.a, tc.b)\n\t\t\tif actual != tc.output {\n\t\t\t\tt.Errorf(\"Expected GCD of %d and %d to be: %v, but got: %d\", tc.a, tc.b, tc.output, actual)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkGCD(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tGcd(98, 56)\n\t}\n}\n","index":55},{"title":"Power","category":"math","id":"power","index":56},{"title":"Fastexponent","category":"power","id":"fastexponent_power","algorithm":"package power\n\n// IterativePower is iterative O(logn) function for pow(x, y)\nfunc IterativePower(n uint, power uint) uint {\n\tvar res uint = 1\n\tfor power > 0 {\n\n\t\tif (power & 1) != 0 {\n\t\t\tres = res * n\n\t\t}\n\n\t\tpower = power >> 1\n\t\tn = n * n\n\t}\n\treturn res\n}\n\n// RecursivePower is recursive O(logn) function for pow(x, y)\nfunc RecursivePower(n uint, power uint) uint {\n\tif power == 0 {\n\t\treturn 1\n\t}\n\tvar temp = RecursivePower(n, power/2)\n\tif power%2 == 0 {\n\t\treturn temp * temp\n\t}\n\treturn n * temp * temp\n}\n\n// RecursivePower1 is recursive O(n) function for pow(x, y)\nfunc RecursivePower1(n uint, power uint) uint {\n\tif power == 0 {\n\t\treturn 1\n\t} else if power%2 == 0 {\n\t\treturn RecursivePower1(n, power/2) * RecursivePower1(n, power/2)\n\t} else {\n\t\treturn n * RecursivePower1(n, power/2) * RecursivePower1(n, power/2)\n\t}\n}\n","index":57},{"title":"Fastexponent Test","category":"power","id":"fastexponent_test_power","algorithm":"package power\n\nimport \"testing\"\n\nvar testCases = []struct {\n\tname     string\n\tbase     uint\n\tpower    uint\n\texpected uint\n}{\n\t{\"0^2\", 0, 2, 0},\n\t{\"2^0\", 2, 0, 1},\n\t{\"2^3\", 2, 3, 8},\n\t{\"8^3\", 8, 3, 512},\n\t{\"10^5\", 10, 5, 100000},\n}\n\nfunc TestIterativePower(t *testing.T) {\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual := IterativePower(tc.base, tc.power)\n\t\t\tif actual != tc.expected {\n\t\t\t\tt.Errorf(\"Expected %d to the power of %d to be: %d, but got: %d\", tc.base, tc.power, tc.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRecursivePower(t *testing.T) {\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual := RecursivePower(tc.base, tc.power)\n\t\t\tif actual != tc.expected {\n\t\t\t\tt.Errorf(\"Expected %d to the power of %d to be: %d, but got: %d\", tc.base, tc.power, tc.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRecursivePower1(t *testing.T) {\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual := RecursivePower1(tc.base, tc.power)\n\t\t\tif actual != tc.expected {\n\t\t\t\tt.Errorf(\"Expected %d to the power of %d to be: %d, but got: %d\", tc.base, tc.power, tc.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkIterativePower(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tIterativePower(10, 5)\n\t}\n}\n\nfunc BenchmarkRecursivePower(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tRecursivePower(10, 5)\n\t}\n}\n\nfunc BenchmarkRecursivePower1(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tRecursivePower1(10, 5)\n\t}\n}\n","index":58},{"title":"Primecheck","category":"math","id":"primecheck","index":59},{"title":"Primecheck","category":"primecheck","id":"primecheck_primecheck","algorithm":"package primecheck\n\n// A primality test is an algorithm for determining whether an input number is prime.Among other fields of mathematics, it is used for cryptography.\n//Unlike integer factorization, primality tests do not generally give prime factors, only stating whether the input number is prime or not.\n//Source - Wikipedia https://en.wikipedia.org/wiki/Primality_test\n\n// NaiveApproach checks if an integer is prime or not. Returns a bool.\nfunc NaiveApproach(n int) bool {\n\tif n < 2 {\n\t\treturn false\n\t}\n\tfor i := 2; i < n; i++ {\n\n\t\tif n%i == 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// PairApproach checks primality of an integer and returns a bool. More efficient than the naive approach as number of iterations are less.\nfunc PairApproach(n int) bool {\n\tif n < 2 {\n\t\treturn false\n\t}\n\tfor i := 2; i*i <= n; i++ {\n\t\tif n%i == 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n","index":60},{"title":"Primecheck Test","category":"primecheck","id":"primecheck_test_primecheck","algorithm":"package primecheck\n\nimport (\n\t\"testing\"\n)\n\nfunc TestTableNaiveApproach(t *testing.T) {\n\tvar tests = []struct {\n\t\tname     string\n\t\tinput    int\n\t\texpected bool\n\t}{\n\t\t{\"smallest prime\", 2, true},\n\t\t{\"random prime\", 3, true},\n\t\t{\"neither prime nor composite\", 1, false},\n\t\t{\"random non-prime\", 10, false},\n\t\t{\"another random prime\", 23, true},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tif output := NaiveApproach(test.input); output != test.expected {\n\t\t\t\tt.Errorf(\"For input: %d, expected: %v, but got: %v\", test.input, test.expected, output)\n\t\t\t}\n\t\t})\n\t}\n\n}\nfunc TestTablePairApproach(t *testing.T) {\n\tvar tests = []struct {\n\t\tname     string\n\t\tinput    int\n\t\texpected bool\n\t}{\n\t\t{\"smallest prime\", 2, true},\n\t\t{\"random prime\", 3, true},\n\t\t{\"neither prime nor composite\", 1, false},\n\t\t{\"random non-prime\", 10, false},\n\t\t{\"another random prime\", 23, true},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tif output := NaiveApproach(test.input); output != test.expected {\n\t\t\t\tt.Errorf(\"For input: %d, expected: %v, but got: %v\", test.input, test.expected, output)\n\t\t\t}\n\t\t})\n\t}\n\n}\n\nfunc BenchmarkNaiveApproach(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tNaiveApproach(23)\n\t}\n}\n\nfunc BenchmarkPairApproach(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tPairApproach(23)\n\t}\n}\n","index":61},{"title":"Pythagoras","category":"math","id":"pythagoras","index":62},{"title":"Pythagoras","category":"pythagoras","id":"pythagoras_pythagoras","algorithm":"package pythagoras\n\nimport (\n\t\"math\"\n)\n\n//Vector defines a tuple with 3 values in 3d-space\ntype Vector struct {\n\tx float64\n\ty float64\n\tz float64\n}\n\n//Distance calculates the distance between to vectors with the   Pythagoras theorem\nfunc Distance(a, b Vector) float64 {\n\tres := math.Pow(b.x-a.x, 2.0) + math.Pow(b.y-a.y, 2.0) + math.Pow(b.z-a.z, 2.0)\n\treturn math.Sqrt(res)\n}\n","index":63},{"title":"Pythagoras Test","category":"pythagoras","id":"pythagoras_test_pythagoras","algorithm":"package pythagoras\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\n// TableDrivenTest for checking multiple values against our Test Function\nvar distanceTest = []struct {\n\tname string\n\tv1   Vector\n\tv2   Vector\n\tres  float64\n}{\n\t{\"random negative vector\", Vector{2, -1, 7}, Vector{1, -3, 5}, 3.0},\n\t{\"random wide vectors\", Vector{4, 10, 9}, Vector{4, 3, 5}, 8.06},\n\t{\"random wide vectors\", Vector{8, 5, 5}, Vector{1, 1, 12}, 10.67},\n\t{\"random short vectors\", Vector{1, 1, 1}, Vector{2, 2, 2}, 1.73},\n}\n\n//TestDistance tests the Function Distance with 2 vectors\nfunc TestDistance(t *testing.T) {\n\tt.Parallel() // marks TestDistance as capable of running in parallel with other tests\n\tfor _, tt := range distanceTest {\n\t\ttt := tt // NOTE: https://github.com/golang/go/wiki/CommonMistakes#using-goroutines-on-loop-iterator-variables\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tres := Distance(tt.v1, tt.v2)           // Calculate result for\n\t\t\troundRes := (math.Floor(res*100) / 100) // Round to 2 decimal places because we can't compare an infinite number of places\n\t\t\t// Check result\n\t\t\tif roundRes != tt.res {\n\t\t\t\tt.Errorf(\"Distance(%v, %v) = %f, expected %f\",\n\t\t\t\t\ttt.v1, tt.v2, roundRes, tt.res)\n\t\t\t}\n\t\t})\n\t}\n}\n","index":64},{"title":"Sieve","category":"math","id":"sieve","index":65},{"title":"Sieve","category":"sieve","id":"Sieve_sieve","algorithm":"package main\n\nimport (\n\t_ \"fmt\"\n)\n\nfunc main() {\n\tvar l, f int\n\tl = 100\n\tchannel := make(chan int, l)\n\tchannelTwo := make(chan int, l)\n\tvar nums []bool\n\n\tfor i := 0; i < l; i++ {\n\t\tnums = append(nums, true)\n\t}\n\tf = 2\n\n\tgo crossOff(channel, channelTwo, f, l)\n\tgo nextF(f, channelTwo, nums)\n\t//blocks and sieves out non-primes\n\tfor {\n\t\tselect {\n\t\tcase index := <-channel:\n\t\t\tnums[index-1] = false\n\t\t}\n\t}\n}\nfunc crossOff(c chan int, r chan int, f int, l int) {\n\tfor f != -1 {\n\t\tfor f <= l {\n\t\t\tc <- f\n\t\t\tf += f\n\t\t}\n\t\tf = <-r\n\t\tr <- 1\n\t}\n\n}\n\nfunc nextF(f int, r chan int, nums []bool) {\n\tfor {\n\t\t<-r\n\t\tfor i, v := range nums[f:] {\n\t\t\tif v {\n\t\t\t\tr <- i + f\n\t\t\t}\n\t\t}\n\t}\n}\n","index":66},{"title":"Other","category":null,"id":"other","index":67},{"title":"PrimeNumbers","category":"other","id":"PrimeNumbers_other","algorithm":"package main\n\nimport (\n\t\"fmt\"\n\t\"github.com/douglasmakey/golang-algorithms-/utils\"\n\t\"math\"\n\t\"os\"\n\t\"strconv\"\n\t\"time\"\n)\n\n// Define struct\ntype numberResult struct {\n\tnumber  int64\n\tisPrime bool\n}\n\n// Define functions\n\n// isPrime: validate N number is prime\nfunc isPrime(n int64) bool {\n\tvar i, limit int64\n\tif n <= 1 {\n\t\treturn false\n\t}\n\n\tif n == 2 {\n\t\treturn true\n\t}\n\n\tif math.Mod(float64(n), 2) == 0 {\n\t\treturn false\n\t}\n\n\tlimit = int64(math.Ceil(math.Sqrt(float64(n))))\n\tfor i = 3; i <= limit; i += 2 {\n\t\tif math.Mod(float64(n), float64(i)) == 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// createNrAndValidate: Receive number and validate if is prime, send channel this same\nfunc createNrAndValidate(n int64, c chan numberResult) {\n\n\tresult := new(numberResult)\n\tresult.number = n\n\tresult.isPrime = isPrime(n)\n\tc <- *result\n}\n\nfunc initGoCalculations(min int64, max int64, c chan numberResult) {\n\tvar i int64\n\tfor i = min; i <= max; i++ {\n\t\tgo createNrAndValidate(i, c)\n\t}\n}\n\nfunc primesInRange(min int64, max int64) (primeArr []int64) {\n\tdefer utils.TimeTrack(time.Now(), \"primesInRange\")\n\n\t// Create channels and defer close\n\tc := make(chan numberResult)\n\tdefer close(c)\n\n\t// Execute N goroutines in range number\n\tgo initGoCalculations(min, max, c)\n\n\tfor i := min; i <= max; i++ {\n\t\t// Receive numberResult\n\t\tr := <-c\n\t\tif r.isPrime {\n\t\t\tprimeArr = append(primeArr, r.number)\n\t\t}\n\t}\n\treturn\n}\n\nfunc main() {\n\t// Receive arguments min max\n\tmin, _ := strconv.ParseInt(os.Args[1], 10, 64)\n\tmax, _ := strconv.ParseInt(os.Args[2], 10, 64)\n\tfmt.Println(primesInRange(min, max))\n}\n","index":68},{"title":"Maxsubarraysum","category":"other","id":"maxsubarraysum_other","algorithm":"/* O(n) solution, for calculating\nmaximum contiguous sum in the given array. */\n\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc Max(x int, y int) int {\n\tif x < y {\n\t\treturn y\n\t}\n\treturn x\n}\n\nfunc maxSubarraySum(array []int) int {\n\tvar currentMax int = 0\n\tvar maxTillNow int = 0\n\tfor _, v := range array {\n\t\tcurrentMax = Max(v, currentMax+v)\n\t\tmaxTillNow = Max(maxTillNow, currentMax)\n\t}\n\treturn maxTillNow\n}\n\nfunc main() {\n\tarray := []int{-2, -5, 6, 0, -2, 0, -3, 1, 0, 5, -6}\n\tfmt.Println(\"Maximum contiguous sum: \", maxSubarraySum(array))\n}\n","index":69},{"title":"Monte Carlo Pi","category":"other","id":"monte_carlo_pi","index":70},{"title":"Monte Carlo Pi","category":"monte_carlo_pi","id":"monte_carlo_pi_monte_carlo_pi","algorithm":"package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"math/rand\"\n\t\"runtime\"\n\t\"sync\"\n\t\"time\"\n)\n\nfunc main() {\n\tcpus := runtime.NumCPU()\n\tmonteCarlo := func(iterations, cpus int) float64{\n\t\tstart := time.Now()\n\t\tflow := make(chan int, int(math.Floor(float64(cpus)/2)))\n\t\tvar wg sync.WaitGroup\n\t\tvar total int\n\t\tminiFunc := func(iters int, flow chan int) {\n\t\t\tdefer wg.Done()\n\t\t\tvar inside int\n\t\t\tfor i := 0; i < iters; i++ {\n\t\t\t\tx := rand.Float64()\n\t\t\t\ty := rand.Float64()\n\t\t\t\tif math.Hypot(x, y) <= 1 {\n\t\t\t\t\tinside++\n\t\t\t\t}\n\t\t\t}\n\t\t\tflow <- inside\n\t\t} //end of minifunc\n\t\tfuxc := func(flow chan int) {\n\t\t\tdefer wg.Done()\n\t\t\tfor i := 0; i < int(math.Floor(float64(cpus)/2)); i++ {\n\t\t\t\ttotal += <-flow\n\t\t\t}\n\t\t} //end of fuxc\n\t\twg.Add(int(math.Floor(float64(cpus) / 2)))\n\t\t//spawn goroutines for half the logical processors\n\t\t// This leaves free cpus for swapping\n\t\tfor i := 0; i < int(math.Floor(float64(cpus)/2)); i++ {\n\t\t\tgo miniFunc(int(math.Ceil(float64(iterations/int(math.Floor(float64(cpus)/2))))), flow)\n\t\t}\n\t\twg.Add(1)\n\t\tgo fuxc(flow)\n\t\twg.Wait()\n\t\tfmt.Printf(\"took %v \\n\",time.Since(start))\n\t\treturn 4 * float64(total) / float64(iterations)\n\t}//end of monteCarlo\n\tfmt.Println(monteCarlo(2<<18, cpus))\n}\n","index":71},{"title":"Monte Carlo Pi Test","category":"monte_carlo_pi","id":"monte_carlo_pi_test_monte_carlo_pi","algorithm":"package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestMonteCarloPi(t *testing.T) {\n\tdelta := 0.0001\n\n\tpi := MonteCarloPi(100000000)\n\n\tif math.Abs(pi-math.Pi) > delta {\n\t\tt.Errorf(\"Given: %.4f, expected: %.4f\", pi, math.Pi)\n\t}\n}\n","index":72},{"title":"Nestedbrackets","category":"other","id":"nestedbrackets_other","algorithm":"// The nested brackets problem is a problem that determines if a sequence of\n// brackets are properly nested.  A sequence of brackets s is considered properly nested\n// if any of the following conditions are true:\n// \t- s is empty\n// \t- s has the form (U) or [U] or {U} where U is a properly nested string\n// \t- s has the form VW where V and W are properly nested strings\n// For example, the string \"()()[()]\" is properly nested but \"[(()]\" is not.\n// The function called isBalanced takes as input a string which is a sequence of brackets and\n// returns true if input is nested and false otherwise.\n//note that only an even number of brackets can be properly nested\n\npackage main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n)\n\nfunc isBalanced(input string) string {\n\tif len(input)%2 != 0{\n\t\treturn input + \"is not balanced.\"\n\tif len(input) > 0 {\n\t\tvar stack []byte\n\t\tfor i := 0; i < len(input); i++ {\n\t\t\tif input[i] == '(' || input[i] == '{' || input[i] == '[' {\n\t\t\t\tstack = append(stack, input[i])\n\t\t\t} else {\n\t\t\t\tif len(stack) > 0 {\n\t\t\t\t\tpair := string(stack[len(stack)-1]) + string(input[i])\n\t\t\t\t\tstack = stack[:len(stack)-1]\n\n\t\t\t\t\tif pair != \"[]\" && pair != \"{}\" && pair != \"()\" {\n\t\t\t\t\t\treturn input + \" is not balanced.\"\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn input + \" is not balanced.\"\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif len(stack) == 0 {\n\t\t\treturn input + \" is balanced.\"\n\t\t}\n\t}\n\treturn \"Please enter a sequence of brackets.\"\n}\n\nfunc main() {\n\treader := bufio.NewReader(os.Stdin)\n\tfmt.Print(\"Enter sequence of brackets: \")\n\ttext, _ := reader.ReadString('\\n')\n\n\ttext = strings.TrimSpace(text)\n\tfmt.Println(isBalanced(text))\n}","index":73},{"title":"Passwordgenerator","category":"other","id":"passwordgenerator_other","algorithm":"// This program generates a password from a list of possible chars\n// You must provide a minimum length and a maximum length\n// This length is not fixed if you generate multiple passwords for the same range\n\npackage main\n\nimport (\n\tcrand \"crypto/rand\"\n\t\"fmt\"\n\t\"io\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc generatePassword(minLength int, maxLength int) string {\n\tvar chars = []byte(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()-_=+,.?/:;{}[]`~\")\n\n\tvar length = rand.Intn(maxLength-minLength) + minLength\n\n\tnewPassword := make([]byte, length)\n\trandomData := make([]byte, length+(length/4))\n\tclen := byte(len(chars))\n\tmaxrb := byte(256 - (256 % len(chars)))\n\ti := 0\n\tfor {\n\t\tif _, err := io.ReadFull(crand.Reader, randomData); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tfor _, c := range randomData {\n\t\t\tif c >= maxrb {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tnewPassword[i] = chars[c%clen]\n\t\t\ti++\n\t\t\tif i == length {\n\t\t\t\treturn string(newPassword)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc main() {\n\trand.Seed(time.Now().Unix())\n\n\tfmt.Print(\"Please specify a minimum length: \")\n\tvar minLength int\n\tfmt.Scanf(\"%d\", &minLength)\n\n\tfmt.Print(\"Please specify a maximum length: \")\n\tvar maxLength int\n\tfmt.Scanf(\"%d\", &maxLength)\n\n\tfmt.Printf(\"Your generated password is %v\\n\", generatePassword(minLength, maxLength))\n}\n","index":74},{"title":"Prime Numbers","category":"other","id":"prime_numbers_other","algorithm":"package main\n\nimport (\n\t\"fmt\"\n\t\"github.com/douglasmakey/golang-algorithms-/utils\"\n\t\"math\"\n\t\"os\"\n\t\"strconv\"\n\t\"time\"\n)\n\n// Define struct\ntype numberResult struct {\n\tnumber  int64\n\tisPrime bool\n}\n\n// Define functions\n\n// isPrime: validate N number is prime\nfunc isPrime(n int64) bool {\n\tvar i, limit int64\n\tif n <= 1 {\n\t\treturn false\n\t}\n\n\tif n == 2 {\n\t\treturn true\n\t}\n\n\tif math.Mod(float64(n), 2) == 0 {\n\t\treturn false\n\t}\n\n\tlimit = int64(math.Ceil(math.Sqrt(float64(n))))\n\tfor i = 3; i <= limit; i += 2 {\n\t\tif math.Mod(float64(n), float64(i)) == 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// createNrAndValidate: Receive number and validate if is prime, send channel this same\nfunc createNrAndValidate(n int64, c chan numberResult) {\n\n\tresult := new(numberResult)\n\tresult.number = n\n\tresult.isPrime = isPrime(n)\n\tc <- *result\n}\n\nfunc initGoCalculations(min int64, max int64, c chan numberResult) {\n\tvar i int64\n\tfor i = min; i <= max; i++ {\n\t\tgo createNrAndValidate(i, c)\n\t}\n}\n\nfunc primesInRange(min int64, max int64) (primeArr []int64) {\n\tdefer utils.TimeTrack(time.Now(), \"primesInRange\")\n\n\t// Create channels and defer close\n\tc := make(chan numberResult)\n\tdefer close(c)\n\n\t// Execute N goroutines in range number\n\tgo initGoCalculations(min, max, c)\n\n\tfor i := min; i <= max; i++ {\n\t\t// Receive numberResult\n\t\tr := <-c\n\t\tif r.isPrime {\n\t\t\tprimeArr = append(primeArr, r.number)\n\t\t}\n\t}\n\treturn\n}\n\nfunc main() {\n\t// Receive arguments min max\n\tmin, _ := strconv.ParseInt(os.Args[1], 10, 64)\n\tmax, _ := strconv.ParseInt(os.Args[2], 10, 64)\n\tfmt.Println(primesInRange(min, max))\n}\n","index":75},{"title":"Stringcombinations","category":"other","id":"stringcombinations_other","algorithm":"/*\n  String combinations in Go\n*/\npackage main\n\nimport \"fmt\"\n\ntype Combinations struct {\n\tout []rune\n\tin  []rune\n}\n\nfunc startCombinations(input string) {\n\tc := &Combinations{\n\t\tin: []rune(input),\n\t}\n\n\tc.Combine(0)\n}\n\nfunc (c *Combinations) Combine(seed int) {\n\tinLen := len(c.in)\n\tfor i := seed; i < inLen-1; i++ {\n\t\tc.out = append(c.out, c.in[i])\n\t\tfmt.Println(string(c.out))\n\t\tc.Combine(i + 1)\n\t\tc.out = c.out[:len(c.out)-1]\n\t}\n\tc.out = append(c.out, c.in[inLen-1])\n\tfmt.Println(string(c.out))\n\tc.out = c.out[:len(c.out)-1]\n}\n","index":76},{"title":"Searches","category":null,"id":"searches","index":77},{"title":"Binarysearch","category":"searches","id":"binarysearch_searches","algorithm":"package searches\n\nfunc binarySearch(array []int, target int, lowIndex int, highIndex int) int {\n\tif highIndex < lowIndex {\n\t\treturn -1\n\t}\n\tmid := int(lowIndex + (highIndex-lowIndex)/2)\n\tif array[mid] > target {\n\t\treturn binarySearch(array, target, lowIndex, mid)\n\t} else if array[mid] < target {\n\t\treturn binarySearch(array, target, mid+1, highIndex)\n\t} else {\n\t\treturn mid\n\t}\n}\n\nfunc iterBinarySearch(array []int, target int, lowIndex int, highIndex int) int {\n\tstartIndex := lowIndex\n\tendIndex := highIndex\n\tvar mid int\n\tfor startIndex < endIndex {\n\t\tmid = int(startIndex + (endIndex - startIndex))\n\t\tif array[mid] > target {\n\t\t\tendIndex = mid\n\t\t} else if array[mid] < target {\n\t\t\tstartIndex = mid\n\t\t} else {\n\t\t\treturn mid\n\t\t}\n\t}\n\treturn -1\n}\n","index":78},{"title":"Linearsearch","category":"searches","id":"linearsearch_searches","algorithm":"package searches\n\nimport \"fmt\"\n\nfunc linearSearch(array []int, query int) int {\n\tfor i, item := range array {\n\t\tif item == query {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\n\nfunc main() {\n\n\tfmt.Println(\"Linear search:\")\n\tarray := []int{0, 2, 4, 6, 8, 10, 12, 14, 16, 18}\n\tindex := linearSearch(array, 10)\n\tif index == -1 {\n\t\tfmt.Println(\"Number not found\")\n\t} else {\n\t\tfmt.Println(\"Index: \", index)\n\t\tfmt.Println(\"array[\", index, \"] = \", array[index])\n\t}\n}\n","index":79},{"title":"Search Test","category":"searches","id":"search_test_searches","algorithm":"package searches\n\nimport \"testing\"\n\ntype searchTest struct {\n\tdata     []int\n\tkey      int\n\texpected int\n\tname     string\n}\n\nvar searchTests = []searchTest{\n\t//Sanity\n\t{[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, 5, 4, \"Sanity\"},\n\t//Absent\n\t{[]int{1, 4, 5, 6, 7, 10}, 25, -1, \"Absent\"},\n\t//Empty slice\n\t{[]int{}, 2, -1, \"Empty\"},\n}\n\nfunc TestBinarySearch(t *testing.T) {\n\tfor _, test := range searchTests {\n\t\tactual := binarySearch(test.data, test.key, 0, len(test.data)-1)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"test %s failed\", test.name)\n\t\t}\n\t}\n}\n\nfunc TestLinearSearch(t *testing.T) {\n\tfor _, test := range searchTests {\n\t\tactual := linearSearch(test.data, test.key)\n\t\tif actual != test.expected {\n\t\t\tt.Errorf(\"test %s failed\", test.name)\n\t\t}\n\t}\n}\n","index":80},{"title":"Sorts","category":null,"id":"sorts","index":81},{"title":"Bubblesort","category":"sorts","id":"bubblesort_sorts","algorithm":"// Implementation of basic bubble sort algorithm\n// Reference: https://en.wikipedia.org/wiki/Bubble_sort\n\npackage sorts\n\nfunc bubbleSort(arr []int) []int {\n\tswapped := true\n\tfor swapped {\n\t\tswapped = false\n\t\tfor i := 0; i < len(arr)-1; i++ {\n\t\t\tif arr[i+1] < arr[i] {\n\t\t\t\tarr[i+1], arr[i] = arr[i], arr[i+1]\n\t\t\t\tswapped = true\n\t\t\t}\n\t\t}\n\t}\n\treturn arr\n}\n","index":82},{"title":"Heapsort","category":"sorts","id":"heapsort_sorts","algorithm":"//Package sorts a package for demonstrating sorting algorithms in Go\npackage sorts\n\ntype maxHeap struct {\n\tslice    []int\n\theapSize int\n}\n\nfunc buildMaxHeap(slice []int) maxHeap {\n\th := maxHeap{slice: slice, heapSize: len(slice)}\n\tfor i := len(slice) / 2; i >= 0; i-- {\n\t\th.MaxHeapify(i)\n\t}\n\treturn h\n}\n\nfunc (h maxHeap) MaxHeapify(i int) {\n\tl, r := 2*i+1, 2*i+2\n\tmax := i\n\n\tif l < h.size() && h.slice[l] > h.slice[max] {\n\t\tmax = l\n\t}\n\tif r < h.size() && h.slice[r] > h.slice[max] {\n\t\tmax = r\n\t}\n\t//log.Printf(\"MaxHeapify(%v): l,r=%v,%v; max=%v\\t%v\\n\", i, l, r, max, h.slice)\n\tif max != i {\n\t\th.slice[i], h.slice[max] = h.slice[max], h.slice[i]\n\t\th.MaxHeapify(max)\n\t}\n}\n\nfunc (h maxHeap) size() int { return h.heapSize } // ???\n\nfunc HeapSort(slice []int) []int {\n\th := buildMaxHeap(slice)\n\t//log.Println(slice)\n\tfor i := len(h.slice) - 1; i >= 1; i-- {\n\t\th.slice[0], h.slice[i] = h.slice[i], h.slice[0]\n\t\th.heapSize--\n\t\th.MaxHeapify(0)\n\t\t/*if i == len(h.slice)-1 || i == len(h.slice)-3 || i == len(h.slice)-5 {\n\t\t\telement := (i - len(h.slice)) * -1\n\t\t\tfmt.Println(\"Heap after removing \", element, \" elements\")\n\t\t\tfmt.Println(h.slice)\n\n\t\t}*/\n\t}\n\treturn h.slice\n}\n","index":83},{"title":"Insertionsort","category":"sorts","id":"insertionsort_sorts","algorithm":"//Package sorts a package for demonstrating sorting algorithms in Go\npackage sorts\n\nfunc InsertionSort(arr []int) []int {\n\tfor currentIndex := 1; currentIndex < len(arr); currentIndex++ {\n\t\ttemporary := arr[currentIndex]\n\t\titerator := currentIndex\n\t\tfor ; iterator > 0 && arr[iterator-1] >= temporary; iterator-- {\n\t\t\tarr[iterator] = arr[iterator-1]\n\t\t}\n\t\tarr[iterator] = temporary\n\t}\n\treturn arr\n}\n","index":84},{"title":"Mergesort","category":"sorts","id":"mergesort_sorts","algorithm":"//Package sorts a package for demonstrating sorting algorithms in Go\npackage sorts\n\nfunc merge(a []int, b []int) []int {\n\n\tvar r = make([]int, len(a)+len(b))\n\tvar i = 0\n\tvar j = 0\n\n\tfor i < len(a) && j < len(b) {\n\n\t\tif a[i] <= b[j] {\n\t\t\tr[i+j] = a[i]\n\t\t\ti++\n\t\t} else {\n\t\t\tr[i+j] = b[j]\n\t\t\tj++\n\t\t}\n\n\t}\n\n\tfor i < len(a) {\n\t\tr[i+j] = a[i]\n\t\ti++\n\t}\n\tfor j < len(b) {\n\t\tr[i+j] = b[j]\n\t\tj++\n\t}\n\n\treturn r\n\n}\n\n//Mergesort Perform mergesort on a slice of ints\nfunc Mergesort(items []int) []int {\n\n\tif len(items) < 2 {\n\t\treturn items\n\n\t}\n\n\tvar middle = len(items) / 2\n\tvar a = Mergesort(items[:middle])\n\tvar b = Mergesort(items[middle:])\n\treturn merge(a, b)\n\n}\n","index":85},{"title":"Quicksort","category":"sorts","id":"quicksort_sorts","algorithm":"//Package sorts a package for demonstrating sorting algorithms in Go\npackage sorts\n\nimport (\n\t\"math/rand\"\n)\n\nfunc QuickSort(arr []int) []int {\n\n\tif len(arr) <= 1 {\n\t\treturn arr\n\t}\n\n\tmedian := arr[rand.Intn(len(arr))]\n\n\tlowPart := make([]int, 0, len(arr))\n\thighPart := make([]int, 0, len(arr))\n\tmiddlePart := make([]int, 0, len(arr))\n\n\tfor _, item := range arr {\n\t\tswitch {\n\t\tcase item < median:\n\t\t\tlowPart = append(lowPart, item)\n\t\tcase item == median:\n\t\t\tmiddlePart = append(middlePart, item)\n\t\tcase item > median:\n\t\t\thighPart = append(highPart, item)\n\t\t}\n\t}\n\n\tlowPart = QuickSort(lowPart)\n\thighPart = QuickSort(highPart)\n\n\tlowPart = append(lowPart, middlePart...)\n\tlowPart = append(lowPart, highPart...)\n\n\treturn lowPart\n}\n","index":86},{"title":"Radixsort","category":"sorts","id":"radixsort_sorts","algorithm":"package sorts\n\nfunc max(arr []int) int {\n\tmax := arr[0]\n\tfor _, item := range arr {\n\t\tif item > max {\n\t\t\tmax = item\n\t\t}\n\t}\n\treturn max\n}\n\nfunc countSort(arr []int, exp int) []int {\n\tvar digits [10]int\n\tvar output = make([]int, len(arr))\n\n\tfor _, item := range arr {\n\t\tdigits[(item/exp)%10]++\n\t}\n\tfor i := 1; i < 10; i++ {\n\t\tdigits[i] += digits[i-1]\n\t}\n\n\tfor i := len(arr) - 1; i >= 0; i-- {\n\t\toutput[digits[(arr[i]/exp)%10]-1] = arr[i]\n\t\tdigits[(arr[i]/exp)%10]--\n\t}\n\n\treturn output\n}\n\nfunc unsignedRadixSort(arr []int) []int {\n\tif len(arr) == 0 {\n\t\treturn arr\n\t}\n\tmaxElement := max(arr)\n\tfor exp := 1; maxElement/exp > 0; exp *= 10 {\n\t\tarr = countSort(arr, exp)\n\t}\n\treturn arr\n}\n\nfunc RadixSort(arr []int) []int {\n\tvar negatives, nonNegatives []int\n\n\tfor _, item := range arr {\n\t\tif item < 0 {\n\t\t\tnegatives = append(negatives, -item)\n\t\t} else {\n\t\t\tnonNegatives = append(nonNegatives, item)\n\t\t}\n\t}\n\tnegatives = unsignedRadixSort(negatives)\n\n\t// Reverse the negative array and restore signs\n\tfor i, j := 0, len(negatives)-1; i <= j; i, j = i+1, j-1 {\n\t\tnegatives[i], negatives[j] = -negatives[j], -negatives[i]\n\t}\n\treturn append(negatives, unsignedRadixSort(nonNegatives)...)\n}\n","index":87},{"title":"Selectionsort","category":"sorts","id":"selectionsort_sorts","algorithm":"//Package sorts a package for demonstrating sorting algorithms in Go\npackage sorts\n\nfunc SelectionSort(arr []int) []int {\n\n\tfor i := 0; i < len(arr); i++ {\n\t\tmin := i\n\t\tfor j := i + 1; j < len(arr); j++ {\n\t\t\tif arr[j] < arr[min] {\n\t\t\t\tmin = j\n\t\t\t}\n\t\t}\n\n\t\ttmp := arr[i]\n\t\tarr[i] = arr[min]\n\t\tarr[min] = tmp\n\t}\n\treturn arr\n}\n","index":88},{"title":"Shellsort","category":"sorts","id":"shellsort_sorts","algorithm":"//Package sorts a package for demonstrating sorting algorithms in Go\npackage sorts\n\nfunc ShellSort(arr []int) []int {\n\tfor d := int(len(arr) / 2); d > 0; d /= 2 {\n\t\tfor i := d; i < len(arr); i++ {\n\t\t\tfor j := i; j >= d && arr[j-d] > arr[j]; j -= d {\n\t\t\t\tarr[j], arr[j-d] = arr[j-d], arr[j]\n\t\t\t}\n\t\t}\n\t}\n\treturn arr\n}\n","index":89},{"title":"Sorts Test","category":"sorts","id":"sorts_test_sorts","algorithm":"package sorts\n\nimport (\n\t\"testing\"\n)\n\nfunc testFramework(t *testing.T, sortingFunction func([]int) []int) {\n\tfor _, test := range sortTests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tactual := sortingFunction(test.input)\n\t\t\tpos, sorted := compareSlices(actual, test.expected)\n\t\t\tif !sorted {\n\t\t\t\tif pos == -1 {\n\t\t\t\t\tt.Errorf(\"test %s failed due to slice length changing\", test.name)\n\t\t\t\t}\n\t\t\t\tt.Errorf(\"test %s failed at index %d\", test.name, pos)\n\t\t\t}\n\t\t})\n\t}\n}\n\n//BEGIN TESTS\n\nfunc TestBubble(t *testing.T) {\n\ttestFramework(t, bubbleSort)\n}\n\nfunc TestInsertion(t *testing.T) {\n\ttestFramework(t, InsertionSort)\n}\n\nfunc TestMerge(t *testing.T) {\n\ttestFramework(t, Mergesort)\n}\n\nfunc TestHeap(t *testing.T) {\n\ttestFramework(t, HeapSort)\n}\n\nfunc TestQuick(t *testing.T) {\n\ttestFramework(t, QuickSort)\n}\n\nfunc TestShell(t *testing.T) {\n\ttestFramework(t, ShellSort)\n}\n\nfunc TestRadix(t *testing.T) {\n\ttestFramework(t, RadixSort)\n}\n\n// Very slow, consider commenting\nfunc TestSelection(t *testing.T) {\n\ttestFramework(t, SelectionSort)\n}\n\n/* func TestTopological(t *testing.T) {\n\ttestFramework(t, topologicalSort)\n} */\n\n//END TESTS\n\nfunc BenchmarkBubble(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tfor _, test := range sortTests {\n\t\t\tbubbleSort(test.input)\n\t\t}\n\t}\n}\n\nfunc BenchmarkInsertion(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tfor _, test := range sortTests {\n\t\t\tInsertionSort(test.input)\n\t\t}\n\t}\n}\n\nfunc BenchmarkMerge(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tfor _, test := range sortTests {\n\t\t\tMergesort(test.input)\n\t\t}\n\t}\n}\n\nfunc BenchmarkHeap(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tfor _, test := range sortTests {\n\t\t\tHeapSort(test.input)\n\t\t}\n\t}\n}\n\nfunc BenchmarkQuick(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tfor _, test := range sortTests {\n\t\t\tQuickSort(test.input)\n\t\t}\n\t}\n}\n\nfunc BenchmarkShell(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tfor _, test := range sortTests {\n\t\t\tShellSort(test.input)\n\t\t}\n\t}\n}\n\nfunc BenchmarkRadix(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tfor _, test := range sortTests {\n\t\t\tRadixSort(test.input)\n\t\t}\n\t}\n}\n\n// Very Slow, consider commenting\nfunc BenchmarkSelection(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tfor _, test := range sortTests {\n\t\t\tSelectionSort(test.input)\n\t\t}\n\t}\n}\n\nfunc compareSlices(a []int, b []int) (int, bool) {\n\tif len(a) != len(b) {\n\t\treturn -1, false\n\t}\n\tfor pos := range a {\n\t\tif a[pos] != b[pos] {\n\t\t\treturn pos, false\n\t\t}\n\t}\n\treturn -1, true\n}\n","index":90},{"title":"Sorts Testcases","category":"sorts","id":"sorts_testcases_sorts","algorithm":"//Package sorts a package for demonstrating sorting algorithms in Go\npackage sorts\n\nimport (\n\t\"crypto/rand\"\n\t\"math/big\"\n\t\"sort\"\n)\n\ntype sortTest struct {\n\tinput    []int\n\texpected []int\n\tname     string\n}\n\nvar uarr []int = makeRandomUnsignedSlice(500_000)\nvar arr []int = makeRandomSignedSlice(500_000)\n\nvar sortTests = []sortTest{\n\t//Sorted slice\n\t{[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},\n\t\t[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, \"Sorted Unsigned\"},\n\t//Reversed slice\n\t{[]int{10, 9, 8, 7, 6, 5, 4, 3, 2, 1},\n\t\t[]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, \"Reversed Unsigned\"},\n\t//500k unsigned int values sort\n\t{uarr, getSortedVersion(uarr), \"Large Random Unsigned\"},\n\n\t//Sorted slice\n\t{[]int{-10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10},\n\t\t[]int{-10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, \"Sorted Signed\"},\n\n\t//Reversed slice\n\t{[]int{10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, -1, -2, -3, -4, -5, -6, -7, -8, -9, -10},\n\t\t[]int{-10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, \"Reversed Signed\"},\n\n\t//Reversed slice, even length\n\t{[]int{10, 9, 8, 7, 6, 5, 4, 3, 2, 1, -1, -2, -3, -4, -5, -6, -7, -8, -9, -10},\n\t\t[]int{-10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, \"Reversed Signed #2\"},\n\n\t//Random order with repetitions\n\t{[]int{-5, 7, 4, -2, 6, 5, 8, 3, 2, -7, -1, 0, -3, 9, -6, -4, 10, 9, 1, -8, -9, -10},\n\t\t[]int{-10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 9, 10}, \"Random order Signed\"},\n\n\t//500k int values sort\n\t{arr, getSortedVersion(arr), \"Large Random Signed\"},\n\n\t//Empty slice\n\t{[]int{}, []int{}, \"Empty\"},\n\t//Single-entry slice\n\t{[]int{1}, []int{1}, \"Singleton\"},\n}\n\nfunc makeRandomUnsignedSlice(size int) []int {\n\tvals := make([]int, size)\n\tfor i := 0; i < size; i++ {\n\t\ttemp, _ := rand.Int(rand.Reader, big.NewInt(int64(size)))\n\t\tvals[i] = int(temp.Int64())\n\t}\n\treturn vals\n}\n\nfunc makeRandomSignedSlice(size int) []int {\n\tvals := make([]int, size)\n\tfor i := 0; i < size; i++ {\n\t\ttemp, _ := rand.Int(rand.Reader, big.NewInt(int64(size)))\n\t\tvals[i] = int(temp.Int64()) - 250_000\n\t}\n\treturn vals\n}\n\nfunc getSortedVersion(a []int) []int {\n\tsort.Slice(a, func(i, j int) bool { return a[i] < a[j] })\n\treturn a\n}\n","index":91},{"title":"Strings","category":null,"id":"strings","index":92},{"title":"Levenshteindistance","category":"strings","id":"levenshteindistance","index":93},{"title":"LevenshteinDistance","category":"levenshteindistance","id":"levenshteinDistance_levenshteindistance","algorithm":"/*\nThis algorithm calculates the distance between two strings.\nParameters: two strings to compare and weights of insertion, substitution and deletion.\nOutput: distance between both strings\n*/\n\npackage levenshteindistance\n\nfunc levenshteinDistance(str1, str2 string, icost, scost, dcost int) int {\n\trow1 := make([]int, len(str2)+1)\n\trow2 := make([]int, len(str2)+1)\n\n\tfor i := 1; i <= len(str2); i++ {\n\t\trow1[i] = i * icost\n\t}\n\n\tfor i := 1; i <= len(str1); i++ {\n\t\trow2[0] = i * dcost\n\n\t\tfor j := 1; j <= len(str2); j++ {\n\t\t\tif str1[i-1] == str2[j-1] {\n\t\t\t\trow2[j] = row1[j-1]\n\t\t\t} else {\n\t\t\t\tins := row2[j-1] + icost\n\t\t\t\tdel := row1[j] + dcost\n\t\t\t\tsub := row1[j-1] + scost\n\n\t\t\t\tif ins < del && ins < sub {\n\t\t\t\t\trow2[j] = ins\n\t\t\t\t} else if del < sub {\n\t\t\t\t\trow2[j] = del\n\t\t\t\t} else {\n\t\t\t\t\trow2[j] = sub\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trow1, row2 = row2, row1\n\t}\n\n\treturn row1[len(row1)-1]\n}\n","index":94},{"title":"LevenshteinDistance Test","category":"levenshteindistance","id":"levenshteinDistance_test_levenshteindistance","algorithm":"package levenshteindistance\n\nimport \"testing\"\n\nvar testCases = []struct {\n\tname             string\n\tstring1          string\n\tstring2          string\n\tinsertionCost    int\n\tsubstitutionCost int\n\tdeletionCost     int\n\texpected         int\n}{\n\t{\n\t\t\"strings with equal operation weights.\",\n\t\t\"stingy\",\n\t\t\"ring\",\n\t\t1,\n\t\t1,\n\t\t1,\n\t\t3,\n\t},\n\t{\n\t\t\"strings with different operation weights.\",\n\t\t\"stingy\",\n\t\t\"ring\",\n\t\t1,\n\t\t1,\n\t\t3,\n\t\t7,\n\t},\n\t{\n\t\t\"strings with different operation weights.\",\n\t\t\"kitten\",\n\t\t\"sitting\",\n\t\t1,\n\t\t1,\n\t\t1,\n\t\t3,\n\t},\n}\n\nfunc TestLevenshteinDistance(t *testing.T) {\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual := levenshteinDistance(tc.string1, tc.string2, tc.insertionCost, tc.substitutionCost, tc.deletionCost)\n\t\t\tif actual != tc.expected {\n\t\t\t\tt.Errorf(\"Expected Levenshtein distance between strings: '%s' and '%s' is %v, but got: %v\", tc.string1, tc.string2, tc.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}\n","index":95},{"title":"Multiple-string-matching","category":"strings","id":"multiple-string-matching","index":96},{"title":"Advanced-aho-corasick","category":"multiple-string-matching","id":"advanced-aho-corasick","index":97},{"title":"Adac","category":"advanced-aho-corasick","id":"adac_advanced-aho-corasick","algorithm":"package advancedahocorasick\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"strings\"\n\t\"time\"\n)\n\n// User defined.\n// Set to true to print various extra stuff out (slows down the execution)\n// Set to false for quick and quiet execution.\nconst debugMode bool = true\n\ntype result struct {\n\toccurrences map[string][]int\n}\n\n// Implementation of Advanced Aho-Corasick algorithm (Prefix based).\n// Searches for a set of strings (patterns.txt) in text.txt.\nfunc main() {\n\tpatFile, err := ioutil.ReadFile(\"../patterns.txt\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\ttextFile, err := ioutil.ReadFile(\"../text.txt\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tpatterns := strings.Split(string(patFile), \" \")\n\tfmt.Printf(\"\\nRunning: Advanced Aho-Corasick algorithm.\\n\\n\")\n\tif debugMode == true {\n\t\tfmt.Printf(\"Searching for %d patterns/words:\\n\", len(patterns))\n\t}\n\tfor i := 0; i < len(patterns); i++ {\n\t\tif len(patterns[i]) > len(textFile) {\n\t\t\tlog.Fatal(\"There is a pattern that is longer than text! Pattern number:\", i+1)\n\t\t}\n\t\tif debugMode == true {\n\t\t\tfmt.Printf(\"%q \", patterns[i])\n\t\t}\n\t}\n\tif debugMode == true {\n\t\tfmt.Printf(\"\\n\\nIn text (%d chars long): \\n%q\\n\\n\", len(textFile), textFile)\n\t}\n\tr := ahoCorasick(string(textFile), patterns)\n\tfor key, value := range r.occurrences { //prints all occurrences of each pattern (if there was at least one)\n\t\tfmt.Printf(\"\\nThere were %d occurences for word: %q at positions: \", len(value), key)\n\t\tfor i := range value {\n\t\t\tfmt.Printf(\"%d\", value[i])\n\t\t\tif i != len(value)-1 {\n\t\t\t\tfmt.Printf(\", \")\n\t\t\t}\n\t\t}\n\t\tfmt.Printf(\".\")\n\t}\n\treturn\n}\n\n// Function performing the Advanced Aho-Corasick alghoritm.\n// Finds and prints occurrences of each pattern.\nfunc ahoCorasick(t string, p []string) result {\n\tstartTime := time.Now()\n\toccurrences := make(map[int][]int)\n\tac, f := buildExtendedAc(p)\n\tif debugMode == true {\n\t\tfmt.Printf(\"\\n\\nAC:\\n\\n\")\n\t}\n\tcurrent := 0\n\tfor pos := 0; pos < len(t); pos++ {\n\t\tif getTransition(current, t[pos], ac) != -1 {\n\t\t\tcurrent = getTransition(current, t[pos], ac)\n\t\t} else {\n\t\t\tcurrent = 0\n\t\t}\n\t\t_, ok := f[current]\n\t\tif ok {\n\t\t\tfor i := range f[current] {\n\t\t\t\tif p[f[current][i]] == getWord(pos-len(p[f[current][i]])+1, pos, t) { //check for word match\n\t\t\t\t\tif debugMode == true {\n\t\t\t\t\t\tfmt.Printf(\"Occurence at position %d, %q = %q\\n\", pos-len(p[f[current][i]])+1, p[f[current][i]], p[f[current][i]])\n\t\t\t\t\t}\n\t\t\t\t\tnewOccurrences := intArrayCapUp(occurrences[f[current][i]])\n\t\t\t\t\toccurrences[f[current][i]] = newOccurrences\n\t\t\t\t\toccurrences[f[current][i]][len(newOccurrences)-1] = pos - len(p[f[current][i]]) + 1\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telapsed := time.Since(startTime)\n\tfmt.Printf(\"\\n\\nElapsed %f secs\\n\", elapsed.Seconds())\n\n\tvar resultOccurrences = make(map[string][]int)\n\tfor key, value := range occurrences {\n\t\tresultOccurrences[p[key]] = value\n\t}\n\n\treturn result{\n\t\tresultOccurrences,\n\t}\n}\n\n// Functions that builds extended Aho Corasick automaton.\nfunc buildExtendedAc(p []string) (acToReturn map[int]map[uint8]int, f map[int][]int) {\n\tacTrie, stateIsTerminal, f := constructTrie(p)\n\ts := make([]int, len(stateIsTerminal)) //supply function\n\ti := 0                                 //root of acTrie\n\tacToReturn = acTrie\n\ts[i] = -1\n\tif debugMode == true {\n\t\tfmt.Printf(\"\\n\\nAC construction: \\n\")\n\t}\n\tfor current := 1; current < len(stateIsTerminal); current++ {\n\t\to, parent := getParent(current, acTrie)\n\t\tdown := s[parent]\n\t\tfor stateExists(down, acToReturn) && getTransition(down, o, acToReturn) == -1 {\n\t\t\tdown = s[down]\n\t\t}\n\t\tif stateExists(down, acToReturn) {\n\t\t\ts[current] = getTransition(down, o, acToReturn)\n\t\t\tif stateIsTerminal[s[current]] == true {\n\t\t\t\tstateIsTerminal[current] = true\n\t\t\t\tf[current] = arrayUnion(f[current], f[s[current]]) //F(Current) <- F(Current) union F(S(Current))\n\t\t\t\tif debugMode == true {\n\t\t\t\t\tfmt.Printf(\" f[%d] set to: \", current)\n\t\t\t\t\tfor i := range f[current] {\n\t\t\t\t\t\tfmt.Printf(\"%d\\n\", f[current][i])\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\ts[current] = i //initial state?\n\t\t}\n\t}\n\tif debugMode == true {\n\t\tfmt.Printf(\"\\nsupply function: \\n\")\n\t\tfor i := range s {\n\t\t\tfmt.Printf(\"\\ns[%d]=%d\", i, s[i])\n\t\t}\n\t\tfmt.Printf(\"\\n\\n\")\n\t\tfor i, j := range f {\n\t\t\tfmt.Printf(\"f[%d]=\", i)\n\t\t\tfor k := range j {\n\t\t\t\tfmt.Printf(\"%d\\n\", j[k])\n\t\t\t}\n\t\t}\n\t}\n\tif debugMode == true {\n\t\tfmt.Printf(\"\\n\\nAdAC completion: \\n\")\n\t}\n\t// advanced Aho-Corasick part\n\ta := computeAlphabet(p) // concat of all patterns in p\n\tfor j := range a {\n\t\tif getTransition(i, a[j], acToReturn) == -1 {\n\t\t\tcreateTransition(i, a[j], i, acToReturn)\n\t\t}\n\t}\n\tfor current := 1; current < len(stateIsTerminal); current++ {\n\t\tfor j := range a {\n\t\t\tif getTransition(current, a[j], acToReturn) == -1 {\n\t\t\t\tcreateTransition(current, a[j], getTransition(s[current], a[j], acToReturn), acToReturn)\n\t\t\t}\n\t\t}\n\t}\n\treturn acToReturn, f\n}\n\n// Function that constructs Trie as an automaton for a set of reversed & trimmed strings.\nfunc constructTrie(p []string) (trie map[int]map[uint8]int, stateIsTerminal []bool, f map[int][]int) {\n\ttrie = make(map[int]map[uint8]int)\n\tstateIsTerminal = make([]bool, 1)\n\tf = make(map[int][]int)\n\tstate := 1\n\tif debugMode == true {\n\t\tfmt.Printf(\"\\n\\nTrie construction: \\n\")\n\t}\n\tcreateNewState(0, trie)\n\tfor i := 0; i < len(p); i++ {\n\t\tcurrent := 0\n\t\tj := 0\n\t\tfor j < len(p[i]) && getTransition(current, p[i][j], trie) != -1 {\n\t\t\tcurrent = getTransition(current, p[i][j], trie)\n\t\t\tj++\n\t\t}\n\t\tfor j < len(p[i]) {\n\t\t\tstateIsTerminal = boolArrayCapUp(stateIsTerminal)\n\t\t\tcreateNewState(state, trie)\n\t\t\tstateIsTerminal[state] = false\n\t\t\tcreateTransition(current, p[i][j], state, trie)\n\t\t\tcurrent = state\n\t\t\tj++\n\t\t\tstate++\n\t\t}\n\t\tif stateIsTerminal[current] {\n\t\t\tnewArray := intArrayCapUp(f[current])\n\t\t\tnewArray[len(newArray)-1] = i\n\t\t\tf[current] = newArray // F(Current) <- F(Current) union {i}\n\t\t\tif debugMode == true {\n\t\t\t\tfmt.Printf(\" and %d\", i)\n\t\t\t}\n\t\t} else {\n\t\t\tstateIsTerminal[current] = true\n\t\t\tf[current] = []int{i} // F(Current) <- {i}\n\t\t\tif debugMode == true {\n\t\t\t\tfmt.Printf(\"\\n%d is terminal for word number %d\", current, i)\n\t\t\t}\n\t\t}\n\t}\n\treturn trie, stateIsTerminal, f\n}\n\n// Returns 'true' if arry of int's 's' contains int 'e', 'false' otherwise.\nfunc contains(s []int, e int) bool {\n\tfor _, a := range s {\n\t\tif a == e {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// Function that returns word found in text 't' at position range 'begin' to 'end'.\nfunc getWord(begin, end int, t string) string {\n\tfor end >= len(t) {\n\t\treturn \"\"\n\t}\n\td := make([]uint8, end-begin+1)\n\tfor j, i := 0, begin; i <= end; i, j = i+1, j+1 {\n\t\td[j] = t[i]\n\t}\n\treturn string(d)\n}\n\n// Function that returns string of all the possible characters in given patterns.\nfunc computeAlphabet(p []string) (s string) {\n\ts = p[0]\n\tfor i := 1; i < len(p); i++ {\n\t\ts = s + p[i]\n\t}\n\treturn s\n}\n\n// Dynamically increases an array size of int's by 1.\nfunc intArrayCapUp(old []int) (new []int) {\n\tnew = make([]int, cap(old)+1)\n\tcopy(new, old) //copy(dst,src)\n\told = new\n\treturn new\n}\n\n// Dynamically increases an array size of bool's by 1.\nfunc boolArrayCapUp(old []bool) (new []bool) {\n\tnew = make([]bool, cap(old)+1)\n\tcopy(new, old)\n\told = new\n\treturn new\n}\n\n// Concats two arrays of int's into one.\nfunc arrayUnion(to, from []int) (concat []int) {\n\tconcat = to\n\tfor i := range from {\n\t\tif !contains(concat, from[i]) {\n\t\t\tconcat = intArrayCapUp(concat)\n\t\t\tconcat[len(concat)-1] = from[i]\n\t\t}\n\t}\n\treturn concat\n}\n\n// Function that finds the first previous state of a state and returns it.\n// Used for trie where there is only one parent.\nfunc getParent(state int, at map[int]map[uint8]int) (uint8, int) {\n\tfor beginState, transitions := range at {\n\t\tfor c, endState := range transitions {\n\t\t\tif endState == state {\n\t\t\t\treturn c, beginState\n\t\t\t}\n\t\t}\n\t}\n\treturn 0, 0 //unreachable\n}\n\n// Automaton function for creating a new state 'state'.\nfunc createNewState(state int, at map[int]map[uint8]int) {\n\tat[state] = make(map[uint8]int)\n\tif debugMode == true {\n\t\tfmt.Printf(\"\\ncreated state %d\", state)\n\t}\n}\n\n// Creates a transition for function σ(state,letter) = end.\nfunc createTransition(fromState int, overChar uint8, toState int, at map[int]map[uint8]int) {\n\tat[fromState][overChar] = toState\n\tif debugMode == true {\n\t\tfmt.Printf(\"\\n    σ(%d,%c)=%d;\", fromState, overChar, toState)\n\t}\n}\n\n// Returns ending state for transition σ(fromState,overChar), '-1' if there is none.\nfunc getTransition(fromState int, overChar uint8, at map[int]map[uint8]int) (toState int) {\n\tif !stateExists(fromState, at) {\n\t\treturn -1\n\t}\n\ttoState, ok := at[fromState][overChar]\n\tif ok == false {\n\t\treturn -1\n\t}\n\treturn toState\n}\n\n// Checks if state 'state' exists. Returns 'true' if it does, 'false' otherwise.\nfunc stateExists(state int, at map[int]map[uint8]int) bool {\n\t_, ok := at[state]\n\tif !ok || state == -1 || at[state] == nil {\n\t\treturn false\n\t}\n\treturn true\n}\n","index":98},{"title":"Adac Test","category":"advanced-aho-corasick","id":"adac_test_advanced-aho-corasick","algorithm":"package advancedahocorasick\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nvar testCases = []struct {\n\tname     string\n\twords    []string\n\ttext     string\n\texpected result\n}{\n\n\t{\n\t\t\"String comparison on all patterns found\",\n\t\t[]string{\"announce\", \"annual\", \"annually\"},\n\t\t\"CPM_annual_conferenceannounce_announce_annually_announce\",\n\t\tresult{\n\t\t\tmap[string][]int{\n\t\t\t\t\"annual\":   {4, 39},\n\t\t\t\t\"announce\": {21, 30, 48},\n\t\t\t\t\"annually\": {39},\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\t\"String comparison on not all patterns found\",\n\t\t[]string{\"announce\", \"annual\", \"annually\"},\n\t\t\"CPM_annual_conference_announce\",\n\t\tresult{\n\t\t\tmap[string][]int{\n\t\t\t\t\"annual\":   {4},\n\t\t\t\t\"announce\": {22},\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\t\"String comparison on not all patterns found\",\n\t\t[]string{\"announce\", \"annual\", \"annually\"},\n\t\t\"CPM_annual_conference_announce\",\n\t\tresult{\n\t\t\tmap[string][]int{\n\t\t\t\t\"annual\":   {4},\n\t\t\t\t\"announce\": {22},\n\t\t\t},\n\t\t},\n\t},\n}\n\nfunc TestAhoCorasick(t *testing.T) {\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual := ahoCorasick(tc.text, tc.words)\n\t\t\tif !reflect.DeepEqual(actual, tc.expected) {\n\t\t\t\tactualString := convertToString(actual)\n\t\t\t\texpectedString := convertToString(tc.expected)\n\t\t\t\tt.Errorf(\"Expected matches for patterns %s for string '%s' are: patterns and positions found %v, but actual matches are: patterns and positions found %v\",\n\t\t\t\t\ttc.words, tc.text, actualString, expectedString)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc convertToString(res result) string {\n\tvar r string\n\tfor key, val := range res.occurrences {\n\t\tr = r + fmt.Sprintf(\"Word: '%s' at positions: \", key)\n\t\tfor i := range val {\n\t\t\tr = r + fmt.Sprintf(\"%d\", val[i])\n\t\t\tif i != len(val)-1 {\n\t\t\t\tr = r + fmt.Sprintf(\", \")\n\t\t\t}\n\t\t}\n\t\tr = r + fmt.Sprintf(\". \")\n\t}\n\treturn r\n}\n","index":99},{"title":"Aho-corasick","category":"multiple-string-matching","id":"aho-corasick","index":100},{"title":"Ac","category":"aho-corasick","id":"ac_aho-corasick","algorithm":"package ahocorasick\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"strings\"\n\t\"time\"\n)\n\n// User defined.\n// Set to true to print various extra stuff out (slows down the execution)\n// Set to false for quick and quiet execution.\nconst debugMode bool = true\n\ntype result struct {\n\toccurrences map[string][]int\n}\n\n// Implementation of Basic Aho-Corasick algorithm (Prefix based).\n// Searches for a set of strings (patterns.txt) in text.txt.\nfunc main() {\n\tpatFile, err := ioutil.ReadFile(\"../patterns.txt\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\ttextFile, err := ioutil.ReadFile(\"../text.txt\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tpatterns := strings.Split(string(patFile), \" \")\n\tfmt.Printf(\"\\nRunning: Basic Aho-Corasick algorithm.\\n\\n\")\n\tif debugMode == true {\n\t\tfmt.Printf(\"Searching for %d patterns/words:\\n\", len(patterns))\n\t}\n\tfor i := 0; i < len(patterns); i++ {\n\t\tif len(patterns[i]) > len(textFile) {\n\t\t\tlog.Fatal(\"There is a pattern that is longer than text! Pattern number:\", i+1)\n\t\t}\n\t\tif debugMode == true {\n\t\t\tfmt.Printf(\"%q \", patterns[i])\n\t\t}\n\t}\n\tif debugMode == true {\n\t\tfmt.Printf(\"\\n\\nIn text (%d chars long): \\n%q\\n\\n\", len(textFile), textFile)\n\t}\n\tr := ahoCorasick(string(textFile), patterns)\n\tfor key, value := range r.occurrences { //prints all occurrences of each pattern (if there was at least one)\n\t\tfmt.Printf(\"\\nThere were %d occurences for word: %q at positions: \", len(value), key)\n\t\tfor i := range value {\n\t\t\tfmt.Printf(\"%d\", value[i])\n\t\t\tif i != len(value)-1 {\n\t\t\t\tfmt.Printf(\", \")\n\t\t\t}\n\t\t}\n\t\tfmt.Printf(\".\")\n\t}\n}\n\n// Function performing the Basic Aho-Corasick algorithm.\n// Finds and prints occurrences of each pattern.\nfunc ahoCorasick(t string, p []string) result {\n\tstartTime := time.Now()\n\toccurrences := make(map[int][]int)\n\tac, f, s := buildAc(p)\n\tif debugMode == true {\n\t\tfmt.Printf(\"\\n\\nAC:\\n\\n\")\n\t}\n\tcurrent := 0\n\tfor pos := 0; pos < len(t); pos++ {\n\t\tif debugMode == true {\n\t\t\tfmt.Printf(\"Position: %d, we read: %c\", pos, t[pos])\n\t\t}\n\t\tfor getTransition(current, t[pos], ac) == -1 && s[current] != -1 {\n\t\t\tcurrent = s[current]\n\t\t}\n\t\tif getTransition(current, t[pos], ac) != -1 {\n\t\t\tcurrent = getTransition(current, t[pos], ac)\n\t\t\tfmt.Printf(\" (Continue) \\n\")\n\t\t} else {\n\t\t\tcurrent = 0\n\t\t\tif debugMode == true {\n\t\t\t\tfmt.Printf(\" (FAIL) \\n\")\n\t\t\t}\n\t\t}\n\t\t_, ok := f[current]\n\t\tif ok {\n\t\t\tfor i := range f[current] {\n\t\t\t\tif p[f[current][i]] == getWord(pos-len(p[f[current][i]])+1, pos, t) { //check for word match\n\t\t\t\t\tif debugMode == true {\n\t\t\t\t\t\tfmt.Printf(\"Occurence at position %d, %q = %q\\n\", pos-len(p[f[current][i]])+1, p[f[current][i]], p[f[current][i]])\n\t\t\t\t\t}\n\t\t\t\t\tnewOccurrences := intArrayCapUp(occurrences[f[current][i]])\n\t\t\t\t\toccurrences[f[current][i]] = newOccurrences\n\t\t\t\t\toccurrences[f[current][i]][len(newOccurrences)-1] = pos - len(p[f[current][i]]) + 1\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telapsed := time.Since(startTime)\n\tfmt.Printf(\"\\n\\nElapsed %f secs\\n\", elapsed.Seconds())\n\tvar resultOccurrences = make(map[string][]int)\n\tfor key, value := range occurrences {\n\t\tresultOccurrences[p[key]] = value\n\t}\n\n\treturn result{\n\t\tresultOccurrences,\n\t}\n}\n\n// Functions that builds Aho Corasick automaton.\nfunc buildAc(p []string) (acToReturn map[int]map[uint8]int, f map[int][]int, s []int) {\n\tacTrie, stateIsTerminal, f := constructTrie(p)\n\ts = make([]int, len(stateIsTerminal)) //supply function\n\ti := 0                                //root of acTrie\n\tacToReturn = acTrie\n\ts[i] = -1\n\tif debugMode == true {\n\t\tfmt.Printf(\"\\n\\nAC construction: \\n\")\n\t}\n\tfor current := 1; current < len(stateIsTerminal); current++ {\n\t\to, parent := getParent(current, acTrie)\n\t\tdown := s[parent]\n\t\tfor stateExists(down, acToReturn) && getTransition(down, o, acToReturn) == -1 {\n\t\t\tdown = s[down]\n\t\t}\n\t\tif stateExists(down, acToReturn) {\n\t\t\ts[current] = getTransition(down, o, acToReturn)\n\t\t\tif stateIsTerminal[s[current]] == true {\n\t\t\t\tstateIsTerminal[current] = true\n\t\t\t\tf[current] = arrayUnion(f[current], f[s[current]]) //F(Current) <- F(Current) union F(S(Current))\n\t\t\t\tif debugMode == true {\n\t\t\t\t\tfmt.Printf(\" f[%d] set to: \", current)\n\t\t\t\t\tfor i := range f[current] {\n\t\t\t\t\t\tfmt.Printf(\"%d\\n\", f[current][i])\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\ts[current] = i //initial state?\n\t\t}\n\t}\n\tif debugMode == true {\n\t\tfmt.Printf(\"\\nsupply function: \\n\")\n\t\tfor i := range s {\n\t\t\tfmt.Printf(\"\\ns[%d]=%d\", i, s[i])\n\t\t}\n\t\tfmt.Printf(\"\\n\\n\")\n\t\tfor i, j := range f {\n\t\t\tfmt.Printf(\"f[%d]=\", i)\n\t\t\tfor k := range j {\n\t\t\t\tfmt.Printf(\"%d\\n\", j[k])\n\t\t\t}\n\t\t}\n\t}\n\treturn acToReturn, f, s\n}\n\n// Function that constructs Trie as an automaton for a set of reversed & trimmed strings.\nfunc constructTrie(p []string) (trie map[int]map[uint8]int, stateIsTerminal []bool, f map[int][]int) {\n\ttrie = make(map[int]map[uint8]int)\n\tstateIsTerminal = make([]bool, 1)\n\tf = make(map[int][]int)\n\tstate := 1\n\tif debugMode == true {\n\t\tfmt.Printf(\"\\n\\nTrie construction: \\n\")\n\t}\n\tcreateNewState(0, trie)\n\tfor i := 0; i < len(p); i++ {\n\t\tcurrent := 0\n\t\tj := 0\n\t\tfor j < len(p[i]) && getTransition(current, p[i][j], trie) != -1 {\n\t\t\tcurrent = getTransition(current, p[i][j], trie)\n\t\t\tj++\n\t\t}\n\t\tfor j < len(p[i]) {\n\t\t\tstateIsTerminal = boolArrayCapUp(stateIsTerminal)\n\t\t\tcreateNewState(state, trie)\n\t\t\tstateIsTerminal[state] = false\n\t\t\tcreateTransition(current, p[i][j], state, trie)\n\t\t\tcurrent = state\n\t\t\tj++\n\t\t\tstate++\n\t\t}\n\t\tif stateIsTerminal[current] {\n\t\t\tnewArray := intArrayCapUp(f[current])\n\t\t\tnewArray[len(newArray)-1] = i\n\t\t\tf[current] = newArray //F(Current) <- F(Current) union {i}\n\t\t\tif debugMode == true {\n\t\t\t\tfmt.Printf(\" and %d\", i)\n\t\t\t}\n\t\t} else {\n\t\t\tstateIsTerminal[current] = true\n\t\t\tf[current] = []int{i} //F(Current) <- {i}\n\t\t\tif debugMode == true {\n\t\t\t\tfmt.Printf(\"\\n%d is terminal for word number %d\", current, i)\n\t\t\t}\n\t\t}\n\t}\n\treturn trie, stateIsTerminal, f\n}\n\n/**\nReturns 'true' if array of int's 's' contains int 'e', 'false' otherwise.\n\n@author Mostafa http://stackoverflow.com/a/10485970\n*/\nfunc contains(s []int, e int) bool {\n\tfor _, a := range s {\n\t\tif a == e {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// Function that returns word found in text 't' at position range 'begin' to 'end'.\nfunc getWord(begin, end int, t string) string {\n\tfor end >= len(t) {\n\t\treturn \"\"\n\t}\n\td := make([]uint8, end-begin+1)\n\tfor j, i := 0, begin; i <= end; i, j = i+1, j+1 {\n\t\td[j] = t[i]\n\t}\n\treturn string(d)\n}\n\n// Dynamically increases an array size of int's by 1.\nfunc intArrayCapUp(old []int) (new []int) {\n\tnew = make([]int, cap(old)+1)\n\tcopy(new, old) //copy(dst,src)\n\told = new\n\treturn new\n}\n\n// Dynamically increases an array size of bool's by 1.\nfunc boolArrayCapUp(old []bool) (new []bool) {\n\tnew = make([]bool, cap(old)+1)\n\tcopy(new, old)\n\told = new\n\treturn new\n}\n\n// Concats two arrays of int's into one.\nfunc arrayUnion(to, from []int) (concat []int) {\n\tconcat = to\n\tfor i := range from {\n\t\tif !contains(concat, from[i]) {\n\t\t\tconcat = intArrayCapUp(concat)\n\t\t\tconcat[len(concat)-1] = from[i]\n\t\t}\n\t}\n\treturn concat\n}\n\n// Function that finds the first previous state of a state and returns it.\n// Used for trie where there is only one parent.\nfunc getParent(state int, at map[int]map[uint8]int) (uint8, int) {\n\tfor beginState, transitions := range at {\n\t\tfor c, endState := range transitions {\n\t\t\tif endState == state {\n\t\t\t\treturn c, beginState\n\t\t\t}\n\t\t}\n\t}\n\treturn 0, 0 //unreachable\n}\n\n// Automaton function for creating a new state 'state'.\nfunc createNewState(state int, at map[int]map[uint8]int) {\n\tat[state] = make(map[uint8]int)\n\tif debugMode == true {\n\t\tfmt.Printf(\"\\ncreated state %d\", state)\n\t}\n}\n\n// Creates a transition for function σ(state,letter) = end.\nfunc createTransition(fromState int, overChar uint8, toState int, at map[int]map[uint8]int) {\n\tat[fromState][overChar] = toState\n\tif debugMode == true {\n\t\tfmt.Printf(\"\\n    σ(%d,%c)=%d;\", fromState, overChar, toState)\n\t}\n}\n\n// Returns ending state for transition σ(fromState,overChar), '-1' if there is none.\nfunc getTransition(fromState int, overChar uint8, at map[int]map[uint8]int) (toState int) {\n\tif !stateExists(fromState, at) {\n\t\treturn -1\n\t}\n\ttoState, ok := at[fromState][overChar]\n\tif ok == false {\n\t\treturn -1\n\t}\n\treturn toState\n}\n\n// Checks if state 'state' exists. Returns 'true' if it does, 'false' otherwise.\nfunc stateExists(state int, at map[int]map[uint8]int) bool {\n\t_, ok := at[state]\n\tif !ok || state == -1 || at[state] == nil {\n\t\treturn false\n\t}\n\treturn true\n}\n","index":101},{"title":"Ac Test","category":"aho-corasick","id":"ac_test_aho-corasick","algorithm":"package ahocorasick\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nvar testCases = []struct {\n\tname     string\n\twords    []string\n\ttext     string\n\texpected result\n}{\n\n\t{\n\t\t\"String comparison on all patterns found\",\n\t\t[]string{\"announce\", \"annual\", \"annually\"},\n\t\t\"CPM_annual_conferenceannounce_announce_annually_announce\",\n\t\tresult{\n\t\t\tmap[string][]int{\n\t\t\t\t\"annual\":   {4, 39},\n\t\t\t\t\"announce\": {21,30,48},\n\t\t\t\t\"annually\": {39},\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\t\"String comparison on not all patterns found\",\n\t\t[]string{\"announce\", \"annual\", \"annually\"},\n\t\t\"CPM_annual_conference_announce\",\n\t\tresult{\n\t\t\tmap[string][]int{\n\t\t\t\t\"annual\":   {4},\n\t\t\t\t\"announce\": {22},\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\t\"String comparison on not all patterns found\",\n\t\t[]string{\"announce\", \"annual\", \"annually\"},\n\t\t\"CPM_annual_conference_announce\",\n\t\tresult{\n\t\t\tmap[string][]int{\n\t\t\t\t\"annual\":   {4},\n\t\t\t\t\"announce\": {22},\n\t\t\t},\n\t\t},\n\t},\n}\n\nfunc TestAhoCorasick(t *testing.T) {\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual := ahoCorasick(tc.text, tc.words)\n\t\t\tif !reflect.DeepEqual(actual, tc.expected) {\n\t\t\t\tactualString := convertToString(actual)\n\t\t\t\texpectedString := convertToString(tc.expected)\n\t\t\t\tt.Errorf(\"Expected matches for patterns %s for string '%s' are: patterns and positions found %v, but actual matches are: patterns and positions found %v\",\n\t\t\t\t\ttc.words, tc.text, actualString, expectedString)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc convertToString(res result) string {\n\tvar r string\n\tfor key, val := range res.occurrences {\n\t\tr = r + fmt.Sprintf(\"Word: '%s' at positions: \", key)\n\t\tfor i := range val {\n\t\t\tr = r + fmt.Sprintf(\"%d\", val[i])\n\t\t\tif i != len(val)-1 {\n\t\t\t\tr = r + fmt.Sprintf(\", \")\n\t\t\t}\n\t\t}\n\t\tr = r + fmt.Sprintf(\". \")\n\t}\n\treturn r\n}\n","index":102},{"title":"Sbom","category":"multiple-string-matching","id":"sbom","index":103},{"title":"Sbom","category":"sbom","id":"sbom_sbom","algorithm":"package sbom\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"strings\"\n\t\"time\"\n)\n\n// User defined.\n// Set to true to print various extra stuff out (slows down the execution)\n// Set to false for quick and quiet execution.\nconst debugMode bool = true\n\ntype result struct {\n\toccurrences map[string][]int\n}\n\n// Implementation of Set Backward Oracle Matching algorithm (Factor based).\n// Searches for a set of strings (in 'patterns.txt') in text.txt.\nfunc main() {\n\tpatFile, err := ioutil.ReadFile(\"../patterns.txt\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\ttextFile, err := ioutil.ReadFile(\"../text.txt\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tpatterns := strings.Split(string(patFile), \" \")\n\tfmt.Printf(\"\\nRunning: Set Backward Oracle Matching algorithm.\\n\\n\")\n\tif debugMode == true {\n\t\tfmt.Printf(\"Searching for %d patterns/words:\\n\", len(patterns))\n\t}\n\tfor i := 0; i < len(patterns); i++ {\n\t\tif len(patterns[i]) > len(textFile) {\n\t\t\tlog.Fatal(\"There is a pattern that is longer than text! Pattern number:\", i+1)\n\t\t}\n\t\tif debugMode == true {\n\t\t\tfmt.Printf(\"%q \", patterns[i])\n\t\t}\n\t}\n\tif debugMode == true {\n\t\tfmt.Printf(\"\\n\\nIn text (%d chars long): \\n%q\\n\\n\", len(textFile), textFile)\n\t}\n\tr := sbom(string(textFile), patterns)\n\tfor key, value := range r.occurrences { //prints all occurrences of each pattern (if there was at least one)\n\t\tfmt.Printf(\"\\nThere were %d occurences for word: %q at positions: \", len(value), key)\n\t\tfor i := range value {\n\t\t\tfmt.Printf(\"%d\", value[i])\n\t\t\tif i != len(value)-1 {\n\t\t\t\tfmt.Printf(\", \")\n\t\t\t}\n\t\t}\n\t\tfmt.Printf(\".\")\n\t}\n\n}\n\n// Function sbom performing the Set Backward Oracle Matching algorithm.\n// Finds and prints occurrences of each pattern.\nfunc sbom(t string, p []string) result {\n\tstartTime := time.Now()\n\toccurrences := make(map[int][]int)\n\tlmin := computeMinLength(p)\n\tor, f := buildOracleMultiple(reverseAll(trimToLength(p, lmin)))\n\tif debugMode == true {\n\t\tfmt.Printf(\"\\n\\nSBOM:\\n\\n\")\n\t}\n\tpos := 0\n\tfor pos <= len(t)-lmin {\n\t\tcurrent := 0\n\t\tj := lmin\n\t\tif debugMode == true {\n\t\t\tfmt.Printf(\"Position: %d, we read: \", pos)\n\t\t}\n\t\tfor j >= 1 && stateExists(current, or) {\n\t\t\tif debugMode == true {\n\t\t\t\tfmt.Printf(\"%c\", t[pos+j-1])\n\t\t\t}\n\t\t\tcurrent = getTransition(current, t[pos+j-1], or)\n\t\t\tif debugMode == true {\n\t\t\t\tif current == -1 {\n\t\t\t\t\tfmt.Printf(\" (FAIL) \")\n\t\t\t\t} else {\n\t\t\t\t\tfmt.Printf(\", \")\n\t\t\t\t}\n\t\t\t}\n\t\t\tj--\n\t\t}\n\t\tif debugMode == true {\n\t\t\tfmt.Printf(\"in the factor oracle. \\n\")\n\t\t}\n\t\tword := getWord(pos, pos+lmin-1, t)\n\t\tif stateExists(current, or) && j == 0 && strings.HasPrefix(word, getCommonPrefix(p, f[current], lmin)) { //check for prefix match\n\t\t\tfor i := range f[current] {\n\t\t\t\tif p[f[current][i]] == getWord(pos, pos-1+len(p[f[current][i]]), t) { //check for word match\n\t\t\t\t\tif debugMode == true {\n\t\t\t\t\t\tfmt.Printf(\"- Occurence, %q = %q\\n\", p[f[current][i]], word)\n\t\t\t\t\t}\n\t\t\t\t\tnewOccurences := intArrayCapUp(occurrences[f[current][i]])\n\t\t\t\t\toccurrences[f[current][i]] = newOccurences\n\t\t\t\t\toccurrences[f[current][i]][len(newOccurences)-1] = pos\n\t\t\t\t}\n\t\t\t}\n\t\t\tj = 0\n\t\t}\n\t\tpos = pos + j + 1\n\t}\n\telapsed := time.Since(startTime)\n\tfmt.Printf(\"\\n\\nElapsed %f secs\\n\", elapsed.Seconds())\n\tvar resultOccurrences = make(map[string][]int)\n\tfor key, value := range occurrences {\n\t\tresultOccurrences[p[key]] = value\n\t}\n\n\treturn result{\n\t\tresultOccurrences,\n\t}\n}\n\n// Function that builds factor oracle.\nfunc buildOracleMultiple(p []string) (orToReturn map[int]map[uint8]int, f map[int][]int) {\n\torTrie, stateIsTerminal, f := constructTrie(p)\n\ts := make([]int, len(stateIsTerminal)) //supply function\n\ti := 0                                 //root of trie\n\torToReturn = orTrie\n\ts[i] = -1\n\tif debugMode == true {\n\t\tfmt.Printf(\"\\n\\nOracle construction: \\n\")\n\t}\n\tfor current := 1; current < len(stateIsTerminal); current++ {\n\t\to, parent := getParent(current, orTrie)\n\t\tdown := s[parent]\n\t\tfor stateExists(down, orToReturn) && getTransition(down, o, orToReturn) == -1 {\n\t\t\tcreateTransition(down, o, current, orToReturn)\n\t\t\tdown = s[down]\n\t\t}\n\t\tif stateExists(down, orToReturn) {\n\t\t\ts[current] = getTransition(down, o, orToReturn)\n\t\t} else {\n\t\t\ts[current] = i\n\t\t}\n\t}\n\treturn orToReturn, f\n}\n\n// Function that constructs Trie as an automaton for a set of reversed & trimmed strings.\nfunc constructTrie(p []string) (trie map[int]map[uint8]int, stateIsTerminal []bool, f map[int][]int) {\n\ttrie = make(map[int]map[uint8]int)\n\tstateIsTerminal = make([]bool, 1)\n\tf = make(map[int][]int)\n\tstate := 1\n\tif debugMode == true {\n\t\tfmt.Printf(\"\\n\\nTrie construction: \\n\")\n\t}\n\tcreateNewState(0, trie)\n\tfor i := 0; i < len(p); i++ {\n\t\tcurrent := 0\n\t\tj := 0\n\t\tfor j < len(p[i]) && getTransition(current, p[i][j], trie) != -1 {\n\t\t\tcurrent = getTransition(current, p[i][j], trie)\n\t\t\tj++\n\t\t}\n\t\tfor j < len(p[i]) {\n\t\t\tstateIsTerminal = boolArrayCapUp(stateIsTerminal)\n\t\t\tcreateNewState(state, trie)\n\t\t\tstateIsTerminal[state] = false\n\t\t\tcreateTransition(current, p[i][j], state, trie)\n\t\t\tcurrent = state\n\t\t\tj++\n\t\t\tstate++\n\t\t}\n\t\tif stateIsTerminal[current] {\n\t\t\tnewArray := intArrayCapUp(f[current])\n\t\t\tnewArray[len(newArray)-1] = i\n\t\t\tf[current] = newArray //F(Current) <- F(Current) union {i}\n\t\t\tif debugMode == true {\n\t\t\t\tfmt.Printf(\" and %d\", i)\n\t\t\t}\n\t\t} else {\n\t\t\tstateIsTerminal[current] = true\n\t\t\tf[current] = []int{i} //F(Current) <- {i}\n\t\t\tif debugMode == true {\n\t\t\t\tfmt.Printf(\"\\n%d is terminal for word number %d\", current, i)\n\t\t\t}\n\t\t}\n\t}\n\treturn trie, stateIsTerminal, f\n}\n\n// Dynamically increases an array size of int's by 1.\nfunc intArrayCapUp(old []int) (new []int) {\n\tnew = make([]int, cap(old)+1)\n\tcopy(new, old) //copy(dst,src)\n\told = new\n\treturn new\n}\n\n// Dynamically increases an array size of bool's by 1.\nfunc boolArrayCapUp(old []bool) (new []bool) {\n\tnew = make([]bool, cap(old)+1)\n\tcopy(new, old)\n\told = new\n\treturn new\n}\n\n// Function that takes an array of strings and reverses it.\nfunc reverseAll(s []string) (reversed []string) {\n\treversed = make([]string, len(s))\n\tfor i := 0; i < len(s); i++ {\n\t\treversed[i] = reverse(s[i])\n\t}\n\treturn reversed\n}\n\n// Function that takes a single string and reverses it.\nfunc reverse(s string) string {\n\tl := len(s)\n\tm := make([]rune, l)\n\tfor _, c := range s {\n\t\tl--\n\t\tm[l] = c\n\t}\n\treturn string(m)\n}\n\n// Returns a prefix size 'lmin' for one string 'p' of first index found in 'f'.\n// It is not needed to compare all the strings from 'p' indexed in 'f',\n// thanks to the konwledge of 'lmin'.\nfunc getCommonPrefix(p []string, f []int, lmin int) string {\n\tr := []rune(p[f[0]])\n\tnewR := make([]rune, lmin)\n\tfor j := 0; j < lmin; j++ {\n\t\tnewR[j] = r[j]\n\t}\n\treturn string(newR)\n}\n\n// Function that takes a set of strings 'p' and their wanted 'length'\n// and then trims each string in that set to have desired 'length'.\nfunc trimToLength(p []string, length int) (trimmedP []string) {\n\ttrimmedP = make([]string, len(p))\n\tfor i := range p {\n\t\tr := []rune(p[i])\n\t\tnewR := make([]rune, length)\n\t\tfor j := 0; j < length; j++ {\n\t\t\tnewR[j] = r[j]\n\t\t}\n\t\ttrimmedP[i] = string(newR)\n\t}\n\treturn trimmedP\n}\n\n// Function that returns word found in text 't' at position range 'begin' to 'end'.\nfunc getWord(begin, end int, t string) string {\n\tfor end >= len(t) {\n\t\treturn \"\"\n\t}\n\td := make([]uint8, end-begin+1)\n\tfor j, i := 0, begin; i <= end; i, j = i+1, j+1 {\n\t\td[j] = t[i]\n\t}\n\treturn string(d)\n}\n\n// Function that computes minimal length string in a set of strings.\nfunc computeMinLength(p []string) (lmin int) {\n\tlmin = len(p[0])\n\tfor i := 1; i < len(p); i++ {\n\t\tif len(p[i]) < lmin {\n\t\t\tlmin = len(p[i])\n\t\t}\n\t}\n\treturn lmin\n}\n\n// Function that finds the first previous state of a state and returns it.\n// Used for trie where there is only one parent.\nfunc getParent(state int, at map[int]map[uint8]int) (uint8, int) {\n\tfor beginState, transitions := range at {\n\t\tfor c, endState := range transitions {\n\t\t\tif endState == state {\n\t\t\t\treturn c, beginState\n\t\t\t}\n\t\t}\n\t}\n\treturn 0, 0 //unreachable\n}\n\n// Automaton function for creating a new state 'state'.\nfunc createNewState(state int, at map[int]map[uint8]int) {\n\tat[state] = make(map[uint8]int)\n\tif debugMode == true {\n\t\tfmt.Printf(\"\\ncreated state %d\", state)\n\t}\n}\n\n// Creates a transition for function σ(state,letter) = end.\nfunc createTransition(fromState int, overChar uint8, toState int, at map[int]map[uint8]int) {\n\tat[fromState][overChar] = toState\n\tif debugMode == true {\n\t\tfmt.Printf(\"\\n    σ(%d,%c)=%d;\", fromState, overChar, toState)\n\t}\n}\n\n// Returns ending state for transition σ(fromState,overChar), '-1' if there is none.\nfunc getTransition(fromState int, overChar uint8, at map[int]map[uint8]int) (toState int) {\n\tif !stateExists(fromState, at) {\n\t\treturn -1\n\t}\n\ttoState, ok := at[fromState][overChar]\n\tif ok == false {\n\t\treturn -1\n\t}\n\treturn toState\n}\n\n// Checks if state 'state' exists. Returns 'true' if it does, 'false' otherwise.\nfunc stateExists(state int, at map[int]map[uint8]int) bool {\n\t_, ok := at[state]\n\tif !ok || state == -1 || at[state] == nil {\n\t\treturn false\n\t}\n\treturn true\n}\n","index":104},{"title":"Sbom Test","category":"sbom","id":"sbom_test_sbom","algorithm":"package sbom\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nvar testCases = []struct {\n\tname     string\n\twords    []string\n\ttext     string\n\texpected result\n}{\n\n\t{\n\t\t\"String comparison on all patterns found\",\n\t\t[]string{\"announce\", \"annual\", \"annually\"},\n\t\t\"CPM_annual_conferenceannounce_announce_annually_announce\",\n\t\tresult{\n\t\t\tmap[string][]int{\n\t\t\t\t\"annual\":   {4, 39},\n\t\t\t\t\"announce\": {21, 30, 48},\n\t\t\t\t\"annually\": {39},\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\t\"String comparison on not all patterns found\",\n\t\t[]string{\"announce\", \"annual\", \"annually\"},\n\t\t\"CPM_annual_conference_announce\",\n\t\tresult{\n\t\t\tmap[string][]int{\n\t\t\t\t\"annual\":   {4},\n\t\t\t\t\"announce\": {22},\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\t\"String comparison on not all patterns found\",\n\t\t[]string{\"announce\", \"annual\", \"annually\"},\n\t\t\"CPM_annual_conference_announce\",\n\t\tresult{\n\t\t\tmap[string][]int{\n\t\t\t\t\"annual\":   {4},\n\t\t\t\t\"announce\": {22},\n\t\t\t},\n\t\t},\n\t},\n}\n\nfunc TestAhoCorasick(t *testing.T) {\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual := sbom(tc.text, tc.words)\n\t\t\tif !reflect.DeepEqual(actual, tc.expected) {\n\t\t\t\tactualString := convertToString(actual)\n\t\t\t\texpectedString := convertToString(tc.expected)\n\t\t\t\tt.Errorf(\"Expected matches for patterns %s for string '%s' are: patterns and positions found %v, but actual matches are: patterns and positions found %v\",\n\t\t\t\t\ttc.words, tc.text, actualString, expectedString)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc convertToString(res result) string {\n\tvar r string\n\tfor key, val := range res.occurrences {\n\t\tr = r + fmt.Sprintf(\"Word: '%s' at positions: \", key)\n\t\tfor i := range val {\n\t\t\tr = r + fmt.Sprintf(\"%d\", val[i])\n\t\t\tif i != len(val)-1 {\n\t\t\t\tr = r + fmt.Sprintf(\", \")\n\t\t\t}\n\t\t}\n\t\tr = r + fmt.Sprintf(\". \")\n\t}\n\treturn r\n}\n","index":105},{"title":"Naivesearch","category":"strings","id":"naivesearch","index":106},{"title":"NaiveStringSearch","category":"naivesearch","id":"naiveStringSearch_naivesearch","algorithm":"/*\nThis algorithm tries to search the given pattern in the given text.\nIf pattern is found from index position i in the text,\nit is added to positions.\n\nTime Complexity : O(n*m)\n    n = length of text\n    m = length of pattern\n*/\n\npackage naivesearch\n\nfunc naivePatternSearch(text string, pattern string) []int {\n\tvar positions []int\n\tfor i := 0; i <= len(text)-len(pattern); i++ {\n\t\tvar match bool = true\n\t\tfor j := 0; j < len(pattern); j++ {\n\t\t\tif text[i+j] != pattern[j] {\n\t\t\t\tmatch = false\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t}\n\t\tif match {\n\t\t\tpositions = append(positions, i)\n\t\t}\n\t}\n\treturn positions\n}\n","index":107},{"title":"NaiveStringSearch Test","category":"naivesearch","id":"naiveStringSearch_test_naivesearch","algorithm":"package naivesearch\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nvar testCases = []struct {\n\tname     string\n\tinput    string\n\tpattern  string\n\texpected []int\n}{\n\t{\n\t\t\"string with multiple pattern matches\",\n\t\t\"ABAAABCDBBABCDDEBCABC\",\n\t\t\"ABC\",\n\t\t[]int{4, 10, 18},\n\t},\n\t{\n\t\t\"string with single pattern match\",\n\t\t\"ABCDEFGHIJKLMN\",\n\t\t\"CDE\",\n\t\t[]int{2},\n\t},\n\t{\n\t\t\"string with no pattern match\",\n\t\t\"ABCDEFGHIJKLMN\",\n\t\t\"XYZ\",\n\t\t[]int(nil),\n\t},\n\t{\n\t\t\"empty string\",\n\t\t\"\",\n\t\t\"XYZ\",\n\t\t[]int(nil),\n\t},\n}\n\nfunc TestNaivePatternSearch(t *testing.T) {\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual := naivePatternSearch(tc.input, tc.pattern)\n\t\t\tif !reflect.DeepEqual(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"Expected matches for pattern '%s' for string '%s' are: %v, but actual matches are: %v\", tc.pattern, tc.input, tc.expected, actual)\n\t\t\t}\n\t\t})\n\t}\n}\n","index":108},{"title":"Single-string-matching","category":"strings","id":"single-string-matching","index":109},{"title":"Bom","category":"single-string-matching","id":"bom_single-string-matching","algorithm":"package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n\t\"time\"\n)\n\n// User defined.\n// Set to true to print various extra stuff out (slows down the execution)\n// Set to false for quick and quiet execution.\nconst debugMode bool = false\n\n// User defined.\n// Set to true to read input from two command line arguments\n// Set to false to read input from two files \"pattern.txt\" and \"text.txt\"\nconst commandLineInput bool = false\n\n// Implementation of Backward Oracle Matching algorithm (Factor based approach).\n// Requires either a two command line arguments separated by a single space,\n// or two files in the same folder: \"pattern.txt\" containing the string to\n// be searched for, \"text.txt\" containing the text to be searched in.\nfunc main() {\n\tif commandLineInput == true { // case of command line input\n\t\targs := os.Args\n\t\tif len(args) <= 2 {\n\t\t\tlog.Fatal(\"Not enough arguments. Two string arguments separated by spaces are required!\")\n\t\t}\n\t\tpattern := args[1]\n\t\ts := args[2]\n\t\tfor i := 3; i < len(args); i++ {\n\t\t\ts = s + \" \" + args[i]\n\t\t}\n\t\tif len(args[1]) > len(s) {\n\t\t\tlog.Fatal(\"Pattern  is longer than text!\")\n\t\t}\n\t\tif debugMode == true {\n\t\t\tfmt.Printf(\"\\nRunning: Backward Oracle Matching algorithm.\\n\\n\")\n\t\t\tfmt.Printf(\"Search word (%d chars long): %q.\\n\", len(args[1]), pattern)\n\t\t\tfmt.Printf(\"Text        (%d chars long): %q.\\n\\n\", len(s), s)\n\t\t} else {\n\t\t\tfmt.Printf(\"\\nRunning: Backward Oracle Matching algorithm.\\n\\n\")\n\t\t}\n\t\tbom(s, pattern)\n\t} else if commandLineInput == false { // case of file line input\n\t\tpatFile, err := ioutil.ReadFile(\"pattern.txt\")\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\ttextFile, err := ioutil.ReadFile(\"text.txt\")\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tif len(patFile) > len(textFile) {\n\t\t\tlog.Fatal(\"Pattern  is longer than text!\")\n\t\t}\n\t\tif debugMode == true {\n\t\t\tfmt.Printf(\"\\nRunning: Backward Oracle Matching alghoritm.\\n\\n\")\n\t\t\tfmt.Printf(\"Search word (%d chars long): %q.\\n\", len(patFile), patFile)\n\t\t\tfmt.Printf(\"Text        (%d chars long): %q.\\n\\n\", len(textFile), textFile)\n\t\t} else {\n\t\t\tfmt.Printf(\"\\nRunning: Backward Oracle Matching alghoritm.\\n\\n\")\n\t\t}\n\t\tbom(string(textFile), string(patFile))\n\t}\n}\n\n// Function bom performing the Backward Oracle Matching algorithm.\n// Prints whether the word/pattern was found + positions of possible multiple occurrences\n// or that the word was not found.\nfunc bom(t, p string) {\n\tstartTime := time.Now()\n\tn, m := len(t), len(p)\n\tvar current, j, pos int\n\toracle := oracleOnLine(reverse(p))\n\toccurences := make([]int, len(t))\n\tcurrentOcc := 0\n\tpos = 0\n\tif debugMode == true {\n\t\tfmt.Printf(\"\\n\\nWe are reading backwards in %q, searching for %q\\n\\nat position %d:\\n\", t, p, pos+m-1)\n\t}\n\tfor pos <= n-m {\n\t\tcurrent = 0 //initial state of the oracle\n\t\tj = m\n\t\tfor j > 0 && stateExists(current, oracle) {\n\t\t\tif debugMode == true {\n\t\t\t\tprettyPrint(current, j, n, pos, t, oracle)\n\t\t\t}\n\t\t\tcurrent = getTransition(current, t[pos+j-1], oracle)\n\t\t\tj--\n\t\t}\n\t\tif stateExists(current, oracle) {\n\t\t\tif debugMode == true {\n\t\t\t\tfmt.Printf(\" We got an occurence!\")\n\t\t\t}\n\t\t\toccurences[currentOcc] = pos\n\t\t\tcurrentOcc++\n\t\t}\n\t\tpos = pos + j + 1\n\t\tif pos+m-1 < len(t) {\n\t\t\tif debugMode == true {\n\t\t\t\tfmt.Printf(\"\\n\\nposition %d:\\n\", pos+m-1)\n\t\t\t}\n\t\t}\n\t}\n\telapsed := time.Since(startTime)\n\tfmt.Printf(\"\\n\\nElapsed %f secs\\n\", elapsed.Seconds())\n\tfmt.Printf(\"\\n\\n\")\n\tif currentOcc > 0 {\n\t\tfmt.Printf(\"Word %q was found %d times at positions: \", p, currentOcc)\n\t\tfor k := 0; k < currentOcc-1; k++ {\n\t\t\tfmt.Printf(\"%d, \", occurences[k])\n\t\t}\n\t\tfmt.Printf(\"%d\", occurences[currentOcc-1])\n\t\tfmt.Printf(\".\\n\")\n\t}\n\tif currentOcc == 0 {\n\t\tfmt.Printf(\"\\nWord was not found.\\n\")\n\t}\n\treturn\n}\n\n// Construction of the factor oracle automaton for a word p.\nfunc oracleOnLine(p string) (oracle map[int]map[uint8]int) {\n\tif debugMode == true {\n\t\tfmt.Printf(\"Oracle construction: \\n\")\n\t}\n\toracle = make(map[int]map[uint8]int)\n\tsupply := make([]int, len(p)+2) // supply function\n\tcreateNewState(0, oracle)\n\tsupply[0] = -1\n\tvar orP string\n\tfor j := 0; j < len(p); j++ {\n\t\toracle, orP = oracleAddLetter(oracle, supply, orP, p[j])\n\t}\n\treturn oracle\n}\n\n// Adds one letter to the oracle.\nfunc oracleAddLetter(oracle map[int]map[uint8]int, supply []int, orP string, o uint8) (oracleToReturn map[int]map[uint8]int, orPToReturn string) {\n\tm := len(orP)\n\tvar s int\n\tcreateNewState(m+1, oracle)\n\tcreateTransition(m, o, m+1, oracle)\n\tk := supply[m]\n\tfor k > -1 && getTransition(k, o, oracle) == -1 {\n\t\tcreateTransition(k, o, m+1, oracle)\n\t\tk = supply[k]\n\t}\n\tif k == -1 {\n\t\ts = 0\n\t} else {\n\t\ts = getTransition(k, o, oracle)\n\t}\n\tsupply[m+1] = s\n\treturn oracle, orP + string(o)\n}\n\n// Function that takes a single string and reverses it.\n// @author 'Walter' http://stackoverflow.com/a/10043083\nfunc reverse(s string) string {\n\tl := len(s)\n\tm := make([]rune, l)\n\tfor _, c := range s {\n\t\tl--\n\t\tm[l] = c\n\t}\n\treturn string(m)\n}\n\n// Automaton function for creating a new state.\nfunc createNewState(state int, at map[int]map[uint8]int) {\n\tat[state] = make(map[uint8]int)\n\tif debugMode == true {\n\t\tfmt.Printf(\"\\ncreated state %d\", state)\n\t}\n}\n\n// Creates a transition for function σ(state,letter) = end.\nfunc createTransition(fromState int, overChar uint8, toState int, at map[int]map[uint8]int) {\n\tat[fromState][overChar] = toState\n\tif debugMode == true {\n\t\tfmt.Printf(\"\\n    σ(%d,%c)=%d;\", fromState, overChar, toState)\n\t}\n}\n\n// Returns ending state for transition σ(fromState,overChar), -1 if there is none.\nfunc getTransition(fromState int, overChar uint8, at map[int]map[uint8]int) (toState int) {\n\tif !stateExists(fromState, at) {\n\t\treturn -1\n\t}\n\ttoState, ok := at[fromState][overChar]\n\tif ok == false {\n\t\treturn -1\n\t}\n\treturn toState\n}\n\n// Checks if state exists. Returns true if it does, false otherwise.\nfunc stateExists(state int, at map[int]map[uint8]int) bool {\n\t_, ok := at[state]\n\tif !ok || state == -1 || at[state] == nil {\n\t\treturn false\n\t}\n\treturn true\n}\n\n// Just some printing of extra information about what the algorithm does.\nfunc prettyPrint(current int, j int, n int, pos int, t string, oracle map[int]map[uint8]int) {\n\tif current == 0 && !(getTransition(current, t[pos+j-1], oracle) == -1) {\n\t\tfmt.Printf(\"\\n -->(%d)---(%c)--->(%d)\", current, t[pos+j-1], getTransition(current, t[pos+j-1], oracle))\n\t} else if getTransition(current, t[pos+j-1], oracle) == -1 && current != 0 {\n\t\tfmt.Printf(\"\\n    (%d)---(%c)       \", current, t[pos+j-1])\n\t} else if getTransition(current, t[pos+j-1], oracle) == -1 && current == 0 {\n\t\tfmt.Printf(\"\\n -->(%d)---(%c)       \", current, t[pos+j-1])\n\t} else {\n\t\tfmt.Printf(\"\\n    (%d)---(%c)--->(%d)\", current, t[pos+j-1], getTransition(current, t[pos+j-1], oracle))\n\t}\n\tfmt.Printf(\" \")\n\tfor a := 0; a < pos+j-1; a++ {\n\t\tfmt.Printf(\"%c\", t[a])\n\t}\n\tif getTransition(current, t[pos+j-1], oracle) == -1 {\n\t\tfmt.Printf(\"[%c]\", t[pos+j-1])\n\t} else {\n\t\tfmt.Printf(\"[%c]\", t[pos+j-1])\n\t}\n\tfor a := pos + j; a < n; a++ {\n\t\tfmt.Printf(\"%c\", t[a])\n\t}\n\tif getTransition(current, t[pos+j-1], oracle) == -1 {\n\t\tfmt.Printf(\" FAIL on the character[%c]\", t[pos+j-1])\n\t}\n}\n","index":110},{"title":"Horspool","category":"single-string-matching","id":"horspool_single-string-matching","algorithm":"package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n)\n\n// User defined.\n// Set to true to read input from two command line arguments\n// Set to false to read input from two files \"pattern.txt\" and \"text.txt\"\nconst commandLineInput bool = false\n\n// Implementation of Boyer-Moore-Horspool algorithm (Suffix based approach).\n// Requires either a two command line arguments separated by a single space,\n// or two files in the same folder: \"pattern.txt\" containing the string to\n// be searched for, \"text.txt\" containing the text to be searched in.\nfunc main() {\n\tif commandLineInput == true { // case of command line input\n\t\targs := os.Args\n\t\tif len(args) <= 2 {\n\t\t\tlog.Fatal(\"Not enough arguments. Two string arguments separated by spaces are required!\")\n\t\t}\n\t\tpattern := args[1]\n\t\ts := args[2]\n\t\tfor i := 3; i < len(args); i++ {\n\t\t\ts = s + \" \" + args[i]\n\t\t}\n\t\tif len(args[1]) > len(s) {\n\t\t\tlog.Fatal(\"Pattern  is longer than text!\")\n\t\t}\n\t\tfmt.Printf(\"\\nRunning: Horspool algorithm.\\n\\n\")\n\t\tfmt.Printf(\"Search word (%d chars long): %q.\\n\", len(args[1]), pattern)\n\t\tfmt.Printf(\"Text        (%d chars long): %q.\\n\\n\", len(s), s)\n\t\thorspool(s, pattern)\n\t} else if commandLineInput == false { // case of file line input\n\t\tpatFile, err := ioutil.ReadFile(\"pattern.txt\")\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\ttextFile, err := ioutil.ReadFile(\"text.txt\")\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tif len(patFile) > len(textFile) {\n\t\t\tlog.Fatal(\"Pattern  is longer than text!\")\n\t\t}\n\t\tfmt.Printf(\"\\nRunning: Horspool algorithm.\\n\\n\")\n\t\tfmt.Printf(\"Search word (%d chars long): %q.\\n\", len(patFile), patFile)\n\t\tfmt.Printf(\"Text        (%d chars long): %q.\\n\\n\", len(textFile), textFile)\n\t\thorspool(string(textFile), string(patFile))\n\t}\n}\n\n// Function horspool performing the Horspool algorithm.\n// Prints whether the word/pattern was found and on what position in the text or not.\nfunc horspool(t, p string) {\n\tm, n, c, pos := len(p), len(t), 0, 0\n\t//Perprocessing\n\td := preprocess(t, p)\n\t//Map output\n\tfmt.Printf(\"Precomputed shifts per symbol: \")\n\tfor key, value := range d {\n\t\tfmt.Printf(\"%c:%d; \", key, value)\n\t}\n\tfmt.Println()\n\t//Searching\n\tfor pos <= n-m {\n\t\tj := m\n\t\tif t[pos+j-1] != p[j-1] {\n\t\t\tfmt.Printf(\"\\n   comparing characters %c %c at positions %d %d\", t[pos+j-1], p[j-1], pos+j-1, j-1)\n\t\t\tc++\n\t\t}\n\t\tfor j > 0 && t[pos+j-1] == p[j-1] {\n\t\t\tfmt.Printf(\"\\n   comparing characters %c %c at positions %d %d\", t[pos+j-1], p[j-1], pos+j-1, j-1)\n\t\t\tc++\n\t\t\tfmt.Printf(\" - match\")\n\t\t\tj--\n\t\t}\n\t\tif j == 0 {\n\t\t\tfmt.Printf(\"\\n\\nWord %q was found at position %d in %q. \\n%d comparisons were done.\", p, pos, t, c)\n\t\t\treturn\n\t\t}\n\t\tpos = pos + d[t[pos+m]]\n\t}\n\tfmt.Printf(\"\\n\\nWord was not found.\\n%d comparisons were done.\", c)\n\treturn\n}\n\n// Function that pre-computes map with Key: uint8 (char) Value: int.\n// Values determine safe shifting of search window.\nfunc preprocess(t, p string) (d map[uint8]int) {\n\td = make(map[uint8]int)\n\tfor i := 0; i < len(t); i++ {\n\t\td[t[i]] = len(p)\n\t}\n\tfor i := 0; i < len(p); i++ {\n\t\td[p[i]] = len(p) - i\n\t}\n\treturn d\n}\n","index":111},{"title":"Kmp","category":"single-string-matching","id":"kmp","index":112},{"title":"Kmp","category":"kmp","id":"kmp_kmp","algorithm":"package kmp\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n)\n\n// User defined.\n// Set to true to read input from two command line arguments\n// Set to false to read input from two files \"pattern.txt\" and \"text.txt\"\nconst isTakingInputFromCommandLine bool = true\nconst notFoundPosition int = -1\n\ntype result struct {\n\tresultPosition     int\n\tnumberOfComparison int\n}\n\n// Implementation of Knuth-Morris-Pratt algorithm (Prefix based approach).\n// Requires either a two command line arguments separated by a single space,\n// or two files in the same folder: \"pattern.txt\" containing the string to\n// be searched for, \"text.txt\" containing the text to be searched in.\nfunc main() {\n\tvar text string\n\tvar word string\n\n\tif isTakingInputFromCommandLine { // case of command line input\n\t\targs := os.Args\n\t\tif len(args) <= 2 {\n\t\t\tlog.Fatal(\"Not enough arguments. Two string arguments separated by spaces are required!\")\n\t\t}\n\t\tword = args[1]\n\t\ttext = args[2]\n\t\tfor i := 3; i < len(args); i++ {\n\t\t\ttext = text + \" \" + args[i]\n\t\t}\n\t} else { // case of file input\n\t\tpatFile, err := ioutil.ReadFile(\"../pattern.txt\")\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\ttextFile, err := ioutil.ReadFile(\"../text.txt\")\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\ttext = string(textFile)\n\t\tword = string(patFile)\n\t}\n\n\tif len(word) > len(text) {\n\t\tlog.Fatal(\"Pattern is longer than text!\")\n\t}\n\tfmt.Printf(\"\\nRunning: Knuth-Morris-Pratt algorithm.\\n\\n\")\n\tfmt.Printf(\"Search word (%d chars long): %q.\\n\", len(word), word)\n\tfmt.Printf(\"Text        (%d chars long): %q.\\n\\n\", len(text), text)\n\n\tr := kmp(text, word)\n\tif r.resultPosition == notFoundPosition {\n\t\tfmt.Printf(\"\\n\\nWord was not found.\\n%d comparisons were done.\", r.numberOfComparison)\n\t} else {\n\t\tfmt.Printf(\"\\n\\nWord %q was found at position %d in %q. \\n%d comparisons were done.\", word,\n\t\t\tr.resultPosition, text, r.numberOfComparison)\n\t}\n}\n\n// Function kmp performing the Knuth-Morris-Pratt algorithm.\n// Prints whether the word/pattern was found and on what position in the text or not.\n// m - current match in text, i - current character in w, c - amount of comparisons.\nfunc kmp(text string, word string) result {\n\tm, i, c := 0, 0, 0\n\tt := kmp_table(word)\n\tfor m+i < len(text) {\n\t\tfmt.Printf(\"\\n   comparing characters %c %c at positions %d %d\", text[m+i], word[i], m+i, i)\n\t\tc++\n\t\tif word[i] == text[m+i] {\n\t\t\tfmt.Printf(\" - match\")\n\t\t\tif i == len(word)-1 {\n\t\t\t\treturn result{\n\t\t\t\t\tm, c,\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++\n\t\t} else {\n\t\t\tm = m + i - t[i]\n\t\t\tif t[i] > -1 {\n\t\t\t\ti = t[i]\n\t\t\t} else {\n\t\t\t\ti = 0\n\t\t\t}\n\t\t}\n\t}\n\treturn result{notFoundPosition,\n\t\tc,\n\t}\n}\n\n// Table building alghoritm.\n// Takes word to be analyzed and table to be filled.\nfunc kmp_table(word string) (t []int) {\n\tt = make([]int, len(word))\n\tpos, cnd := 2, 0\n\tt[0], t[1] = -1, 0\n\tfor pos < len(word) {\n\t\tif word[pos-1] == word[cnd] {\n\t\t\tcnd++\n\t\t\tt[pos] = cnd\n\t\t\tpos++\n\t\t} else if cnd > 0 {\n\t\t\tcnd = t[cnd]\n\t\t} else {\n\t\t\tt[pos] = 0\n\t\t\tpos++\n\t\t}\n\t}\n\treturn t\n}\n","index":113},{"title":"Kmp Test","category":"kmp","id":"kmp_test_kmp","algorithm":"package kmp\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nvar testCases = []struct {\n\tname     string\n\tword     string\n\ttext     string\n\texpected result\n}{\n\t{\n\t\t\"String comparison on single pattern match\",\n\t\t\"announce\",\n\t\t\"CPM_annual_conference_announce\",\n\t\tresult{\n\t\t\t22,\n\t\t\t32,\n\t\t},\n\t},\n\t{\n\t\t\"String comparison on multiple pattern match\",\n\t\t\"AABA\",\n\t\t\"AABAACAADAABAABA\",\n\t\tresult{\n\t\t\t0,\n\t\t\t4,\n\t\t},\n\t},\n\t{\n\t\t\"String comparison with not found pattern\",\n\t\t\"AABC\",\n\t\t\"AABAACAADAABAABA\",\n\t\tresult{\n\t\t\t-1,\n\t\t\t23,\n\t\t},\n\t},\n}\n\nfunc TestKMP(t *testing.T) {\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tactual := kmp(tc.text, tc.word)\n\t\t\tif !reflect.DeepEqual(actual, tc.expected) {\n\t\t\t\tt.Errorf(\"Expected matches for pattern '%s' for string '%s' are: %v steps at position %v, but actual matches are: %v steps at position %v\",\n\t\t\t\t\ttc.word, tc.text, tc.expected.numberOfComparison, tc.expected.resultPosition, actual.numberOfComparison, actual.resultPosition)\n\t\t\t}\n\t\t})\n\t}\n}\n","index":114}]