[{"title":"Javascript-master","category":".","id":"Javascript-master"},{"title":"Backtracking","category":null,"id":"Backtracking","index":0},{"title":"Knight Tour","category":"Backtracking","id":"KnightTour_Backtracking","algorithm":"// Wikipedia: https://en.wikipedia.org/wiki/Knight%27s_tour\n\nclass OpenKnightTour {\n  constructor (size) {\n    this.board = new Array(size).fill(0).map(() => new Array(size).fill(0))\n    this.size = size\n  }\n\n  getMoves ([i, j]) {\n    // helper function to get the valid moves of the knight from the current position\n    const moves = [\n      [i + 2, j - 1],\n      [i + 2, j + 1],\n      [i - 2, j - 1],\n      [i - 2, j + 1],\n      [i + 1, j - 2],\n      [i + 1, j + 2],\n      [i - 1, j - 2],\n      [i - 1, j + 2]\n    ]\n\n    return moves.filter(([y, x]) => y >= 0 && y < this.size && x >= 0 && x < this.size)\n  }\n\n  isComplete () {\n    // helper function to check if the board is complete\n    return !this.board.map(row => row.includes(0)).includes(true)\n  }\n\n  solve () {\n    // function to find the solution for the given board\n    for (let i = 0; i < this.size; i++) {\n      for (let j = 0; j < this.size; j++) {\n        if (this.solveHelper([i, j], 0)) return true\n      }\n    }\n    return false\n  }\n\n  solveHelper ([i, j], curr) {\n    // helper function for the main computation\n    if (this.isComplete()) return true\n\n    for (const [y, x] of this.getMoves([i, j])) {\n      if (this.board[y][x] === 0) {\n        this.board[y][x] = curr + 1\n        if (this.solveHelper([y, x], curr + 1)) return true\n        // backtracking\n        this.board[y][x] = 0\n      }\n    }\n    return false\n  }\n\n  printBoard () {\n    // utility function to display the board\n    for (const row of this.board) {\n      let string = ''\n      for (const elem of row) {\n        string += elem + '\\t'\n      }\n      console.log(string)\n    }\n  }\n}\n\nfunction main () {\n  const board = new OpenKnightTour(5)\n\n  board.printBoard()\n  console.log('\\n')\n\n  board.solve()\n\n  board.printBoard()\n}\n\nmain()\n","index":1},{"title":"N Queen","category":"Backtracking","id":"NQueen_Backtracking","algorithm":"class NQueen {\n  constructor (size) {\n    this.board = new Array(size).fill('.').map(() => new Array(size).fill('.'))\n    this.size = size\n  }\n\n  isValid ([row, col]) {\n    // function to check if the placement of the queen in the given location is valid\n\n    // checking the left of the current row\n    for (let i = 0; i < col; i++) {\n      if (this.board[row][i] === 'Q') return false\n    }\n\n    // checking the upper left diagonal\n    for (let i = row, j = col; i >= 0 && j >= 0; i--, j--) {\n      if (this.board[i][j] === 'Q') return false\n    }\n\n    // checking the lower left diagonal\n    for (let i = row, j = col; j >= 0 && i < this.size; i++, j--) {\n      if (this.board[i][j] === 'Q') return false\n    }\n\n    return true\n  }\n\n  solve (col = 0) {\n    // function to solve the board\n    if (col >= this.size) { return true }\n\n    for (let i = 0; i < this.size; i++) {\n      if (this.isValid([i, col])) {\n        this.board[i][col] = 'Q'\n\n        if (this.solve(col + 1)) { return true }\n\n        // backtracking\n        this.board[i][col] = '.'\n      }\n    }\n\n    return false\n  }\n\n  printBoard () {\n    // utility function to display the board\n    for (const row of this.board) {\n      console.log(...row)\n    }\n  }\n}\n\nfunction main () {\n  const board = new NQueen(8)\n\n  board.printBoard()\n  console.log('\\n')\n\n  board.solve()\n\n  board.printBoard()\n}\n\nmain()\n","index":2},{"title":"Sudoku","category":"Backtracking","id":"Sudoku_Backtracking","algorithm":"class Sudoku {\n  // Sudoku Class to hold the board and related functions\n  constructor (board) {\n    this.board = board\n  }\n\n  findEmptyCell () {\n    // Find a empty cell in the board (returns [-1, -1] if all cells are filled)\n    for (let i = 0; i < 9; i++) {\n      for (let j = 0; j < 9; j++) {\n        if (this.board[i][j] === 0) return [i, j]\n      }\n    }\n    return [-1, -1]\n  }\n\n  check ([y, x], value) {\n    // checks if the value to be added in the board is an acceptable value for the cell\n\n    // checking through the row\n    for (let i = 0; i < 9; i++) {\n      if (this.board[i][x] === value) return false\n    }\n    // checking through the column\n    for (let i = 0; i < 9; i++) {\n      if (this.board[y][i] === value) return false\n    }\n\n    // checking through the 3x3 block of the cell\n    const secRow = Math.floor(y / 3)\n    const secCol = Math.floor(x / 3)\n    for (let i = (secRow * 3); i < ((secRow * 3) + 3); i++) {\n      for (let j = (secCol * 3); j < ((secCol * 3) + 3); j++) {\n        if (y !== i && x !== j && this.board[i][j] === value) return false\n      }\n    }\n\n    return true\n  }\n\n  solve () {\n    const [y, x] = this.findEmptyCell()\n\n    // checking if the board is complete\n    if (y === -1 && x === -1) return true\n\n    for (let val = 1; val < 10; val++) {\n      if (this.check([y, x], val)) {\n        this.board[y][x] = val\n        if (this.solve()) return true\n        // backtracking if the board cannot be solved using current configuration\n        this.board[y][x] = 0\n      }\n    }\n    // returning false the board cannot be solved using current configuration\n    return false\n  }\n\n  getSection (row, [start, end]) {\n    return this.board[row].slice(start, end)\n  }\n\n  printBoard () {\n    // helper function to display board\n    for (let i = 0; i < 9; i++) {\n      if (i % 3 === 0 && i !== 0) console.log('- - - - - - - - - - - -')\n      console.log(\n        ...this.getSection(i, [0, 3]), ' | ',\n        ...this.getSection(i, [3, 6]), ' | ',\n        ...this.getSection(i, [6, 9]))\n    }\n  }\n}\n\nfunction main () {\n  // main function with an example\n  const sudokuBoard = new Sudoku([\n    [3, 0, 6, 5, 0, 8, 4, 0, 0],\n    [5, 2, 0, 0, 0, 0, 0, 0, 0],\n    [0, 8, 7, 0, 0, 0, 0, 3, 1],\n    [0, 0, 3, 0, 1, 0, 0, 8, 0],\n    [9, 0, 0, 8, 6, 3, 0, 0, 5],\n    [0, 5, 0, 0, 9, 0, 6, 0, 0],\n    [1, 3, 0, 0, 0, 0, 2, 5, 0],\n    [0, 0, 0, 0, 0, 0, 0, 7, 4],\n    [0, 0, 5, 2, 0, 6, 3, 0, 0]\n  ])\n\n  sudokuBoard.printBoard()\n\n  console.log('\\n')\n  sudokuBoard.solve()\n\n  sudokuBoard.printBoard()\n}\n\nmain()\n","index":3},{"title":"Cache","category":null,"id":"Cache","index":4},{"title":"L F U Cache","category":"Cache","id":"LFUCache_Cache","algorithm":"class DoubleLinkedListNode {\n  // Double Linked List Node built specifically for LFU Cache\n  constructor (key, val) {\n    this.key = key\n    this.val = val\n    this.freq = 0\n    this.next = null\n    this.prev = null\n  }\n}\n\nclass DoubleLinkedList {\n  // Double Linked List built specifically for LFU Cache\n  constructor () {\n    this.head = new DoubleLinkedListNode(null, null)\n    this.rear = new DoubleLinkedListNode(null, null)\n    this.head.next = this.rear\n    this.rear.prev = this.head\n  }\n\n  _positionNode (node) {\n    // Helper function to position a node based on the frequency of the key\n    while (node.prev.key && node.prev.freq > node.freq) {\n      const node1 = node\n      const node2 = node.prev\n      node1.prev = node2.prev\n      node2.next = node1.prev\n      node1.next = node2\n      node2.prev = node1\n    }\n  }\n\n  add (node) {\n    // Adds the given node to the end of the list (before rear) and positions it based on frequency\n    const temp = this.rear.prev\n    temp.next = node\n    node.prev = temp\n    this.rear.prev = node\n    node.next = this.rear\n    this._positionNode(node)\n  }\n\n  remove (node) {\n    // Removes and returns the given node from the list\n    const tempLast = node.prev\n    const tempNext = node.next\n    node.prev = null\n    node.next = null\n    tempLast.next = tempNext\n    tempNext.prev = tempLast\n\n    return node\n  }\n}\n\nclass LFUCache {\n  // LFU Cache to store a given capacity of data\n  // The Double Linked List is used to store the order of deletion from the cache\n  // The rear.prev holds the most frequently used key and the head.next holds the least used key\n  // When the number of elements reaches the capacity, the least frequently used item is removed before adding the next key\n  constructor (capacity) {\n    this.list = new DoubleLinkedList()\n    this.capacity = capacity\n    this.numKeys = 0\n    this.hits = 0\n    this.miss = 0\n    this.cache = {}\n  }\n\n  cacheInfo () {\n    // Return the details for the cache instance [hits, misses, capacity, current_size]\n    return `CacheInfo(hits=${this.hits}, misses=${this.miss}, capacity=${this.capacity}, current size=${this.numKeys})`\n  }\n\n  set (key, value) {\n    // Sets the value for the input key and updates the Double Linked List\n    if (!(key in this.cache)) {\n      if (this.numKeys >= this.capacity) {\n        const keyToDelete = this.list.head.next.key\n        this.list.remove(this.cache[keyToDelete])\n        delete this.cache[keyToDelete]\n        this.numKeys -= 1\n      }\n      this.cache[key] = new DoubleLinkedListNode(key, value)\n      this.list.add(this.cache[key])\n      this.numKeys += 1\n    } else {\n      const node = this.list.remove(this.cache[key])\n      node.val = value\n      this.list.add(node)\n    }\n  }\n\n  get (key) {\n    // Returns the value for the input key and updates the Double Linked List. Returns null if key is not present in cache\n    if (key in this.cache) {\n      this.hits += 1\n      this.list.add(this.list.remove(this.cache[key]))\n      return this.cache[key].val\n    }\n    this.miss += 1\n    return null\n  }\n}\n\nfunction main () {\n  // Example 1 (Small Cache)\n  const cache = new LFUCache(2)\n  cache.set(1, 1)\n  cache.set(2, 2)\n\n  console.log(cache.get(1))\n\n  cache.set(3, 3)\n\n  console.log(cache.get(2)) // cache miss\n\n  cache.set(4, 4)\n\n  console.log(cache.get(1)) // cache miss\n  console.log(cache.get(3))\n  console.log(cache.get(4))\n\n  console.log('Example Cache: ', cache.cacheInfo(), '\\n')\n\n  // Example 2 (Computing Fibonacci Series - 100 terms)\n  function fib (num, cache = null) {\n    if (cache) {\n      const value = cache.get(num)\n      if (value) { return value }\n    }\n    if (num === 1 || num === 2) { return 1 }\n    const result = fib(num - 1, cache) + fib(num - 2, cache)\n    if (cache) { cache.set(num, result) }\n    return result\n  }\n\n  const fibCache = new LFUCache(100)\n  for (let i = 1; i <= 100; i++) { fib(i, fibCache) }\n  console.log('Fibonacci Series Cache: ', fibCache.cacheInfo(), '\\n')\n}\n\nmain()\n","index":5},{"title":"L R U Cache","category":"Cache","id":"LRUCache_Cache","algorithm":"class DoubleLinkedListNode {\n  // Double Linked List Node built specifically for LRU Cache\n  constructor (key, val) {\n    this.key = key\n    this.val = val\n    this.next = null\n    this.prev = null\n  }\n}\n\nclass DoubleLinkedList {\n  // Double Linked List built specifically for LRU Cache\n  constructor () {\n    this.head = new DoubleLinkedListNode(null, null)\n    this.rear = new DoubleLinkedListNode(null, null)\n    this.head.next = this.rear\n    this.rear.prev = this.head\n  }\n\n  add (node) {\n    // Adds the given node to the end of the list (before rear)\n    const temp = this.rear.prev\n    temp.next = node\n    node.prev = temp\n    this.rear.prev = node\n    node.next = this.rear\n  }\n\n  remove (node) {\n    // Removes and returns the given node from the list\n    const tempLast = node.prev\n    const tempNext = node.next\n    node.prev = null\n    node.next = null\n    tempLast.next = tempNext\n    tempNext.prev = tempLast\n\n    return node\n  }\n}\n\nclass LRUCache {\n  // LRU Cache to store a given capacity of data\n  constructor (capacity) {\n    this.list = new DoubleLinkedList()\n    this.capacity = capacity\n    this.numKeys = 0\n    this.hits = 0\n    this.miss = 0\n    this.cache = {}\n  }\n\n  cacheInfo () {\n    // Return the details for the cache instance [hits, misses, capacity, current_size]\n    return `CacheInfo(hits=${this.hits}, misses=${this.miss}, capacity=${this.capacity}, current size=${this.numKeys})`\n  }\n\n  set (key, value) {\n    // Sets the value for the input key and updates the Double Linked List\n    if (!(key in this.cache)) {\n      if (this.numKeys >= this.capacity) {\n        const keyToDelete = this.list.head.next.key\n        this.list.remove(this.cache[keyToDelete])\n        delete this.cache[keyToDelete]\n        this.numKeys -= 1\n      }\n      this.cache[key] = new DoubleLinkedListNode(key, value)\n      this.list.add(this.cache[key])\n      this.numKeys += 1\n    } else {\n      const node = this.list.remove(this.cache[key])\n      node.val = value\n      this.list.add(node)\n    }\n  }\n\n  get (key) {\n    // Returns the value for the input key and updates the Double Linked List. Returns null if key is not present in cache\n    if (key in this.cache) {\n      this.hits += 1\n      this.list.add(this.list.remove(this.cache[key]))\n      return this.cache[key].val\n    }\n    this.miss += 1\n    return null\n  }\n}\n\nfunction main () {\n  // Example 1 (Small Cache)\n  const cache = new LRUCache(2)\n  cache.set(1, 1)\n  cache.set(2, 2)\n\n  console.log(cache.get(1))\n\n  cache.set(3, 3)\n\n  console.log(cache.get(2)) // cache miss\n\n  cache.set(4, 4)\n\n  console.log(cache.get(1)) // cache miss\n  console.log(cache.get(3))\n  console.log(cache.get(4))\n\n  console.log('Example Cache: ', cache.cacheInfo(), '\\n')\n\n  // Example 2 (Computing Fibonacci Series - 100 terms)\n  function fib (num, cache = null) {\n    if (cache) {\n      const value = cache.get(num)\n      if (value) { return value }\n    }\n    if (num === 1 || num === 2) { return 1 }\n    const result = fib(num - 1, cache) + fib(num - 2, cache)\n    if (cache) { cache.set(num, result) }\n    return result\n  }\n\n  const fibCache = new LRUCache(100)\n  for (let i = 1; i <= 100; i++) { fib(i, fibCache) }\n  console.log('Fibonacci Series Cache: ', fibCache.cacheInfo(), '\\n')\n}\n\nmain()\n","index":6},{"title":"Ciphers","category":null,"id":"Ciphers","index":7},{"title":"Caesars Cipher","category":"Ciphers","id":"CaesarsCipher_Ciphers","algorithm":"/**\n * Caesar's Cipher - also known as the ROT13 Cipher is when\n * a letter is replaced by the one that is 13 spaces away\n * from it in the alphabet. If the letter is in the first half\n * of the alphabet we add 13, if it's in the latter half we\n * subtract 13 from the character code value.\n */\n\n/**\n * Decrypt a ROT13 cipher\n * @param {String} str - string to be decrypted\n * @return {String} decrypted string\n */\nfunction rot13 (str) {\n  const response = []\n  const strLength = str.length\n\n  for (let i = 0; i < strLength; i++) {\n    const char = str.charCodeAt(i)\n\n    if (char < 65 || (char > 90 && char < 97) || char > 122) {\n      response.push(str.charAt(i))\n    } else if ((char > 77 && char <= 90) || (char > 109 && char <= 122)) {\n      response.push(String.fromCharCode(str.charCodeAt(i) - 13))\n    } else {\n      response.push(String.fromCharCode(str.charCodeAt(i) + 13))\n    }\n  }\n  return response.join('')\n}\n\n// Caesars Cipher Example\nconst encryptedString = 'Uryyb Jbeyq'\nconst decryptedString = rot13(encryptedString)\n\nconsole.log(decryptedString) // Hello World\n","index":8},{"title":"Key Finder","category":"Ciphers","id":"KeyFinder_Ciphers","algorithm":"/******************************************************\n Find and retrieve the encryption key automatically\n Note: This is a draft version, please help to modify, Thanks!\n ******************************************************/\nfunction keyFinder (str) { // str is used to get the input of encrypted string\n  const wordBank = [\n    'I ',\n    'You ',\n    'We ',\n    'They ',\n    'He ',\n    'She ',\n    'It ',\n    ' the ',\n    'The ',\n    ' of ',\n    ' is ',\n    'Is ',\n    ' am ',\n    'Am ',\n    ' are ',\n    'Are ',\n    ' have ',\n    'Have ',\n    ' has ',\n    'Has ',\n    ' may ',\n    'May ',\n    ' be ',\n    'Be ']\n  // let wordbankelementCounter = 0;\n  // let key = 0; // return zero means the key can not be found\n  const inStr = str.toString() // convert the input to String\n  let outStr = '' // store the output value\n  let outStrElement = '' // temporary store the word inside the outStr, it is used for comparison\n  for (let k = 0; k < 26; k++) { // try the number of key shifted, the sum of character from a-z or A-Z is 26\n    outStr = caesarCipherEncodeAndDecodeEngine(inStr, k) // use the encryption engine to decrypt the input string\n\n    // loop through the whole input string\n    for (let s = 0; s < outStr.length; s++) {\n      for (let i = 0; i < wordBank.length; i++) {\n        // initialize the outStrElement which is a temp output string for comparison,\n        // use a loop to find the next digit of wordBank element and compare with outStr's digit\n        for (let w = 0; w < wordBank[i].length; w++) {\n          outStrElement += outStr[s + w]\n        }\n\n        // console.log( k + outStrElement + wordBank[i] );//debug\n\n        // this part need to be optimize with the calculation of the number of occurrence of word's probabilities\n        // linked list will be used in the next stage of development to calculate the number of occurace of the key\n        if (wordBank[i] === outStrElement) {\n          return k // return the key number if founded\n        }\n\n        outStrElement = '' // reset the temp word\n      } // end for ( let i=0; i < wordBank.length; i++)\n    }\n  }\n  return 0 // return 0 if found nothing\n}\n\n/* this sub-function is used to assist the keyFinder to find the key */\nfunction caesarCipherEncodeAndDecodeEngine (inStr, numShifted) {\n  const shiftNum = numShifted\n  let charCode = 0\n  let outStr = ''\n  let shiftedCharCode = 0\n  let result = 0\n\n  for (let i = 0; i < inStr.length; i++) {\n    charCode = inStr[i].charCodeAt()\n    shiftedCharCode = charCode + shiftNum\n    result = charCode\n\n    if ((charCode >= 48 && charCode <= 57)) {\n      if (shiftedCharCode < 48) {\n        let diff = Math.abs(48 - 1 - shiftedCharCode) % 10\n\n        while (diff >= 10) {\n          diff = diff % 10\n        }\n        document.getElementById('diffID').innerHTML = diff\n\n        shiftedCharCode = 57 - diff\n\n        result = shiftedCharCode\n      } else if (shiftedCharCode >= 48 && shiftedCharCode <= 57) {\n        result = shiftedCharCode\n      } else if (shiftedCharCode > 57) {\n        let diff = Math.abs(57 + 1 - shiftedCharCode) % 10\n\n        while (diff >= 10) {\n          diff = diff % 10\n        }\n        document.getElementById('diffID').innerHTML = diff\n\n        shiftedCharCode = 48 + diff\n\n        result = shiftedCharCode\n      }\n    } else if ((charCode >= 65 && charCode <= 90)) {\n      if (shiftedCharCode <= 64) {\n        let diff = Math.abs(65 - 1 - shiftedCharCode) % 26\n\n        while ((diff % 26) >= 26) {\n          diff = diff % 26\n        }\n        shiftedCharCode = 90 - diff\n        result = shiftedCharCode\n      } else if (shiftedCharCode >= 65 && shiftedCharCode <= 90) {\n        result = shiftedCharCode\n      } else if (shiftedCharCode > 90) {\n        let diff = Math.abs(shiftedCharCode - 1 - 90) % 26\n\n        while ((diff % 26) >= 26) {\n          diff = diff % 26\n        }\n        shiftedCharCode = 65 + diff\n        result = shiftedCharCode\n      }\n    } else if ((charCode >= 97 && charCode <= 122)) {\n      if (shiftedCharCode <= 96) {\n        let diff = Math.abs(97 - 1 - shiftedCharCode) % 26\n\n        while ((diff % 26) >= 26) {\n          diff = diff % 26\n        }\n        shiftedCharCode = 122 - diff\n        result = shiftedCharCode\n      } else if (shiftedCharCode >= 97 && shiftedCharCode <= 122) {\n        result = shiftedCharCode\n      } else if (shiftedCharCode > 122) {\n        let diff = Math.abs(shiftedCharCode - 1 - 122) % 26\n\n        while ((diff % 26) >= 26) {\n          diff = diff % 26\n        }\n        shiftedCharCode = 97 + diff\n        result = shiftedCharCode\n      }\n    }\n    outStr = outStr + String.fromCharCode(parseInt(result))\n  }\n  return outStr\n}\n\nconsole.log('Testing: ' + keyFinder('test')) // returns 0\n","index":9},{"title":"R O T13","category":"Ciphers","id":"ROT13_Ciphers","algorithm":"/**\n * Transcipher a ROT13 cipher\n * @param  {String} text - string to be encrypted\n * @return {String} - decrypted string\n */\nconst transcipher = (text) => {\n  const originalCharacterList = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'\n  const toBeMappedCharaterList = 'NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm'\n  const index = x => originalCharacterList.indexOf(x)\n  const replace = x => index(x) > -1 ? toBeMappedCharaterList[index(x)] : x\n  return text.split('').map(replace).join('')\n}\n\n(() => {\n  const messageToBeEncrypted = 'The quick brown fox jumps over the lazy dog'\n  console.log(`Original Text = \"${messageToBeEncrypted}\"`)\n  const rot13CipheredText = transcipher(messageToBeEncrypted)\n  console.log(`Ciphered Text = \"${rot13CipheredText}\"`)\n  const rot13DecipheredText = transcipher(rot13CipheredText)\n  console.log(`Deciphered Text = \"${rot13DecipheredText}\"`)\n})()\n","index":10},{"title":"Vigenere Cipher","category":"Ciphers","id":"VigenereCipher_Ciphers","algorithm":"/**\n * Check if the Character is letter or not\n * @param {String} str - character to check\n * @return {object} An array with the character or null if isn't a letter\n */\nfunction isLetter (str) {\n  return str.length === 1 && str.match(/[a-zA-Z]/i)\n}\n\n/**\n * Check if is Uppercase or Lowercase\n * @param {String} character - character to check\n * @return {Boolean} result of the checking\n */\nfunction isUpperCase (character) {\n  if (character === character.toUpperCase()) {\n    return true\n  }\n  if (character === character.toLowerCase()) {\n    return false\n  }\n}\n\n/**\n * Encrypt a Vigenere cipher\n * @param {String} message - string to be encrypted\n * @param {String} key - key for encrypt\n * @return {String} result - encrypted string\n */\nfunction encrypt (message, key) {\n  let result = ''\n\n  for (let i = 0, j = 0; i < message.length; i++) {\n    const c = message.charAt(i)\n    if (isLetter(c)) {\n      if (isUpperCase(c)) {\n        result += String.fromCharCode((c.charCodeAt(0) + key.toUpperCase().charCodeAt(j) - 2 * 65) % 26 + 65) // A: 65\n      } else {\n        result += String.fromCharCode((c.charCodeAt(0) + key.toLowerCase().charCodeAt(j) - 2 * 97) % 26 + 97) // a: 97\n      }\n    } else {\n      result += c\n    }\n    j = ++j % key.length\n  }\n  return result\n}\n\n/**\n * Decrypt a Vigenere cipher\n * @param {String} message - string to be decrypted\n * @param {String} key - key for decrypt\n * @return {String} result - decrypted string\n */\nfunction decrypt (message, key) {\n  let result = ''\n\n  for (let i = 0, j = 0; i < message.length; i++) {\n    const c = message.charAt(i)\n    if (isLetter(c)) {\n      if (isUpperCase(c)) {\n        result += String.fromCharCode(90 - (25 - (c.charCodeAt(0) - key.toUpperCase().charCodeAt(j))) % 26)\n      } else {\n        result += String.fromCharCode(122 - (25 - (c.charCodeAt(0) - key.toLowerCase().charCodeAt(j))) % 26)\n      }\n    } else {\n      result += c\n    }\n    j = ++j % key.length\n  }\n  return result\n}\n\nconst messageEncrypt = encrypt('Hello World!', 'code')\nconsole.log(messageEncrypt) // \"Jhpnr Yrvng!\"\n\nconst messageDecrypt = decrypt('Jsopq Zstzg!', 'code')\nconsole.log(messageDecrypt) // \"Hello World!\"\n","index":11},{"title":"X O R Cipher","category":"Ciphers","id":"XORCipher_Ciphers","algorithm":"/**\n * The XOR cipher is a type of additive cipher.\n * Each character is bitwise XORed with the key.\n * We loop through the input string, XORing each\n * character with the key.\n */\n\n/**\n * Encrypt using an XOR cipher\n * @param {String} str - String to be encrypted\n * @param {Number} key - key for encryption\n * @return {String} encrypted string\n */\n\nfunction XOR (str, key) {\n  let result = ''\n  for (const elem of str) {\n    result += String.fromCharCode(elem.charCodeAt(0) ^ key)\n  }\n  return result\n}\n\nconst encryptedString = XOR('test string', 32)\nconsole.log('Encrypted: ', encryptedString)\nconst decryptedString = XOR(encryptedString, 32)\nconsole.log('Decrypted: ', decryptedString)\n","index":12},{"title":"Conversions","category":null,"id":"Conversions","index":13},{"title":"Binary To Decimal","category":"Conversions","id":"BinaryToDecimal_Conversions","algorithm":"const binaryToDecimal = (binaryString) => {\n  let decimalNumber = 0\n  const binaryDigits = binaryString.split('').reverse() // Splits the binary number into reversed single digits\n  binaryDigits.forEach((binaryDigit, index) => {\n    decimalNumber += binaryDigit * (Math.pow(2, index)) // Summation of all the decimal converted digits\n  })\n  console.log(`Decimal of ${binaryString} is ${decimalNumber}`)\n  return decimalNumber\n}\n\n(() => {\n  binaryToDecimal('111001')\n  binaryToDecimal('101')\n})()\n","index":14},{"title":"Decimal To Binary","category":"Conversions","id":"DecimalToBinary_Conversions","algorithm":"function decimalToBinary (num) {\n  var bin = []\n  while (num > 0) {\n    bin.unshift(num % 2)\n    num >>= 1 // basically /= 2 without remainder if any\n  }\n  console.log('The decimal in binary is ' + bin.join(''))\n}\n\ndecimalToBinary(2)\ndecimalToBinary(7)\ndecimalToBinary(35)\n","index":15},{"title":"Decimal To Hex","category":"Conversions","id":"DecimalToHex_Conversions","algorithm":"function intToHex (num) {\n  switch (num) {\n    case 10: return 'A'\n    case 11: return 'B'\n    case 12: return 'C'\n    case 13: return 'D'\n    case 14: return 'E'\n    case 15: return 'F'\n  }\n  return num\n}\n\nfunction decimalToHex (num) {\n  const hexOut = []\n  while (num > 15) {\n    hexOut.unshift(intToHex(num % 16))\n    num = Math.floor(num / 16)\n  }\n  return intToHex(num) + hexOut.join('')\n}\n\n// test cases\nconsole.log(decimalToHex(999098) === 'F3EBA')\nconsole.log(decimalToHex(123) === '7B')\n","index":16},{"title":"Decimal To Octal","category":"Conversions","id":"DecimalToOctal_Conversions","algorithm":"function decimalToOctal (num) {\n  let oct = 0\n  let c = 0\n  while (num > 0) {\n    const r = num % 8\n    oct = oct + (r * Math.pow(10, c++))\n    num = Math.floor(num / 8) // basically /= 8 without remainder if any\n  }\n  console.log('The decimal in octal is ' + oct)\n}\n\ndecimalToOctal(2)\ndecimalToOctal(8)\ndecimalToOctal(65)\ndecimalToOctal(216)\ndecimalToOctal(512)\n","index":17},{"title":"Hex To R G B","category":"Conversions","id":"HexToRGB_Conversions","algorithm":"function hexStringToRGB (hexString) {\n  var r = hexString.substring(0, 2)\n  var g = hexString.substring(2, 4)\n  var b = hexString.substring(4, 6)\n\n  r = parseInt(r, 16)\n  g = parseInt(g, 16)\n  b = parseInt(b, 16)\n  var obj = { r, g, b }\n\n  return obj\n}\n\nconsole.log(hexStringToRGB('ffffff'))\n","index":18},{"title":"R G B To Hex","category":"Conversions","id":"RGBToHex_Conversions","algorithm":"function RGBToHex (r, g, b) {\n  if (\n    typeof r !== 'number' ||\n    typeof g !== 'number' ||\n    typeof b !== 'number'\n  ) {\n    throw new TypeError('argument is not a Number')\n  }\n\n  const toHex = n => (n || '0').toString(16).padStart(2, '0')\n\n  return `#${toHex(r)}${toHex(g)}${toHex(b)}`\n}\n\nconsole.log(RGBToHex(255, 255, 255) === '#ffffff')\nconsole.log(RGBToHex(255, 99, 71) === '#ff6347')\n","index":19},{"title":"Roman To Decimal","category":"Conversions","id":"RomanToDecimal_Conversions","algorithm":"var values = {\n  I: 1,\n  V: 5,\n  X: 10,\n  L: 50,\n  C: 100,\n  D: 500,\n  M: 1000\n}\n\nfunction romanToDecimal (romanNumber) {\n  let prev = ' '\n\n  let sum = 0\n\n  let newPrev = 0\n  for (let i = romanNumber.length - 1; i >= 0; i--) {\n    const c = romanNumber.charAt(i)\n\n    if (prev !== ' ') {\n      newPrev = values[prev] > newPrev ? values[prev] : newPrev\n    }\n\n    const currentNum = values[c]\n    if (currentNum >= newPrev) {\n      sum += currentNum\n    } else {\n      sum -= currentNum\n    }\n\n    prev = c\n  }\n  return sum\n}\n\nconsole.log(romanToDecimal('XXIIVV'))\nconsole.log(romanToDecimal('MDCCCIV'))\nconsole.log(romanToDecimal('XXIVI'))\n","index":20},{"title":"Data- Structures","category":null,"id":"Data-Structures","index":21},{"title":"Array","category":"Data-Structures","id":"Array","index":22},{"title":"Quick Select","category":"Array","id":"QuickSelect_Array","algorithm":"/**\n * QuickSelect is an algorithm to find the kth smallest number\n *\n * Notes:\n * -QuickSelect is related to QuickSort, thus has optimal best and average\n *  case (O(n)) but unlikely poor worst case (O(n^2))\n * -This implementation uses randomly selected pivots for better performance\n *\n * @complexity: O(n) (on average )\n * @complexity: O(n^2) (worst case)\n * @flow\n */\n\nfunction QuickSelect (items, kth) {\n  return RandomizedSelect(items, 0, items.length - 1, kth)\n}\n\nfunction RandomizedSelect (\n  items,\n  left,\n  right,\n  i\n) {\n  if (left === right) return items[left]\n\n  const pivotIndex = RandomizedPartition(items, left, right)\n  const k = pivotIndex - left + 1\n\n  if (i === k) return items[pivotIndex]\n  if (i < k) return RandomizedSelect(items, left, pivotIndex - 1, i)\n\n  return RandomizedSelect(items, pivotIndex + 1, right, i - k)\n}\n\nfunction RandomizedPartition (items, left, right) {\n  const rand = getRandomInt(left, right)\n  Swap(items, rand, right)\n  return Partition(items, left, right)\n}\n\nfunction Partition (items, left, right) {\n  const x = items[right]\n  let pivotIndex = left - 1\n\n  for (let j = left; j < right; j++) {\n    if (items[j] <= x) {\n      pivotIndex++\n      Swap(items, pivotIndex, j)\n    }\n  }\n\n  Swap(items, pivotIndex + 1, right)\n\n  return pivotIndex + 1\n}\n\nfunction getRandomInt (min, max) {\n  return Math.floor(Math.random() * (max - min + 1)) + min\n}\n\nfunction Swap (arr, x, y) {\n  [arr[x], arr[y]] = [arr[y], arr[x]]\n}\n\n// testing\nconsole.log(QuickSelect([1, 4, 2, -2, 4, 5]))\n","index":23},{"title":"Graph","category":"Data-Structures","id":"Graph","index":24},{"title":"Graph","category":"Graph","id":"Graph_Graph","algorithm":"class Graph {\n  constructor () {\n    this.adjacencyMap = {}\n  }\n\n  addVertex (v) {\n    this.adjacencyMap[v] = []\n  }\n\n  containsVertex (vertex) {\n    return typeof (this.adjacencyMap[vertex]) !== 'undefined'\n  }\n\n  addEdge (v, w) {\n    let result = false\n    if (this.containsVertex(v) && this.containsVertex(w)) {\n      this.adjacencyMap[v].push(w)\n      this.adjacencyMap[w].push(v)\n      result = true\n    }\n    return result\n  }\n\n  printGraph () {\n    const keys = Object.keys(this.adjacencyMap)\n    for (const i of keys) {\n      const values = this.adjacencyMap[i]\n      let vertex = ''\n      for (const j of values) { vertex += j + ' ' }\n      console.log(i + ' -> ' + vertex)\n    }\n  }\n\n  /**\n   * Prints the Breadth first traversal of the graph from source.\n   *\n   * @param {number} source The source vertex to start BFS.\n   */\n  bfs (source) {\n    const queue = []\n    const visited = new Set()\n    queue.unshift([source, 0]) // level of source is 0\n    visited.add(source)\n    while (queue.length) {\n      const front = queue[0]\n      const node = front[0]\n      const level = front[1]\n      queue.shift() // remove the front of the queue\n      console.log(`Visited node ${node} at level ${level}.`)\n      for (const next of this.adjacencyMap[node]) {\n        if (!visited.has(next)) { // not visited\n          queue.unshift([next, level + 1]) // level 1 more than current\n          visited.add(next)\n        }\n      }\n    }\n  }\n}\n\nconst example = () => {\n  const g = new Graph()\n  g.addVertex(1)\n  g.addVertex(2)\n  g.addVertex(3)\n  g.addVertex(4)\n  g.addVertex(5)\n  g.addEdge(1, 2)\n  g.addEdge(1, 3)\n  g.addEdge(2, 4)\n  g.addEdge(2, 5)\n  console.log('Printing the adjacency list:\\n')\n  g.printGraph()\n\n  // perform a breadth first search\n  console.log('\\nBreadth first search at node 1:\\n')\n  g.bfs(1)\n}\nexample()\n","index":25},{"title":"Graph2","category":"Graph","id":"Graph2_Graph","algorithm":"// create a graph class\nclass Graph {\n  // defining vertex array and\n  // adjacent list\n  constructor (noOfVertices) {\n    this.noOfVertices = noOfVertices\n    this.AdjList = new Map()\n  }\n\n  // functions to be implemented\n\n  // addVertex(v)\n  // addEdge(v, w)\n  // printGraph()\n\n  // bfs(v)\n  // dfs(v)\n\n  // add vertex to the graph\n  addVertex (v) {\n    // initialize the adjacent list with a\n    // null array\n\n    this.AdjList.set(v, [])\n  }\n\n  // add edge to the graph\n  addEdge (v, w) {\n    // get the list for vertex v and put the\n    // vertex w denoting edge between v and w\n    this.AdjList.get(v).push(w)\n\n    // Since graph is undirected,\n    // add an edge from w to v also\n    this.AdjList.get(w).push(v)\n  }\n\n  // Prints the vertex and adjacency list\n  printGraph () {\n    // get all the vertices\n    const getKeys = this.AdjList.keys()\n\n    // iterate over the vertices\n    for (const i of getKeys) {\n      // great the corresponding adjacency list\n      // for the vertex\n      const getValues = this.AdjList.get(i)\n      let conc = ''\n\n      // iterate over the adjacency list\n      // concatenate the values into a string\n      for (const j of getValues) {\n        conc += j + ' '\n      }\n\n      // print the vertex and its adjacency list\n      console.log(i + ' -> ' + conc)\n    }\n  }\n}\n// Example\nconst graph = new Graph(6)\nconst vertices = ['A', 'B', 'C', 'D', 'E', 'F']\n\n// adding vertices\nfor (let i = 0; i < vertices.length; i++) {\n  graph.addVertex(vertices[i])\n}\n\n// adding edges\ngraph.addEdge('A', 'B')\ngraph.addEdge('A', 'D')\ngraph.addEdge('A', 'E')\ngraph.addEdge('B', 'C')\ngraph.addEdge('D', 'E')\ngraph.addEdge('E', 'F')\ngraph.addEdge('E', 'C')\ngraph.addEdge('C', 'F')\n\n// prints all vertex and\n// its adjacency list\n// A -> B D E\n// B -> A C\n// C -> B E F\n// D -> A E\n// E -> A D F C\n// F -> E C\ngraph.printGraph()\n","index":26},{"title":"Heap","category":"Data-Structures","id":"Heap","index":27},{"title":"Max Heap","category":"Heap","id":"MaxHeap_Heap","algorithm":"/**\n * Author: Samarth Jain\n * Max Heap implementation in Javascript\n */\n\nclass BinaryHeap {\n  constructor () {\n    this.heap = []\n  }\n\n  insert (value) {\n    this.heap.push(value)\n    this.heapify()\n  }\n\n  size () {\n    return this.heap.length\n  }\n\n  empty () {\n    return this.size() === 0\n  }\n\n  // using iterative approach to reorder the heap after insertion\n  heapify () {\n    let index = this.size() - 1\n\n    while (index > 0) {\n      const element = this.heap[index]\n      const parentIndex = Math.floor((index - 1) / 2)\n      const parent = this.heap[parentIndex]\n\n      if (parent[0] >= element[0]) break\n      this.heap[index] = parent\n      this.heap[parentIndex] = element\n      index = parentIndex\n    }\n  }\n\n  // Extracting the maximum element from the Heap\n  extractMax () {\n    const max = this.heap[0]\n    const tmp = this.heap.pop()\n    if (!this.empty()) {\n      this.heap[0] = tmp\n      this.sinkDown(0)\n    }\n    return max\n  }\n\n  // To restore the balance of the heap after extraction.\n  sinkDown (index) {\n    const left = 2 * index + 1\n    const right = 2 * index + 2\n    let largest = index\n    const length = this.size()\n\n    if (left < length && this.heap[left][0] > this.heap[largest][0]) {\n      largest = left\n    }\n    if (right < length && this.heap[right][0] > this.heap[largest][0]) {\n      largest = right\n    }\n    // swap\n    if (largest !== index) {\n      const tmp = this.heap[largest]\n      this.heap[largest] = this.heap[index]\n      this.heap[index] = tmp\n      this.sinkDown(largest)\n    }\n  }\n}\n\nconst maxHeap = new BinaryHeap()\nmaxHeap.insert([4])\nmaxHeap.insert([3])\nmaxHeap.insert([6])\nmaxHeap.insert([1])\nmaxHeap.insert([8])\nmaxHeap.insert([2])\n\nwhile (!maxHeap.empty()) {\n  const mx = maxHeap.extractMax()\n  console.log(mx)\n}\n","index":28},{"title":"Min Priority Queue","category":"Heap","id":"MinPriorityQueue_Heap","algorithm":"\n/* Minimum Priority Queue\n* It is a part of heap data structure\n* A heap is a specific tree based data structure\n* in which all the nodes of tree are in a specific order.\n* that is the children are arranged in some\n* respect of their parents, can either be greater\n* or less than the parent. This makes it a min priority queue\n* or max priority queue.\n*/\n\n// Functions: insert, delete, peek, isEmpty, print, heapSort, sink\n\nclass MinPriorityQueue {\n  // calls the constructor and initializes the capacity\n  constructor (c) {\n    this.heap = []\n    this.capacity = c\n    this.size = 0\n  }\n\n  // inserts the key at the end and rearranges it\n  // so that the binary heap is in appropriate order\n  insert (key) {\n    if (this.isFull()) return\n    this.heap[this.size + 1] = key\n    let k = this.size + 1\n    while (k > 1) {\n      if (this.heap[k] < this.heap[Math.floor(k / 2)]) {\n        const temp = this.heap[k]\n        this.heap[k] = this.heap[Math.floor(k / 2)]\n        this.heap[Math.floor(k / 2)] = temp\n      }\n      k = Math.floor(k / 2)\n    }\n    this.size++\n  }\n\n  // returns the highest priority value\n  peek () {\n    return this.heap[1]\n  }\n\n  // returns boolean value whether the heap is empty or not\n  isEmpty () {\n    return this.size === 0\n  }\n\n  // returns boolean value whether the heap is full or not\n  isFull () {\n    if (this.size === this.capacity) return true\n    return false\n  }\n\n  // prints the heap\n  print () {\n    console.log(this.heap.slice(1))\n  }\n\n  // heap sorting can be done by performing\n  // delete function to the number of times of the size of the heap\n  // it returns reverse sort because it is a min priority queue\n  heapSort () {\n    for (let i = 1; i < this.capacity; i++) {\n      this.delete()\n    }\n  }\n\n  // this function reorders the heap after every delete function\n  sink () {\n    let k = 1\n    while (2 * k <= this.size || 2 * k + 1 <= this.size) {\n      let minIndex\n      if (this.heap[2 * k] >= this.heap[k]) {\n        if (2 * k + 1 <= this.size && this.heap[2 * k + 1] >= this.heap[k]) {\n          break\n        } else if (2 * k + 1 > this.size) {\n          break\n        }\n      }\n      if (2 * k + 1 > this.size) {\n        minIndex = this.heap[2 * k] < this.heap[k] ? 2 * k : k\n      } else {\n        if (\n          this.heap[k] > this.heap[2 * k] ||\n          this.heap[k] > this.heap[2 * k + 1]\n        ) {\n          minIndex =\n            this.heap[2 * k] < this.heap[2 * k + 1] ? 2 * k : 2 * k + 1\n        } else {\n          minIndex = k\n        }\n      }\n      const temp = this.heap[k]\n      this.heap[k] = this.heap[minIndex]\n      this.heap[minIndex] = temp\n      k = minIndex\n    }\n  }\n\n  // deletes the highest priority value from the heap\n  delete () {\n    const min = this.heap[1]\n    this.heap[1] = this.heap[this.size]\n    this.heap[this.size] = min\n    this.size--\n    this.sink()\n    return min\n  }\n}\n\n// testing\nconst q = new MinPriorityQueue(8)\n\nq.insert(5)\nq.insert(2)\nq.insert(4)\nq.insert(1)\nq.insert(7)\nq.insert(6)\nq.insert(3)\nq.insert(8)\nq.print() // [ 1, 2, 3, 5, 7, 6, 4, 8 ]\nq.heapSort()\nq.print() // [ 8, 7, 6, 5, 4, 3, 2, 1 ]\n","index":29},{"title":"Linked- List","category":"Data-Structures","id":"Linked-List","index":30},{"title":"Cycle Detection","category":"Linked-List","id":"CycleDetection_Linked-List","algorithm":"/**\n * A LinkedList based solution for Detect a Cycle in a list\n * https://en.wikipedia.org/wiki/Cycle_detection\n */\n\nfunction main () {\n  /*\n  Problem Statement:\n  Given head, the head of a linked list, determine if the linked list has a cycle in it.\n\n  Note:\n  * While Solving the problem in given link below, don't use main() function.\n  * Just use only the code inside main() function.\n  * The purpose of using main() function here is to aviod global variables.\n\n  Link for the Problem: https://leetcode.com/problems/linked-list-cycle/\n  */\n  const head = '' // Reference to head is given in the problem. So please ignore this line\n  let fast = head\n  let slow = head\n\n  while (fast != null && fast.next != null && slow != null) {\n    fast = fast.next.next\n    slow = slow.next\n    if (fast === slow) {\n      return true\n    }\n  }\n  return false\n}\n\nmain()\n","index":31},{"title":"Doubly Linked List","category":"Linked-List","id":"DoublyLinkedList_Linked-List","algorithm":"// Hamza chabchoub contribution for a university project\nfunction DoubleLinkedList () {\n  const Node = function (element) {\n    this.element = element\n    this.next = null\n    this.prev = null\n  }\n\n  let length = 0\n  let head = null\n  let tail = null\n\n  // Add new element\n  this.append = function (element) {\n    const node = new Node(element)\n\n    if (!head) {\n      head = node\n      tail = node\n    } else {\n      node.prev = tail\n      tail.next = node\n      tail = node\n    }\n\n    length++\n  }\n\n  // Add element\n  this.insert = function (position, element) {\n    // Check of out-of-bound values\n    if (position >= 0 && position <= length) {\n      const node = new Node(element)\n      let current = head\n      let previous = 0\n      let index = 0\n\n      if (position === 0) {\n        if (!head) {\n          head = node\n          tail = node\n        } else {\n          node.next = current\n          current.prev = node\n          head = node\n        }\n      } else if (position === length) {\n        current = tail\n        current.next = node\n        node.prev = current\n        tail = node\n      } else {\n        while (index++ < position) {\n          previous = current\n          current = current.next\n        }\n\n        node.next = current\n        previous.next = node\n\n        // New\n        current.prev = node\n        node.prev = previous\n      }\n\n      length++\n      return true\n    } else {\n      return false\n    }\n  }\n\n  // Remove element at any position\n  this.removeAt = function (position) {\n    // look for out-of-bounds value\n    if (position > -1 && position < length) {\n      let current = head\n      let previous = 0\n      let index = 0\n\n      // Removing first item\n      if (position === 0) {\n        head = current.next\n\n        // if there is only one item, update tail //NEW\n        if (length === 1) {\n          tail = null\n        } else {\n          head.prev = null\n        }\n      } else if (position === length - 1) {\n        current = tail\n        tail = current.prev\n        tail.next = null\n      } else {\n        while (index++ < position) {\n          previous = current\n          current = current.next\n        }\n\n        // link previous with current's next - skip it\n        previous.next = current.next\n        current.next.prev = previous\n      }\n\n      length--\n      return current.element\n    } else {\n      return null\n    }\n  }\n\n  // Get the indexOf item\n  this.indexOf = function (elm) {\n    let current = head\n    let index = -1\n\n    // If element found then return its position\n    while (current) {\n      if (elm === current.element) {\n        return ++index\n      }\n\n      index++\n      current = current.next\n    }\n\n    // Else return -1\n    return -1\n  }\n\n  // Find the item in the list\n  this.isPresent = (elm) => {\n    return this.indexOf(elm) !== -1\n  }\n\n  // Delete an item from the list\n  this.delete = (elm) => {\n    return this.removeAt(this.indexOf(elm))\n  }\n\n  // Delete first item from the list\n  this.deleteHead = function () {\n    this.removeAt(0)\n  }\n\n  // Delete last item from the list\n  this.deleteTail = function () {\n    this.removeAt(length - 1)\n  }\n\n  // Print item of the string\n  this.toString = function () {\n    let current = head\n    let string = ''\n\n    while (current) {\n      string += current.element + (current.next ? '\\n' : '')\n      current = current.next\n    }\n\n    return string\n  }\n\n  // Convert list to array\n  this.toArray = function () {\n    const arr = []\n    let current = head\n\n    while (current) {\n      arr.push(current.element)\n      current = current.next\n    }\n\n    return arr\n  }\n\n  // Check if list is empty\n  this.isEmpty = function () {\n    return length === 0\n  }\n\n  // Get the size of the list\n  this.size = function () {\n    return length\n  }\n\n  // Get the head\n  this.getHead = function () {\n    return head\n  }\n\n  // Get the tail\n  this.getTail = function () {\n    return tail\n  }\n}\n\nconst newDoubleLinkedList = new DoubleLinkedList()\nnewDoubleLinkedList.append(1)\nnewDoubleLinkedList.append(2)\nconsole.log('Testing: ' + newDoubleLinkedList.size()) // returns 2\n","index":32},{"title":"Rotate List Right","category":"Linked-List","id":"RotateListRight_Linked-List","algorithm":"/**\n * A LinkedList based solution for Rotating a List to the right by k places\n */\n\nfunction main () {\n  /*\n  Problem Statement:\n  Given a linked list, rotate the list to the right by k places, where k is non-negative.\n\n  Note:\n  * While Solving the problem in given link below, don't use main() function.\n  * Just use only the code inside main() function.\n  * The purpose of using main() function here is to aviod global variables.\n\n  Link for the Problem: https://leetcode.com/problems/rotate-list/\n  */\n  // Reference to both head and k is given in the problem. So please ignore below two lines\n  let head = ''\n  let k = ''\n  let i = 0\n  let current = head\n  while (current) {\n    i++\n    current = current.next\n  }\n  k %= i\n  current = head\n  let prev = null\n  while (k--) {\n    if (!current || !current.next) {\n      return current\n    } else {\n      while (current.next) {\n        prev = current\n        current = current.next\n      }\n      prev.next = current.next\n      current.next = head\n      head = current\n    }\n  }\n  return head\n}\n\nmain()\n","index":33},{"title":"Single Circular Linked List.js","category":"Linked-List","id":"SingleCircularLinkedList.js_Linked-List","algorithm":"class Node {\n  constructor (data, next = null) {\n    this.data = data\n    this.next = next\n  }\n}\n\nclass SinglyCircularLinkedList {\n  constructor () {\n    this.head = null\n    this.size = 0\n  }\n\n  insert (data) {\n    const node = new Node(data)\n\n    if (!this.head) {\n      node.next = node\n      this.head = node\n      this.size++\n    } else {\n      node.next = this.head\n\n      let current = this.head\n\n      while (current.next.data !== this.head.data) {\n        current = current.next\n      }\n\n      current.next = node\n      this.size++\n    }\n  }\n\n  insertAt (index, data) {\n    const node = new Node(data)\n\n    if (index < 0 || index > this.size) return\n\n    if (index === 0) {\n      this.head = node\n      this.size = 1\n      return\n    }\n\n    let previous\n    let count = 0\n    let current = this.head\n\n    while (count < index) {\n      previous = current\n      current = current.next\n      count++\n    }\n\n    node.next = current\n    previous.next = node\n    this.size++\n  }\n\n  remove () {\n    if (!this.head) return\n\n    let prev\n    let current = this.head\n\n    while (current.next !== this.head) {\n      prev = current\n      current = current.next\n    }\n\n    prev.next = this.head\n    this.size--\n  }\n\n  printData () {\n    let count = 0\n    let current = this.head\n\n    while (current !== null && count !== this.size) {\n      console.log(current.data + '\\n')\n      current = current.next\n      count++\n    }\n  }\n}\n\nconst ll = new SinglyCircularLinkedList()\n\nll.insert(10)\nll.insert(20)\nll.insert(30)\nll.insert(40)\nll.insert(50)\nll.insertAt(5, 60)\nll.remove(5)\nll.printData()\n","index":34},{"title":"Singly Link List","category":"Linked-List","id":"SinglyLinkList_Linked-List","algorithm":"/* SinglyLinkedList!!\n* A linked list is implar to an array, it hold values.\n* However, links in a linked list do not have indexes. With\n* a linked list you do not need to predetermine it's size as\n* it grows and shrinks as it is edited. This is an example of\n* a singly linked list.\n*/\n\n// Functions - add, remove, indexOf, elementAt, addAt, removeAt, view\n\n// class LinkedList and constructor\n// Creates a LinkedList\nvar LinkedList = (function () {\n  function LinkedList () {\n    // Length of linklist and head is null at start\n    this.length = 0\n    this.head = null\n  }\n\n  // class node (constructor)\n  // Creating Node with element's value\n  var Node = (function () {\n    function Node (element) {\n      this.element = element\n      this.next = null\n    }\n    return Node\n  }())\n\n  // Returns length\n  LinkedList.prototype.size = function () {\n    return this.length\n  }\n\n  // Returns the head\n  LinkedList.prototype.head = function () {\n    return this.head\n  }\n\n  // Creates a node and adds it to linklist\n  LinkedList.prototype.add = function (element) {\n    var node = new Node(element)\n    // Check if its the first element\n    if (this.head === null) {\n      this.head = node\n    } else {\n      var currentNode = this.head\n\n      // Loop till there is node present in the list\n      while (currentNode.next) {\n        currentNode = currentNode.next\n      }\n\n      // Adding node to the end of the list\n      currentNode.next = node\n    }\n    // Increment the length\n    this.length++\n  }\n\n  // Removes the node with the value as param\n  LinkedList.prototype.remove = function (element) {\n    var currentNode = this.head\n    var previousNode\n\n    // Check if the head node is the element to remove\n    if (currentNode.element === element) {\n      this.head = currentNode.next\n    } else {\n      // Check which node is the node to remove\n      while (currentNode.element !== element) {\n        previousNode = currentNode\n        currentNode = currentNode.next\n      }\n\n      // Removing the currentNode\n      previousNode.next = currentNode.next\n    }\n\n    // Decrementing the length\n    this.length--\n  }\n\n  // Return if the list is empty\n  LinkedList.prototype.isEmpty = function () {\n    return this.length === 0\n  }\n\n  // Returns the index of the element passed as param otherwise -1\n  LinkedList.prototype.indexOf = function (element) {\n    var currentNode = this.head\n    var index = -1\n\n    while (currentNode) {\n      index++\n\n      // Checking if the node is the element we are searching for\n      if (currentNode.element === element) {\n        return index + 1\n      }\n      currentNode = currentNode.next\n    }\n\n    return -1\n  }\n\n  // Returns the element at an index\n  LinkedList.prototype.elementAt = function (index) {\n    var currentNode = this.head\n    var count = 0\n    while (count < index) {\n      count++\n      currentNode = currentNode.next\n    }\n    return currentNode.element\n  }\n\n  // Adds the element at specified index\n  LinkedList.prototype.addAt = function (index, element) {\n    index--\n    var node = new Node(element)\n\n    var currentNode = this.head\n    var previousNode\n    var currentIndex = 0\n\n    // Check if index is out of bounds of list\n    if (index > this.length) {\n      return false\n    }\n\n    // Check if index is the start of list\n    if (index === 0) {\n      node.next = currentNode\n      this.head = node\n    } else {\n      while (currentIndex < index) {\n        currentIndex++\n        previousNode = currentNode\n        currentNode = currentNode.next\n      }\n\n      // Adding the node at specified index\n      node.next = currentNode\n      previousNode.next = node\n    }\n\n    // Incrementing the length\n    this.length++\n    return true\n  }\n\n  // Removes the node at specified index\n  LinkedList.prototype.removeAt = function (index) {\n    index--\n    var currentNode = this.head\n    var previousNode\n    var currentIndex = 0\n\n    // Check if index is present in list\n    if (index < 0 || index >= this.length) {\n      return null\n    }\n\n    // Check if element is the first element\n    if (index === 0) {\n      this.head = currentNode.next\n    } else {\n      while (currentIndex < index) {\n        currentIndex++\n        previousNode = currentNode\n        currentNode = currentNode.next\n      }\n      previousNode.next = currentNode.next\n    }\n\n    // Decrementing the length\n    this.length--\n    return currentNode.element\n  }\n\n  // Function to view the LinkedList\n  LinkedList.prototype.view = function () {\n    var currentNode = this.head\n    var count = 0\n    while (count < this.length) {\n      count++\n      console.log(currentNode.element)\n      currentNode = currentNode.next\n    }\n  }\n\n  // returns the constructor\n  return LinkedList\n}())\n\n// Implementation of LinkedList\nvar linklist = new LinkedList()\nlinklist.add(2)\nlinklist.add(5)\nlinklist.add(8)\nlinklist.add(12)\nlinklist.add(17)\nconsole.log(linklist.size())\nconsole.log(linklist.removeAt(4))\nlinklist.addAt(4, 15)\nconsole.log(linklist.indexOf(8))\nconsole.log(linklist.size())\nlinklist.view()\n","index":35},{"title":"Queue","category":"Data-Structures","id":"Queue","index":36},{"title":"Queue","category":"Queue","id":"Queue_Queue","algorithm":"/* Queue\n* A Queue is a data structure that allows you to add an element to the end of\n* a list and remove the item at the front. A queue follows a \"First In First Out\"\n* system, where the first item to enter the queue is the first to be removed. This\n* implementation uses an array to store the queue.\n*/\n\n// Functions: enqueue, dequeue, peek, view, length\n\nconst Queue = (function () {\n  // constructor\n  function Queue () {\n    // This is the array representation of the queue\n    this.queue = []\n  }\n\n  // methods\n  // Add a value to the end of the queue\n  Queue.prototype.enqueue = function (item) {\n    this.queue.push(item)\n  }\n\n  // Removes the value at the front of the queue\n  Queue.prototype.dequeue = function () {\n    if (this.queue.length === 0) {\n      throw new Error('Queue is Empty')\n    }\n\n    const result = this.queue[0]\n    this.queue.splice(0, 1) // remove the item at position 0 from the array\n\n    return result\n  }\n\n  // Return the length of the queue\n  Queue.prototype.length = function () {\n    return this.queue.length\n  }\n\n  // Return the item at the front of the queue\n  Queue.prototype.peek = function () {\n    return this.queue[0]\n  }\n\n  // List all the items in the queue\n  Queue.prototype.view = function () {\n    console.log(this.queue)\n  }\n\n  return Queue\n}())\n\n// Implementation\nconst myQueue = new Queue()\n\nmyQueue.enqueue(1)\nmyQueue.enqueue(5)\nmyQueue.enqueue(76)\nmyQueue.enqueue(69)\nmyQueue.enqueue(32)\nmyQueue.enqueue(54)\n\nmyQueue.view()\n\nconsole.log(`Length: ${myQueue.length()}`)\nconsole.log(`Front item: ${myQueue.peek()}`)\nconsole.log(`Removed ${myQueue.dequeue()} from front.`)\nconsole.log(`New front item: ${myQueue.peek()}`)\nconsole.log(`Removed ${myQueue.dequeue()} from front.`)\nconsole.log(`New front item: ${myQueue.peek()}`)\nmyQueue.enqueue(55)\nconsole.log('Inserted 55')\nconsole.log(`New front item: ${myQueue.peek()}`)\n\nfor (let i = 0; i < 5; i++) {\n  myQueue.dequeue()\n  myQueue.view()\n}\n\n// console.log(myQueue.dequeue()); // throws exception!\n","index":37},{"title":"Queue Using2 Stacks","category":"Queue","id":"QueueUsing2Stacks_Queue","algorithm":"// implementation of Queue using 2 stacks\n// contribution made by hamza chabchoub for a university project\n\nclass Queue {\n  constructor () {\n    this.inputStack = []\n    this.outputStack = []\n  }\n\n  // Push item into the inputstack\n  enqueue (item) {\n    this.inputStack.push(item)\n  }\n\n  dequeue (item) {\n    // push all items to outputstack\n    this.outputStack = []\n    if (this.inputStack.length > 0) {\n      while (this.inputStack.length > 0) {\n        this.outputStack.push(this.inputStack.pop())\n      }\n    }\n    // display the top element of the outputstack\n    if (this.outputStack.length > 0) {\n      console.log(this.outputStack.pop())\n      // repush all the items to the inputstack\n      this.inputStack = []\n      while (this.outputStack.length > 0) {\n        this.inputStack.push(this.outputStack.pop())\n      }\n    }\n  }\n\n  // display elements of the inputstack\n  listIn () {\n    let i = 0\n    while (i < this.inputStack.length) {\n      console.log(this.inputStack[i])\n      i++\n    }\n  }\n\n  // display element of the outputstack\n  listOut () {\n    let i = 0\n    while (i < this.outputStack.length) {\n      console.log(this.outputStack[i])\n      i++\n    }\n  }\n}\n\n// testing\n\nconst queue = new Queue()\nqueue.enqueue(1)\nqueue.enqueue(2)\nqueue.enqueue(8)\nqueue.enqueue(9)\n\nconsole.log(queue.dequeue())\n// ans = 1\nconsole.log(queue.dequeue())\n// ans = 2\n","index":38},{"title":"Stack","category":"Data-Structures","id":"Stack","index":39},{"title":"Stack","category":"Stack","id":"Stack_Stack","algorithm":"/* Stack!!\n* A stack is exactly what it sounds like. An element gets added to the top of\n* the stack and only the element on the top may be removed. This is an example\n* of an array implementation of a Stack. So an element can only be added/removed\n* from the end of the array.\n*/\n\n// Functions: push, pop, peek, view, length\n\n// Creates a stack constructor\nvar Stack = (function () {\n  function Stack () {\n    // The top of the Stack\n    this.top = 0\n    // The array representation of the stack\n    this.stack = []\n  }\n\n  // Adds a value onto the end of the stack\n  Stack.prototype.push = function (value) {\n    this.stack[this.top] = value\n    this.top++\n  }\n\n  // Removes and returns the value at the end of the stack\n  Stack.prototype.pop = function () {\n    if (this.top === 0) {\n      return 'Stack is Empty'\n    }\n\n    this.top--\n    var result = this.stack[this.top]\n    this.stack = this.stack.splice(0, this.top)\n    return result\n  }\n\n  // Returns the size of the stack\n  Stack.prototype.size = function () {\n    return this.top\n  }\n\n  // Returns the value at the end of the stack\n  Stack.prototype.peek = function () {\n    return this.stack[this.top - 1]\n  }\n\n  // To see all the elements in the stack\n  Stack.prototype.view = function () {\n    for (var i = 0; i < this.top; i++) { console.log(this.stack[i]) }\n  }\n\n  return Stack\n}())\n\n// Implementation\nvar myStack = new Stack()\n\nmyStack.push(1)\nmyStack.push(5)\nmyStack.push(76)\nmyStack.push(69)\nmyStack.push(32)\nmyStack.push(54)\nconsole.log(myStack.size())\nconsole.log(myStack.peek())\nconsole.log(myStack.pop())\nconsole.log(myStack.peek())\nconsole.log(myStack.pop())\nconsole.log(myStack.peek())\nmyStack.push(55)\nconsole.log(myStack.peek())\nmyStack.view()\n","index":40},{"title":"Stack E S6","category":"Stack","id":"StackES6_Stack","algorithm":"/* Stack data-structure. It's work is based on the LIFO method (last-IN-first-OUT).\n * It means that elements added to the stack are placed on the top and only the\n * last element (from the top) can be reached. After we get access to the last\n * element, he pops from the stack.\n * This is a class-based implementation of a Stack. It provides functions\n * 'push' - to add an element, 'pop' - to remove an element from the top.\n * Also it implements 'length', 'last' and 'isEmpty' properties and\n * static isStack method to check is an object the instance of Stack class.\n */\n\n// Class declaration\nclass Stack {\n  constructor () {\n    this.stack = []\n    this.top = 0\n  }\n\n  // Adds a value to the end of the Stack\n  push (newValue) {\n    this.stack.push(newValue)\n    this.top += 1\n  }\n\n  // Returns and removes the last element of the Stack\n  pop () {\n    if (this.top !== 0) {\n      this.top -= 1\n      return this.stack.pop()\n    }\n    throw new Error('Stack Underflow')\n  }\n\n  // Returns the number of elements in the Stack\n  get length () {\n    return this.top\n  }\n\n  // Returns true if stack is empty, false otherwise\n  get isEmpty () {\n    return this.top === 0\n  }\n\n  // Returns the last element without removing it\n  get last () {\n    if (this.top !== 0) {\n      return this.stack[this.stack.length - 1]\n    }\n    return null\n  }\n\n  // Checks if an object is the instance os the Stack class\n  static isStack (el) {\n    return el instanceof Stack\n  }\n}\nconst newStack = new Stack()\nconsole.log('Is it a Stack?,', Stack.isStack(newStack))\nconsole.log('Is stack empty? ', newStack.isEmpty)\nnewStack.push('Hello world')\nnewStack.push(42)\nnewStack.push({ a: 6, b: 7 })\nconsole.log('The length of stack is ', newStack.length)\nconsole.log('Is stack empty? ', newStack.isEmpty)\nconsole.log('Give me the last one ', newStack.last)\nconsole.log('Pop the latest ', newStack.pop())\nconsole.log('Pop the latest ', newStack.pop())\nconsole.log('Pop the latest ', newStack.pop())\nconsole.log('Is stack empty? ', newStack.isEmpty)\n","index":41},{"title":"Tree","category":"Data-Structures","id":"Tree","index":42},{"title":"Binary Search Tree","category":"Tree","id":"BinarySearchTree_Tree","algorithm":"/* Binary Search Tree!!\n*\n* Nodes that will go on the Binary Tree.\n* They consist of the data in them, the node to the left, the node\n* to the right, and the parent from which they came from.\n*\n* A binary tree is a data structure in which an element\n* has two successors(children). The left child is usually\n* smaller than the parent, and the right child is usually\n* bigger.\n*/\n\n// class Node\nvar Node = (function () {\n  // Node in the tree\n  function Node (val) {\n    this.value = val\n    this.left = null\n    this.right = null\n  }\n\n  // Search the tree for a value\n  Node.prototype.search = function (val) {\n    if (this.value === val) {\n      return this\n    } else if (val < this.value && this.left != null) {\n      return this.left.search(val)\n    } else if (val > this.value && this.right != null) {\n      return this.right.search(val)\n    }\n    return null\n  }\n\n  // Visit a node\n  Node.prototype.visit = function () {\n    // Recursively go left\n    if (this.left != null) {\n      this.left.visit()\n    }\n    // Print out value\n    console.log(this.value)\n    // Recursively go right\n    if (this.right != null) {\n      this.right.visit()\n    }\n  }\n\n  // Add a node\n  Node.prototype.addNode = function (n) {\n    if (n.value < this.value) {\n      if (this.left == null) {\n        this.left = n\n      } else {\n        this.left.addNode(n)\n      }\n    } else if (n.value > this.value) {\n      if (this.right == null) {\n        this.right = n\n      } else {\n        this.right.addNode(n)\n      }\n    }\n  }\n\n  // returns the constructor\n  return Node\n}())\n\n// class Tree\nvar Tree = (function () {\n  function Tree () {\n    // Just store the root\n    this.root = null\n  };\n\n  // Inorder traversal\n  Tree.prototype.traverse = function () {\n    this.root.visit()\n  }\n\n  // Start by searching the root\n  Tree.prototype.search = function (val) {\n    const found = this.root.search(val)\n    if (found === null) {\n      console.log(val + ' not found')\n    } else {\n      console.log('Found:' + found.value)\n    }\n  }\n\n  // Add a new value to the tree\n  Tree.prototype.addValue = function (val) {\n    const n = new Node(val)\n    if (this.root == null) {\n      this.root = n\n    } else {\n      this.root.addNode(n)\n    }\n  }\n\n  // returns the constructor\n  return Tree\n}())\n\n// Implementation of BST\nvar bst = new Tree()\nbst.addValue(6)\nbst.addValue(3)\nbst.addValue(9)\nbst.addValue(2)\nbst.addValue(8)\nbst.addValue(4)\nbst.traverse()\nbst.search(8)\n","index":43},{"title":"Trie","category":"Tree","id":"Trie_Tree","algorithm":"var TrieNode = function TrieNode (key, parent) {\n  this.key = key\n  this.count = 0\n  this.children = Object.create(null)\n  if (parent === undefined) {\n    this.parent = null\n  } else {\n    this.parent = parent\n  }\n}\n\nfunction Trie () {\n  // create only root with null key and parent\n  this.root = new TrieNode(null, null)\n}\n\n// Recursively finds the occurence of all words in a given node\nTrie.findAllWords = function (root, word, output) {\n  if (root === null) return\n  if (root.count > 0) {\n    if (typeof output === 'object') { output.push({ word: word, count: root.count }) }\n  }\n  var key\n  for (key in root.children) {\n    word += key\n    this.findAllWords(root.children[key], word, output)\n    word = word.slice(0, -1)\n  }\n}\n\nTrie.prototype.insert = function (word) {\n  if (typeof word !== 'string') return\n  if (word === '') {\n    this.root.count += 1\n    return\n  }\n  var node = this.root\n  var len = word.length\n  var i\n  for (i = 0; i < len; i++) {\n    if (node.children[word.charAt(i)] === undefined) { node.children[word.charAt(i)] = new TrieNode(word.charAt(i), node) }\n    node = node.children[word.charAt(i)]\n  }\n  node.count += 1\n}\n\nTrie.prototype.findPrefix = function (word) {\n  if (typeof word !== 'string') return null\n  var node = this.root\n  var len = word.length\n  var i\n  // After end of this loop node will be at desired prefix\n  for (i = 0; i < len; i++) {\n    if (node.children[word.charAt(i)] === undefined) return null // No such prefix exists\n    node = node.children[word.charAt(i)]\n  }\n  return node\n}\n\nTrie.prototype.remove = function (word, count) {\n  if (typeof word !== 'string') return\n  if (typeof count !== 'number') count = 1\n  else if (count <= 0) return\n\n  // for empty string just delete count of root\n  if (word === '') {\n    if (this.root.count >= count) this.root.count -= count\n    else this.root.count = 0\n    return\n  }\n\n  var child = this.root\n  var len = word.length\n  var i, key\n  // child: node which is to be deleted\n  for (i = 0; i < len; i++) {\n    key = word.charAt(i)\n    if (child.children[key] === undefined) return\n    child = child.children[key]\n  }\n\n  // Delete no of occurences specified\n  if (child.count >= count) child.count -= count\n  else child.count = 0\n\n  // If some occurences are left we dont delete it or else\n  // if the object forms some other objects prefix we dont delete it\n  // For checking an empty object\n  // https://stackoverflow.com/questions/679915/how-do-i-test-for-an-empty-javascript-object\n  if (child.count <= 0 && (Object.keys(child.children).length && child.childre.constructor === Object)) {\n    child.parent.children[child.key] = undefined\n  }\n}\n\nTrie.prototype.findAllWords = function (prefix) {\n  var output = []\n  // find the node with provided prefix\n  var node = this.findPrefix(prefix)\n  // No such prefix exists\n  if (node === null) return output\n  Trie.findAllWords(node, prefix, output)\n  return output\n}\n\nTrie.prototype.contains = function (word) {\n  // find the node with given prefix\n  var node = this.findPrefix(word)\n  // No such word exists\n  if (node === null || node.count === 0) return false\n  return true\n}\n\nTrie.prototype.findOccurences = function (word) {\n  // find the node with given prefix\n  var node = this.findPrefix(word)\n  // No such word exists\n  if (node === null) return 0\n  return node.count\n};\n\n// To test\n(function demo () {\n  var x = new Trie()\n  x.insert('sheldon')\n  x.insert('hello')\n  x.insert('anyword')\n  x.insert('sheldoncooper')\n  console.log(x.findOccurences('sheldon'))\n  x.remove('anything')\n  x.insert('sheldon')\n  console.log(x.findOccurences('sheldon'))\n  console.log(x.findAllWords('sheldon'))\n  x.insert('anything')\n  x.remove('sheldoncooper')\n  console.log(x.contains('sheldoncooper'))\n  console.log(x.findAllWords('sheldon'))\n})()\n","index":44},{"title":"Dynamic- Programming","category":null,"id":"Dynamic-Programming","index":45},{"title":"Climbing Stairs","category":"Dynamic-Programming","id":"ClimbingStairs_Dynamic-Programming","algorithm":"/*\n * You are climbing a stair case. It takes n steps to reach to the top.\n * Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\n*/\n\nconst climbStairs = (n) => {\n  let prev = 0\n  let cur = 1\n  let temp\n\n  for (let i = 0; i < n; i++) {\n    temp = prev\n    prev = cur\n    cur += temp\n  }\n  return cur\n}\n\nconst main = () => {\n  const number = 5\n\n  console.log('Number of ways to climb ' + number + ' stairs in ' + climbStairs(5))\n}\n\n// testing\nmain()\n","index":46},{"title":"Coin Change","category":"Dynamic-Programming","id":"CoinChange_Dynamic-Programming","algorithm":"function change (coins, amount) {\n  const combinations = new Array(amount + 1).fill(0)\n  combinations[0] = 1\n\n  for (let i = 0; i < coins.length; i++) {\n    const coin = coins[i]\n\n    for (let j = coin; j < amount + 1; j++) {\n      combinations[j] += combinations[j - coin]\n    }\n  }\n  return combinations[amount]\n}\n\nfunction minimumCoins (coins, amount) {\n  // minimumCoins[i] will store the minimum coins needed for amount i\n  const minimumCoins = new Array(amount + 1).fill(0)\n\n  minimumCoins[0] = 0\n\n  for (let i = 1; i < amount + 1; i++) {\n    minimumCoins[i] = Number.MAX_SAFE_INTEGER\n  }\n  for (let i = 1; i < amount + 1; i++) {\n    for (let j = 0; j < coins.length; j++) {\n      const coin = coins[j]\n      if (coin <= i) {\n        const subRes = minimumCoins[i - coin]\n        if (subRes !== Number.MAX_SAFE_INTEGER && subRes + 1 < minimumCoins[i]) {\n          minimumCoins[i] = subRes + 1\n        }\n      }\n    }\n  }\n  return minimumCoins[amount]\n}\n\nfunction main () {\n  const amount = 12\n  const coins = [2, 4, 5]\n  console.log('Number of combinations of getting change for ' + amount + ' is: ' + change(coins, amount))\n  console.log('Minimum number of coins required for amount :' + amount + ' is: ' + minimumCoins(coins, amount))\n}\n\nmain()\n","index":47},{"title":"Edit Distance","category":"Dynamic-Programming","id":"EditDistance_Dynamic-Programming","algorithm":"/*\nWikipedia -> https://en.wikipedia.org/wiki/Edit_distance\n\nQ. -> Given two strings `word1` and `word2`. You can perform these operations on any of the string to make both strings similar.\n    - Insert\n    - Remove\n    - Replace\nFind the minimum operation cost required to make both same. Each operation cost is 1.\n\nAlgorithm details ->\ntime complexity - O(n*m)\nspace complexity - O(n*m)\n*/\n\nconst minimumEditDistance = (word1, word2) => {\n  const n = word1.length\n  const m = word2.length\n  const dp = new Array(m + 1).fill(0).map(item => [])\n\n  /*\n    fill dp matrix with default values -\n        - first row is filled considering no elements in word2.\n        - first column filled considering no elements in word1.\n    */\n\n  for (let i = 0; i < n + 1; i++) {\n    dp[0][i] = i\n  }\n\n  for (let i = 0; i < m + 1; i++) {\n    dp[i][0] = i\n  }\n\n  /*\n        indexing is 1 based for dp matrix as we defined some known values at first row and first column/\n    */\n\n  for (let i = 1; i < m + 1; i++) {\n    for (let j = 1; j < n + 1; j++) {\n      const letter1 = word1[j - 1]\n      const letter2 = word2[i - 1]\n\n      if (letter1 === letter2) {\n        dp[i][j] = dp[i - 1][j - 1]\n      } else {\n        dp[i][j] = Math.min(dp[i - 1][j], dp[i - 1][j - 1], dp[i][j - 1]) + 1\n      }\n    }\n  }\n\n  return dp[m][n]\n}\n\nconst main = () => {\n  console.log(minimumEditDistance('horse', 'ros'))\n  console.log(minimumEditDistance('cat', 'cut'))\n  console.log(minimumEditDistance('', 'abc'))\n  console.log(minimumEditDistance('google', 'glgool'))\n}\n\nmain()\n","index":48},{"title":"Fibonacci Number","category":"Dynamic-Programming","id":"FibonacciNumber_Dynamic-Programming","algorithm":"//  https://en.wikipedia.org/wiki/Fibonacci_number\n\nconst fibonacci = (N) => {\n  // creating array to store values\n  const memo = new Array(N + 1)\n  memo[0] = 0\n  memo[1] = 1\n  for (let i = 2; i <= N; i++) {\n    memo[i] = memo[i - 1] + memo[i - 2]\n  }\n  return memo[N]\n}\n\n// testing\n(() => {\n  const number = 5\n  console.log(number + 'th Fibonacci number is ' + fibonacci(number))\n})()\n","index":49},{"title":"Kadane Algo","category":"Dynamic-Programming","id":"KadaneAlgo_Dynamic-Programming","algorithm":"function KadaneAlgo (array) {\n  let cummulativeSum = 0\n  let maxSum = 0\n  for (var i = 0; i < array.length; i++) {\n    cummulativeSum = cummulativeSum + array[i]\n    if (cummulativeSum < 0) {\n      cummulativeSum = 0\n    } else if (maxSum < cummulativeSum) {\n      maxSum = cummulativeSum\n    }\n  }\n  return maxSum\n  // This function returns largest sum contigous sum in a array\n}\nfunction main () {\n  var myArray = [1, 2, 3, 4, -6]\n  var result = KadaneAlgo(myArray)\n  console.log(result)\n}\nmain()\n","index":50},{"title":"Levenshtein Distance","category":"Dynamic-Programming","id":"LevenshteinDistance_Dynamic-Programming","algorithm":"/**\n * A Dynamic Programming based solution for calculation of the Levenshtein Distance\n * https://en.wikipedia.org/wiki/Levenshtein_distance\n */\n\nfunction minimum (a, b, c) {\n  if (a < b && a < c) {\n    return a\n  } else if (b < a && b < c) {\n    return b\n  } else {\n    return c\n  }\n}\n\nfunction costOfSubstitution (x, y) {\n  return x === y ? 0 : 1\n}\n\nfunction calculate (x, y) {\n  const dp = new Array(x.length + 1)\n  for (let i = 0; i < x.length + 1; i++) {\n    dp[i] = new Array(y.length + 1)\n  }\n\n  for (let i = 0; i < x.length + 1; i++) {\n    for (let j = 0; j < y.length + 1; j++) {\n      if (i === 0) {\n        dp[i][j] = j\n      } else if (j === 0) {\n        dp[i][j] = i\n      } else {\n        dp[i][j] = minimum(dp[i - 1][j - 1] + costOfSubstitution(x.charAt(i - 1), y.charAt(j - 1)), dp[i - 1][j] + 1, dp[i][j - 1] + 1)\n      }\n    }\n  }\n\n  return dp[x.length][y.length]\n}\n\nfunction main () {\n  const x = '' // enter your string here\n  const y = '' // enter your string here\n\n  console.log('Levenshtein distance between ' + x + ' and ' + y + ' is: ')\n  console.log(calculate(x, y))\n}\n\nmain()\n","index":51},{"title":"Longest Common Subsequence","category":"Dynamic-Programming","id":"LongestCommonSubsequence_Dynamic-Programming","algorithm":"/*\n    * Given two sequences, find the length of longest subsequence present in both of them.\n    * A subsequence is a sequence that appears in the same relative order, but not necessarily contiguous.\n    * For example, “abc”, “abg”, “bdf”, “aeg”, ‘”acefg”, .. etc are subsequences of “abcdefg”\n*/\n\nfunction longestCommonSubsequence (x, y, str1, str2, dp) {\n  if (x === -1 || y === -1) {\n    return 0\n  } else {\n    if (dp[x][y] !== 0) {\n      return dp[x][y]\n    } else {\n      if (str1[x] === str2[y]) {\n        dp[x][y] = 1 + longestCommonSubsequence(x - 1, y - 1, str1, str2, dp)\n        return dp[x][y]\n      } else {\n        dp[x][y] = Math.max(longestCommonSubsequence(x - 1, y, str1, str2, dp), longestCommonSubsequence(x, y - 1, str1, str2, dp))\n        return dp[x][y]\n      }\n    }\n  }\n}\n\nfunction main () {\n  const str1 = 'ABCDGH'\n  const str2 = 'AEDFHR'\n  const dp = new Array(str1.length + 1).fill(0).map(x => new Array(str2.length + 1).fill(0))\n  const res = longestCommonSubsequence(str1.length - 1, str2.length - 1, str1, str2, dp)\n  console.log(res)\n}\n\nmain()\n","index":52},{"title":"Longest Increasing Subsequence","category":"Dynamic-Programming","id":"LongestIncreasingSubsequence_Dynamic-Programming","algorithm":"/**\n * A Dynamic Programming based solution for calculating Longest Increasing Subsequence\n * https://en.wikipedia.org/wiki/Longest_increasing_subsequence\n */\n\nfunction main () {\n  const x = [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]\n  const length = x.length\n  const dp = Array(length).fill(1)\n\n  let res = 1\n\n  for (let i = 0; i < length; i++) {\n    for (let j = 0; j < i; j++) {\n      if (x[i] > x[j]) {\n        dp[i] = Math.max(dp[i], 1 + dp[j])\n        if (dp[i] > res) {\n          res = dp[i]\n        }\n      }\n    }\n  }\n\n  console.log('Length of Longest Increasing Subsequence is:', res)\n}\n\nmain()\n","index":53},{"title":"Longest Palindromic Subsequence","category":"Dynamic-Programming","id":"LongestPalindromicSubsequence_Dynamic-Programming","algorithm":"/*\n  LeetCode -> https://leetcode.com/problems/longest-palindromic-subsequence/\n\n  Given a string s, find the longest palindromic subsequence's length in s.\n  You may assume that the maximum length of s is 1000.\n\n*/\n\nconst longestPalindromeSubsequence = function (s) {\n  const n = s.length\n\n  const dp = new Array(n).fill(0).map(item => new Array(n).fill(0).map(item => 0))\n\n  // fill predefined for single character\n  for (let i = 0; i < n; i++) {\n    dp[i][i] = 1\n  }\n\n  for (let i = 1; i < n; i++) {\n    for (let j = 0; j < n - i; j++) {\n      const col = j + i\n      if (s[j] === s[col]) {\n        dp[j][col] = 2 + dp[j + 1][col - 1]\n      } else {\n        dp[j][col] = Math.max(dp[j][col - 1], dp[j + 1][col])\n      }\n    }\n  }\n\n  return dp[0][n - 1]\n}\n\nconst main = () => {\n  console.log(longestPalindromeSubsequence('bbbab')) // 4\n  console.log(longestPalindromeSubsequence('axbya')) // 3\n  console.log(longestPalindromeSubsequence('racexyzcxar')) // 7\n}\n\nmain()\n","index":54},{"title":"Longest Valid Parentheses","category":"Dynamic-Programming","id":"LongestValidParentheses_Dynamic-Programming","algorithm":"/*\n  LeetCode -> https://leetcode.com/problems/longest-valid-parentheses/\n\n  Given a string containing just the characters '(' and ')',\n  find the length of the longest valid (well-formed) parentheses substring.\n*/\n\nconst longestValidParentheses = (s) => {\n  const n = s.length\n  const stack = []\n\n  // storing results\n  const res = new Array(n).fill(-Infinity)\n\n  for (let i = 0; i < n; i++) {\n    const bracket = s[i]\n\n    if (bracket === ')' && s[stack[stack.length - 1]] === '(') {\n      res[i] = 1\n      res[stack[stack.length - 1]] = 1\n      stack.pop()\n    } else {\n      stack.push(i)\n    }\n  }\n\n  // summing all adjacent valid\n  for (let i = 1; i < n; i++) {\n    res[i] = Math.max(res[i], res[i] + res[i - 1])\n  }\n\n  // adding 0 if there are none so it will return 0 instead of -Infinity\n  res.push(0)\n  return Math.max(...res)\n}\n\nconst main = () => {\n  console.log(longestValidParentheses(')()())')) // output -> 4\n  console.log(longestValidParentheses('')) // output -> 0\n  console.log(longestValidParentheses('(()')) // output -> 2\n}\n\nmain()\n","index":55},{"title":"Max Non Adjacent Sum","category":"Dynamic-Programming","id":"MaxNonAdjacentSum_Dynamic-Programming","algorithm":"function maximumNonAdjacentSum (nums) {\n  /*\n         * Find the maximum non-adjacent sum of the integers in the nums input list\n         * :param nums: Array of Numbers\n         * :return: The maximum non-adjacent sum\n    */\n\n  if (nums.length < 0) return 0\n\n  let maxIncluding = nums[0]\n  let maxExcluding = 0\n\n  for (const num of nums.slice(1)) {\n    const temp = maxIncluding\n    maxIncluding = maxExcluding + num\n    maxExcluding = Math.max(temp, maxExcluding)\n  }\n\n  return Math.max(maxExcluding, maxIncluding)\n}\n\nfunction main () {\n  console.log(maximumNonAdjacentSum([1, 2, 3]))\n  console.log(maximumNonAdjacentSum([1, 5, 3, 7, 2, 2, 6]))\n  console.log(maximumNonAdjacentSum([-1, -5, -3, -7, -2, -2, -6]))\n  console.log(maximumNonAdjacentSum([499, 500, -3, -7, -2, -2, -6]))\n}\n\nmain()\n","index":56},{"title":"Minimum Cost Path","category":"Dynamic-Programming","id":"MinimumCostPath_Dynamic-Programming","algorithm":"// Problem Statement => https://www.youtube.com/watch?v=lBRtnuxg-gU\n\nconst minCostPath = (matrix) => {\n  /*\n        Find the min cost path from top-left to bottom-right in matrix\n        >>> minCostPath([[2, 1], [3, 1], [4, 2]])\n        >>> 6\n    */\n\n  const n = matrix.length\n  const m = matrix[0].length\n\n  // moves[i][j] => minimum number of moves to reach cell i, j\n  const moves = new Array(n)\n  for (let i = 0; i < moves.length; i++) moves[i] = new Array(m)\n\n  // base conditions\n  moves[0][0] = matrix[0][0] // to reach cell (0, 0) from (0, 0) is of no moves\n  for (let i = 1; i < m; i++) moves[0][i] = moves[0][i - 1] + matrix[0][i]\n  for (let i = 1; i < n; i++) moves[i][0] = moves[i - 1][0] + matrix[i][0]\n\n  for (let i = 1; i < n; i++) {\n    for (let j = 1; j < m; j++) { moves[i][j] = Math.min(moves[i - 1][j], moves[i][j - 1]) + matrix[i][j] }\n  }\n\n  return moves[n - 1][m - 1]\n}\n\nconst main = () => {\n  console.log(\n    minCostPath([\n      [2, 1],\n      [3, 1],\n      [4, 2]\n    ])\n  )\n  console.log(\n    minCostPath([\n      [2, 1, 4],\n      [2, 1, 3],\n      [3, 2, 1]\n    ])\n  )\n}\n\nmain()\n","index":57},{"title":"Number Of Subset Equal To Given Sum","category":"Dynamic-Programming","id":"NumberOfSubsetEqualToGivenSum_Dynamic-Programming","algorithm":"/*\nGiven an array of non-negative integers and a value sum,\ndetermine the total number of the subset with sum\nequal to the given sum.\n*/\n/*\n Given solution is O(n*sum) Time complexity and O(sum) Space complexity\n*/\nfunction NumberOfSubsetSum (array, sum) {\n  const dp = [] // create an dp array where dp[i] denote number of subset with sum equal to i\n  for (let i = 1; i <= sum; i++) {\n    dp[i] = 0\n  }\n  dp[0] = 1 // since sum equal to 0 is always possible with no element in subset\n\n  for (let i = 0; i < array.length; i++) {\n    for (let j = sum; j >= array[i]; j--) {\n      if (j - array[i] >= 0) {\n        dp[j] += dp[j - array[i]]\n      }\n    }\n  }\n  return dp[sum]\n}\n\nfunction main () {\n  const array = [1, 1, 2, 2, 3, 1, 1]\n  const sum = 4\n  const result = NumberOfSubsetSum(array, sum)\n  console.log(result)\n}\nmain()\n","index":58},{"title":"Sieve Of Eratosthenes","category":"Dynamic-Programming","id":"SieveOfEratosthenes_Dynamic-Programming","algorithm":"function sieveOfEratosthenes (n) {\n  /*\n     * Calculates prime numbers till a number n\n     * :param n: Number upto which to calculate primes\n     * :return: A boolean list contaning only primes\n     */\n  const primes = new Array(n + 1)\n  primes.fill(true) // set all as true initially\n  primes[0] = primes[1] = false // Handling case for 0 and 1\n  const sqrtn = Math.ceil(Math.sqrt(n))\n  for (let i = 2; i <= sqrtn; i++) {\n    if (primes[i]) {\n      for (let j = 2 * i; j <= n; j += i) {\n        primes[j] = false\n      }\n    }\n  }\n  return primes\n}\n\nfunction main () {\n  const n = 69 // number till where we wish to find primes\n  const primes = sieveOfEratosthenes(n)\n  for (let i = 2; i <= n; i++) {\n    if (primes[i]) {\n      console.log(i)\n    }\n  }\n}\n\nmain()\n","index":59},{"title":"Sudoku Solver","category":"Dynamic-Programming","id":"SudokuSolver_Dynamic-Programming","algorithm":"const _board = [\n  ['.', '9', '.', '.', '4', '2', '1', '3', '6'],\n  ['.', '.', '.', '9', '6', '.', '4', '8', '5'],\n  ['.', '.', '.', '5', '8', '1', '.', '.', '.'],\n  ['.', '.', '4', '.', '.', '.', '.', '.', '.'],\n  ['5', '1', '7', '2', '.', '.', '9', '.', '.'],\n  ['6', '.', '2', '.', '.', '.', '3', '7', '.'],\n  ['1', '.', '.', '8', '.', '4', '.', '2', '.'],\n  ['7', '.', '6', '.', '.', '.', '8', '1', '.'],\n  ['3', '.', '.', '.', '9', '.', '.', '.', '.']\n]\n\nconst isValid = (board, row, col, k) => {\n  for (let i = 0; i < 9; i++) {\n    const m = 3 * Math.floor(row / 3) + Math.floor(i / 3)\n    const n = 3 * Math.floor(col / 3) + i % 3\n    if (board[row][i] === k || board[i][col] === k || board[m][n] === k) {\n      return false\n    }\n  }\n  return true\n}\n\nconst sodokoSolver = (data) => {\n  for (let i = 0; i < 9; i++) {\n    for (let j = 0; j < 9; j++) {\n      if (data[i][j] === '.') {\n        for (let k = 1; k <= 9; k++) {\n          if (isValid(data, i, j, k)) {\n            data[i][j] = `${k}`\n            if (sodokoSolver(data)) {\n              return true\n            } else {\n              data[i][j] = '.'\n            }\n          }\n        }\n        return false\n      }\n    }\n  }\n  return true\n}\n\n// testing\n(() => {\n  if (sodokoSolver(_board)) {\n    console.log(_board)\n  }\n})()\n","index":60},{"title":"Trapping Rain Water","category":"Dynamic-Programming","id":"TrappingRainWater_Dynamic-Programming","algorithm":"/**\n * @param {number[]} height\n * @return {number}\n */\n\n/* 42. Trapping Rain Water\nhttps://leetcode.com/problems/trapping-rain-water/\n\nHelpful animation of this prompt: https://youtu.be/HmBbcDiJapY?t=51\n\nGiven n non-negative integers representing an elevation map where\nthe width of each bar is 1, compute how much water it is able to trap\nafter raining.\n\nVIEW ELEVATION MAP ON LEETCODE\n\nExample:\n\nInput:            [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6\n\nPlan:\niterate through and find left maxes\niterate through and find right maxes\ncreate minheight and assign it to the min(leftmax, rightmax)\nif current height(element) < minheight\n  push minheight - height into water array\nelse\n  push 0 onto water array\n\nsum up water array and return\n\nleft maxes =      [0,0,1,1,2,2,2,2,3,3,3,3]\nright maxes =     [3,3,3,3,3,3,3,2,2,2,1,0]\nwater contained = [0,0,1,0,1,2,1,0,0,1,0,0] -> sum = 6\n*/\n\nfunction trap (heights) {\n  const maxes = new Array(heights.length).fill(0)\n\n  let leftMax = 0\n  for (let i = 0; i < heights.length; i++) {\n    const height = heights[i]\n    maxes[i] = leftMax\n    leftMax = Math.max(leftMax, height)\n  }\n\n  let rightMax = 0\n  for (let i = heights.length - 1; i >= 0; i -= 1) {\n    const height = heights[i]\n    const minHeight = Math.min(rightMax, maxes[i])\n\n    if (height < minHeight) {\n      maxes[i] = minHeight - height\n    } else {\n      maxes[i] = 0\n    }\n    rightMax = Math.max(rightMax, height)\n  }\n  return maxes.reduce((a, b) => a + b, 0)\n}\n\nconsole.log(trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1])) // -> 6\n","index":61},{"title":"Zero One Knapsack","category":"Dynamic-Programming","id":"ZeroOneKnapsack_Dynamic-Programming","algorithm":"/**\n * A Dynamic Programming based solution for calculating Zero One Knapsack\n * https://en.wikipedia.org/wiki/Knapsack_problem\n */\n\nconst zeroOneKnapsack = (arr, n, cap, cache) => {\n  if (cap === 0 || n === 0) {\n    cache[n][cap] = 0\n    return cache[n][cap]\n  }\n  if (cache[n][cap] !== -1) {\n    return cache[n][cap]\n  }\n  if (arr[n - 1][0] <= cap) {\n    cache[n][cap] = Math.max(arr[n - 1][1] + zeroOneKnapsack(arr, n - 1, cap - arr[n - 1][0], cache), zeroOneKnapsack(arr, n - 1, cap, cache))\n    return cache[n][cap]\n  } else {\n    cache[n][cap] = zeroOneKnapsack(arr, n - 1, cap, cache)\n    return cache[n][cap]\n  }\n}\n\nconst main = () => {\n  /*\n  Problem Statement:\n  You are a thief carrying a single bag with limited capacity S. The museum you stole had N artifact that you could steal. Unfortunately you might not be able to steal all the artifact because of your limited bag capacity.\n  You have to cherry pick the artifact in order to maximize the total value of the artifacts you stole.\n\n  Link for the Problem: https://www.hackerrank.com/contests/srin-aadc03/challenges/classic-01-knapsack\n  */\n  let input = `1\n    4 5\n    1 8\n    2 4\n    3 0\n    2 5\n    2 3`\n\n  input = input.trim().split('\\n')\n  input.shift()\n  const length = input.length\n\n  let i = 0\n  while (i < length) {\n    const cap = Number(input[i].trim().split(' ')[0])\n    const currlen = Number(input[i].trim().split(' ')[1])\n    let j = i + 1\n    const arr = []\n    while (j <= i + currlen) {\n      arr.push(input[j])\n      j++\n    }\n    const newArr = []\n    arr.map(e => {\n      newArr.push(e.trim().split(' ').map(Number))\n    })\n    const cache = []\n    for (let i = 0; i <= currlen; i++) {\n      const temp = []\n      for (let j = 0; j <= cap; j++) {\n        temp.push(-1)\n      }\n      cache.push(temp)\n    }\n    const result = zeroOneKnapsack(newArr, currlen, cap, cache)\n    console.log(result)\n    i += currlen + 1\n  }\n}\n\nmain()\n","index":62},{"title":"Graphs","category":null,"id":"Graphs","index":63},{"title":"Connected Components","category":"Graphs","id":"ConnectedComponents_Graphs","algorithm":"class GraphUnweightedUndirectedAdjacencyList {\n  // Unweighted Undirected Graph class\n  constructor () {\n    this.connections = {}\n  }\n\n  addNode (node) {\n    // Function to add a node to the graph (connection represented by set)\n    this.connections[node] = new Set()\n  }\n\n  addEdge (node1, node2) {\n    // Function to add an edge (adds the node too if they are not present in the graph)\n    if (!(node1 in this.connections)) { this.addNode(node1) }\n    if (!(node2 in this.connections)) { this.addNode(node2) }\n    this.connections[node1].add(node2)\n    this.connections[node2].add(node1)\n  }\n\n  DFSComponent (components, node, visited) {\n    // Helper function to populate the visited set with the nodes in each component\n\n    // adding the first visited node in the component to the array\n    components.push(node)\n    const stack = [node]\n    // populating the visited set using DFS (Iterative)\n    while (stack.length > 0) {\n      const curr = stack.pop()\n      visited.add(curr.toString())\n      for (const neighbour of this.connections[curr].keys()) {\n        if (!visited.has(neighbour.toString())) { stack.push(neighbour) }\n      }\n    }\n  }\n\n  connectedComponents () {\n    // Function to generate the Connected Components\n    // Result is an array containing 1 node from each component\n    const visited = new Set()\n    const components = []\n    for (const node of Object.keys(this.connections)) {\n      if (!visited.has(node.toString())) { this.DFSComponent(components, node, visited) }\n    }\n    return components\n  }\n}\n\nfunction main () {\n  const graph = new GraphUnweightedUndirectedAdjacencyList()\n  graph.addEdge(1, 2) // Component 1\n  graph.addEdge(3, 4) // Component 2\n  graph.addEdge(3, 5) // Component 2\n  console.log(graph.connectedComponents())\n}\n\nmain()\n","index":64},{"title":"Depth First Search Iterative","category":"Graphs","id":"DepthFirstSearchIterative_Graphs","algorithm":"class GraphUnweightedUndirected {\n  // Unweighted Undirected Graph class\n  constructor () {\n    this.connections = {}\n  }\n\n  addNode (node) {\n    // Function to add a node to the graph (connection represented by set)\n    this.connections[node] = new Set()\n  }\n\n  addEdge (node1, node2) {\n    // Function to add an edge (adds the node too if they are not present in the graph)\n    if (!(node1 in this.connections)) { this.addNode(node1) }\n    if (!(node2 in this.connections)) { this.addNode(node2) }\n    this.connections[node1].add(node2)\n    this.connections[node2].add(node1)\n  }\n\n  DFSIterative (node, value) {\n    // DFS Function to search if a node with the given value is present in the graph\n    const stack = [node]\n    const visited = new Set()\n    while (stack.length > 0) {\n      const currNode = stack.pop()\n      // if the current node contains the value being searched for, true is returned\n      if (currNode === value) { return true }\n      // adding the current node to the visited set\n      visited.add(currNode)\n      // adding neighbours in the stack\n      for (const neighbour of this.connections[currNode]) {\n        if (!visited.has(neighbour)) {\n          stack.push(neighbour)\n        }\n      }\n    }\n    return false\n  }\n}\n\nfunction main () {\n  const graph = new GraphUnweightedUndirected()\n  graph.addEdge(1, 2)\n  graph.addEdge(2, 3)\n  graph.addEdge(2, 4)\n  graph.addEdge(3, 5)\n  console.log(graph.DFSIterative(5, 1))\n  console.log(graph.DFSIterative(5, 100))\n}\n\nmain()\n","index":65},{"title":"Depth First Search Recursive","category":"Graphs","id":"DepthFirstSearchRecursive_Graphs","algorithm":"class GraphUnweightedUndirected {\n  // Unweighted Undirected Graph class\n  constructor () {\n    this.connections = {}\n  }\n\n  addNode (node) {\n    // Function to add a node to the graph (connection represented by set)\n    this.connections[node] = new Set()\n  }\n\n  addEdge (node1, node2) {\n    // Function to add an edge (adds the node too if they are not present in the graph)\n    if (!(node1 in this.connections)) { this.addNode(node1) }\n    if (!(node2 in this.connections)) { this.addNode(node2) }\n    this.connections[node1].add(node2)\n    this.connections[node2].add(node1)\n  }\n\n  DFSRecursive (node, value, visited = new Set()) {\n    // DFS Function to search if a node with the given value is present in the graph\n    // checking if the searching node has been found\n    if (node === value) { return true }\n    // adding the current node to the visited set\n    visited.add(node)\n    // calling the helper function recursivly for all unvisited nodes\n    for (const neighbour of this.connections[node]) {\n      if (!visited.has(neighbour)) {\n        if (this.DFSRecursive(neighbour, value, visited)) { return true }\n      }\n    }\n    return false\n  }\n}\n\nfunction main () {\n  const graph = new GraphUnweightedUndirected()\n  graph.addEdge(1, 2)\n  graph.addEdge(2, 3)\n  graph.addEdge(2, 4)\n  graph.addEdge(3, 5)\n  console.log(graph.DFSRecursive(5, 1))\n  console.log(graph.DFSRecursive(5, 100))\n}\n\nmain()\n","index":66},{"title":"Dijkstra","category":"Graphs","id":"Dijkstra_Graphs","algorithm":"/**\n * Author: Samarth Jain\n * Dijkstra's Algorithm implementation in JavaScript\n * Dijkstra's Algorithm calculates the minimum distance between two nodes.\n * It is used to find the shortes path.\n * It uses graph data structure.\n */\n\nfunction createGraph (V, E) {\n  // V - Number of vertices in graph\n  // E - Number of edges in graph (u,v,w)\n  const adjList = [] // Adjacency list\n  for (let i = 0; i < V; i++) {\n    adjList.push([])\n  }\n  for (let i = 0; i < E.length; i++) {\n    adjList[E[i][0]].push([E[i][1], E[i][2]])\n    adjList[E[i][1]].push([E[i][0], E[i][2]])\n  }\n  return adjList\n}\n\nfunction djikstra (graph, V, src) {\n  const vis = Array(V).fill(0)\n  const dist = []\n  for (let i = 0; i < V; i++) dist.push([10000, -1])\n  dist[src][0] = 0\n\n  for (let i = 0; i < V - 1; i++) {\n    let mn = -1\n    for (let j = 0; j < V; j++) {\n      if (vis[j] === 0) {\n        if (mn === -1 || dist[j][0] < dist[mn][0]) mn = j\n      }\n    }\n\n    vis[mn] = 1\n    for (let j = 0; j < graph[mn].length; j++) {\n      const edge = graph[mn][j]\n      if (vis[edge[0]] === 0 && dist[edge[0]][0] > dist[mn][0] + edge[1]) {\n        dist[edge[0]][0] = dist[mn][0] + edge[1]\n        dist[edge[0]][1] = mn\n      }\n    }\n  }\n\n  return dist\n}\n\nconst V = 9\nconst E = [\n  [0, 1, 4],\n  [0, 7, 8],\n  [1, 7, 11],\n  [1, 2, 8],\n  [7, 8, 7],\n  [6, 7, 1],\n  [2, 8, 2],\n  [6, 8, 6],\n  [5, 6, 2],\n  [2, 5, 4],\n  [2, 3, 7],\n  [3, 5, 14],\n  [3, 4, 9],\n  [4, 5, 10]\n]\n\nconst graph = createGraph(V, E)\nconst distances = djikstra(graph, V, 0)\n\n/**\n * The first value in the array determines the minimum distance and the\n * second value represents the parent node from which the minimum distance has been calculated\n */\n\nconsole.log(distances)\n","index":67},{"title":"Dijkstra Smallest Path","category":"Graphs","id":"DijkstraSmallestPath_Graphs","algorithm":"// starting at s\nfunction solve (graph, s) {\n  const solutions = {}\n  solutions[s] = []\n  solutions[s].dist = 0\n\n  while (true) {\n    let p = null\n    let neighbor = null\n    let dist = Infinity\n\n    for (const n in solutions) {\n      if (!solutions[n]) { continue }\n      const ndist = solutions[n].dist\n      const adj = graph[n]\n\n      for (const a in adj) {\n        if (solutions[a]) { continue }\n\n        const d = adj[a] + ndist\n        if (d < dist) {\n          p = solutions[n]\n          neighbor = a\n          dist = d\n        }\n      }\n    }\n\n    // no more solutions\n    if (dist === Infinity) {\n      break\n    }\n\n    // extend parent's solution path\n    solutions[neighbor] = p.concat(neighbor)\n    // extend parent's cost\n    solutions[neighbor].dist = dist\n  }\n\n  return solutions\n}\n// create graph\nconst graph = {}\n\nconst layout = {\n  R: ['2'],\n  2: ['3', '4'],\n  3: ['4', '6', '13'],\n  4: ['5', '8'],\n  5: ['7', '11'],\n  6: ['13', '15'],\n  7: ['10'],\n  8: ['11', '13'],\n  9: ['14'],\n  10: [],\n  11: ['12'],\n  12: [],\n  13: ['14'],\n  14: [],\n  15: []\n}\n\n// convert uni-directional to bi-directional graph\n// let  graph = {\n//     a: {e:1, b:1, g:3},\n//     b: {a:1, c:1},\n//     c: {b:1, d:1},\n//     d: {c:1, e:1},\n//     e: {d:1, a:1},\n//     f: {g:1, h:1},\n//     g: {a:3, f:1},\n//     h: {f:1}\n// };\n\nfor (const id in layout) {\n  if (!graph[id]) { graph[id] = {} }\n  layout[id].forEach(function (aid) {\n    graph[id][aid] = 1\n    if (!graph[aid]) { graph[aid] = {} }\n    graph[aid][id] = 1\n  })\n}\n\n// choose start node\nconst start = '10'\n// get all solutions\nconst solutions = solve(graph, start)\n\nconsole.log(\"From '\" + start + \"' to\")\n// display solutions\nfor (const s in solutions) {\n  if (!solutions[s]) continue\n  console.log(' -> ' + s + ': [' + solutions[s].join(', ') + ']   (dist:' + solutions[s].dist + ')')\n}\n\n// From '10' to\n//  -> 2: [7, 5, 4, 2]   (dist:4)\n//  -> 3: [7, 5, 4, 3]   (dist:4)\n//  -> 4: [7, 5, 4]   (dist:3)\n//  -> 5: [7, 5]   (dist:2)\n//  -> 6: [7, 5, 4, 3, 6]   (dist:5)\n//  -> 7: [7]   (dist:1)\n//  -> 8: [7, 5, 4, 8]   (dist:4)\n//  -> 9: [7, 5, 4, 3, 13, 14, 9]   (dist:7)\n//  -> 10: []   (dist:0)\n//  -> 11: [7, 5, 11]   (dist:3)\n//  -> 12: [7, 5, 11, 12]   (dist:4)\n//  -> 13: [7, 5, 4, 3, 13]   (dist:5)\n//  -> 14: [7, 5, 4, 3, 13, 14]   (dist:6)\n//  -> 15: [7, 5, 4, 3, 6, 15]   (dist:6)\n//  -> R: [7, 5, 4, 2, R]   (dist:5)\n","index":68},{"title":"Kruskal M S T","category":"Graphs","id":"KruskalMST_Graphs","algorithm":"class DisjointSetTreeNode {\n  // Disjoint Set Node to store the parent and rank\n  constructor (key) {\n    this.key = key\n    this.parent = this\n    this.rank = 0\n  }\n}\n\nclass DisjointSetTree {\n  // Disjoint Set DataStructure\n  constructor () {\n    // map to from node name to the node object\n    this.map = {}\n  }\n\n  makeSet (x) {\n    // Function to create a new set with x as its member\n    this.map[x] = new DisjointSetTreeNode(x)\n  }\n\n  findSet (x) {\n    // Function to find the set x belongs to (with path-compression)\n    if (this.map[x] !== this.map[x].parent) {\n      this.map[x].parent = this.findSet(this.map[x].parent.key)\n    }\n    return this.map[x].parent\n  }\n\n  union (x, y) {\n    // Function to merge 2 disjoint sets\n    this.link(this.findSet(x), this.findSet(y))\n  }\n\n  link (x, y) {\n    // Helper function for union operation\n    if (x.rank > y.rank) {\n      y.parent = x\n    } else {\n      x.parent = y\n      if (x.rank === y.rank) {\n        y.rank += 1\n      }\n    }\n  }\n}\n\nclass GraphWeightedUndirectedAdjacencyList {\n  // Weighted Undirected Graph class\n  constructor () {\n    this.connections = {}\n    this.nodes = 0\n  }\n\n  addNode (node) {\n    // Function to add a node to the graph (connection represented by set)\n    this.connections[node] = {}\n    this.nodes += 1\n  }\n\n  addEdge (node1, node2, weight) {\n    // Function to add an edge (adds the node too if they are not present in the graph)\n    if (!(node1 in this.connections)) { this.addNode(node1) }\n    if (!(node2 in this.connections)) { this.addNode(node2) }\n    this.connections[node1][node2] = weight\n    this.connections[node2][node1] = weight\n  }\n\n  KruskalMST () {\n    // Kruskal's Algorithm to generate a Minimum Spanning Tree (MST) of a graph\n    // Details: https://en.wikipedia.org/wiki/Kruskal%27s_algorithm\n    // getting the edges in ascending order of weights\n    const edges = []\n    const seen = new Set()\n    for (const start of Object.keys(this.connections)) {\n      for (const end of Object.keys(this.connections[start])) {\n        if (!seen.has(`${start} ${end}`)) {\n          seen.add(`${end} ${start}`)\n          edges.push([start, end, this.connections[start][end]])\n        }\n      }\n    }\n    edges.sort((a, b) => a[2] - b[2])\n    // creating the disjoint set\n    const disjointSet = new DisjointSetTree()\n    Object.keys(this.connections).forEach(node => disjointSet.makeSet(node))\n    // MST generation\n    const graph = new GraphWeightedUndirectedAdjacencyList()\n    let numEdges = 0\n    let index = 0\n    while (numEdges < this.nodes - 1) {\n      const [u, v, w] = edges[index]\n      index += 1\n      if (disjointSet.findSet(u) !== disjointSet.findSet(v)) {\n        numEdges += 1\n        graph.addEdge(u, v, w)\n        disjointSet.union(u, v)\n      }\n    }\n    return graph\n  }\n}\n\nfunction main () {\n  const graph = new GraphWeightedUndirectedAdjacencyList()\n  graph.addEdge(1, 2, 1)\n  graph.addEdge(2, 3, 2)\n  graph.addEdge(3, 4, 1)\n  graph.addEdge(3, 5, 100) // Removed in MST\n  graph.addEdge(4, 5, 5)\n  console.log(graph)\n  console.log(graph.KruskalMST())\n}\n\nmain()\n","index":69},{"title":"Number Of Islands","category":"Graphs","id":"NumberOfIslands_Graphs","algorithm":"/* Number of Islands\nhttps://dev.to/rattanakchea/amazons-interview-question-count-island-21h6\nGiven a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\n\ntwo a dimensial grid map\neach element is going to represent a peice of land\n1 is land,\n0 is water\noutput a number which is the number of islands\n\nExample 1:\n  Input:\n  11110\n  11010\n  11000\n  00000\n\n  Output: 1\n\nExample 2:\n  Input:\n  11000\n  11000\n  00100\n  00011\n\n  Output: 3\n\nI: two dimensional array\nO: a single integer; total number of islands\n\nPseudocode:\n  OUTER FUNCTION\n    set count to 0\n\n    INNER FUNCTION - flood (col, row)\n      if the tile is water\n        return\n      make tile water(flood tile)\n      invoke flood on the neighbor coordinates\n\n    iterate over the matrix (col, row)\n      if the current element is a 1\n        increment count\n        invoke flood (coordinates for col and row)\n\n    Return the count\n*/\nconst grid = [\n  ['1', '1', '0', '0', '0'],\n  ['1', '1', '0', '0', '0'],\n  ['0', '0', '1', '0', '0'],\n  ['0', '0', '0', '1', '1']\n]\n\nconst islands = (matrixGrid) => {\n  const matrix = matrixGrid\n  let counter = 0\n\n  const flood = (row, col) => {\n    if (row < 0 || col < 0) return // Off the map above or left\n    if (row >= matrix.length || col >= matrix[row].length) return // Off the map below or right\n\n    const tile = matrix[row][col]\n    if (tile !== '1') return\n\n    matrix[row][col] = '0'\n\n    flood(row + 1, col) // Down\n    flood(row - 1, col) // Up\n    flood(row, col + 1) // Right\n    flood(row, col - 1) // Left\n  }\n\n  for (let row = 0; row < matrix.length; row += 1) {\n    for (let col = 0; col < matrix[row].length; col += 1) {\n      const current = matrix[row][col]\n      if (current === '1') {\n        flood(row, col)\n        counter += 1\n      }\n    }\n  }\n  return counter\n}\nconsole.log(islands(grid))\n","index":70},{"title":"Prim M S T","category":"Graphs","id":"PrimMST_Graphs","algorithm":"// Priority Queue Helper functions\nfunction getParentPosition (position) {\n  // Get the parent node of the current node\n  return Math.floor((position - 1) / 2)\n}\nfunction getChildrenPosition (position) {\n  // Get the children nodes of the current node\n  return [2 * position + 1, 2 * position + 2]\n}\n\nclass PriorityQueue {\n  // Priority Queue class using Minimum Binary Heap\n  constructor () {\n    this._heap = []\n    this.keys = {}\n  }\n\n  isEmpty () {\n    // Checking if the heap is empty\n    return this._heap.length === 0\n  }\n\n  push (key, priority) {\n    // Adding element to the queue (equivalent to add)\n    this._heap.push([key, priority])\n    this.keys[key] = this._heap.length - 1\n    this._shiftUp(this.keys[key])\n  }\n\n  pop () {\n    // Removing the element with least priority (equivalent to extractMin)\n    this._swap(0, this._heap.length - 1)\n    const [key] = this._heap.pop()\n    delete this.keys[key]\n    this._shiftDown(0)\n    return key\n  }\n\n  contains (key) {\n    // Check if a given key is present in the queue\n    return (key in this.keys)\n  }\n\n  update (key, priority) {\n    // Update the priority of the given element (equivalent to decreaseKey)\n    const currPos = this.keys[key]\n    this._heap[currPos][1] = priority\n    const parentPos = getParentPosition(currPos)\n    const currPriority = this._heap[currPos][1]\n    let parentPriority = Infinity\n    if (parentPos >= 0) {\n      parentPriority = this._heap[parentPos][1]\n    }\n    const [child1Pos, child2Pos] = getChildrenPosition(currPos)\n    let [child1Priority, child2Priority] = [Infinity, Infinity]\n    if (child1Pos < this._heap.length) {\n      child1Priority = this._heap[child1Pos][1]\n    }\n    if (child2Pos < this._heap.length) {\n      child2Priority = this._heap[child2Pos][1]\n    }\n\n    if (parentPos >= 0 && parentPriority > currPriority) {\n      this._shiftUp(currPos)\n    } else if (child2Pos < this._heap.length &&\n      (child1Priority < currPriority || child2Priority < currPriority)) {\n      this._shiftDown(currPos)\n    }\n  }\n\n  _shiftUp (position) {\n    // Helper function to shift up a node to proper position (equivalent to bubbleUp)\n    let currPos = position\n    let parentPos = getParentPosition(currPos)\n    let currPriority = this._heap[currPos][1]\n    let parentPriority = Infinity\n    if (parentPos >= 0) {\n      parentPriority = this._heap[parentPos][1]\n    }\n\n    while (parentPos >= 0 && parentPriority > currPriority) {\n      this._swap(currPos, parentPos)\n      currPos = parentPos\n      parentPos = getParentPosition(currPos)\n      currPriority = this._heap[currPos][1]\n      try {\n        parentPriority = this._heap[parentPos][1]\n      } catch (error) {\n        parentPriority = Infinity\n      }\n    }\n    this.keys[this._heap[currPos][0]] = currPos\n  }\n\n  _shiftDown (position) {\n    // Helper function to shift down a node to proper position (equivalent to bubbleDown)\n    let currPos = position\n    let [child1Pos, child2Pos] = getChildrenPosition(currPos)\n    let [child1Priority, child2Priority] = [Infinity, Infinity]\n    if (child1Pos < this._heap.length) {\n      child1Priority = this._heap[child1Pos][1]\n    }\n    if (child2Pos < this._heap.length) {\n      child2Priority = this._heap[child2Pos][1]\n    }\n    let currPriority\n    try {\n      currPriority = this._heap[currPos][1]\n    } catch {\n      return\n    }\n\n    while (child2Pos < this._heap.length &&\n      (child1Priority < currPriority || child2Priority < currPriority)) {\n      if (child1Priority < currPriority && child1Priority < child2Priority) {\n        this._swap(child1Pos, currPos)\n        currPos = child1Pos\n      } else {\n        this._swap(child2Pos, currPos)\n        currPos = child2Pos\n      }\n      [child1Pos, child2Pos] = getChildrenPosition(currPos)\n      try {\n        [child1Priority, child2Priority] = [this._heap[child1Pos][1], this._heap[child2Pos][1]]\n      } catch (error) {\n        [child1Priority, child2Priority] = [Infinity, Infinity]\n      }\n\n      currPriority = this._heap[currPos][1]\n    }\n    this.keys[this._heap[currPos][0]] = currPos\n    if (child1Pos < this._heap.length && child1Priority < currPriority) {\n      this._swap(child1Pos, currPos)\n      this.keys[this._heap[child1Pos][0]] = child1Pos\n    }\n  }\n\n  _swap (position1, position2) {\n    // Helper function to swap 2 nodes\n    [this._heap[position1], this._heap[position2]] = [this._heap[position2], this._heap[position1]]\n    this.keys[this._heap[position1][0]] = position1\n    this.keys[this._heap[position2][0]] = position2\n  }\n}\n\nclass GraphWeightedUndirectedAdjacencyList {\n  // Weighted Undirected Graph class\n  constructor () {\n    this.connections = {}\n  }\n\n  addNode (node) {\n    // Function to add a node to the graph (connection represented by set)\n    this.connections[node] = {}\n  }\n\n  addEdge (node1, node2, weight) {\n    // Function to add an edge (adds the node too if they are not present in the graph)\n    if (!(node1 in this.connections)) { this.addNode(node1) }\n    if (!(node2 in this.connections)) { this.addNode(node2) }\n    this.connections[node1][node2] = weight\n    this.connections[node2][node1] = weight\n  }\n\n  PrimMST (start) {\n    // Prim's Algorithm to generate a Minimum Spanning Tree (MST) of a graph\n    // Details: https://en.wikipedia.org/wiki/Prim%27s_algorithm\n    const distance = {}\n    const parent = {}\n    const priorityQueue = new PriorityQueue()\n    // Initialization\n    for (const node in this.connections) {\n      distance[node] = (node === start.toString() ? 0 : Infinity)\n      parent[node] = null\n      priorityQueue.push(node, distance[node])\n    }\n    // Updating 'distance' object\n    while (!priorityQueue.isEmpty()) {\n      const node = priorityQueue.pop()\n      Object.keys(this.connections[node]).forEach(neighbour => {\n        if (priorityQueue.contains(neighbour) && distance[node] + this.connections[node][neighbour] < distance[neighbour]) {\n          distance[neighbour] = distance[node] + this.connections[node][neighbour]\n          parent[neighbour] = node\n          priorityQueue.update(neighbour, distance[neighbour])\n        }\n      })\n    }\n\n    // MST Generation from the 'parent' object\n    const graph = new GraphWeightedUndirectedAdjacencyList()\n    Object.keys(parent).forEach(node => {\n      if (node && parent[node]) {\n        graph.addEdge(node, parent[node], this.connections[node][parent[node]])\n      }\n    })\n    return graph\n  }\n}\n\nfunction main () {\n  const graph = new GraphWeightedUndirectedAdjacencyList()\n  graph.addEdge(1, 2, 1)\n  graph.addEdge(2, 3, 2)\n  graph.addEdge(3, 4, 1)\n  graph.addEdge(3, 5, 100) // Removed in MST\n  graph.addEdge(4, 5, 5)\n  console.log(graph.PrimMST(1))\n}\n\nmain()\n","index":71},{"title":"Hashes","category":null,"id":"Hashes","index":72},{"title":"S H A1","category":"Hashes","id":"SHA1_Hashes","algorithm":"//= ===============================================================\n// SHA1.js\n//\n// Module that replicates the SHA-1 Cryptographic Hash\n// function in Javascript.\n//= ===============================================================\n\n// main variables\nconst CHAR_SIZE = 8\n\n/**\n * Adds padding to binary/hex string represention\n *\n * @param {string} str - string represention (binary/hex)\n * @param {int} bits - total number of bits wanted\n * @return {string} - string represention padding with empty (0) bits\n *\n * @example\n *      pad(\"10011\", 8); // \"00010011\"\n */\nfunction pad (str, bits) {\n  let res = str\n  while (res.length % bits !== 0) {\n    res = '0' + res\n  }\n  return res\n}\n\n/**\n * Separates string into chunks of the same size\n *\n * @param {string} str - string to separate into chunks\n * @param {int} size - number of characters wanted in each chunk\n * @return {array} - array of original string split into chunks\n *\n * @example\n *      chunkify(\"this is a test\", 2); // [\"th\", \"is\", \" i\", \"s \", \"a \", \"te\", \"st\"]\n */\nfunction chunkify (str, size) {\n  const chunks = []\n  for (let i = 0; i < str.length; i += size) {\n    chunks.push(str.slice(i, i + size))\n  }\n  return chunks\n}\n\n/**\n * Rotates string representation of bits to the left\n *\n * @param {string} bits - string representation of bits\n * @param {int} turns - number of rotations to make\n * @return {string} - string representation of bits after rotation\n *\n * @example\n *      rotateLeft(\"1011\", 3); // \"1101\"\n */\nfunction rotateLeft (bits, turns) {\n  return bits.substr(turns) + bits.substr(0, turns)\n}\n\n/**\n * Pre-processes message to feed the algorithm loop\n *\n * @param {string} message - message to pre-process\n * @return {string} - processed message\n */\nfunction preProcess (message) {\n  // convert message to binary representation padded to\n  // 8 bits, and add 1\n  let m = message.split('')\n    .map(e => e.charCodeAt(0))\n    .map(e => e.toString(2))\n    .map(e => pad(e, 8))\n    .join('') + '1'\n\n  // extend message by adding empty bits (0)\n  while (m.length % 512 !== 448) {\n    m += '0'\n  }\n\n  // length of message in binary, padded, and extended\n  // to a 64 bit representation\n  let ml = (message.length * CHAR_SIZE).toString(2)\n  ml = pad(ml, 8)\n  ml = '0'.repeat(64 - ml.length) + ml\n\n  return m + ml\n}\n\n/**\n * Hashes message using SHA-1 Cryptographic Hash Function\n *\n * @param {string} message - message to hash\n * @return {string} - message digest (hash value)\n */\nfunction SHA1 (message) {\n  // main variables\n  let H0 = 0x67452301\n  let H1 = 0xEFCDAB89\n  let H2 = 0x98BADCFE\n  let H3 = 0x10325476\n  let H4 = 0xC3D2E1F0\n\n  // pre-process message and split into 512 bit chunks\n  const bits = preProcess(message)\n  const chunks = chunkify(bits, 512)\n\n  chunks.forEach(function (chunk, i) {\n    // break each chunk into 16 32-bit words\n    const words = chunkify(chunk, 32)\n\n    // extend 16 32-bit words to 80 32-bit words\n    for (let i = 16; i < 80; i++) {\n      const val = [words[i - 3], words[i - 8], words[i - 14], words[i - 16]]\n        .map(e => parseInt(e, 2))\n        .reduce((acc, curr) => curr ^ acc, 0)\n      const bin = (val >>> 0).toString(2)\n      const paddedBin = pad(bin, 32)\n      const word = rotateLeft(paddedBin, 1)\n      words.push(word)\n    }\n\n    // initialize variables for this chunk\n    let [a, b, c, d, e] = [H0, H1, H2, H3, H4]\n\n    for (let i = 0; i < 80; i++) {\n      let f, k\n      if (i < 20) {\n        f = (b & c) | (~b & d)\n        k = 0x5A827999\n      } else if (i < 40) {\n        f = b ^ c ^ d\n        k = 0x6ED9EBA1\n      } else if (i < 60) {\n        f = (b & c) | (b & d) | (c & d)\n        k = 0x8F1BBCDC\n      } else {\n        f = b ^ c ^ d\n        k = 0xCA62C1D6\n      }\n      // make sure f is unsigned\n      f >>>= 0\n\n      const aRot = rotateLeft(pad(a.toString(2), 32), 5)\n      const aInt = parseInt(aRot, 2) >>> 0\n      const wordInt = parseInt(words[i], 2) >>> 0\n      const t = aInt + f + e + k + wordInt\n      e = d >>> 0\n      d = c >>> 0\n      const bRot = rotateLeft(pad(b.toString(2), 32), 30)\n      c = parseInt(bRot, 2) >>> 0\n      b = a >>> 0\n      a = t >>> 0\n    }\n\n    // add values for this chunk to main hash variables (unsigned)\n    H0 = (H0 + a) >>> 0\n    H1 = (H1 + b) >>> 0\n    H2 = (H2 + c) >>> 0\n    H3 = (H3 + d) >>> 0\n    H4 = (H4 + e) >>> 0\n  })\n\n  // combine hash values of main hash variables and return\n  const HH = [H0, H1, H2, H3, H4]\n    .map(e => e.toString(16))\n    .map(e => pad(e, 8))\n    .join('')\n\n  return HH\n}\n\nconsole.log(SHA1('A Test'))\nconsole.log(SHA1('A Test'))\n\n// export SHA1 function\nmodule.exports = SHA1\n","index":73},{"title":"S H A256","category":"Hashes","id":"SHA256_Hashes","algorithm":"//= ===============================================================\n// SHA256.js\n//\n// Module that replicates the SHA-256 Cryptographic Hash\n// function in Javascript.\n//= ===============================================================\n\n// main variables\nconst CHAR_SIZE = 8\n\nconst K = [\n  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]\n\n/**\n * Adds padding to binary/hex string represention\n *\n * @param {string} str - string represention (binary/hex)\n * @param {int} bits - total number of bits wanted\n * @return {string} - string represention padding with empty (0) bits\n *\n * @example\n *      pad(\"10011\", 8); // \"00010011\"\n */\nfunction pad (str, bits) {\n  let res = str\n  while (res.length % bits !== 0) {\n    res = '0' + res\n  }\n  return res\n}\n\n/**\n * Separates string into chunks of the same size\n *\n * @param {string} str - string to separate into chunks\n * @param {int} size - number of characters wanted in each chunk\n * @return {array} - array of original string split into chunks\n *\n * @example\n *      chunkify(\"this is a test\", 2); // [\"th\", \"is\", \" i\", \"s \", \"a \", \"te\", \"st\"]\n */\nfunction chunkify (str, size) {\n  const chunks = []\n  for (let i = 0; i < str.length; i += size) {\n    chunks.push(str.slice(i, i + size))\n  }\n  return chunks\n}\n\n/**\n * Rotates string represention of bits to th left\n *\n * @param {string} bits - string representation of bits\n * @param {int} turns - number of rotations to make\n * @return {string} - string representation of bits after rotation\n *\n * @example\n *      rotateLeft(\"1011\", 3); // \"1101\"\n */\nfunction rotateRight (bits, turns) {\n  return bits.substr(bits.length - turns) + bits.substr(0, bits.length - turns)\n}\n\n/**\n * Pre-processes message to feed the algorithm loop\n *\n * @param {string} message - message to pre-process\n * @return {string} - processed message\n */\nfunction preProcess (message) {\n  // covert message to binary representation padded to\n  // 8 bits, and add 1\n  let m = message.split('')\n    .map(e => e.charCodeAt(0))\n    .map(e => e.toString(2))\n    .map(e => pad(e, 8))\n    .join('') + '1'\n\n  // extend message by adding empty bits (0)\n  while (m.length % 512 !== 448) {\n    m += '0'\n  }\n\n  // length of message in binary, padded, and extended\n  // to a 64 bit representation\n  let ml = (message.length * CHAR_SIZE).toString(2)\n  ml = pad(ml, 8)\n  ml = '0'.repeat(64 - ml.length) + ml\n\n  return m + ml\n}\n\n/**\n * Hashes message using SHA-256 Cryptographic Hash Function\n *\n * @param {string} message - message to hash\n * @return {string} - message digest (hash value)\n */\nfunction SHA256 (message) {\n  // initial hash variables\n  let H0 = 0x6a09e667\n  let H1 = 0xbb67ae85\n  let H2 = 0x3c6ef372\n  let H3 = 0xa54ff53a\n  let H4 = 0x510e527f\n  let H5 = 0x9b05688c\n  let H6 = 0x1f83d9ab\n  let H7 = 0x5be0cd19\n\n  // pre-process message and split into 512 bit chunks\n  const bits = preProcess(message)\n  const chunks = chunkify(bits, 512)\n\n  chunks.forEach(function (chunk, i) {\n    // break each chunk into 16 32-bit words\n    const words = chunkify(chunk, 32)\n\n    // extend 16 32-bit words to 80 32-bit words\n    for (let i = 16; i < 64; i++) {\n      const W1 = words[i - 15]\n      const W2 = words[i - 2]\n      const R1 = rotateRight(W1, 7)\n      const R2 = rotateRight(W1, 18)\n      const R3 = rotateRight(W2, 17)\n      const R4 = rotateRight(W2, 19)\n      const S0 = parseInt(R1, 2) ^ parseInt(R2, 2) ^ (parseInt(W1, 2) >>> 3)\n      const S1 = parseInt(R3, 2) ^ parseInt(R4, 2) ^ (parseInt(W2, 2) >>> 10)\n      const val = parseInt(words[i - 16], 2) + S0 + parseInt(words[i - 7], 2) + S1\n      words[i] = pad((val >>> 0).toString(2), 32)\n    }\n\n    // initialize variables for this chunk\n    let [a, b, c, d, e, f, g, h] = [H0, H1, H2, H3, H4, H5, H6, H7]\n\n    for (let i = 0; i < 64; i++) {\n      const S1 = [6, 11, 25]\n        .map(turns => rotateRight(pad(e.toString(2), 32), turns))\n        .map(bitstring => parseInt(bitstring, 2))\n        .reduce((acc, curr) => acc ^ curr, 0) >>> 0\n      const CH = ((e & f) ^ (~e & g)) >>> 0\n      const temp1 = (h + S1 + CH + K[i] + parseInt(words[i], 2)) >>> 0\n      const S0 = [2, 13, 22]\n        .map(turns => rotateRight(pad(a.toString(2), 32), turns))\n        .map(bitstring => parseInt(bitstring, 2))\n        .reduce((acc, curr) => acc ^ curr, 0) >>> 0\n      const maj = ((a & b) ^ (a & c) ^ (b & c)) >>> 0\n      const temp2 = (S0 + maj) >>> 0\n\n      h = g\n      g = f\n      f = e\n      e = (d + temp1) >>> 0\n      d = c\n      c = b\n      b = a\n      a = (temp1 + temp2) >>> 0\n    }\n\n    // add values for this chunk to main hash variables (unsigned)\n    H0 = (H0 + a) >>> 0\n    H1 = (H1 + b) >>> 0\n    H2 = (H2 + c) >>> 0\n    H3 = (H3 + d) >>> 0\n    H4 = (H4 + e) >>> 0\n    H5 = (H5 + f) >>> 0\n    H6 = (H6 + g) >>> 0\n    H7 = (H7 + h) >>> 0\n  })\n\n  // combine hash values of main hash variables and return\n  const HH = [H0, H1, H2, H3, H4, H5, H6, H7]\n    .map(e => e.toString(16))\n    .map(e => pad(e, 8))\n    .join('')\n\n  return HH\n}\n\n// export SHA256 function\nmodule.exports = SHA256\n","index":74},{"title":"Linear- Algebra","category":null,"id":"Linear-Algebra","index":75},{"title":"Package-lock.json","category":"Linear-Algebra","id":"package-lock.json_Linear-Algebra","algorithm":"{\n  \"name\": \"linear-algebra-javascript\",\n  \"version\": \"1.0.0\",\n  \"lockfileVersion\": 1,\n  \"requires\": true,\n  \"dependencies\": {\n    \"balanced-match\": {\n      \"version\": \"1.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/balanced-match/-/balanced-match-1.0.0.tgz\",\n      \"integrity\": \"sha1-ibTRmasr7kneFk6gK4nORi1xt2c=\"\n    },\n    \"brace-expansion\": {\n      \"version\": \"1.1.11\",\n      \"resolved\": \"https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.11.tgz\",\n      \"integrity\": \"sha512-iCuPHDFgrHX7H2vEI/5xpz07zSHB00TpugqhmYtVmMO6518mCuRMoOYFldEBl0g187ufozdaHgWKcYFb61qGiA==\",\n      \"requires\": {\n        \"balanced-match\": \"1.0.0\",\n        \"concat-map\": \"0.0.1\"\n      }\n    },\n    \"browser-stdout\": {\n      \"version\": \"1.3.1\",\n      \"resolved\": \"https://registry.npmjs.org/browser-stdout/-/browser-stdout-1.3.1.tgz\",\n      \"integrity\": \"sha512-qhAVI1+Av2X7qelOfAIYwXONood6XlZE/fXaBSmW/T5SzLAmCgzi+eiWE7fUvbHaeNBQH13UftjpXxsfLkMpgw==\"\n    },\n    \"commander\": {\n      \"version\": \"2.11.0\",\n      \"resolved\": \"https://registry.npmjs.org/commander/-/commander-2.11.0.tgz\",\n      \"integrity\": \"sha512-b0553uYA5YAEGgyYIGYROzKQ7X5RAqedkfjiZxwi0kL1g3bOaBNNZfYkzt/CL0umgD5wc9Jec2FbB98CjkMRvQ==\"\n    },\n    \"concat-map\": {\n      \"version\": \"0.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/concat-map/-/concat-map-0.0.1.tgz\",\n      \"integrity\": \"sha1-2Klr13/Wjfd5OnMDajug1UBdR3s=\"\n    },\n    \"debug\": {\n      \"version\": \"3.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/debug/-/debug-3.1.0.tgz\",\n      \"integrity\": \"sha512-OX8XqP7/1a9cqkxYw2yXss15f26NKWBpDXQd0/uK/KPqdQhxbPa994hnzjcE2VqQpDslf55723cKPUOGSmMY3g==\",\n      \"requires\": {\n        \"ms\": \"2.0.0\"\n      }\n    },\n    \"diff\": {\n      \"version\": \"3.3.1\",\n      \"resolved\": \"https://registry.npmjs.org/diff/-/diff-3.3.1.tgz\",\n      \"integrity\": \"sha512-MKPHZDMB0o6yHyDryUOScqZibp914ksXwAMYMTHj6KO8UeKsRYNJD3oNCKjTqZon+V488P7N/HzXF8t7ZR95ww==\"\n    },\n    \"escape-string-regexp\": {\n      \"version\": \"1.0.5\",\n      \"resolved\": \"https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-1.0.5.tgz\",\n      \"integrity\": \"sha1-G2HAViGQqN/2rjuyzwIAyhMLhtQ=\"\n    },\n    \"fs.realpath\": {\n      \"version\": \"1.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/fs.realpath/-/fs.realpath-1.0.0.tgz\",\n      \"integrity\": \"sha1-FQStJSMVjKpA20onh8sBQRmU6k8=\"\n    },\n    \"glob\": {\n      \"version\": \"7.1.2\",\n      \"resolved\": \"https://registry.npmjs.org/glob/-/glob-7.1.2.tgz\",\n      \"integrity\": \"sha512-MJTUg1kjuLeQCJ+ccE4Vpa6kKVXkPYJ2mOCQyUuKLcLQsdrMCpBPUi8qVE6+YuaJkozeA9NusTAw3hLr8Xe5EQ==\",\n      \"requires\": {\n        \"fs.realpath\": \"1.0.0\",\n        \"inflight\": \"1.0.6\",\n        \"inherits\": \"2.0.3\",\n        \"minimatch\": \"3.0.4\",\n        \"once\": \"1.4.0\",\n        \"path-is-absolute\": \"1.0.1\"\n      }\n    },\n    \"growl\": {\n      \"version\": \"1.10.3\",\n      \"resolved\": \"https://registry.npmjs.org/growl/-/growl-1.10.3.tgz\",\n      \"integrity\": \"sha512-hKlsbA5Vu3xsh1Cg3J7jSmX/WaW6A5oBeqzM88oNbCRQFz+zUaXm6yxS4RVytp1scBoJzSYl4YAEOQIt6O8V1Q==\"\n    },\n    \"has-flag\": {\n      \"version\": \"2.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/has-flag/-/has-flag-2.0.0.tgz\",\n      \"integrity\": \"sha1-6CB68cx7MNRGzHC3NLXovhj4jVE=\"\n    },\n    \"he\": {\n      \"version\": \"1.1.1\",\n      \"resolved\": \"https://registry.npmjs.org/he/-/he-1.1.1.tgz\",\n      \"integrity\": \"sha1-k0EP0hsAlzUVH4howvJx80J+I/0=\"\n    },\n    \"inflight\": {\n      \"version\": \"1.0.6\",\n      \"resolved\": \"https://registry.npmjs.org/inflight/-/inflight-1.0.6.tgz\",\n      \"integrity\": \"sha1-Sb1jMdfQLQwJvJEKEHW6gWW1bfk=\",\n      \"requires\": {\n        \"once\": \"1.4.0\",\n        \"wrappy\": \"1.0.2\"\n      }\n    },\n    \"inherits\": {\n      \"version\": \"2.0.3\",\n      \"resolved\": \"https://registry.npmjs.org/inherits/-/inherits-2.0.3.tgz\",\n      \"integrity\": \"sha1-Yzwsg+PaQqUC9SRmAiSA9CCCYd4=\"\n    },\n    \"minimatch\": {\n      \"version\": \"3.0.4\",\n      \"resolved\": \"https://registry.npmjs.org/minimatch/-/minimatch-3.0.4.tgz\",\n      \"integrity\": \"sha512-yJHVQEhyqPLUTgt9B83PXu6W3rx4MvvHvSUvToogpwoGDOUQ+yDrR0HRot+yOCdCO7u4hX3pWft6kWBBcqh0UA==\",\n      \"requires\": {\n        \"brace-expansion\": \"1.1.11\"\n      }\n    },\n    \"minimist\": {\n      \"version\": \"0.0.8\",\n      \"resolved\": \"https://registry.npmjs.org/minimist/-/minimist-0.0.8.tgz\",\n      \"integrity\": \"sha1-hX/Kv8M5fSYluCKCYuhqp6ARsF0=\"\n    },\n    \"mkdirp\": {\n      \"version\": \"0.5.1\",\n      \"resolved\": \"https://registry.npmjs.org/mkdirp/-/mkdirp-0.5.1.tgz\",\n      \"integrity\": \"sha1-MAV0OOrGz3+MR2fzhkjWaX11yQM=\",\n      \"requires\": {\n        \"minimist\": \"0.0.8\"\n      }\n    },\n    \"mocha\": {\n      \"version\": \"5.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/mocha/-/mocha-5.0.2.tgz\",\n      \"integrity\": \"sha512-nmlYKMRpJZLxgzk0bRhcvlpjSisbi0x1JiRl7kctadOMPmecUie7WwCZmcyth+PzX5txKbpcMIvDZCAlx9ISxg==\",\n      \"requires\": {\n        \"browser-stdout\": \"1.3.1\",\n        \"commander\": \"2.11.0\",\n        \"debug\": \"3.1.0\",\n        \"diff\": \"3.3.1\",\n        \"escape-string-regexp\": \"1.0.5\",\n        \"glob\": \"7.1.2\",\n        \"growl\": \"1.10.3\",\n        \"he\": \"1.1.1\",\n        \"mkdirp\": \"0.5.1\",\n        \"supports-color\": \"4.4.0\"\n      }\n    },\n    \"ms\": {\n      \"version\": \"2.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/ms/-/ms-2.0.0.tgz\",\n      \"integrity\": \"sha1-VgiurfwAvmwpAd9fmGF4jeDVl8g=\"\n    },\n    \"once\": {\n      \"version\": \"1.4.0\",\n      \"resolved\": \"https://registry.npmjs.org/once/-/once-1.4.0.tgz\",\n      \"integrity\": \"sha1-WDsap3WWHUsROsF9nFC6753Xa9E=\",\n      \"requires\": {\n        \"wrappy\": \"1.0.2\"\n      }\n    },\n    \"path-is-absolute\": {\n      \"version\": \"1.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/path-is-absolute/-/path-is-absolute-1.0.1.tgz\",\n      \"integrity\": \"sha1-F0uSaHNVNP+8es5r9TpanhtcX18=\"\n    },\n    \"supports-color\": {\n      \"version\": \"4.4.0\",\n      \"resolved\": \"https://registry.npmjs.org/supports-color/-/supports-color-4.4.0.tgz\",\n      \"integrity\": \"sha512-rKC3+DyXWgK0ZLKwmRsrkyHVZAjNkfzeehuFWdGGcqGDTZFH73+RH6S/RDAAxl9GusSjZSUWYLmT9N5pzXFOXQ==\",\n      \"requires\": {\n        \"has-flag\": \"2.0.0\"\n      }\n    },\n    \"wrappy\": {\n      \"version\": \"1.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz\",\n      \"integrity\": \"sha1-tSQ9jz7BqjXxNkYFvA0QNuMKtp8=\"\n    }\n  }\n}\n","index":76},{"title":"Package.json","category":"Linear-Algebra","id":"package.json_Linear-Algebra","algorithm":"{\n  \"name\": \"linear-algebra-javascript\",\n  \"version\": \"1.0.0\",\n  \"description\": \"simple linear algebra library for JavaScript\",\n  \"main\": \"index.js\",\n  \"directories\": {\n    \"test\": \"test\"\n  },\n  \"scripts\": {\n    \"test\": \"mocha\"\n  },\n  \"author\": \"Christian Bender\",\n  \"license\": \"MIT\",\n  \"dependencies\": {\n    \"mocha\": \"^5.0.2\"\n  }\n}\n","index":77},{"title":"Src","category":"Linear-Algebra","id":"src","index":78},{"title":"La_lib","category":"src","id":"la_lib_src","algorithm":"/*\n    author: Christian Bender\n    license: MIT-license\n\n    The namespace LinearAlgebra contains useful classes and functions for dealing with\n    linear algebra under JavaScript.\n*/\nvar LinearAlgebra;\n(function (LinearAlgebra) {\n  /*\n        class: Vector\n        This class represents a vector of arbitrary size and operations on it.\n    */\n  var Vector = /** @class */ (function () {\n    // constructor\n    function Vector (N, comps) {\n      if (comps === undefined) {\n        comps = []\n      }\n      this.components = new Array(N)\n      if (comps.length === 0) {\n        for (var i = 0; i < N; i++) {\n          this.components[i] = 0.0\n        }\n      } else {\n        if (N === comps.length) {\n          this.components = comps\n        } else {\n          throw new Error('Vector: invalide size!')\n        }\n      }\n    } // end of constructor\n    // returns the size of this vector.\n    // not the eulidean length!\n    Vector.prototype.size = function () {\n      return this.components.length\n    }\n    // computes the eulidean length.\n    Vector.prototype.eulideanLength = function () {\n      var sum = 0\n      for (var i = 0; i < this.components.length; i++) {\n        sum += this.components[i] * this.components[i]\n      }\n      return Math.sqrt(sum)\n    }\n    // getter for the components of the vector.\n    // returns a specified component (index)\n    Vector.prototype.component = function (index) {\n      return this.components[index]\n    }\n    // setter for a specified component of this vector.\n    Vector.prototype.changeComponent = function (index, value) {\n      if (index >= 0 && index < this.components.length) {\n        this.components[index] = value\n      } else {\n        throw new Error('changeComponent: index out of bounds!')\n      }\n    }\n    // vector addition\n    Vector.prototype.add = function (other) {\n      if (this.size() === other.size()) {\n        var SIZE = this.size()\n        var ans = new Vector(SIZE)\n        for (var i = 0; i < SIZE; i++) {\n          ans.changeComponent(i, (this.components[i] + other.component(i)))\n        }\n        return ans\n      } else {\n        throw new Error('add: vector must have same size!')\n      }\n    }\n    // vector subtraction\n    Vector.prototype.sub = function (other) {\n      if (this.size() === other.size()) {\n        var SIZE = this.size()\n        var ans = new Vector(SIZE)\n        for (var i = 0; i < SIZE; i++) {\n          ans.changeComponent(i, (this.components[i] - other.component(i)))\n        }\n        return ans\n      } else {\n        throw new Error('add: vector must have same size!')\n      }\n    }\n    // dot-product\n    Vector.prototype.dot = function (other) {\n      var sum = 0\n      if (other.size() === this.size()) {\n        var SIZE = other.size()\n        for (var i = 0; i < SIZE; i++) {\n          sum += this.components[i] * other.component(i)\n        }\n        return sum\n      } else {\n        throw new Error('dot: vectors must have same size!')\n      }\n    }\n    // scalar multiplication\n    Vector.prototype.scalar = function (s) {\n      var SIZE = this.size()\n      var ans = new Vector(SIZE)\n      for (var i = 0; i < SIZE; i++) {\n        ans.changeComponent(i, (this.components[i] * s))\n      }\n      return ans\n    }\n    // returns a string representation of this vector.\n    Vector.prototype.toString = function () {\n      var ans = '('\n      var SIZE = this.components.length\n      for (var i = 0; i < SIZE; i++) {\n        if (i < SIZE - 1) {\n          ans += this.components[i] + ','\n        } else {\n          ans += this.components[i] + ')'\n        }\n      }\n      return ans\n    }\n    // converts this vector in a unit basis vector and returns it.\n    // the One is on position 'pos'\n    Vector.prototype.createUnitBasis = function (pos) {\n      if (pos >= 0 && pos < this.components.length) {\n        for (var i = 0; i < this.components.length; i++) {\n          if (i === pos) {\n            this.components[i] = 1.0\n          } else {\n            this.components[i] = 0.0\n          }\n        }\n      } else {\n        throw new Error('createUnitBasis: index out of bounds')\n      }\n      return this\n    }\n    // normalizes this vector and returns it.\n    Vector.prototype.norm = function () {\n      var SIZE = this.size()\n      var quotient = 1.0 / this.eulideanLength()\n      for (var i = 0; i < SIZE; i++) {\n        this.components[i] = this.components[i] * quotient\n      }\n      return this\n    }\n    // returns true if the vectors are equal otherwise false.\n    Vector.prototype.equal = function (other) {\n      var ans = true\n      var SIZE = this.size()\n      var EPSILON = 0.001\n      if (SIZE === other.size()) {\n        for (var i = 0; i < SIZE; i++) {\n          if (Math.abs(this.components[i] - other.component(i)) > EPSILON) {\n            ans = false\n          }\n        }\n      } else {\n        ans = false\n      }\n      return ans\n    }\n    return Vector\n  }()) // end of class Vector\n  LinearAlgebra.Vector = Vector\n  // -------------- global functions ---------------------------------\n  // returns a unit basis vector of size N with a One on position 'pos'\n  function unitBasisVector (N, pos) {\n    var ans = new Vector(N)\n    for (var i = 0; i < N; i++) {\n      if (i === pos) {\n        ans.changeComponent(i, 1.0)\n      } else {\n        ans.changeComponent(i, 0)\n      }\n    }\n    return ans\n  }\n  LinearAlgebra.unitBasisVector = unitBasisVector\n  // returns a random vector with integer components (between 'a' and 'b') of size N.\n  function randomVectorInt (N, a, b) {\n    var ans = new Vector(N)\n    for (var i = 0; i < N; i++) {\n      ans.changeComponent(i, (Math.floor((Math.random() * b) + a)))\n    }\n    return ans\n  }\n  LinearAlgebra.randomVectorInt = randomVectorInt\n  // returns a random vector with floating point components (between 'a' and 'b') of size N.\n  function randomVectorFloat (N, a, b) {\n    var ans = new Vector(N)\n    for (var i = 0; i < N; i++) {\n      ans.changeComponent(i, ((Math.random() * b) + a))\n    }\n    return ans\n  }\n  LinearAlgebra.randomVectorFloat = randomVectorFloat\n  // ------------------ end of global functions -----------------------------\n  /*\n        class: Matrix\n        This class represents a matrix of arbitrary size and operations on it.\n    */\n  var Matrix = /** @class */ (function () {\n    // constructor for zero-matrix or fix number matrix.\n    function Matrix (row, col, comps) {\n      if (comps === undefined) {\n        comps = []\n      }\n      if (comps.length === 0) {\n        this.matrix = []\n        var rowVector = []\n        for (var i = 0; i < row; i++) {\n          for (var j = 0; j < col; j++) {\n            rowVector[j] = 0\n          }\n          this.matrix[i] = rowVector\n          rowVector = []\n        }\n      } else {\n        this.matrix = comps\n      }\n      this.rows = row\n      this.cols = col\n    }\n    // returns the specified component.\n    Matrix.prototype.component = function (x, y) {\n      if (x >= 0 && x < this.rows && y >= 0 && y < this.cols) {\n        return this.matrix[x][y]\n      } else {\n        throw new Error('component: index out of bounds')\n      }\n    }\n    // changes the specified component with value 'value'.\n    Matrix.prototype.changeComponent = function (x, y, value) {\n      if (x >= 0 && x < this.rows && y >= 0 && y < this.cols) {\n        this.matrix[x][y] = value\n      } else {\n        throw new Error('changeComponent: index out of bounds')\n      }\n    }\n    // returns a string representation of this matrix.\n    Matrix.prototype.toString = function () {\n      var ans = ''\n      for (var i = 0; i < this.rows; i++) {\n        ans += '|'\n        for (var j = 0; j < this.cols; j++) {\n          if (j < this.cols - 1) {\n            ans += this.matrix[i][j] + ','\n          } else {\n            if (i < this.rows - 1) {\n              ans += this.matrix[i][j] + '|\\n'\n            } else {\n              ans += this.matrix[i][j] + '|'\n            }\n          }\n        }\n      }\n      return ans\n    }\n    // returns the dimension rows x cols as number array\n    Matrix.prototype.dimension = function () {\n      var ans = []\n      ans[0] = this.rows\n      ans[1] = this.cols\n      return ans\n    }\n    // matrix addition. returns the result.\n    Matrix.prototype.add = function (other) {\n      if (this.rows === other.dimension()[0] &&\n        this.cols === other.dimension()[1]) {\n        var ans = new Matrix(this.rows, this.cols)\n        for (var i = 0; i < this.rows; i++) {\n          for (var j = 0; j < this.cols; j++) {\n            ans.changeComponent(i, j, (this.matrix[i][j] + other.component(i, j)))\n          }\n        }\n        return ans\n      } else {\n        throw new Error('add: matrices must have same dimension!')\n      }\n    }\n    // returns true if the matrices are equal, otherwise false.\n    Matrix.prototype.equal = function (other) {\n      var ans = true\n      var EPSILON = 0.001\n      if (this.rows === other.dimension()[0] &&\n        this.cols === other.dimension()[1]) {\n        for (var i = 0; i < this.rows; i++) {\n          for (var j = 0; j < this.cols; j++) {\n            if (Math.abs(this.matrix[i][j] - other.component(i, j)) > EPSILON) {\n              ans = false\n            }\n          }\n        }\n      } else {\n        ans = false\n      }\n      return ans\n    }\n    // matrix-scalar multiplication\n    Matrix.prototype.scalar = function (c) {\n      var ans = new Matrix(this.rows, this.cols)\n      for (var i = 0; i < this.rows; i++) {\n        for (var j = 0; j < this.cols; j++) {\n          ans.changeComponent(i, j, (this.matrix[i][j] * c))\n        }\n      }\n      return ans\n    }\n    return Matrix\n  }()) // end of class Matrix\n  LinearAlgebra.Matrix = Matrix\n})(LinearAlgebra || (LinearAlgebra = {})) // end of namespace LinearAlgebra\n","index":79},{"title":"Test","category":"Linear-Algebra","id":"test","index":80},{"title":"Test","category":"test","id":"test_test","algorithm":"/*\n    author: Christian Bender\n    license: MIT-license\n\n    This file contains the test-suite for the linear algebra library.\n    The tests use javascript test-framework mocha\n*/\n/* eslint-disable */\n\nvar assert = require('assert')\nvar fs = require('fs')\n\n// file is included here\neval(fs.readFileSync('src/la_lib.js') + '')\n// Tests goes here\n\n// creating some vectors\ndescribe('Create Vectors', function () {\n  describe('#toString()', function () {\n    it('should return a string representation', function () {\n      assert.strictEqual((new LinearAlgebra.Vector(3, [1, 2, 3])).toString(), '(1,2,3)')\n    })\n  })\n  describe('#unitBasisVector()', function () {\n    it('should return a unit basis vector', function () {\n      assert.strictEqual(LinearAlgebra.unitBasisVector(3, 1).toString(), '(0,1,0)')\n    })\n  })\n})\n\n// operations on it.\ndescribe('Vector operations', function () {\n  describe('#add()', function () {\n    it('should return vector (2,4,6)', function () {\n      var x = new LinearAlgebra.Vector(3, [1, 2, 3])\n      var y = new LinearAlgebra.Vector(3, [1, 2, 3])\n      assert.strictEqual((x.add(y)).toString(), '(2,4,6)')\n    })\n  })\n  describe('#sub()', function () {\n    it('should return vector (0,0,0)', function () {\n      var x = new LinearAlgebra.Vector(3, [1, 2, 3])\n      var y = new LinearAlgebra.Vector(3, [1, 2, 3])\n      assert.strictEqual((x.sub(y)).toString(), '(0,0,0)')\n    })\n  })\n  describe('#dot()', function () {\n    it('should return the dot-product', function () {\n      var x = new LinearAlgebra.Vector(3, [1, 2, 3])\n      var y = new LinearAlgebra.Vector(3, [5, 6, 7])\n      assert.strictEqual(x.dot(y), 38)\n    })\n  })\n  describe('#scalar()', function () {\n    it('should return the scalar product', function () {\n      var x = new LinearAlgebra.Vector(3, [1, 2, 3])\n      assert.strictEqual(x.scalar(2).toString(), '(2,4,6)')\n    })\n  })\n  describe('#norm()', function () {\n    it('should return the normalizes vector', function () {\n      var x = new LinearAlgebra.Vector(4, [9, 0, 3, 1])\n      var y = x.norm()\n      assert.ok(Math.abs(y.component(0) - (9.0 / Math.sqrt(91))) <= 0.01)\n    })\n  })\n  describe('#eulideanLength()', function () {\n    it('should return the eulidean length of the vector', function () {\n      var x = new LinearAlgebra.Vector(3, [1, 2, 2])\n      assert.ok(Math.abs(x.eulideanLength() - 3) <= 0.001)\n    })\n  })\n  describe('#size()', function () {\n    it('should return the size (not eulidean length!) of the vector', function () {\n      var x = LinearAlgebra.randomVectorInt(10, 1, 5)\n      assert.strictEqual(x.size(), 10)\n    })\n  })\n  describe('#equal()', function () {\n    it('should compares two vectors', function () {\n      var x = new LinearAlgebra.Vector(3, [1, 2, 2])\n      var y = new LinearAlgebra.Vector(3, [1, 2, 3])\n      assert.ok(x.equal(x))\n      assert.ok(!x.equal(y))\n    })\n  })\n})\n\ndescribe('Methods on vectors', function () {\n  describe('#component()', function () {\n    it('should return the specified component', function () {\n      var x = new LinearAlgebra.Vector(3, [1, 2, 2])\n      assert.strictEqual(x.component(1), 2)\n    })\n  })\n  describe('#changeComponent()', function () {\n    it('should return the changed vector', function () {\n      var x = new LinearAlgebra.Vector(3, [1, 2, 2])\n      x.changeComponent(1, 5)\n      assert.strictEqual(x.toString(), '(1,5,2)')\n    })\n  })\n  describe('#toString()', function () {\n    it('should return a string representation of the vector', function () {\n      var x = new LinearAlgebra.Vector(4, [9, 0, 3, 1])\n      assert.strictEqual(x.toString(), '(9,0,3,1)')\n    })\n  })\n})\n\ndescribe('class Matrix', function () {\n  describe('#component()', function () {\n    it('should return the specified component', function () {\n      var A = new LinearAlgebra.Matrix(2, 2)\n      assert.strictEqual(A.component(0, 1), 0)\n      var B = new LinearAlgebra.Matrix(2, 2, [\n        [1, 2],\n        [3, 4]\n      ])\n      assert.strictEqual(B.component(1, 0), 3)\n    })\n  })\n  describe('#toString()', function () {\n    it('should return a string representation of the matrix', function () {\n      var A = new LinearAlgebra.Matrix(2, 2, [\n        [1, 2],\n        [3, 4]\n      ])\n      assert.strictEqual(A.toString(), '|1,2|\\n|3,4|')\n    })\n  })\n  describe('#dimension()', function () {\n    it('should return the dimension of the matrix as number array', function () {\n      var A = new LinearAlgebra.Matrix(3, 2, [\n        [1, 2],\n        [3, 4],\n        [5, 6]\n      ])\n      assert.strictEqual(A.dimension()[0], 3)\n      assert.strictEqual(A.dimension()[1], 2)\n    })\n  })\n  describe('#changeComponent()', function () {\n    it('should change the specified component of the matrix', function () {\n      var A = new LinearAlgebra.Matrix(3, 2, [\n        [1, 2],\n        [3, 4],\n        [5, 6]\n      ])\n      A.changeComponent(1, 0, 5)\n      assert.strictEqual(A.component(1, 0), 5)\n    })\n  })\n  describe('#equal()', function () {\n    it('should compares the matrices', function () {\n      var A = new LinearAlgebra.Matrix(3, 2, [\n        [1, 2],\n        [3, 4],\n        [5, 6]\n      ])\n      var B = new LinearAlgebra.Matrix(3, 2, [\n        [1, 2],\n        [3, 4],\n        [5, 6]\n      ])\n      var C = new LinearAlgebra.Matrix(2, 2, [\n        [1, 2],\n        [3, 4]\n      ])\n      var D = new LinearAlgebra.Matrix(2, 2, [\n        [1, 2],\n        [5, 4]\n      ])\n      assert.ok(A.equal(B))\n      assert.ok(!A.equal(C))\n      assert.ok(!C.equal(D))\n    })\n  })\n  describe('#add()', function () {\n    it('should return the result of the matrix addition', function () {\n      var A = new LinearAlgebra.Matrix(3, 2, [\n        [1, 2],\n        [3, 4],\n        [5, 6]\n      ])\n      var B = new LinearAlgebra.Matrix(3, 2, [\n        [1, 2],\n        [3, 4],\n        [5, 6]\n      ])\n      var C = A.add(B)\n      assert.strictEqual(C.component(1, 0), 6)\n      assert.strictEqual(C.component(1, 1), 8)\n      assert.strictEqual(C.component(0, 0), 2)\n    })\n  })\n  describe('#scalar()', function () {\n    it('should return the result of the matrix-scalar multiplication', function () {\n      var A = new LinearAlgebra.Matrix(3, 2, [\n        [1, 2],\n        [3, 4],\n        [5, 6]\n      ])\n      var B = A.scalar(2)\n      var C = new LinearAlgebra.Matrix(3, 2, [\n        [2, 4],\n        [6, 8],\n        [10, 12]\n      ])\n      assert.ok(B.equal(C))\n    })\n  })\n})","index":81},{"title":"Maths","category":null,"id":"Maths","index":82},{"title":"Abs","category":"Maths","id":"Abs_Maths","algorithm":"/*\n    author: PatOnTheBack\n    license: GPL-3.0 or later\n\n    Modified from:\n        https://github.com/TheAlgorithms/Python/blob/master/maths/abs.py\n\n    This script will find the absolute value of a number.\n\n    More about absolute values:\n        https://en.wikipedia.org/wiki/Absolute_value\n*/\n\nconst absVal = (num) => {\n  // Find absolute value of `num`.\n  'use strict'\n  if (num < 0) {\n    return -num\n  }\n  // Executes if condition is not met.\n  return num\n}\n\nexport { absVal }\n","index":83},{"title":"Area","category":"Maths","id":"Area_Maths","algorithm":"/*\n  Calculate the area of various shapes\n\n  Calculate the Surface Area of a Cube.\n  Example: surfaceAreaCube(1) will return 6\n  More about: https://en.wikipedia.org/wiki/Area#Surface_area\n */\nconst surfaceAreaCube = (sideLength) => {\n  validateNumericParam(sideLength, 'sideLength')\n  return (6.0 * sideLength ** 2.0)\n}\n\n/*\n  Calculate the Surface Area of a Sphere.\n  Wikipedia reference: https://en.wikipedia.org/wiki/Sphere\n  return 4 * pi * r^2\n*/\nconst surfaceAreaSphere = (radius) => {\n  validateNumericParam(radius, 'radius')\n  return (4.0 * Math.PI * radius ** 2.0)\n}\n\n/*\n  Calculate the area of a rectangle\n  Wikipedia reference: https://en.wikipedia.org/wiki/Area#Quadrilateral_area\n  return width * length\n*/\nconst areaRectangle = (length, width) => {\n  validateNumericParam(length, 'Length')\n  validateNumericParam(width, 'Width')\n  return (width * length)\n}\n\n/*\n  Calculate the area of a square\n*/\nconst areaSquare = (sideLength) => {\n  validateNumericParam(sideLength, 'side length')\n  return (sideLength ** 2)\n}\n\n/*\n  Calculate the area of a triangle\n  Wikipedia reference: https://en.wikipedia.org/wiki/Area#Triangle_area\n  return base * height / 2\n*/\nconst areaTriangle = (base, height) => {\n  validateNumericParam(base, 'Base')\n  validateNumericParam(height, 'Height')\n  return (base * height) / 2.0\n}\n\n/*\n  Calculate the area of a parallelogram\n  Wikipedia reference: https://en.wikipedia.org/wiki/Area#Dissection,_parallelograms,_and_triangles\n*/\nconst areaParallelogram = (base, height) => {\n  validateNumericParam(base, 'Base')\n  validateNumericParam(height, 'Height')\n  return (base * height)\n}\n\n/*\n  Calculate the area of a trapezium\n*/\nconst areaTrapezium = (base1, base2, height) => {\n  validateNumericParam(base1, 'Base One')\n  validateNumericParam(base2, 'Base Two')\n  validateNumericParam(height, 'Height')\n  return 1.0 / 2.0 * (base1 + base2) * height\n}\n\n/*\n  Calculate the area of a circle\n*/\nconst areaCircle = (radius) => {\n  validateNumericParam(radius, 'Radius')\n  return (Math.PI * radius ** 2)\n}\n\n/*\n  Calculate the area of a rhombus\n  Wikipedia reference: https://en.wikipedia.org/wiki/Rhombus\n*/\nconst areaRhombus = (diagonal1, diagonal2) => {\n  validateNumericParam(diagonal1, 'diagonal one')\n  validateNumericParam(diagonal2, 'diagonal two')\n  return (1 / 2 * diagonal1 * diagonal2)\n}\n\nconst validateNumericParam = (param, paramName = 'param') => {\n  if (typeof param !== 'number') {\n    throw new TypeError('The ' + paramName + ' should be type Number')\n  } else if (param < 0) {\n    throw new Error('The ' + paramName + ' only accepts non-negative values')\n  }\n}\n\nexport { surfaceAreaCube, surfaceAreaSphere, areaRectangle, areaSquare, areaTriangle, areaParallelogram, areaTrapezium, areaCircle, areaRhombus }\n","index":84},{"title":"Armstrong Number","category":"Maths","id":"ArmstrongNumber_Maths","algorithm":"/**\n * Author: dephraiim\n * License: GPL-3.0 or later\n *\n * An Armstrong number is equal to the sum of the cubes of its digits.\n * For example, 370 is an Armstrong number because 3*3*3 + 7*7*7 + 0*0*0 = 370.\n * An Armstrong number is often called Narcissistic number.\n *\n */\n\nconst armstrongNumber = (num) => {\n  if (num < 0 || typeof num !== 'number') return false\n\n  let newSum = 0\n\n  const numArr = num.toString().split('')\n  numArr.forEach((num) => {\n    newSum += parseInt(num) ** numArr.length\n  })\n\n  return newSum === num\n}\n\nexport { armstrongNumber }\n","index":85},{"title":"Average Mean","category":"Maths","id":"AverageMean_Maths","algorithm":"'use strict'\n/*\n    author: PatOnTheBack\n    license: GPL-3.0 or later\n\n    Modified from:\n        https://github.com/TheAlgorithms/Python/blob/master/maths/average.py\n\n    This script will find the average (mean) of an array of numbers.\n\n    More about mean:\n        https://en.wikipedia.org/wiki/Mean\n*/\n\nconst mean = (nums) => {\n  // This is a function returns average/mean of array\n  let sum = 0\n\n  // This loop sums all values in the 'nums' array using forEach loop\n  nums.forEach(function (current) {\n    sum += current\n  })\n\n  // Divide sum by the length of the 'nums' array.\n  const avg = sum / nums.length\n  return avg\n}\n\nexport { mean }\n","index":86},{"title":"Binary Convert","category":"Maths","id":"BinaryConvert_Maths","algorithm":"const BinaryConvert = (number) => {\n  const result = []\n  let i\n  for (i = number; i > 0; i = parseInt(i / 2)) {\n    result.push(i % 2) // push the value (remainder)to array\n  } return Number(result.reverse().join(''))\n  // reverse index of array as string ,join and change the type of value to become Number\n}\n// call function and value as parameter to passing the value\nexport { BinaryConvert }\n","index":87},{"title":"Binary Exponentiation Iterative","category":"Maths","id":"BinaryExponentiationIterative_Maths","algorithm":"// To calculate x^n i.e. exponent(x, n) in O(log n) time in iterative way\n// n is an integer and n >= 0\n\n// Explanation: https://en.wikipedia.org/wiki/Exponentiation_by_squaring\n\n// Examples:\n// 2^3 = 8\n// 5^0 = 1\n\n// Uses the fact that\n// exponent(x, n)\n//          = exponent(x*x, floor(n/2))   ; if n is odd\n//          = x*exponent(x*x, floor(n/2)) ; if n is even\nconst exponent = (x, n) => {\n  let ans = 1\n  while (n > 0) {\n    if (n % 2 !== 0) ans *= x\n    n = Math.floor(n / 2)\n    if (n > 0) x *= x\n  }\n  return ans\n}\n\nexport { exponent }\n","index":88},{"title":"Digit Sum","category":"Maths","id":"DigitSum_Maths","algorithm":"// program to find sum of digits of a number\n\n// function which would calculate sum and return it\nconst digitSum = (num) => {\n  // sum will store sum of digits of a number\n  let sum = 0\n  // while will run untill num become 0\n  while (num) {\n    sum += num % 10\n    num = parseInt(num / 10)\n  }\n\n  return sum\n}\n\nexport { digitSum }\n","index":89},{"title":"Eulers Totient Function","category":"Maths","id":"EulersTotientFunction_Maths","algorithm":"/*\n    author sandyboypraper\n\n    Here is the EulerTotientFunction.\n    it is also represented by phi\n\n    so EulersTotientFunction(n) (or phi(n)) is the count of numbers in {1,2,3,....,n} that are relatively\n    prime to n, i.e., the numbers whose GCD (Greatest Common Divisor) with n is 1.\n*/\n\nconst gcdOfTwoNumbers = (x, y) => {\n  // x is smaller than y\n  // let gcd of x and y is gcdXY\n  // so it devides x and y completely\n  // so gcdXY should also devides y%x (y = gcdXY*a and x = gcdXY*b and y%x = y - x*k so y%x = gcdXY(a - b*k))\n  // and gcd(x,y) is equals to gcd(y%x , x)\n  return x === 0 ? y : gcdOfTwoNumbers(y % x, x)\n}\n\nconst eulersTotientFunction = (n) => {\n  let countOfRelativelyPrimeNumbers = 1\n  for (let iterator = 2; iterator <= n; iterator++) {\n    if (gcdOfTwoNumbers(iterator, n) === 1) countOfRelativelyPrimeNumbers++\n  }\n  return countOfRelativelyPrimeNumbers\n}\n\nexport { eulersTotientFunction }\n","index":90},{"title":"Factorial","category":"Maths","id":"Factorial_Maths","algorithm":"/*\n    author: PatOnTheBack\n    license: GPL-3.0 or later\n\n    Modified from:\n        https://github.com/TheAlgorithms/Python/blob/master/maths/factorial_python.py\n\n    This script will find the factorial of a number provided by the user.\n\n    More about factorials:\n        https://en.wikipedia.org/wiki/factorial\n*/\n\n'use strict'\n\nconst calcRange = (num) => {\n  // Generate a range of numbers from 1 to `num`.\n  let i = 1\n  const range = []\n  while (i <= num) {\n    range.push(i)\n    i += 1\n  }\n  return range\n}\n\nconst calcFactorial = (num) => {\n  let factorial\n  const range = calcRange(num)\n\n  // Check if the number is negative, positive, null, undefined, or zero\n  if (num < 0) {\n    return 'Sorry, factorial does not exist for negative numbers.'\n  }\n  if (num === null || num === undefined) {\n    return 'Sorry, factorial does not exist for null or undefined numbers.'\n  }\n  if (num === 0) {\n    return 'The factorial of 0 is 1.'\n  }\n  if (num > 0) {\n    factorial = 1\n    range.forEach(function (i) {\n      factorial = factorial * i\n    })\n    return `The factorial of ${num} is ${factorial}`\n  }\n}\n\nexport { calcFactorial }\n","index":91},{"title":"Factors","category":"Maths","id":"Factors_Maths","algorithm":"/**\n * Author: dephraiim\n * License: GPL-3.0 or later\n *\n * More on Factors:\n *      https://www.mathsisfun.com/definitions/factor.html\n *\n */\n\nconst factorsOfANumber = (number = 0) => {\n  return Array.from(Array(number + 1).keys()).filter(\n    (num) => number % num === 0\n  )\n}\n\nexport { factorsOfANumber }\n","index":92},{"title":"Fibonacci","category":"Maths","id":"Fibonacci_Maths","algorithm":"const list = []\n\nconst FibonacciIterative = (nth) => {\n  const sequence = []\n\n  if (nth >= 1) sequence.push(1)\n  if (nth >= 2) sequence.push(1)\n\n  for (let i = 2; i < nth; i++) {\n    sequence.push(sequence[i - 1] + sequence[i - 2])\n  }\n\n  return sequence\n}\n\nconst FibonacciRecursive = (number) => {\n  return (() => {\n    switch (list.length) {\n      case 0:\n        list.push(1)\n        return FibonacciRecursive(number)\n      case 1:\n        list.push(1)\n        return FibonacciRecursive(number)\n      case number:\n        return list\n      default:\n        list.push(list[list.length - 1] + list[list.length - 2])\n        return FibonacciRecursive(number)\n    }\n  })()\n}\n\nconst dict = new Map()\n\nconst FibonacciRecursiveDP = (stairs) => {\n  if (stairs <= 0) return 0\n  if (stairs === 1) return 1\n\n  // Memoize stair count\n  if (dict.has(stairs)) return dict.get(stairs)\n\n  const res =\n    FibonacciRecursiveDP(stairs - 1) + FibonacciRecursiveDP(stairs - 2)\n\n  dict.set(stairs, res)\n\n  return res\n}\n\n// Algorithms\n// Calculates Fibonacci(n) such that Fibonacci(n) = Fibonacci(n - 1) + Fibonacci(n - 2)\n// Fibonacci(0) = Fibonacci(1) = 1\n// Uses a bottom up dynamic programming approach\n// Solve each sub-problem once, using results of previous sub-problems\n// which are n-1 and n-2 for Fibonacci numbers\n// Although this algorithm is linear in space and time as a function\n// of the input value n, it is exponential in the size of n as\n// a function of the number of input bits\n// @Satzyakiz\n\nconst FibonacciDpWithoutRecursion = (number) => {\n  const table = []\n  table.push(1)\n  table.push(1)\n  for (var i = 2; i < number; ++i) {\n    table.push(table[i - 1] + table[i - 2])\n  }\n  return table\n}\n\n// Using Matrix exponentiation to find n-th fibonacci in O(log n) time\n\nconst copyMatrix = (A) => {\n  return A.map(row => row.map(cell => cell))\n}\n\nconst Identity = (size) => {\n  const I = Array(size).fill(null).map(() => Array(size).fill())\n  return I.map((row, rowIdx) => row.map((_col, colIdx) => {\n    return rowIdx === colIdx ? 1 : 0\n  }))\n}\n\n// A of size (l x m) and B of size (m x n)\n// product C will be of size (l x n)\nconst matrixMultiply = (A, B) => {\n  A = copyMatrix(A)\n  B = copyMatrix(B)\n  const l = A.length\n  const m = B.length\n  const n = B[0].length // Assuming non-empty matrices\n  const C = Array(l).fill(null).map(() => Array(n).fill())\n  for (let i = 0; i < l; i++) {\n    for (let j = 0; j < n; j++) {\n      C[i][j] = 0\n      for (let k = 0; k < m; k++) {\n        C[i][j] += A[i][k] * B[k][j]\n      }\n    }\n  }\n  return C\n}\n\n/**\n * Computes A raised to the power n i.e. pow(A, n) where A is a square matrix\n * @param {*} A the square matrix\n * @param {*} n the exponent\n */\n// A is a square matrix\nconst matrixExpo = (A, n) => {\n  A = copyMatrix(A)\n\n  // Just like Binary exponentiation mentioned in ./BinaryExponentiationIterative.js\n  let result = Identity(A.length) // Identity matrix\n  while (n > 0) {\n    if (n % 2 !== 0) result = matrixMultiply(result, A)\n    n = Math.floor(n / 2)\n    if (n > 0) A = matrixMultiply(A, A)\n  }\n  return result\n}\n\nconst FibonacciMatrixExpo = (n) => {\n  // F(0) = 0, F(1) = 1\n  // F(n) = F(n-1) + F(n-2)\n  // Consider below matrix multiplication:\n\n  // | F(n) |   |1  1|   |F(n-1)|\n  // |      | = |    | * |      |\n  // |F(n-1)|   |1  0|   |F(n-2)|\n\n  // Let's rewrite it as F(n, n-1) = A * F(n-1, n-2)\n  // or                  F(n, n-1) = A * A * F(n-2, n-3)\n  // or                  F(n, n-1) = pow(A, n-1) * F(1, 0)\n\n  if (n === 0) return 0\n\n  const A = [\n    [1, 1],\n    [1, 0]\n  ]\n  const poweredA = matrixExpo(A, n - 1) // A raised to the power n-1\n  let F = [\n    [1],\n    [0]\n  ]\n  F = matrixMultiply(poweredA, F)\n  return F[0][0]\n}\n\nexport { FibonacciDpWithoutRecursion }\nexport { FibonacciIterative }\nexport { FibonacciRecursive }\nexport { FibonacciRecursiveDP }\nexport { FibonacciMatrixExpo }\n","index":93},{"title":"Find Hcf","category":"Maths","id":"FindHcf_Maths","algorithm":"/*\n    author: redfly1\n    More about HCF:\n        https://en.wikipedia.org/wiki/Greatest_common_divisor\n */\n\nconst findHCF = (x, y) => {\n  // If the input numbers are less than 1 return an error message.\n  if (x < 1 || y < 1) {\n    return 'Please enter values greater than zero.'\n  }\n\n  // If the input numbers are not integers return an error message.\n  if (x !== Math.round(x) || y !== Math.round(y)) {\n    return 'Please enter whole numbers.'\n  }\n\n  // Now apply Euclid's algorithm to the two numbers.\n  while (Math.max(x, y) % Math.min(x, y) !== 0) {\n    if (x > y) {\n      x %= y\n    } else {\n      y %= x\n    }\n  }\n\n  // When the while loop finishes the minimum of x and y is the HCF.\n  return Math.min(x, y)\n}\n\nexport { findHCF }\n","index":94},{"title":"Find Lcm","category":"Maths","id":"FindLcm_Maths","algorithm":"/*\n    author: PatOnTheBack\n    license: GPL-3.0 or later\n\n    Modified from:\n        https://github.com/TheAlgorithms/Python/blob/master/maths/findLcm.py\n\n    More about LCM:\n        https://en.wikipedia.org/wiki/Least_common_multiple\n*/\n\n'use strict'\n\n// Find the LCM of two numbers.\nconst findLcm = (num1, num2) => {\n  // If the input numbers are less than 1 return an error message.\n  if (num1 < 1 || num2 < 1) {\n    return 'Please enter values greater than zero.'\n  }\n\n  // If the input numbers are not integers return an error message.\n  if (num1 !== Math.round(num1) || num2 !== Math.round(num2)) {\n    return 'Please enter whole numbers.'\n  }\n\n  let maxNum\n  let lcm\n  // Check to see whether num1 or num2 is larger.\n  if (num1 > num2) {\n    maxNum = num1\n  } else {\n    maxNum = num2\n  }\n  lcm = maxNum\n\n  while (true) {\n    if (lcm % num1 === 0 && lcm % num2 === 0) break\n    lcm += maxNum\n  }\n  return lcm\n}\n\nexport { findLcm }\n","index":95},{"title":"Grid Get","category":"Maths","id":"GridGet_Maths","algorithm":"/*\n    author: TangibleDream\n    license: GPL-3.0 or later\n\n    These methods will find x or y given the element and columns for a 2 dimensional array.\n\n    If your array is a perfect square, you can find columns by getting the square\n    root of the length of the array.\n\n    Let's say for instance you had an array of 10 by 10 or 100, elements and you wanted to\n    find the shortest distance between element 3, and element 49. In this case coding out\n    a function to return the distance without finding x and y for both elements I found to\n    be painful. If you first find x and y, where 3 becomes 4,1 and 49 becomes 10,5, you can\n    find distance by first subtracting x from x and y from y this returns 6,4 or -6,-4.\n    Next apply absolute value to assure the results are positive,\n    last choose the maximum value of the set, or 6.\n\n    +--+--+--+--+--+--+--+--+--+--+\n    |  |  |  | 3|  |  |  |  |  |  |\n    +--+--+--+--+--+--+--+--+--+--+\n    |  |  |  |  |  |  |  |  |  |  |\n    +--+--+--+--+--+--+--+--+--+--+\n    |  |  |  |  |  |  |  |  |  |  |\n    +--+--+--+--+--+--+--+--+--+--+\n    |  |  |  |  |  |  |  |  |  |49|\n    +--+--+--+--+--+--+--+--+--+--+\n    |  |  |  |  |  |  |  |  |  |  |\n\n    +--+--+--+--+--+--+--+--+--+--+\n    |  |  |  | 3|  |  |  |  |  |  |\n    +--+--+--+--+--+--+--+--+--+--+\n    |  |  |  |  | 1|  |  |  |  |  |\n    +--+--+--+--+--+--+--+--+--+--+\n    |  |  |  |  |  | 2|  |  |  |  |\n    +--+--+--+--+--+--+--+--+--+--+\n    |  |  |  |  |  |  | 3| 4| 5|6!|\n    +--+--+--+--+--+--+--+--+--+--+\n    |  |  |  |  |  |  |  |  |  |  |\n\n*/\n\nconst gridGetX = (columns, index) => {\n  while (index + 1 > columns) {\n    index = index - columns\n  }\n  return index + 1\n}\n\nconst gridGetY = (columns, index) => {\n  return Math.floor(index / columns) + 1\n}\n\nexport { gridGetX, gridGetY }\n","index":96},{"title":"Matrix Multiplication","category":"Maths","id":"MatrixMultiplication_Maths","algorithm":"// Wikipedia URL for General Matrix Multiplication Concepts: https://en.wikipedia.org/wiki/Matrix_multiplication\n\n// This algorithm has multiple functions that ultimately check if the inputs are actually matrices and if two Matrices (that can be different sizes) can be multiplied together.\n// matrices that are of the same size [2x2]x[2x2], and the second is the multiplication of two matrices that are not the same size [2x3]x[3x2].\n\n// MatrixCheck tests to see if all of the rows of the matrix inputted have similar size columns\nconst matrixCheck = (matrix) => {\n  let columnNumb\n  for (let index = 0; index < matrix.length; index++) {\n    if (index === 0) {\n      columnNumb = matrix[index].length\n    } else if (matrix[index].length !== columnNumb) {\n      console.log('The columns in this array are not equal')\n    } else {\n      return columnNumb\n    }\n  }\n}\n\n// tests to see if the matrices have a like side, i.e. the row length on the first matrix matches the column length on the second matrix, or vise versa.\nconst twoMatricesCheck = (first, second) => {\n  const [firstRowLength, secondRowLength, firstColLength, secondColLength] = [first.length, second.length, matrixCheck(first), matrixCheck(second)]\n  if (firstRowLength !== secondColLength || secondRowLength !== firstColLength) {\n    console.log('These matrices do not have a common side')\n    return false\n  } else {\n    return true\n  }\n}\n\n// returns an empty array that has the same number of rows as the left matrix being multiplied.\n// Uses Array.prototype.map() to loop over the first (or left) matrix and returns an empty array on each iteration.\nconst initiateEmptyArray = (first, second) => {\n  if (twoMatricesCheck(first, second)) {\n    const emptyArray = first.map(() => {\n      return ['']\n    })\n    return emptyArray\n  } else {\n    return false\n  }\n}\n\n// Finally, `matrixMult` uses `Array.prototype.push()`, multiple layers of nested `for` loops, the addition assignment `+=` operator and multiplication operator `*` to perform the dot product between two matrices of differing sizes.\n// Dot product, takes the row of the first matrix and multiplies it by the column of the second matrix, the `twoMatricesCheck` tested to see if they were the same size already.\n// The dot product for each iteration is then saved to its respective index into `multMatrix`.\nconst matrixMult = (firstArray, secondArray) => {\n  const multMatrix = initiateEmptyArray(firstArray, secondArray)\n  for (let rm = 0; rm < firstArray.length; rm++) {\n    const rowMult = []\n    for (let col = 0; col < firstArray[0].length; col++) {\n      rowMult.push(firstArray[rm][col])\n    }\n    for (let cm = 0; cm < firstArray.length; cm++) {\n      const colMult = []\n      for (let row = 0; row < secondArray.length; row++) {\n        colMult.push(secondArray[row][cm])\n      }\n      let newNumb = 0\n      for (let index = 0; index < rowMult.length; index++) {\n        newNumb += rowMult[index] * colMult[index]\n      }\n      multMatrix[rm][cm] = newNumb\n    }\n  }\n  return multMatrix\n}\n\nconst firstMatrix = [\n  [1, 2],\n  [3, 4]\n]\n\nconst secondMatrix = [\n  [5, 6],\n  [7, 8]\n]\n\nconsole.log(matrixMult(firstMatrix, secondMatrix)) // [ [ 19, 22 ], [ 43, 50 ] ]\n\nconst thirdMatrix = [\n  [-1, 4, 1],\n  [7, -6, 2]\n]\nconst fourthMatrix = [\n  [2, -2],\n  [5, 3],\n  [3, 2]\n]\n\nconsole.log(matrixMult(thirdMatrix, fourthMatrix)) // [ [ 21, 16 ], [ -10, -28 ] ]\n","index":97},{"title":"Mean Square Error","category":"Maths","id":"MeanSquareError_Maths","algorithm":"// Wikipedia: https://en.wikipedia.org/wiki/Mean_squared_error\n\nconst meanSquaredError = (predicted, expected) => {\n  if (!Array.isArray(predicted) || !Array.isArray(expected)) {\n    throw new TypeError('Argument must be an Array')\n  }\n\n  if (predicted.length !== expected.length) {\n    throw new TypeError('The two lists must be of equal length')\n  }\n\n  let err = 0\n\n  for (let i = 0; i < expected.length; i++) {\n    err += (expected[i] - predicted[i]) ** 2\n  }\n\n  return err / expected.length\n}\n\nexport { meanSquaredError }\n","index":98},{"title":"Modular Binary Exponentiation Recursive","category":"Maths","id":"ModularBinaryExponentiationRecursive_Maths","algorithm":"/*\r\n  Modified from:\r\n    https://github.com/TheAlgorithms/Python/blob/master/maths/binary_exp_mod.py\r\n\r\n  Explaination:\r\n    https://en.wikipedia.org/wiki/Exponentiation_by_squaring\r\n*/\r\n\r\nconst modularBinaryExponentiation = (a, n, m) => {\r\n  // input: a: int, n: int, m: int\r\n  // returns: (a^n) % m: int\r\n  if (n === 0) {\r\n    return 1\r\n  } else if (n % 2 === 1) {\r\n    return (modularBinaryExponentiation(a, n - 1, m) * a) % m\r\n  } else {\r\n    const b = modularBinaryExponentiation(a, n / 2, m)\r\n    return (b * b) % m\r\n  }\r\n}\r\n\r\nexport { modularBinaryExponentiation }\r\n","index":99},{"title":"Number Of Digits","category":"Maths","id":"NumberOfDigits_Maths","algorithm":"/**\n *\n * Author: dephraiim\n * License: GPL-3.0 or later\n *\n * Returns the number of digits of a given integer\n *\n */\n\nconst numberOfDigit = (n) => Math.abs(n).toString().length\n\nexport { numberOfDigit }\n","index":100},{"title":"Palindrome","category":"Maths","id":"Palindrome_Maths","algorithm":"/**\n * A palindrome is any string that can be reversed and still be the same.\n * An example of one is 'radar', since it is spelled the same even after\n * being reversed. One method to check if a\n *\n * Here's how this works recursively:\n *\n * Palindrome('radar')\n * true && Palindrome('ada')\n * true && true && Palindrome('d')\n * true && true && true && true\n *\n * @flow\n * @complexity: O(n)\n */\n\nconst PalindromeRecursive = (string) => {\n  // Base case\n  if (string.length < 2) return true\n\n  // Check outermost keys\n  if (string[0] !== string[string.length - 1]) {\n    return false\n  }\n\n  return PalindromeRecursive(string.slice(1, string.length - 1))\n}\n\nconst PalindromeIterative = (string) => {\n  const _string = string\n    .toLowerCase()\n    .replace(/ /g, '')\n    .replace(/,/g, '')\n    .replace(/'.'/g, '')\n    .replace(/:/g, '')\n    .split('')\n\n  // A word of only 1 character is already a palindrome, so we skip to check it\n  while (_string.length > 1) {\n    if (_string.shift() !== _string.pop()) {\n      return false\n    }\n  }\n\n  return true\n}\n\nexport { PalindromeIterative, PalindromeRecursive }\n","index":101},{"title":"Pascal Triangle","category":"Maths","id":"PascalTriangle_Maths","algorithm":"const addRow = (triangle) => {\n  const previous = triangle[triangle.length - 1]\n  const newRow = [1]\n  for (let i = 0; i < previous.length - 1; i++) {\n    const current = previous[i]\n    const next = previous[i + 1]\n    newRow.push(current + next)\n  }\n  newRow.push(1)\n  return triangle.push(newRow)\n}\n\nconst generate = (numRows) => {\n  const triangle = [[1], [1, 1]]\n\n  if (numRows === 0) {\n    return []\n  } else if (numRows === 1) {\n    return [[1]]\n  } else if (numRows === 2) {\n    return [[1], [1, 1]]\n  } else {\n    for (let i = 2; i < numRows; i++) {\n      addRow(triangle)\n    }\n  }\n  return triangle\n}\n\nexport { generate }\n","index":102},{"title":"Perfect Cube","category":"Maths","id":"PerfectCube_Maths","algorithm":"/**\n * Author: dephraiim\n * License: GPL-3.0 or later\n *\n */\n\nconst perfectCube = (num) => Math.round(num ** (1 / 3)) ** 3 === num\n\nexport { perfectCube }\n","index":103},{"title":"Perfect Number","category":"Maths","id":"PerfectNumber_Maths","algorithm":"/**\n * Author: dephraiim\n * License: GPL-3.0 or later\n *\n * == Perfect Number ==\n * In number theory, a perfect number is a positive integer that is equal to the sum of\n * its positive divisors(factors), excluding the number itself.\n * For example: 6 ==> divisors[1, 2, 3, 6]\n *      Excluding 6, the sum(divisors) is 1 + 2 + 3 = 6\n *      So, 6 is a Perfect Number\n * Other examples of Perfect Numbers: 28, 486, ...\n *\n * More on Perfect Number:\n *      https://en.wikipedia.org/wiki/Perfect_number\n *\n */\n\nconst factorsExcludingNumber = (n) => {\n  return [...Array(n).keys()].filter((num) => n % num === 0)\n}\n\nconst perfectNumber = (n) => {\n  const factorSum = factorsExcludingNumber(n).reduce((num, initialValue) => {\n    return num + initialValue\n  }, 0)\n\n  return factorSum === n\n}\n\nexport { perfectNumber }\n","index":104},{"title":"Perfect Square","category":"Maths","id":"PerfectSquare_Maths","algorithm":"/**\n * Author: dephraiim\n * License: GPL-3.0 or later\n *\n */\n\nconst perfectSquare = (num) => Math.sqrt(num) ** 2 === num\n\nexport { perfectSquare }\n","index":105},{"title":"Permutation And Combination","category":"Maths","id":"PermutationAndCombination_Maths","algorithm":"/**\n * @details Calculates the number of permutations and combinations.\n * @external_link (Permutation And Combinations)[https://www.geeksforgeeks.org/permutation-and-combination/]\n */\n\n/**\n * @brief Calculates the factorial of the given number.\n * @param num: integer\n * @details Factorial of n = n * (n - 1) * (n - 2) * ... * 1\n * @returns integer: Factorial of the number.\n            NaN: if negative number is provided.\n */\nconst factorial = (n) => {\n  if (n >= 0) {\n    if (n === 0) {\n      return 1\n    } else {\n      return n * factorial(n - 1)\n    }\n  } else {\n    return NaN\n  }\n}\n\n/**\n * @brief Calculates the number of Permutations from the given data.\n * @param\n * n: integer -> number of items.\n * r: integer -> number of times n is taken.\n * @returns integer: The number of permutations.\n            NaN: if negative number is provided.\n */\nconst permutation = (n, r) => {\n  return factorial(n) / factorial(n - r)\n}\n\n/**\n * @brief Calculates the number of Combinations from the given data.\n * @param\n * n -> number of items.\n * r -> number of times n is taken.\n * @returns integer: The number of combinations.\n            NaN: if negative number is provided.\n */\nconst combination = (n, r) => {\n  return factorial(n) / (factorial(r) * factorial(n - r))\n}\n\n// Exports the functions to be used in other files.\nmodule.exports.factorial = factorial\nmodule.exports.permutation = permutation\nmodule.exports.combination = combination\n\n/**\n * @example\n\n   const funcs = require(\"./PermutationAndCombination.js\");\n\n   console.log(funcs.factorial(5));\n   console.log(funcs.permutation(5, 2));\n   console.log(funcs.combination(5, 2));\n\n * @output\n   120\n   20\n   10\n */\n","index":106},{"title":"Pi Approximation Monte Carlo","category":"Maths","id":"PiApproximationMonteCarlo_Maths","algorithm":"// Wikipedia: https://en.wikipedia.org/wiki/Monte_Carlo_method\n// Video Explaination: https://www.youtube.com/watch?v=ELetCV_wX_c\n\nconst piEstimation = (iterations = 100000) => {\n  let circleCounter = 0\n\n  for (let i = 0; i < iterations; i++) {\n    // generating random points and checking if it lies within a circle of radius 1\n    const x = Math.random()\n    const y = Math.random()\n    const radius = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2))\n\n    if (radius < 1) circleCounter += 1\n  }\n\n  // fomula for pi = (ratio of number inside circle and total iteration) x 4\n  const pi = (circleCounter / iterations) * 4\n  return pi\n}\n\nexport { piEstimation }\n","index":107},{"title":"Polynomial","category":"Maths","id":"Polynomial_Maths","algorithm":"/**\n * Polynomials are algebraic expressions consisting of two or more algebraic terms.\n * Terms of a polynomial are:\n * 1. Coefficients e.g. 5, 4 in 5x^0, 4x^3 respectively\n * 2. Variables e.g. y in 3y^2\n * 3. Exponents e.g. 5 in y^5\n *\n * Class Polynomial constructs the polynomial using Array as an argument.\n * The members of array are coefficients and their indexes as exponents.\n */\nclass Polynomial {\n  constructor (array) {\n    this.coefficientArray = array // array of coefficients\n    this.polynomial = '' // in terms of x e.g. (2x) + (1)\n    this.construct()\n  }\n\n  /**\n   * Function to construct the polynomial in terms of x using the coefficientArray\n   */\n  construct () {\n    this.polynomial = this.coefficientArray\n      .map((coefficient, exponent) => {\n        if (coefficient === 0) {\n          return '0'\n        }\n        if (exponent === 0) {\n          return `(${coefficient})`\n        } else if (exponent === 1) {\n          return `(${coefficient}x)`\n        } else {\n          return `(${coefficient}x^${exponent})`\n        }\n      })\n      .filter((x) => {\n        if (x !== '0') {\n          return x\n        }\n      })\n      .reverse()\n      .join(' + ')\n  }\n\n  /**\n   * Function to display polynomial in terms of x\n   * @returns {String} of polynomial representation in terms of x\n   */\n  display () {\n    return this.polynomial\n  }\n\n  /**\n   * Function to calculate the value of the polynomial by substituting variable x\n   * @param {Number} value\n   */\n  evaluate (value) {\n    return this.coefficientArray.reduce((result, coefficient, exponent) => {\n      return result + coefficient * Math.pow(value, exponent)\n    }, 0)\n  }\n}\n\nexport { Polynomial }\n","index":108},{"title":"Pow","category":"Maths","id":"Pow_Maths","algorithm":"// Returns the value of x to the power of y\n\nconst pow = (x, y) => {\n  let result = 1\n  for (let i = 1; i <= y; i++) {\n    result *= x\n  }\n  return result\n}\n\nexport { pow }\n","index":109},{"title":"Prime Check","category":"Maths","id":"PrimeCheck_Maths","algorithm":"/*\r\n  Modified from:\r\n    https://github.com/TheAlgorithms/Python/blob/master/maths/prime_check.py\r\n\r\n  Complexity:\r\n    O(sqrt(n))\r\n*/\r\n\r\nconst PrimeCheck = (n) => {\r\n  // input: n: int\r\n  // output: boolean\r\n  if (n === 1) return false\r\n  if (n === 0) return false\r\n\r\n  for (let i = 2; i * i <= n; i++) {\r\n    if (n % i === 0) {\r\n      return false\r\n    }\r\n  }\r\n  return true\r\n}\r\n\r\nexport { PrimeCheck }\r\n","index":110},{"title":"Reverse Polish Notation","category":"Maths","id":"ReversePolishNotation_Maths","algorithm":"// Wikipedia: https://en.wikipedia.org/wiki/Reverse_Polish_notation\n\nconst calcRPN = (expression) => {\n  const operators = {\n    '+': (a, b) => a + b,\n    '-': (a, b) => a - b,\n    '*': (a, b) => a * b,\n    '/': (a, b) => b / a\n  }\n\n  const tokens = expression.split(' ')\n\n  const stack = []\n\n  tokens.forEach((token) => {\n    const operator = operators[token]\n\n    if (typeof operator === 'function') {\n      const a = stack.pop()\n      const b = stack.pop()\n\n      const result = operator(a, b)\n\n      stack.push(result)\n    } else {\n      stack.push(parseFloat(token))\n    }\n  })\n\n  return stack.pop()\n}\n\nexport { calcRPN }\n","index":111},{"title":"Sieve Of Eratosthenes","category":"Maths","id":"SieveOfEratosthenes_Maths","algorithm":"const sieveOfEratosthenes = (n) => {\n  /*\n   * Calculates prime numbers till a number n\n   * :param n: Number upto which to calculate primes\n   * :return: A boolean list contaning only primes\n   */\n  const primes = new Array(n + 1)\n  primes.fill(true) // set all as true initially\n  primes[0] = primes[1] = false // Handling case for 0 and 1\n  const sqrtn = Math.ceil(Math.sqrt(n))\n  for (let i = 2; i <= sqrtn; i++) {\n    if (primes[i]) {\n      for (let j = 2 * i; j <= n; j += i) {\n        primes[j] = false\n      }\n    }\n  }\n  return primes\n}\n\nexport { sieveOfEratosthenes }\n","index":112},{"title":"Softmax","category":"Maths","id":"Softmax_Maths","algorithm":"// Wikipedia: https://en.wikipedia.org/wiki/Softmax_function\n\nconst Softmax = (inputs) => {\n  const eulerExpOfAllInputs = inputs.map(input => Math.exp(input))\n  const sumOfEulerExpOfAllInputs = eulerExpOfAllInputs.reduce((a, b) => a + b)\n\n  return inputs.map((input) => {\n    const eulerExpInputs = Math.exp(input)\n    return eulerExpInputs / sumOfEulerExpOfAllInputs\n  })\n}\n\nexport { Softmax }\n","index":113},{"title":"While Loop Factorial","category":"Maths","id":"WhileLoopFactorial_Maths","algorithm":"/*\n    author: Theepag\n */\nconst factorialize = (num) => {\n  // Step 1. variable result to store num\n  let result = num\n  // If num = 0 OR 1, the factorial will return 1\n  if (num === 0 || num === 1) { return 1 }\n  // Step 2. WHILE loop\n  while (num > 1) {\n    num-- // decrement 1 at each iteration\n    result = result * num // or result = result * num;\n  }\n  // Step 3. Return the factorial\n  return result\n}\n// test\nconsole.log(factorialize(5))\nconsole.log(factorialize(4))\n","index":114},{"title":"Decimal Isolate","category":"Maths","id":"decimalIsolate_Maths","algorithm":"/*\n * function isolates the decimal part of a number.\n * Take the number and subtract it from the floored number.\n * Return the result.\n */\n\nconst decimalIsolate = (number) => {\n  const ans = parseFloat((number + '').replace(/^[-\\d]+./, '.'))\n  return isNaN(ans) === true ? 0 : ans\n}\n\n// testing\nconsole.log(decimalIsolate(35.345))\nconsole.log(decimalIsolate(56.879))\nconsole.log(decimalIsolate(89.5643))\nconsole.log(decimalIsolate(38.00))\nconsole.log(decimalIsolate(33))\n","index":115},{"title":"Is Divisible","category":"Maths","id":"isDivisible_Maths","algorithm":"// Checks if a number is divisible by another number.\n\nconst isDivisible = (num1, num2) => {\n  if (isNaN(num1) || isNaN(num2) || num1 == null || num2 == null) {\n    return 'All parameters have to be numbers'\n  }\n  if (num2 === 0) {\n    return 'Not possible to divide by zero'\n  }\n  return num1 % num2 === 0\n}\n\nconsole.log(isDivisible(10, 5)) // returns true\nconsole.log(isDivisible(123498175, 5)) // returns true\nconsole.log(isDivisible(99, 5)) // returns false\n","index":116},{"title":"Is Odd","category":"Maths","id":"isOdd_Maths","algorithm":"/*\n * function to check if number is odd\n * return true if number is odd\n * else false\n */\n\nconst isOdd = (value) => {\n  return !!((value & 1))\n}\n\n// testing\nconsole.log(isOdd(2))\nconsole.log(isOdd(3))\n","index":117},{"title":"Test","category":"Maths","id":"test","index":118},{"title":"Abs.test","category":"test","id":"Abs.test_test","algorithm":"import { absVal } from '../Abs'\n\ndescribe('absVal', () => {\n  it('should return an absolute value of a negative number', () => {\n    const absOfNegativeNumber = absVal(-34)\n    expect(absOfNegativeNumber).toBe(34)\n  })\n\n  it('should return an absolute value of a positive number', () => {\n    const absOfPositiveNumber = absVal(50)\n    expect(absOfPositiveNumber).toBe(50)\n  })\n})\n","index":119},{"title":"Area.test","category":"test","id":"Area.test_test","algorithm":"import * as area from '../Area'\n\ndescribe('Testing surfaceAreaCube calculations', () => {\n  it('with natural number', () => {\n    const surfaceAreaOfOne = area.surfaceAreaCube(1.2)\n    const surfaceAreaOfThree = area.surfaceAreaCube(3)\n    expect(surfaceAreaOfOne).toBe(8.64)\n    expect(surfaceAreaOfThree).toBe(54)\n  })\n  it('with negative argument, expect throw', () => {\n    expect(() => area.surfaceAreaCube(-1)).toThrow()\n  })\n  it('with non-numeric argument, expect throw', () => {\n    expect(() => area.surfaceAreaCube('199')).toThrow()\n  })\n})\ndescribe('Testing surfaceAreaSphere calculations', () => {\n  it('with correct value', () => {\n    const calculateArea = area.surfaceAreaSphere(5)\n    const expected = 314.1592653589793\n    expect(calculateArea).toBe(expected)\n  })\n  it('with negative value, expect throw', () => {\n    expect(() => area.surfaceAreaSphere(-1)).toThrow()\n  })\n})\ndescribe('Testing areaRectangle calculations', () => {\n  it('with correct args', () => {\n    const areaRectangle = area.areaRectangle(2.5, 2)\n    expect(areaRectangle).toBe(5.0)\n  })\n  it('with incorrect args, expect throw', () => {\n    expect(() => area.areaRectangle(-1, 20)).toThrow()\n    expect(() => area.areaRectangle('1', 0)).toThrow()\n    expect(() => area.areaRectangle(23, -1)).toThrow()\n    expect(() => area.areaRectangle(23, 'zero')).toThrow()\n  })\n})\ndescribe('Testing areaSquare calculations', () => {\n  it('with correct args', () => {\n    const areaSquare = area.areaSquare(2.5)\n    expect(areaSquare).toBe(6.25)\n  })\n  it('with incorrect side length, expect throw', () => {\n    expect(() => area.areaSquare(-1)).toThrow()\n    expect(() => area.areaSquare('zero')).toThrow()\n  })\n})\ndescribe('Testing areaTriangle calculations', () => {\n  it('with correct args', () => {\n    const areaTriangle = area.areaTriangle(1.66, 3.44)\n    expect(areaTriangle).toBe(2.8552)\n  })\n  it('with incorrect base and height, expect throw', () => {\n    expect(() => area.areaTriangle(-1, 1)).toThrow()\n    expect(() => area.areaTriangle(9, 'zero')).toThrow()\n  })\n})\ndescribe('Testing areaParallelogram calculations', () => {\n  it('with correct args', () => {\n    const areaParallelogram = area.areaParallelogram(1.66, 3.44)\n    expect(areaParallelogram).toBe(5.7104)\n  })\n  it('with incorrect base and height, expect throw', () => {\n    expect(() => area.areaParallelogram(-1, 1)).toThrow()\n    expect(() => area.areaParallelogram(9, 'zero')).toThrow()\n  })\n})\ndescribe('Testing areaTrapezium calculations', () => {\n  it('with correct args', () => {\n    const areaTrapezium = area.areaTrapezium(1.66, 2.41, 4.1)\n    expect(areaTrapezium).toBe(8.3435)\n  })\n  it('with incorrect bases and height, expect throw', () => {\n    expect(() => area.areaTrapezium(-1, 1, 0)).toThrow()\n    expect(() => area.areaTrapezium(9, 'zero', 2)).toThrow()\n    expect(() => area.areaTrapezium(9, 1, 'seven')).toThrow()\n  })\n})\ndescribe('Testing areaCircle calculations', () => {\n  it('with correct args', () => {\n    const areaCircle = area.areaCircle(3.456)\n    expect(areaCircle).toBe(37.52298159254666)\n  })\n  it('with incorrect diagonal, expect throw', () => {\n    expect(() => area.areaCircle(-1)).toThrow()\n    expect(() => area.areaCircle('zero')).toThrow()\n  })\n})\ndescribe('Testing areaRhombus calculations', () => {\n  it('with correct args', () => {\n    const areaRhombus = area.areaRhombus(2.5, 2.0)\n    expect(areaRhombus).toBe(2.5)\n  })\n  it('with incorrect diagonals, expect throw', () => {\n    expect(() => area.areaRhombus(7, -1)).toThrow()\n    expect(() => area.areaRhombus('zero', 2)).toThrow()\n  })\n})\n","index":120},{"title":"Armstrong Number.test","category":"test","id":"ArmstrongNumber.test_test","algorithm":"import { armstrongNumber } from '../ArmstrongNumber'\n\ndescribe('ArmstrongNumber', () => {\n  it('should return true for an armstrong number', () => {\n    expect(armstrongNumber(371)).toBeTruthy()\n  })\n\n  it('should return false for a non-armstrong number', () => {\n    expect(armstrongNumber(300)).toBeFalsy()\n  })\n  it('should return false for negative values', () => {\n    expect(armstrongNumber(-2)).toBeFalsy()\n  })\n})\n","index":121},{"title":"Average Mean.test","category":"test","id":"AverageMean.test_test","algorithm":"import { mean } from '../AverageMean'\n\ndescribe('Tests for average mean', () => {\n  it('should be a function', () => {\n    expect(typeof mean).toEqual('function')\n  })\n  it('should return the mean of an array of numbers', () => {\n    const meanFunction = mean([1, 2, 4, 5])\n    expect(meanFunction).toBe(3)\n  })\n})\n","index":122},{"title":"B Inary Convert.test","category":"test","id":"BInaryConvert.test_test","algorithm":"import { BinaryConvert } from '../BinaryConvert'\n\ndescribe('Binary Convert', () => {\n  it('should return the correct value', () => {\n    expect(BinaryConvert(12)).toBe(1100)\n  })\n  it('should return the correct value of the sum from two number', () => {\n    expect(BinaryConvert(12 + 2)).toBe(1110)\n  })\n})\n","index":123},{"title":"Binary Exponentiation Iterative.test","category":"test","id":"BinaryExponentiationIterative.test_test","algorithm":"import { exponent } from '../BinaryExponentiationIterative'\n\ndescribe('exponent', () => {\n  it('should return 1 when power is 0', () => {\n    expect(exponent(5, 0)).toBe(1)\n  })\n\n  it('should return 0 when base is 0', () => {\n    expect(exponent(0, 7)).toBe(0)\n  })\n\n  it('should return the value of a base raised to a power', () => {\n    expect(exponent(3, 5)).toBe(243)\n  })\n})\n","index":124},{"title":"Digit Sum.test","category":"test","id":"DigitSum.test_test","algorithm":"import { digitSum } from '../DigitSum'\n\ndescribe('digitSum', () => {\n  it('is a function', () => {\n    expect(typeof digitSum).toEqual('function')\n  })\n  it('should return the sum of digits of a given number', () => {\n    const sumOfNumber = digitSum(12345)\n    expect(sumOfNumber).toBe(15)\n  })\n})\n","index":125},{"title":"Eulers Totient Function.test","category":"test","id":"EulersTotientFunction.test_test","algorithm":"import { eulersTotientFunction } from '../EulersTotientFunction'\n\ndescribe('eulersTotientFunction', () => {\n  it('is a function', () => {\n    expect(typeof eulersTotientFunction).toEqual('function')\n  })\n  it('should return the phi of a given number', () => {\n    const phiOfNumber = eulersTotientFunction(10)\n    expect(phiOfNumber).toBe(4)\n  })\n})\n","index":126},{"title":"Factorial.test","category":"test","id":"Factorial.test_test","algorithm":"import { calcFactorial } from '../Factorial'\n\ndescribe('calcFactorial', () => {\n  it('is a function', () => {\n    expect(typeof calcFactorial).toEqual('function')\n  })\n\n  it('should return a statement for value \"0\"', () => {\n    expect(calcFactorial(0)).toBe('The factorial of 0 is 1.')\n  })\n\n  it('should return a statement for \"null\" and \"undefined\"', () => {\n    const nullFactorial = calcFactorial(null)\n    const undefinedFactorial = calcFactorial(undefined)\n\n    expect(nullFactorial).toBe(\n      'Sorry, factorial does not exist for null or undefined numbers.'\n    )\n    expect(undefinedFactorial).toBe(\n      'Sorry, factorial does not exist for null or undefined numbers.'\n    )\n  })\n\n  it('should not support negative numbers', () => {\n    const negativeFactorial = calcFactorial(-5)\n    expect(negativeFactorial).toBe(\n      'Sorry, factorial does not exist for negative numbers.'\n    )\n  })\n\n  it('should return the factorial of a positive number', () => {\n    const positiveFactorial = calcFactorial(3)\n    expect(positiveFactorial).toBe('The factorial of 3 is 6')\n  })\n})\n","index":127},{"title":"Factors.test","category":"test","id":"Factors.test_test","algorithm":"import { factorsOfANumber } from '../Factors'\n\ndescribe('Factors', () => {\n  factorsOfANumber(50).forEach((num) => {\n    it(`${num} is a factor of 50`, () => {\n      const isFactor = 50 % num === 0\n      expect(isFactor).toBeTruthy()\n    })\n  })\n})\n","index":128},{"title":"Fibonacci.test","category":"test","id":"Fibonacci.test_test","algorithm":"import {\n  FibonacciDpWithoutRecursion,\n  FibonacciRecursiveDP,\n  FibonacciIterative,\n  FibonacciRecursive,\n  FibonacciMatrixExpo\n} from '../Fibonacci'\n\ndescribe('Fibonanci', () => {\n  it('should return an array of numbers for FibonnaciIterative', () => {\n    expect(FibonacciIterative(5)).toEqual(\n      expect.arrayContaining([1, 1, 2, 3, 5])\n    )\n  })\n\n  it('should return an array of numbers for FibonnaciRecursive', () => {\n    expect(FibonacciRecursive(5)).toEqual(\n      expect.arrayContaining([1, 1, 2, 3, 5])\n    )\n  })\n\n  it('should return number for FibonnaciRecursiveDP', () => {\n    expect(FibonacciRecursiveDP(5)).toBe(5)\n  })\n\n  it('should return an array of numbers for FibonacciDpWithoutRecursion', () => {\n    expect(FibonacciDpWithoutRecursion(5)).toEqual(\n      expect.arrayContaining([1, 1, 2, 3, 5])\n    )\n  })\n\n  it('should return number for FibonnaciMatrixExpo', () => {\n    expect(FibonacciMatrixExpo(0)).toBe(0)\n    expect(FibonacciMatrixExpo(1)).toBe(1)\n    expect(FibonacciMatrixExpo(2)).toBe(1)\n    expect(FibonacciMatrixExpo(3)).toBe(2)\n    expect(FibonacciMatrixExpo(4)).toBe(3)\n    expect(FibonacciMatrixExpo(5)).toBe(5)\n  })\n})\n","index":129},{"title":"Find Hcf.test","category":"test","id":"FindHcf.test_test","algorithm":"import { findHCF } from '../FindHcf'\n\ndescribe('findHCF', () => {\n  it('should throw a statement for values less than 1', () => {\n    expect(findHCF(0, 0)).toBe('Please enter values greater than zero.')\n  })\n\n  it('should throw a statement for one value less than 1', () => {\n    expect(findHCF(0, 1)).toBe('Please enter values greater than zero.')\n    expect(findHCF(1, 0)).toBe('Please enter values greater than zero.')\n  })\n\n  it('should return an error for values non-integer values', () => {\n    expect(findHCF(2.24, 4.35)).toBe('Please enter whole numbers.')\n  })\n\n  it('should return the HCF of two given integers', () => {\n    expect(findHCF(27, 36)).toBe(9)\n  })\n})\n","index":130},{"title":"Find Lcm.test","category":"test","id":"FindLcm.test_test","algorithm":"import { findLcm } from '../FindLcm'\n\ndescribe('findLcm', () => {\n  it('should throw a statement for values less than 1', () => {\n    expect(findLcm(0, 0)).toBe('Please enter values greater than zero.')\n  })\n\n  it('should throw a statement for one value less than 1', () => {\n    expect(findLcm(1, 0)).toBe('Please enter values greater than zero.')\n    expect(findLcm(0, 1)).toBe('Please enter values greater than zero.')\n  })\n\n  it('should return an error for values non-integer values', () => {\n    expect(findLcm(4.564, 7.39)).toBe('Please enter whole numbers.')\n  })\n\n  it('should return the LCM of two given integers', () => {\n    expect(findLcm(27, 36)).toBe(108)\n  })\n})\n","index":131},{"title":"Grid Get.test","category":"test","id":"GridGet.test_test","algorithm":"import { gridGetX, gridGetY } from '../GridGet'\n\ndescribe('GridGet', () => {\n  it('should have a value of x for the 27th element if the square array has 400 elements', () => {\n    expect(gridGetX(Math.sqrt(400), 27)).toEqual(8)\n  })\n  it('should have a value of x for the 11th element if the square array has 7 columns and 3 rows', () => {\n    expect(gridGetX(7, 11)).toEqual(5)\n  })\n  it('should have a value of y for the 27th element if the square array has 400 elements', () => {\n    expect(gridGetY(Math.sqrt(400), 27)).toEqual(2)\n  })\n  it('should have a value of y for the 11th element if the square array has 7 columns and 3 rows ', () => {\n    expect(gridGetX(7, 11)).toEqual(5)\n  })\n})\n","index":132},{"title":"Mean Square Error.test","category":"test","id":"MeanSquareError.test_test","algorithm":"import { meanSquaredError } from '../MeanSquareError'\n\ndescribe('meanSquareError', () => {\n  it('should throw an error on non-array arguments', () => {\n    expect(() => meanSquaredError(1, 4)).toThrow('Argument must be an Array')\n  })\n\n  it('should throw an error on non equal length ', () => {\n    const firstArr = [1, 2, 3, 4, 5]\n    const secondArr = [1, 2, 3]\n    expect(() => meanSquaredError(firstArr, secondArr)).toThrow(\n      'The two lists must be of equal length'\n    )\n  })\n\n  it('should return the mean square error of two equal length arrays', () => {\n    const firstArr = [1, 2, 3, 4, 5]\n    const secondArr = [1, 3, 5, 6, 7]\n    expect(meanSquaredError(firstArr, secondArr)).toBe(2.6)\n  })\n})\n","index":133},{"title":"Modular Binary Exponentiation Recursive.test","category":"test","id":"ModularBinaryExponentiationRecursive.test_test","algorithm":"import { modularBinaryExponentiation } from '../ModularBinaryExponentiationRecursive'\n\ndescribe('modularBinaryExponentiation', () => {\n  it('should return the binary exponentiation', () => {\n    expect(modularBinaryExponentiation(2, 10, 17)).toBe(4)\n  })\n})\n","index":134},{"title":"Number Of Digits.test","category":"test","id":"NumberOfDigits.test_test","algorithm":"import { numberOfDigit } from '../NumberOfDigits'\n\ndescribe('NumberOfDigits', () => {\n  it('should return the correct number of digits for an integer', () => {\n    expect(numberOfDigit(1234000)).toBe(7)\n  })\n\n  it('should return the correct number of digits for a negative number', () => {\n    expect(numberOfDigit(-2346243)).toBe(7)\n  })\n})\n","index":135},{"title":"Palindrome.test","category":"test","id":"Palindrome.test_test","algorithm":"import { PalindromeRecursive, PalindromeIterative } from '../Palindrome'\n\ndescribe('Palindrome', () => {\n  it('should return true for a palindrome for PalindromeRecursive', () => {\n    expect(PalindromeRecursive('mom')).toBeTruthy()\n  })\n  it('should return true  for a palindrome for PalindromeIterative', () => {\n    expect(PalindromeIterative('mom')).toBeTruthy()\n  })\n  it('should return false for a non-palindrome for PalindromeRecursive', () => {\n    expect(PalindromeRecursive('Algorithms')).toBeFalsy()\n  })\n  it('should return true  for a non-palindrome for PalindromeIterative', () => {\n    expect(PalindromeIterative('JavaScript')).toBeFalsy()\n  })\n})\n","index":136},{"title":"Pascal Triangle.test","category":"test","id":"PascalTriangle.test_test","algorithm":"import { generate } from '../PascalTriangle'\n\ndescribe('Pascals Triangle', () => {\n  it('should have the the same length as the number', () => {\n    const pascalsTriangle = generate(5)\n    expect(pascalsTriangle.length).toEqual(5)\n  })\n  it('should have same length as its index in the array', () => {\n    const pascalsTriangle = generate(5)\n    pascalsTriangle.forEach((arr, index) => {\n      expect(arr.length).toEqual(index + 1)\n    })\n  })\n  it('should return an array of arrays', () => {\n    const pascalsTriangle = generate(3)\n    expect(pascalsTriangle).toEqual(\n      expect.arrayContaining([[1], [1, 1], [1, 2, 1]])\n    )\n  })\n})\n","index":137},{"title":"Perfect Cube.test","category":"test","id":"PerfectCube.test_test","algorithm":"import { perfectCube } from '../PerfectCube'\n\ndescribe('PerfectCube', () => {\n  it('should return true for a perfect cube', () => {\n    expect(perfectCube(125)).toBeTruthy()\n  })\n  it('should return false for a non perfect cube', () => {\n    expect(perfectCube(100)).toBeFalsy()\n  })\n})\n","index":138},{"title":"Perfect Number.test","category":"test","id":"PerfectNumber.test_test","algorithm":"import { perfectNumber } from '../PerfectNumber'\n\ndescribe('PerfectNumber', () => {\n  it('should return true for a perfect cube', () => {\n    expect(perfectNumber(28)).toBeTruthy()\n  })\n  it('should return false for a non perfect cube', () => {\n    expect(perfectNumber(10)).toBeFalsy()\n  })\n})\n","index":139},{"title":"Perfect Square.test","category":"test","id":"PerfectSquare.test_test","algorithm":"import { perfectSquare } from '../PerfectSquare'\n\ndescribe('PerfectSquare', () => {\n  it('should return true for a perfect cube', () => {\n    expect(perfectSquare(16)).toBeTruthy()\n  })\n  it('should return false for a non perfect cube', () => {\n    expect(perfectSquare(10)).toBeFalsy()\n  })\n})\n","index":140},{"title":"Pi Approximation Monte Carlo.test","category":"test","id":"PiApproximationMonteCarlo.test_test","algorithm":"import { piEstimation } from '../PiApproximationMonteCarlo'\n\ndescribe('PiApproximationMonteCarlo', () => {\n  it('should be between the range of 2 to 4', () => {\n    const pi = piEstimation()\n    const piRange = pi >= 2 && pi <= 4\n    expect(piRange).toBeTruthy()\n  })\n})\n","index":141},{"title":"Polynomial.test","category":"test","id":"Polynomial.test_test","algorithm":"import { Polynomial } from '../Polynomial'\n\ndescribe('Polynomial', () => {\n  it('should not return a expression for zero', () => {\n    const polynomial = new Polynomial([0])\n    expect(polynomial.display()).toBe('')\n  })\n  it('should not return an expression for zero values', () => {\n    const polynomial = new Polynomial([0, 0, 0, 0, 0])\n    expect(polynomial.display()).toBe('')\n  })\n  it('should return an expression for single a non zero value', () => {\n    const polynomial = new Polynomial([9])\n    expect(polynomial.display()).toBe('(9)')\n  })\n  it('should return an expression for two values', () => {\n    const polynomial = new Polynomial([3, 2])\n    expect(polynomial.display()).toBe('(2x) + (3)')\n  })\n  it('should return an expression for values including zero', () => {\n    const polynomial = new Polynomial([0, 2])\n    expect(polynomial.display()).toBe('(2x)')\n  })\n  it('should return an expression and evaluate it', () => {\n    const polynomial = new Polynomial([1, 2, 3, 4])\n    expect(polynomial.display()).toBe('(4x^3) + (3x^2) + (2x) + (1)')\n    expect(polynomial.evaluate(2)).toEqual(49)\n  })\n  it('should evaluate 0 for zero values', () => {\n    const polynomial = new Polynomial([0, 0, 0, 0])\n    expect(polynomial.evaluate(5)).toEqual(0)\n  })\n  it('should evaluate for negative values', () => {\n    const polynomial = new Polynomial([-1, -3, -4, -7])\n    expect(polynomial.evaluate(-5)).toBe(789)\n  })\n})\n","index":142},{"title":"Pow.test","category":"test","id":"Pow.test_test","algorithm":"import { pow } from '../Pow'\n\ndescribe('Pow', () => {\n  it('should return 1 for numbers with exponent 0', () => {\n    expect(pow(2, 0)).toBe(1)\n  })\n\n  it('should return 0 for numbers with base 0', () => {\n    expect(pow(0, 23)).toBe(0)\n  })\n\n  it('should return the base to the exponent power', () => {\n    expect(pow(24, 4)).toBe(331776)\n  })\n})\n","index":143},{"title":"Prime Check.test","category":"test","id":"PrimeCheck.test_test","algorithm":"import { PrimeCheck } from '../PrimeCheck'\n\ndescribe('PrimeCheck', () => {\n  it('should return true for Prime Numbers', () => {\n    expect(PrimeCheck(1000003)).toBeTruthy()\n  })\n  it('should return false for Non Prime Numbers', () => {\n    expect(PrimeCheck(1000001)).toBeFalsy()\n  })\n  it('should return false for 1 and 0', () => {\n    expect(PrimeCheck(1)).toBeFalsy()\n    expect(PrimeCheck(0)).toBeFalsy()\n  })\n})\n","index":144},{"title":"Reverse Polish Notation.test","category":"test","id":"ReversePolishNotation.test_test","algorithm":"import { calcRPN } from '../ReversePolishNotation'\n\ndescribe('ReversePolishNotation', () => {\n  it('should evaluate correctly for two values', () => {\n    expect(calcRPN('2 3 +')).toEqual(5)\n  })\n  it(\"should evaluate' for multiple values\", () => {\n    expect(calcRPN('2 2 2 * +')).toEqual(6)\n    expect(calcRPN('6 9 7 + 2 / + 3 *')).toEqual(42)\n  })\n})\n","index":145},{"title":"Sieve Of Eratosthenes.test","category":"test","id":"SieveOfEratosthenes.test_test","algorithm":"import { sieveOfEratosthenes } from '../SieveOfEratosthenes'\nimport { PrimeCheck } from '../PrimeCheck'\n\ndescribe('should return an array of prime booleans', () => {\n  it('should have each element in the array as a prime boolean', () => {\n    const n = 30\n    const primes = sieveOfEratosthenes(n)\n    primes.forEach((primeBool, index) => {\n      if (primeBool) {\n        expect(PrimeCheck(index)).toBeTruthy()\n      }\n    })\n  })\n})\n","index":146},{"title":"Softmax.test","category":"test","id":"Softmax.test_test","algorithm":"import { Softmax } from '../Softmax'\n\ndescribe('Softmax', () => {\n  it('should return equal distribution of 1 for equal input values', () => {\n    expect(Softmax([1, 1])).toEqual([0.5, 0.5])\n    expect(Softmax([1, 1, 1, 1])).toEqual([0.25, 0.25, 0.25, 0.25])\n  })\n\n  it('should return values which sum to the value of 1', () => {\n    expect(Softmax([1, 2, 3, 4]).reduce((a, b) => a + b, 0)).toEqual(1)\n  })\n})\n","index":147},{"title":"Navigation","category":null,"id":"Navigation","index":148},{"title":"Haversine","category":"Navigation","id":"Haversine_Navigation","algorithm":"/*\n  Calculate the distance between two coordinates using the haversine formula\n  More about: https://pt.wikipedia.org/wiki/F%C3%B3rmula_de_Haversine\n  @Param {number} latitude1\n  @Param {number} latitude2\n  @Param {number} longitude1\n  @Param {number} longitude2\n */\nconst haversineDistance = (latitude1 = 0, longitude1 = 0, latitude2 = 0, longitude2 = 0) => {\n  validateLatOrLong(latitude1)\n  validateLatOrLong(latitude2)\n  validateLatOrLong(longitude1)\n  validateLatOrLong(longitude2)\n  const earthRadius = 6371e3 // 6,371km\n  const pi = Math.PI\n  const cos1 = latitude1 * pi / 180.0\n  const cos2 = latitude2 * pi / 180.0\n  const deltaLatitude = (latitude2 - latitude1) * pi / 180.0\n  const deltaLongitude = (longitude2 - longitude1) * pi / 180.0\n\n  const alpha = Math.sin(deltaLatitude / 2) * Math.sin(deltaLatitude / 2) + Math.cos(cos1) * Math.cos(cos2) * Math.sin(deltaLongitude / 2) * Math.sin(deltaLongitude / 2)\n  const constant = 2 * Math.atan2(Math.sqrt(alpha), Math.sqrt(1 - alpha))\n  return earthRadius * constant\n}\n\nconst validateLatOrLong = value => {\n  if (typeof value !== 'number') {\n    throw new TypeError('The value of latitude or longitude should be a number')\n  }\n}\n\nexport { haversineDistance }\n","index":149},{"title":"Haversine.test","category":"Navigation","id":"Haversine.test_Navigation","algorithm":"import { haversineDistance } from './Haversine'\n\ndescribe('Testing the haversine distance calculator', () => {\n  it('Calculate distance', () => {\n    const distance = haversineDistance(64.1265, -21.8174, 40.7128, -74.0060)\n    expect(distance).toBe(4208198.758424171)\n  })\n  it('Test validation, expect throw', () => {\n    expect(() => haversineDistance(64.1265, -21.8174, 40.7128, '74.0060')).toThrow()\n  })\n})\n","index":150},{"title":"Project- Euler","category":null,"id":"Project-Euler","index":151},{"title":"Problem020","category":"Project-Euler","id":"Problem020_Project-Euler","algorithm":"/*\nFactorial digit sum\n\nn! means n × (n − 1) × ... × 3 × 2 × 1\n\nFor example, 10! = 10 × 9 × ... × 3 × 2 × 1 = 3628800,\nand the sum of the digits in the number 10! is 3 + 6 + 2 + 8 + 8 + 0 + 0 = 27.\n\nFind the sum of the digits in the number 100!\n*/\n\nconst findFactorialDigitSum = (num) => {\n  let result = 0\n  const stringifiedNumber = factorize(num).toLocaleString('fullwide', { useGrouping: false })\n  stringifiedNumber.split('').map(num => { result += Number(num) })\n  return result\n}\n\nconst factorize = (num) => num === 0 ? 1 : num * factorize(num - 1)\n\nconsole.log(findFactorialDigitSum(100))\n","index":152},{"title":"Problem1","category":"Project-Euler","id":"Problem1_Project-Euler","algorithm":"// https://projecteuler.net/problem=1\n/*    Multiples of 3 and 5\n    If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.\nFind the sum of all the multiples of 3 or 5 below the provided parameter value number.\n*/\n\nconst readline = require('readline')\n\nconst multiplesThreeAndFive = (num) => {\n  let total = 0\n  // total for calculating the sum\n  for (let i = 0; i < num; i++) {\n    if (i % 3 === 0 || i % 5 === 0) {\n      total += i\n    }\n  }\n  return total\n}\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n})\nrl.question('Enter a number: ', function (num) {\n  console.log(multiplesThreeAndFive(num)) // multiples3_5 function to calculate the sum of multiples of 3 and 5 within num\n  rl.close()\n})\n","index":153},{"title":"Problem2","category":"Project-Euler","id":"Problem2_Project-Euler","algorithm":"// https://projecteuler.net/problem=2\nconst SQ5 = 5 ** 0.5 // Square root of 5\nconst PHI = (1 + SQ5) / 2 // definition of PHI\n\n// theoretically it should take O(1) constant amount of time as long\n// arithmetic calculations are considered to be in constant amount of time\nconst EvenFibonacci = (limit) => {\n  const highestIndex = Math.floor(Math.log(limit * SQ5) / Math.log(PHI))\n  const n = Math.floor(highestIndex / 3)\n  return ((PHI ** (3 * n + 3) - 1) / (PHI ** 3 - 1) -\n    ((1 - PHI) ** (3 * n + 3) - 1) / ((1 - PHI) ** 3 - 1)) / SQ5\n}\nconsole.log(EvenFibonacci(4e6)) // Sum of even Fibonacci upto 4 Million\n","index":154},{"title":"Problem3","category":"Project-Euler","id":"Problem3_Project-Euler","algorithm":"// https://projecteuler.net/problem=3\nconst problem = 600851475143\n\nconst largestPrime = (num) => {\n  let newnumm = num\n  let largestFact = 0\n  let counter = 2\n  while (counter * counter <= newnumm) {\n    if (newnumm % counter === 0) {\n      newnumm = newnumm / counter\n    } else {\n      counter++\n    }\n  }\n  if (newnumm > largestFact) {\n    largestFact = newnumm\n  }\n  return largestFact\n}\nconsole.log(largestPrime(problem))\n","index":155},{"title":"Problem4","category":"Project-Euler","id":"Problem4_Project-Euler","algorithm":"// https://projecteuler.net/problem=4\n/* A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.\n   Find the largest palindrome made from the product of two 3-digit numbers.\n*/\nconst largestPalindromic = (digits) => {\n  let i\n  let n\n  let m\n  let d\n  let limit\n  let number = 0\n\n  for (i = 1; i < digits; i++) {\n    number = 10 * number + 9\n  }\n  const inf = number // highest (digits - 1) number, in this example highest 2 digit number\n  const sup = 10 * number + 9 // highest (digits) number, in this example highest 3 digit number\n\n  const isPalindromic = (n) => {\n    let p = 0\n    const q = n\n    let r\n    while (n > 0) {\n      r = n % 10\n      p = 10 * p + r\n      n = Math.floor(n / 10)\n    }\n    return p === q // returning whether the number is palindromic or not\n  }\n\n  for (n = sup * sup, m = inf * inf; n > m; n--) {\n    if (isPalindromic(n)) {\n      limit = Math.ceil(Math.sqrt(n))\n      d = sup\n      while (d >= limit) {\n        if (n % d === 0 && n / d > inf) {\n          return n\n        }\n        d -= 1\n      }\n    }\n  }\n  return NaN // returning not a number, if any such case arise\n}\n\nconsole.log(largestPalindromic(3))\n","index":156},{"title":"Problem6","category":"Project-Euler","id":"Problem6_Project-Euler","algorithm":"// https://projecteuler.net/problem=6\n\nconst num = 100 // number we are checking; change to 10 to check 10 from example\n\nconst squareDifference = (num) => {\n  let sumOfSquares = 0\n  let sums = 0\n  for (let i = 1; i <= num; i++) {\n    sumOfSquares += i ** 2 // add squares to the sum of squares\n    sums += i // add number to sum to square later\n  }\n  return (sums ** 2) - sumOfSquares // difference of square of the total sum and sum of squares\n}\n\nconsole.log(squareDifference(num))\n","index":157},{"title":"Problem7","category":"Project-Euler","id":"Problem7_Project-Euler","algorithm":"// https://projecteuler.net/problem=7\n// My approach does not use the Sieve of Eratosthenes but that is another common way to approach this problem. Sieve of Atkin is another possibility as well.\n\nconst num = 10001\nconst primes = [2, 3, 5, 7, 11, 13] // given list of primes you start with\n\nconst calculatePrime = (num) => {\n  // Calculate each next prime by checking each number to see what it's divisible by\n  let count = primes.length // count number of primes calculated\n  let current = primes[count - 1] + 1 // current number being assessed if prime\n  while (count < num) { // repeat while we haven't reached goal number of primes\n    // go through each prime and see if divisible by the previous primes\n    let prime = false\n    primes.some((n, i) => {\n      if (current % n === 0) {\n        return true\n      }\n      if (i === count - 1) {\n        prime = true\n      }\n    })\n    if (prime) { // if prime, add to prime list and increment count\n      primes.push(current)\n      count += 1\n    }\n    current += 1\n  }\n  return primes[num - 1]\n}\n\nconsole.log(calculatePrime(num))\n","index":158},{"title":"Recursive","category":null,"id":"Recursive","index":159},{"title":"Binary Search","category":"Recursive","id":"BinarySearch_Recursive","algorithm":"\n// https://en.wikipedia.org/wiki/Binary_search_algorithm\n// Search the integer inside the sorted integers array using Binary Search Algorithm\n\nconst BinarySearch = (intArr, searchQuery) => {\n  if (searchQuery === null || searchQuery === undefined || intArr.length === 0) {\n    return false\n  }\n\n  const middleIndex = intArr.length === 1 ? 0 : Math.ceil(intArr.length / 2)\n\n  if (intArr[middleIndex] === searchQuery) {\n    return true\n  } else if (intArr.length > 1) {\n    return intArr[middleIndex] < searchQuery ? BinarySearch(intArr.slice(1, middleIndex)) : BinarySearch(intArr.slice(middleIndex))\n  } else {\n    return false\n  }\n}\n\n// testing\n(() => {\n  console.log('Number Present with odd array length: 5 = ', BinarySearch([1, 2, 3, 4, 5, 6, 7], 5))\n  console.log('Number Present with even array length: 5 = ', BinarySearch([1, 2, 4, 5, 6], 5))\n  console.log('Number Present with only single element: 5 = ', BinarySearch([5], 5))\n  console.log('Number Not Present: 0 = ', BinarySearch([1, 2, 3, 4, 5], 0))\n  console.log('Undefined number search query = ', BinarySearch([1, 2, 3, 4, 5]))\n  console.log('With Empty array = ', BinarySearch([], 1))\n})()\n","index":160},{"title":"Eucledian G C D","category":"Recursive","id":"EucledianGCD_Recursive","algorithm":"function euclideanGCDRecursive (first, second) {\n  /*\n    Calculates GCD of two numbers using Euclidean Recursive Algorithm\n    :param first: First number\n    :param second: Second number\n    :return: GCD of the numbers\n    */\n  if (second === 0) {\n    return first\n  } else {\n    return euclideanGCDRecursive(second, (first % second))\n  }\n}\n\nfunction euclideanGCDIterative (first, second) {\n  /*\n    Calculates GCD of two numbers using Euclidean Iterative Algorithm\n    :param first: First number\n    :param second: Second number\n    :return: GCD of the numbers\n    */\n  while (second !== 0) {\n    const temp = second\n    second = first % second\n    first = temp\n  }\n  return first\n}\n\nfunction main () {\n  const first = 20\n  const second = 30\n  console.log('Recursive GCD for %d and %d is %d', first, second, euclideanGCDRecursive(first, second))\n  console.log('Iterative GCD for %d and %d is %d', first, second, euclideanGCDIterative(first, second))\n}\n\nmain()\n","index":161},{"title":"Fibonacci Number Recursive","category":"Recursive","id":"FibonacciNumberRecursive_Recursive","algorithm":"//  https://en.wikipedia.org/wiki/Fibonacci_number\n\nconst fibonacci = (N) => {\n  if (N === 0 || N === 1) return N\n\n  return fibonacci(N - 2) + fibonacci(N - 1)\n}\n\n// testing\n(() => {\n  const number = 5\n  console.log(number + 'th Fibonacci number is ' + fibonacci(number))\n})()\n","index":162},{"title":"Palindrome","category":"Recursive","id":"Palindrome_Recursive","algorithm":"\n// Check whether the given string is Palindrome or not\nconst Palindrome = (str) => {\n  if (typeof str !== 'string') {\n    str = str.toString()\n  }\n\n  if (str === null || str === undefined) {\n    return false\n  }\n\n  if (str.length === 1 || str.length === 0) {\n    return true\n  }\n\n  if (str[0] !== str[str.length - 1]) {\n    return false\n  } else {\n    return Palindrome(str.slice(1, str.length - 1))\n  }\n};\n\n// testing\n(() => {\n  console.log('Palindrome: String: a = ', Palindrome('a'))\n  console.log('Palindrome: String: abba = ', Palindrome('abba'))\n  console.log('Palindrome: String: ababa = ', Palindrome('ababa'))\n  console.log('Not Palindrome: String: abbxa = ', Palindrome('abbxa'))\n  console.log('Not Palindrome: String: abxa = ', Palindrome('abxa'))\n})()\n","index":163},{"title":"Tower Of Hanoi","category":"Recursive","id":"TowerOfHanoi_Recursive","algorithm":"// wiki - https://en.wikipedia.org/wiki/Tower_of_Hanoi\n// Recursive Javascript function to solve tower of hanoi\n\nfunction TowerOfHanoi (n, fromRod, toRod, auxRod) {\n  if (n === 1) {\n    console.log(`Move disk 1 from rod ${fromRod} to rod ${toRod}`)\n    return\n  }\n  TowerOfHanoi(n - 1, fromRod, auxRod, toRod)\n  console.log(`Move disk ${n} from rod ${fromRod} to rod ${toRod}`)\n  TowerOfHanoi(n - 1, auxRod, toRod, fromRod)\n}\n// Driver code\nconst n = 4\nTowerOfHanoi(n, 'A', 'C', 'B')\n// A, C, B are the name of rods\n","index":164},{"title":"Factorial","category":"Recursive","id":"factorial_Recursive","algorithm":"// function to find factorial using recursion\r\n// example :\r\n//    5! = 1*2*3*4*5 = 120\r\n//    2! = 1*2 = 2\r\n\r\nconst factorial = (n) => {\r\n  if (n === 0) {\r\n    return 1\r\n  }\r\n  return n * factorial(n - 1)\r\n}\r\n\r\n// testing\r\nconsole.log(factorial(4))\r\nconsole.log(factorial(15))\r\nconsole.log(factorial(0))\r\n","index":165},{"title":"Search","category":null,"id":"Search","index":166},{"title":"Binary Search","category":"Search","id":"BinarySearch_Search","algorithm":"/* Binary Search: https://en.wikipedia.org/wiki/Binary_search_algorithm\n *\n * Search a sorted array by repeatedly dividing the search interval\n * in half. Begin with an interval covering the whole array. If the value of the\n * search key is less than the item in the middle of the interval, narrow the interval\n * to the lower half. Otherwise narrow it to the upper half. Repeatedly check until the\n * value is found or the interval is empty.\n */\n\nfunction binarySearch (arr, x, low = 0, high = arr.length - 1) {\n  const mid = Math.floor(low + (high - low) / 2)\n\n  if (high >= low) {\n    if (arr[mid] === x) {\n      // item found => return its index\n      return mid\n    }\n\n    if (x < arr[mid]) {\n      // arr[mid] is an upper bound for x, so if x is in arr => low <= x < mid\n      return binarySearch(arr, x, low, mid - 1)\n    } else {\n      // arr[mid] is a lower bound for x, so if x is in arr => mid < x <= high\n      return binarySearch(arr, x, mid + 1, high)\n    }\n  } else {\n    // if low > high => we have searched the whole array without finding the item\n    return -1\n  }\n}\n\n/* ---------------------------------- Test ---------------------------------- */\n\nconst arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nconst stringArr = [\n  'Alpha',\n  'Bravo',\n  'Charlie',\n  'Delta',\n  'Echo',\n  'Foxtrot',\n  'Golf',\n  'Hotel',\n  'India',\n  'Juliet',\n  'Kilo',\n  'Lima',\n  'Mike',\n  'November',\n  'Oscar',\n  'Papa',\n  'Quebec',\n  'Romeo',\n  'Sierra',\n  'Tango',\n  'Uniform',\n  'Victor',\n  'Whiskey',\n  'X-Ray',\n  'Yankee',\n  'Zulu'\n]\n\nconsole.log(binarySearch(arr, 3))\nconsole.log(binarySearch(arr, 7))\nconsole.log(binarySearch(arr, 13))\n\nconsole.log(binarySearch(stringArr, 'Charlie'))\nconsole.log(binarySearch(stringArr, 'Zulu'))\nconsole.log(binarySearch(stringArr, 'Sierra'))\n","index":167},{"title":"Exponential Search","category":"Search","id":"ExponentialSearch_Search","algorithm":"/**\n * Exponential Search\n *\n * The algorithm consists of two stages. The first stage determines a\n * range in which the search key would reside if it were in the list.\n * In the second stage, a binary search is performed on this range.\n *\n *\n *\n */\n\nfunction binarySearch (arr, x, floor, ceiling) {\n  // Middle index\n  const mid = Math.floor((floor + ceiling) / 2)\n\n  // If value is at the mid position return this position\n  if (arr[mid] === x) {\n    return mid\n  }\n\n  if (floor > ceiling) return -1\n\n  // If the middle element is great than the value\n  // search the left part of the array\n  if (arr[mid] > value) {\n    return binarySearch(arr, value, floor, mid - 1)\n    // If the middle element is lower than the value\n    // search the right part of the array\n  } else {\n    return binarySearch(arr, value, mid + 1, ceiling)\n  }\n}\n\nfunction exponentialSearch (arr, length, value) {\n  // If value is the first element of the array return this position\n  if (arr[0] === value) {\n    return 0\n  }\n\n  // Find range for binary search\n  let i = 1\n  while (i < length && arr[i] <= value) {\n    i = i * 2\n  }\n\n  // Call binary search for the range found above\n  return binarySearch(arr, value, i / 2, Math.min(i, length))\n}\n\nconst arr = [2, 3, 4, 10, 40, 65, 78, 100]\nconst value = 78\nconst result = exponentialSearch(arr, arr.length, value)\n\nif (result < 0) {\n  console.log('Element not found')\n} else {\n  console.log('Element found at position :' + result)\n}\n","index":168},{"title":"Fibonacci Search","category":"Search","id":"FibonacciSearch_Search","algorithm":"/****************************************************************************\n * Fibonacci Search JavaScript Implementation\n * Author   Alhassan Atama Isiaka\n * Version v1.0.0\n * Copyright 2020\n * https://github.com/komputarist\n *\n * This implementation is based on Generalizing the Fibonacci search we\n * define the Fibonacci search of degree K. Like the Fibonacci search,\n * which it reduces to for K = 2, the Fibonacci search of degree K\n * involves only addition and subtraction.\n *  Capocelli R.M. (1991) A Generalization of the Fibonacci Search. In:\n * Bergum G.E., Philippou A.N., Horadam A.F. (eds) Applications of Fibonacci\n * Numbers. Springer, Dordrecht. https://doi.org/10.1007/978-94-011-3586-3_9\n *\n * This snippet is free. Feel free to improve on it\n *\n * We define a function fibonacciSearch() that takes an array of numbers,\n * the item (number) to be searched for and the length of the items in the array\n ****************************************************************************/\n\nconst fibonacciSearch = (arr, x, n) => {\n  let fib2 = 0 // (K-2)'th Fibonacci Number\n  let fib1 = 1 // (K-1)'th Fibonacci Number.\n  let fibK = fib2 + fib1 // Kth Fibonacci\n\n  /* We want to store the smallest fibonacci number smaller such that\n    number is greater than or equal to n, we use fibK for this */\n  while (fibK < n) {\n    fib2 = fib1\n    fib1 = fibK\n    fibK = fib2 + fib1\n  }\n  //  This marks the eliminated range from front\n  let offset = -1\n\n  /* while there are elements to be checked. We compare arr[fib2] with x.\n    When fibM becomes 1, fib2 becomes 0 */\n\n  while (fibK > 1) {\n    // Check if fibK is a valid location\n    const i = Math.min(offset + fib2, n - 1)\n\n    /*  If x is greater than the value at\n      index fib2, Partition the subarray array\n      from offset to i */\n    if (arr[i] < x) {\n      fibK = fib1\n      fib1 = fib2\n      fib2 = fibK - fib1\n      offset = i\n      /* If x is greater than the value at\n            index fib2, cut the subarray array\n            from offset to i */\n    } else if (arr[i] > x) {\n      fibK = fib2\n      fib1 = fib1 - fib2\n      fib2 = fibK - fib1\n    } else {\n    //  return index for found element\n      return i\n    }\n  }\n\n  //    comparing the last element with x */\n  if (fib1 && arr[offset + 1] === x) {\n    return offset + 1\n  }\n  //    element not found. return -1\n  return -1\n}\n// Example\nconst myArray = [10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100]\nconst n = myArray.length\nconst x = 90\nconst fibFinder = fibonacciSearch(myArray, x, n)\nconsole.log('Element found at index:', fibFinder)\n","index":169},{"title":"Interpolation Search","category":"Search","id":"InterpolationSearch_Search","algorithm":"/**\n * Interpolation Search\n *\n * Time Complexity:\n * -Best case: O(1)\n * -Worst case: O(n)\n * -O((log(log(n))) If the data are uniformly distributed\n *\n *\n */\n\nfunction interpolationSearch (arr, key) {\n  const length = arr.length - 1\n  let low = 0\n  let high = length\n  let position = -1\n  let delta = -1\n\n  // Because the array is sorted the key must be between low and high\n  while (low <= high && key >= arr[low] && key <= arr[high]) {\n    delta = (key - arr[low]) / (arr[high] - arr[low])\n    position = low + Math.floor((high - low) * delta)\n\n    // Target found return its position\n    if (arr[position] === key) {\n      return position\n    }\n\n    // If the key is larger then it is in the upper part of the array\n    if (arr[position] < key) {\n      low = position + 1\n      // If the key is smaller then it is in the lower part of the array\n    } else {\n      high = position - 1\n    }\n  }\n\n  return -1\n}\n\nconst arr = [2, 6, 8, 10, 12, 14, 16, 18, 20, 22, 26, 34, 39]\n\nconsole.log('Found at position :' + interpolationSearch(arr, 2))\nconsole.log('Found at position :' + interpolationSearch(arr, 12))\nconsole.log('Found at position :' + interpolationSearch(arr, 1000))\nconsole.log('Found at position :' + interpolationSearch(arr, 39))\n","index":170},{"title":"Jump Search","category":"Search","id":"JumpSearch_Search","algorithm":"/* The Jump Search algorithm allows to combine a linear search with a speed optimization.\n  * This means that instead of going 1 by 1, we will increase the step of √n and increase that\n  * step of √n which make the step getting bigger and bigger.\n  * The asymptotic analysis of Jump Search is o(√n). Like the binary search, it needs to be sorted.\n  * The advantage against binary search is that Jump Search traversed back only once.\n */\n\nconst jumpSearch = (arr, value) => {\n  const length = arr.length\n  let step = Math.floor(Math.sqrt(length))\n  let lowerBound = 0\n  while (arr[Math.min(step, length) - 1] < value) {\n    lowerBound = step\n    step += step\n    if (lowerBound >= length) {\n      return -1\n    }\n  }\n\n  const upperBound = Math.min(step, length)\n  while (arr[lowerBound] < value) {\n    lowerBound++\n    if (lowerBound === upperBound) {\n      return -1\n    }\n  }\n  if (arr[lowerBound] === value) {\n    return lowerBound\n  }\n  return -1\n}\nconst arr = [0, 0, 4, 7, 10, 23, 34, 40, 55, 68, 77, 90]\njumpSearch(arr, 4)\njumpSearch(arr, 34)\njumpSearch(arr, 77)\n","index":171},{"title":"Linear Search","category":"Search","id":"LinearSearch_Search","algorithm":"/*\n * Linear search or sequential search is a method for finding a target\n * value within a list. It sequentially checks each element of the list\n * for the target value until a match is found or until all the elements\n * have been searched.\n */\nfunction SearchArray (searchNum, ar) {\n  var position = Search(ar, searchNum)\n  if (position !== -1) {\n    console.log('The element was found at ' + (position + 1))\n  } else {\n    console.log('The element not found')\n  }\n}\n\n// Search “theArray” for the specified “key” value\nfunction Search (theArray, key) {\n  for (var n = 0; n < theArray.length; n++) {\n    if (theArray[n] === key) { return n }\n  }\n  return -1\n}\n\nvar ar = [1, 2, 3, 4, 5, 6, 7, 8, 9]\nSearchArray(3, ar)\nSearchArray(4, ar)\nSearchArray(11, ar)\n","index":172},{"title":"String Search","category":"Search","id":"StringSearch_Search","algorithm":"/*\n * String Search\n */\n\nfunction makeTable (str) {\n  // create a table of size equal to the length of `str`\n  // table[i] will store the prefix of the longest prefix of the substring str[0..i]\n  const table = new Array(str.length)\n  let maxPrefix = 0\n  // the longest prefix of the substring str[0] has length\n  table[0] = 0\n\n  // for the substrings the following substrings, we have two cases\n  for (let i = 1; i < str.length; i++) {\n    // case 1. the current character doesn't match the last character of the longest prefix\n    while (maxPrefix > 0 && str.charAt(i) !== str.charAt(maxPrefix)) {\n      // if that is the case, we have to backtrack, and try find a character  that will be equal to the current character\n      // if we reach 0, then we couldn't find a chracter\n      maxPrefix = table[maxPrefix - 1]\n    }\n    // case 2. The last character of the longest prefix matches the current character in `str`\n    if (str.charAt(maxPrefix) === str.charAt(i)) {\n      // if that is the case, we know that the longest prefix at position i has one more character.\n      // for example consider `.` be any character not contained in the set [a.c]\n      // str = abc....abc\n      // consider `i` to be the last character `c` in `str`\n      // maxPrefix = will be 2 (the first `c` in `str`)\n      // maxPrefix now will be 3\n      maxPrefix++\n      // so the max prefix for table[9] is 3\n    }\n    table[i] = maxPrefix\n  }\n  return table\n}\n\n// Find all the words that matches in a given string `str`\nfunction stringSearch (str, word) {\n  // find the prefix table in O(n)\n  const prefixes = makeTable(word)\n  const matches = []\n\n  // `j` is the index in `P`\n  let j = 0\n  // `i` is the index in `S`\n  let i = 0\n  while (i < str.length) {\n    // Case 1.  S[i] == P[j] so we move to the next index in `S` and `P`\n    if (str.charAt(i) === word.charAt(j)) {\n      i++\n      j++\n    }\n    // Case 2.  `j` is equal to the length of `P`\n    // that means that we reached the end of `P` and thus we found a match\n    // Next we have to update `j` because we want to save some time\n    // instead of updating to j = 0 , we can jump to the last character of the longest prefix well known so far.\n    // j-1 means the last character of `P` because j is actually `P.length`\n    // e.g.\n    // S =  a b a b d e\n    // P = `a b`a b\n    // we will jump to `a b` and we will compare d and a in the next iteration\n    // a b a b `d` e\n    //     a b `a` b\n    if (j === word.length) {\n      matches.push(i - j)\n      j = prefixes[j - 1]\n      // Case 3.\n      // S[i] != P[j] There's a mismatch!\n    } else if (str.charAt(i) !== word.charAt(j)) {\n      // if we  found at least a character in common, do the same thing as in case 2\n      if (j !== 0) {\n        j = prefixes[j - 1]\n      } else {\n        // else j = 0, and we can move to the next character S[i+1]\n        i++\n      }\n    }\n  }\n\n  return matches\n}\n\nconsole.log(stringSearch('Hello search the position of me', 'pos'))\n","index":173},{"title":"Sorts","category":null,"id":"Sorts","index":174},{"title":"Bead Sort","category":"Sorts","id":"BeadSort_Sorts","algorithm":"/**\n * Bead sort (also known as Gravity sort)\n * https://en.wikipedia.org/wiki/Bead_sort\n *\n * Does counting sort of provided array according to\n * the digit represented by exp.\n * Only works for arrays of positive integers.\n */\n\n// > beadSort([-1, 5, 8, 4, 3, 19])\n// ! RangeError: Sequence must be a list of positive integers!\n// > beadSort([5, 4, 3, 2, 1])\n// [1, 2, 3, 4, 5]\n// > beadSort([7, 9, 4, 3, 5])\n// [3, 4, 5, 7, 9]\n\nfunction beadSort (sequence) {\n  // first, let's check that our sequence consists\n  // of positive integers\n  if (sequence.some((integer) => integer < 0)) {\n    throw RangeError('Sequence must be a list of positive integers!')\n  }\n\n  const sequenceLength = sequence.length\n  const max = Math.max(...sequence)\n\n  // set initial grid\n  const grid = sequence.map(number => {\n    const maxArr = new Array(max)\n\n    for (let i = 0; i < number; i++) {\n      maxArr[i] = '*'\n    }\n\n    return maxArr\n  })\n\n  // drop the beads!\n  for (let col = 0; col < max; col++) {\n    let beadsCount = 0\n\n    for (let row = 0; row < sequenceLength; row++) {\n      if (grid[row][col] === '*') {\n        beadsCount++\n      }\n    }\n\n    for (let row = sequenceLength - 1; row > -1; row--) {\n      if (beadsCount) {\n        grid[row][col] = '*'\n        beadsCount--\n      } else {\n        grid[row][col] = undefined\n      }\n    }\n  }\n\n  // and, finally, let's turn our bead rows into their respective numbers\n  const sortedSequence = grid.map((beadArray) => {\n    const beadsArray = beadArray.filter(bead => bead === '*')\n\n    return beadsArray.length\n  })\n\n  return sortedSequence\n}\n\n// implementation\nconsole.log(beadSort([5, 4, 3, 2, 1]))\n","index":175},{"title":"Bogo Sort","category":"Sorts","id":"BogoSort_Sorts","algorithm":"/*\n * A simple helper function that checks, if the array is\n * sorted in ascending order.\n */\n\n// > [].isSorted()\n// true\n// > [1].isSorted()\n// true\n// > [1,2,3].isSorted()\n// true\n// > [3,2,1].isSorted()\n// false\n/* eslint no-extend-native: [\"off\", { \"exceptions\": [\"Object\"] }] */\nArray.prototype.isSorted = function () {\n  const length = this.length\n  for (let i = 0; i < length - 1; i++) {\n    if (this[i] > this[i + 1]) {\n      return false\n    }\n  }\n  return true\n}\n\n/*\n * A simple helper function to shuffle the array randomly in place.\n */\nArray.prototype.shuffle = function () {\n  for (let i = this.length - 1; i; i--) {\n    const m = Math.floor(Math.random() * i)\n    const n = this[i - 1]\n    this[i - 1] = this[m]\n    this[m] = n\n  }\n}\n\n/*\n * Implementation of the bogosort algorithm. This sorting algorithm randomly\n * rearranges the array until it is sorted.\n * For more information see: https://en.wikipedia.org/wiki/Bogosort\n */\nfunction bogoSort (items) {\n  while (!items.isSorted()) {\n    items.shuffle()\n  }\n  return items\n}\n\n// Implementation of bogoSort\n\nvar ar = [5, 6, 7, 8, 1, 2, 12, 14]\n// Array before Sort\nconsole.log(ar)\nbogoSort(ar)\n// Array after sort\nconsole.log(ar)\n","index":176},{"title":"Bubble Sort","category":"Sorts","id":"BubbleSort_Sorts","algorithm":"/* Bubble Sort is an algorithm to sort an array. It\n*  compares adjacent element and swaps thier position\n*  The big O on bubble sort in worst and best case is O(N^2).\n*  Not efficient.\n*\n*  In bubble sort, we keep iterating while something was swapped in\n*  the previous inner-loop iteration. By swapped I mean, in the\n*  inner loop iteration, we check each number if the number proceeding\n*  it is greater than itself, if so we swap them.\n*\n*  Wikipedia: https://en.wikipedia.org/wiki/Bubble_sort\n*/\n\n/*\n*  Doctests\n*\n*  > bubbleSort([5, 4, 1, 2, 3])\n*  [1, 2, 3, 4, 5]\n*  > bubbleSort([])\n*  []\n*  > bubbleSort([1, 2, 3])\n*  [1, 2, 3]\n*\n*  > alternativeBubbleSort([5, 4, 1, 2, 3])\n*  [1, 2, 3, 4, 5]\n*  > alternativeBubbleSort([])\n*  []\n*  > alternativeBubbleSort([1, 2, 3])\n*  [1, 2, 3]\n*/\n\n/*\n*  Using 2 for loops\n*/\nfunction bubbleSort (items) {\n  const length = items.length\n\n  for (let i = (length - 1); i > 0; i--) {\n    // Number of passes\n    for (let j = (length - i); j > 0; j--) {\n      // Compare the adjacent positions\n      if (items[j] < items[j - 1]) {\n        // Swap the numbers\n        [items[j], items[j - 1]] = [items[j - 1], items[j]]\n      }\n    }\n  }\n\n  return items\n}\n\n/*\n*  Implementation of 2 for loops method\n*/\nvar array1 = [5, 6, 7, 8, 1, 2, 12, 14]\n// Before Sort\nconsole.log('\\n- Before Sort | Implementation using 2 for loops -')\nconsole.log(array1)\n// After Sort\nconsole.log('- After Sort | Implementation using 2 for loops -')\nconsole.log(bubbleSort(array1))\nconsole.log('\\n')\n\n/*\n*  Using a while loop and a for loop\n*/\nfunction alternativeBubbleSort (arr) {\n  let swapped = true\n\n  while (swapped) {\n    swapped = false\n    for (let i = 0; i < arr.length - 1; i++) {\n      if (arr[i] > arr[i + 1]) {\n        [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]]\n        swapped = true\n      }\n    }\n  }\n\n  return arr\n}\n\n/*\n*  Implementation of a while loop and a for loop method\n*/\nvar array2 = [5, 6, 7, 8, 1, 2, 12, 14]\n// Before Sort\nconsole.log('\\n- Before Sort | Implementation using a while loop and a for loop -')\nconsole.log(array2)\n// After Sort\nconsole.log('- After Sort | Implementation using a while loop and a for loop -')\nconsole.log(alternativeBubbleSort(array2))\nconsole.log('\\n')\n","index":177},{"title":"Bucket Sort","category":"Sorts","id":"BucketSort_Sorts","algorithm":"/*\nWikipedia says: Bucket sort, or bin sort, is a sorting algorithm that works by distributing the\nelements of an array into a number of buckets. Each bucket is then sorted individually, either using\na different sorting algorithm, or by recursively applying the bucket sorting algorithm. It is a\ndistribution sort, and is a cousin of radix sort in the most to least significant digit flavour.\nBucket sort is a generalization of pigeonhole sort. Bucket sort can be implemented with comparisons\nand therefore can also be considered a comparison sort algorithm. The computational complexity estimates\ninvolve the number of buckets.\n\nTime Complexity of Solution:\nBest Case O(n); Average Case O(n); Worst Case O(n)\n\n*/\nfunction bucketSort (list, size) {\n  if (undefined === size) {\n    size = 5\n  }\n  if (list.length === 0) {\n    return list\n  }\n  let min = list[0]\n  let max = list[0]\n  // find min and max\n  for (let iList = 0; iList < list.length; iList++) {\n    if (list[iList] < min) {\n      min = list[iList]\n    } else if (list[iList] > max) {\n      max = list[iList]\n    }\n  }\n  // how many buckets we need\n  const count = Math.floor((max - min) / size) + 1\n\n  // create buckets\n  const buckets = []\n  for (let iCount = 0; iCount < count; iCount++) {\n    buckets.push([])\n  }\n\n  // bucket fill\n  for (let iBucket = 0; iBucket < list.length; iBucket++) {\n    const key = Math.floor((list[iBucket] - min) / size)\n    buckets[key].push(list[iBucket])\n  }\n  const sorted = []\n  // now sort every bucket and merge it to the sorted list\n  for (let iBucket = 0; iBucket < buckets.length; iBucket++) {\n    const arr = buckets[iBucket].sort()\n    for (let iSorted = 0; iSorted < arr.length; iSorted++) {\n      sorted.push(arr[iSorted])\n    }\n  }\n  return sorted\n}\n\n// Testing\nconst arrOrignal = [5, 6, 7, 8, 1, 2, 12, 14]\n// > bucketSort(arrOrignal)\n// [1, 2, 5, 6, 7, 8, 12, 14]\n// Array before Sort\nconsole.log(arrOrignal)\nconst arrSorted = bucketSort(arrOrignal)\n// Array after sort\nconsole.log(arrSorted)\n","index":178},{"title":"Cocktail Shaker Sort","category":"Sorts","id":"CocktailShakerSort_Sorts","algorithm":"/*\n * Cocktail Shaker Sort is an algorithm that is a Bidirectional Bubble Sort.\n * The algorithm extends bubble sort by operating in two directions.\n * While it improves on bubble sort by more quickly moving items to the beginning of the list,\n * it provides only marginal performance improvements.\n *\n * Wikipedia (Cocktail Shaker Sort): https://en.wikipedia.org/wiki/Cocktail_shaker_sort\n * Wikipedia (Bubble Sort): https://en.wikipedia.org/wiki/Bubble_sort\n *\n */\n\n/**\n * Doctests\n *\n * > cocktailShakerSort([5, 4, 1, 2, 3])\n * [1, 2, 3, 4, 5]\n * > cocktailShakerSort([])\n * []\n * > cocktailShakerSort([1, 2, 3])\n * [1, 2, 3]\n */\n\nfunction cocktailShakerSort (items) {\n  for (let i = items.length - 1; i > 0; i--) {\n    let j\n\n    // Backwards\n    for (j = items.length - 1; j > i; j--) {\n      if (items[j] < items[j - 1]) {\n        [items[j], items[j - 1]] = [items[j - 1], items[j]]\n      }\n    }\n\n    // Forwards\n    for (j = 0; j < i; j++) {\n      if (items[j] > items[j + 1]) {\n        [items[j], items[j + 1]] = [items[j + 1], items[j]]\n      }\n    }\n  }\n\n  return items\n}\n\n/**\n* Implementation of Cocktail Shaker Sort\n*/\nconst array = [5, 6, 7, 8, 1, 2, 12, 14]\n// Before Sort\nconsole.log('\\n- Before Sort | Implementation of Cocktail Shaker Sort -')\nconsole.log(array)\n// After Sort\nconsole.log('- After Sort | Implementation of Cocktail Shaker Sort -')\nconsole.log(cocktailShakerSort(array))\nconsole.log('\\n')\n","index":179},{"title":"Comb Sort","category":"Sorts","id":"CombSort_Sorts","algorithm":"/*\nWikipedia says: Comb sort improves on bubble sort.\n\nThe basic idea is to eliminate turtles, or small values\nnear the end of the list, since in a bubble sort these slow the sorting\ndown tremendously. Rabbits, large values around the beginning of the list,\ndo not pose a problem in bubble sort.\n\nIn bubble sort, when any two elements are compared, they always have a\ngap (distance from each other) of 1. The basic idea of comb sort is\nthat the gap can be much more than 1. The inner loop of bubble sort,\nwhich does the actual swap, is modified such that gap between swapped\nelements goes down (for each iteration of outer loop) in steps of\na \"shrink factor\" k: [ n/k, n/k2, n/k3, ..., 1 ].\n\n*/\n\nfunction combSort (list) {\n  if (list.length === 0) {\n    return list\n  }\n  const shrink = 1.3\n  let gap = list.length\n  let isSwapped = true\n  let i = 0\n\n  while (gap > 1 || isSwapped) {\n    // Update the gap value for a next comb\n    gap = parseInt(parseFloat(gap) / shrink, 10)\n\n    isSwapped = false\n    i = 0\n\n    while (gap + i < list.length) {\n      if (list[i] > list[i + gap]) {\n        [list[i], list[i + gap]] = [list[i + gap], list[i]]\n        isSwapped = true\n      }\n      i += 1\n    }\n  }\n  return list\n}\nconst arrOrignal = [5, 6, 7, 8, 1, 2, 12, 14]\n// Array before Sort\nconsole.log(arrOrignal)\nconst arrSorted = combSort(arrOrignal)\n// Array after sort\nconsole.log(arrSorted)\n","index":180},{"title":"Counting Sort","category":"Sorts","id":"CountingSort_Sorts","algorithm":"/*\n * Counting sort is an algorithm for sorting a collection of objects according to keys that are small integers;\n * that is, it is an integer sorting algorithm.\n * more information: https://en.wikipedia.org/wiki/Counting_sort\n * counting sort visualization: https://www.cs.usfca.edu/~galles/visualization/CountingSort.html\n */\n\nfunction countingSort (arr, min, max) {\n  let i\n  let z = 0\n  const count = []\n\n  for (i = min; i <= max; i++) {\n    count[i] = 0\n  }\n\n  for (i = 0; i < arr.length; i++) {\n    count[arr[i]]++\n  }\n\n  for (i = min; i <= max; i++) {\n    while (count[i]-- > 0) {\n      arr[z++] = i\n    }\n  }\n\n  return arr\n}\n\nconst arr = [3, 0, 2, 5, 4, 1]\n\n// Array before Sort\nconsole.log('-----before sorting-----')\nconsole.log(arr)\n// Array after sort\nconsole.log('-----after sorting-----')\nconsole.log(countingSort(arr, 0, 5))\n","index":181},{"title":"Cycle Sort","category":"Sorts","id":"CycleSort_Sorts","algorithm":"/*\nWikipedia says: Cycle sort is an in-place, unstable sorting algorithm,\na comparison sort that is theoretically optimal in terms of the total\nnumber of writes to the original array, unlike any other in-place sorting\nalgorithm. It is based on the idea that the permutation to be sorted can\nbe factored into cycles, which can individually be rotated to give a sorted result.\n*/\n\nfunction cycleSort (list) {\n  let writes = 0\n  for (let cycleStart = 0; cycleStart < list.length; cycleStart++) {\n    let value = list[cycleStart]\n    let position = cycleStart\n\n    // search position\n    for (let i = cycleStart + 1; i < list.length; i++) {\n      if (list[i] < value) {\n        position++\n      }\n    }\n    // if its the same continue\n    if (position === cycleStart) {\n      continue\n    }\n\n    while (value === list[position]) {\n      position++\n    }\n\n    const oldValue = list[position]\n    list[position] = value\n    value = oldValue\n    writes++\n\n    // rotate the rest\n    while (position !== cycleStart) {\n      position = cycleStart\n      for (let i = cycleStart + 1; i < list.length; i++) {\n        if (list[i] < value) {\n          position++\n        }\n      }\n      while (value === list[position]) {\n        position++\n      }\n      const oldValueCycle = list[position]\n      list[position] = value\n      value = oldValueCycle\n      writes++\n    }\n  }\n  return writes\n}\nconst arrOrignal = [5, 6, 7, 8, 1, 2, 12, 14]\n// Array before Sort\nconsole.log(arrOrignal)\ncycleSort(arrOrignal)\n// Array after sort\nconsole.log(arrOrignal)\n","index":182},{"title":"Flash Sort","category":"Sorts","id":"FlashSort_Sorts","algorithm":"/*\n * Flashsort is a distribution sorting algorithm showing linear computational complexity O(n) for uniformly distributed\n * data sets and relatively little additional memory requirement.\n * more information: https://en.wikipedia.org/wiki/Flashsort\n */\n\nfunction flashSort (arr) {\n  let max = 0; let min = arr[0]\n  const n = arr.length\n  const m = ~~(0.45 * n)\n  const l = new Array(m)\n\n  for (let i = 1; i < n; ++i) {\n    if (arr[i] < min) {\n      min = arr[i]\n    }\n    if (arr[i] > arr[max]) {\n      max = i\n    }\n  }\n\n  if (min === arr[max]) {\n    return arr\n  }\n\n  const c1 = (m - 1) / (arr[max] - min)\n\n  for (let k = 0; k < m; k++) {\n    l[k] = 0\n  }\n\n  for (let j = 0; j < n; ++j) {\n    const k = ~~(c1 * (arr[j] - min))\n    ++l[k]\n  }\n\n  for (let p = 1; p < m; ++p) {\n    l[p] = l[p] + l[p - 1]\n  }\n\n  let hold = arr[max]\n  arr[max] = arr[0]\n  arr[0] = hold\n\n  // permutation\n  let move = 0; let t; let flash\n  let j = 0\n  let k = m - 1\n\n  while (move < (n - 1)) {\n    while (j > (l[k] - 1)) {\n      ++j\n      k = ~~(c1 * (arr[j] - min))\n    }\n    if (k < 0) break\n    flash = arr[j]\n    while (j !== l[k]) {\n      k = ~~(c1 * (flash - min))\n      hold = arr[t = --l[k]]\n      arr[t] = flash\n      flash = hold\n      ++move\n    }\n  }\n\n  // insertion\n  for (j = 1; j < n; j++) {\n    hold = arr[j]\n    let i = j - 1\n    while (i >= 0 && arr[i] > hold) {\n      arr[i + 1] = arr[i--]\n    }\n    arr[i + 1] = hold\n  }\n  return arr\n}\n\nconst array = [3, 0, 2, 5, -1, 4, 1, -2]\n\n// Array before Sort\nconsole.log('-----before sorting-----')\nconsole.log(array)\n// Array after sort\nconsole.log('-----after sorting-----')\nconsole.log(flashSort(array))\n","index":183},{"title":"Gnome Sort","category":"Sorts","id":"GnomeSort_Sorts","algorithm":"/*\n * Gnome sort is a sort algorithm that moving an element to its proper place is accomplished by a series of swap\n * more information: https://en.wikipedia.org/wiki/Gnome_sort\n *\n */\nfunction gnomeSort (items) {\n  if (items.length <= 1) {\n    return\n  }\n\n  let i = 1\n\n  while (i < items.length) {\n    if (items[i - 1] <= items[i]) {\n      i++\n    } else {\n      [items[i], items[i - 1]] = [items[i - 1], items[i]]\n\n      i = Math.max(1, i - 1)\n    }\n  }\n}\n\n// Implementation of gnomeSort\n\nvar ar = [5, 6, 7, 8, 1, 2, 12, 14]\n// Array before Sort\nconsole.log(ar)\ngnomeSort(ar)\n// Array after sort\nconsole.log(ar)\n","index":184},{"title":"Heap Sort","category":"Sorts","id":"HeapSort_Sorts","algorithm":"/*\n * Build a max heap out of the array. A heap is a specialized tree like\n * data structure that satisfies the heap property. The heap property\n * for max heap is the following: \"if P is a parent node of C, then the\n * key (the value) of node P is greater than the key of node C\"\n * Source: https://en.wikipedia.org/wiki/Heap_(data_structure)\n */\n/* eslint no-extend-native: [\"off\", { \"exceptions\": [\"Object\"] }] */\nArray.prototype.heapify = function (index, heapSize) {\n  let largest = index\n  const leftIndex = 2 * index + 1\n  const rightIndex = 2 * index + 2\n\n  if (leftIndex < heapSize && this[leftIndex] > this[largest]) {\n    largest = leftIndex\n  }\n\n  if (rightIndex < heapSize && this[rightIndex] > this[largest]) {\n    largest = rightIndex\n  }\n\n  if (largest !== index) {\n    const temp = this[largest]\n    this[largest] = this[index]\n    this[index] = temp\n\n    this.heapify(largest, heapSize)\n  }\n}\n\n/*\n * Heap sort sorts an array by building a heap from the array and\n * utilizing the heap property.\n * For more information see: https://en.wikipedia.org/wiki/Heapsort\n */\nfunction heapSort (items) {\n  const length = items.length\n\n  for (let i = Math.floor(length / 2) - 1; i > -1; i--) {\n    items.heapify(i, length)\n  }\n  for (let j = length - 1; j > 0; j--) {\n    const tmp = items[0]\n    items[0] = items[j]\n    items[j] = tmp\n    items.heapify(0, j)\n  }\n  return items\n}\n\n// Implementation of heapSort\n\nvar ar = [5, 6, 7, 8, 1, 2, 12, 14]\n// Array before Sort\nconsole.log(ar)\nheapSort(ar)\n// Array after sort\nconsole.log(ar)\n","index":185},{"title":"Heap Sort V2","category":"Sorts","id":"HeapSortV2_Sorts","algorithm":"let arrayLength = 0\n\n/* to create MAX  array */\n\nfunction heapRoot (input, i) {\n  const left = 2 * i + 1\n  const right = 2 * i + 2\n  let max = i\n\n  if (left < arrayLength && input[left] > input[max]) {\n    max = left\n  }\n\n  if (right < arrayLength && input[right] > input[max]) {\n    max = right\n  }\n\n  if (max !== i) {\n    swap(input, i, max)\n    heapRoot(input, max)\n  }\n}\n\nfunction swap (input, indexA, indexB) {\n  [input[indexA], input[indexB]] = [input[indexB], input[indexA]]\n}\n\nfunction heapSort (input) {\n  arrayLength = input.length\n\n  for (let i = Math.floor(arrayLength / 2); i >= 0; i -= 1) {\n    heapRoot(input, i)\n  }\n\n  for (let i = input.length - 1; i > 0; i--) {\n    swap(input, 0, i)\n    arrayLength--\n\n    heapRoot(input, 0)\n  }\n}\n\nconst arr = [3, 0, 2, 5, -1, 4, 1]\nheapSort(arr)\nconsole.log(arr)\n","index":186},{"title":"Insertion Sort","category":"Sorts","id":"InsertionSort_Sorts","algorithm":"/* In insertion sort, we divide the initial unsorted array into two parts;\n* sorted part and unsorted part. Initially the sorted part just has one\n* element (Array of only 1 element is a sorted array). We then pick up\n* element one by one from unsorted part; insert into the sorted part at\n* the correct position and expand sorted part one element at a time.\n*/\nfunction insertionSort (unsortedList) {\n  var len = unsortedList.length\n  for (var i = 1; i < len; i++) {\n    var tmp = unsortedList[i] // Copy of the current element.\n    /* Check through the sorted part and compare with the number in tmp. If large, shift the number */\n    for (var j = i - 1; j >= 0 && (unsortedList[j] > tmp); j--) {\n      // Shift the number\n      unsortedList[j + 1] = unsortedList[j]\n    }\n    // Insert the copied number at the correct position\n    // in sorted part.\n    unsortedList[j + 1] = tmp\n  }\n}\n\nvar arr = [5, 3, 1, 2, 4, 8, 3, 8]\ninsertionSort(arr)\nconsole.log(arr)\n","index":187},{"title":"Intro Sort","category":"Sorts","id":"IntroSort_Sorts","algorithm":"/**\n * @function Intosort (As implemented in STD C++ Lib)\n * The function performs introsort which is used in\n * C++ Standard LIbrary, the implemntation is inspired from]\n * library routine itself.\n * ALGORITHM:\n * 1) It performs quicksort on array until the recursion depth\n *    exceeds a pre determined limit.\n * 2) If the limit is reached it switches to heapsort\n * 3) For array size less than a threshold(16) directly\n *    does insertion sort on array\n * @param {Array} array the array to be sorted\n * @param {Function} compare the comparison function\n *\n * @see [Introsort](https://en.wikipedia.org/wiki/Introsort)\n * @author [Lakhan Nad](https://github.com/Lakhan-Nad)\n */\nfunction introsort (array, compare) {\n  /**\n   * @function Default Comparison Function\n   * This function is same as implemented by\n   * Array.sort method\n   * @see [StackOverflow](https://stackoverflow.com/questions/47334234/how-to-implement-array-prototype-sort-default-compare-function)\n   * @param {*} a variable 1\n   * @param {*} b variable 2\n   * @returns {Number}\n   * -1 if a is less than b\n   *  0 if a is equal to b\n   *  1 if a greater than b\n   */\n  var defaultComparator = function (x, y) {\n    if (x === undefined && y === undefined) return 0\n    if (x === undefined) return 1\n    if (y === undefined) return -1\n    var xString = toString(x)\n    var yString = toString(y)\n    if (xString < yString) return -1\n    if (xString > yString) return 1\n    return 0\n  }\n  /**\n   * @function helper function for defaultComparator\n   * Converts a given object to String\n   * @throws TypeError()\n   * @param {Object} obj\n   * @returns {String} String representation of given object\n   */\n  var toString = function (obj) {\n    if (obj === null) return 'null'\n    if (typeof obj === 'boolean' || typeof obj === 'number') {\n      return obj.toString()\n    }\n    if (typeof obj === 'string') return obj\n    if (typeof obj === 'symbol') throw new TypeError()\n    return obj.toString()\n  }\n  /**\n   * Checks if the value passed is an array\n   * or not\n   */\n  if (Array.isArray(array) === false) {\n    return\n  }\n  /**\n   * If the compare parameter is not a function\n   * or not passed at all use default comparator\n   * function\n   */\n  if (typeof compare !== 'function') {\n    compare = defaultComparator // If compare is not a comparator function\n  }\n  /**\n   * Use a closure to define the whole sort\n   * implementation this is done through\n   * [IIFE](https://en.wikipedia.org/wiki/Immediately_invoked_function_expression)\n   */\n  return (function (array, comparator) {\n    var swap = function (index1, index2) {\n      var temp = array[index1]\n      array[index1] = array[index2]\n      array[index2] = temp\n    }\n    /**\n     * @constant THRESHOLD\n     * If the length of array is less than\n     * this then we simply perform insertion sort\n     */\n    var THRESHOLD = 16\n    /**\n     * @constant TUNEMAXDEPTH\n     * Constant usec to increase or decrease value\n     * of maxDepth\n     */\n    var TUNEMAXDEPTH = 1\n    var len = array.length\n    /**\n     * Return if array is only of length 1\n     * Array of size 1 is always sorted\n     */\n    if (len === 1) {\n      return\n    }\n    /**\n     * Calculate maxDepth = log2(len)\n     * Taken from implementation in stdc++\n     */\n    var maxDepth = Math.floor(Math.log2(len)) * TUNEMAXDEPTH\n    /**\n     * The very first call to quicksort\n     * this initiates sort routine\n     */\n    quickSort(0, len, maxDepth)\n    /**\n     * A final checlk call to insertion sort\n     * on sorted array\n     */\n    insertionSort(0, len)\n    /** *********************  Implementation of various routines  **************************/\n    /**\n     * @function\n     * This is recursive quicksort implementation in array\n     * of segment [start,last-1]\n     * [QuickSort](https://en.wikipedia.org/wiki/Quicksort)\n     * @param {Number} start the start index of array segment to be sorted\n     * @param {Number} last  one more than the last index of array segment\n     * @param {Number} depth this measures how many recursive calls are done\n     */\n    function quickSort (start, last, depth) {\n      if (last - start <= THRESHOLD) {\n        insertionSort(start, last)\n        return\n      } else if (depth <= 0) {\n        heapSort(start, last)\n        return\n      }\n      var pivot = (last + start) >> 1\n      pivot = partition(start, last, pivot)\n      quickSort(start, pivot, depth - 1)\n      quickSort(pivot + 1, last, depth - 1)\n    }\n    /**\n     * @function Helper function to quicksort\n     * @param {Number} start the start of array segment to partitiion\n     * @param {Number} last  one more than last index of the array segment\n     * @param {Number} pivot the index of pivot to be used\n     * @returns {Number} the index of pivot after partition\n     */\n    function partition (start, last, pivot) {\n      swap(start, pivot)\n      pivot = start\n      var lo = start\n      var hi = last\n      while (true) {\n        lo++\n        while (comparator(array[lo], array[pivot]) <= 0 && lo !== last) {\n          lo++\n        }\n        hi--\n        while (comparator(array[hi], array[pivot]) > 0 && hi !== start) {\n          hi--\n        }\n        if (lo >= hi) {\n          break\n        }\n        swap(lo, hi)\n      }\n      swap(start, hi)\n      return hi\n    }\n    /**\n     * @function\n     * Performs insertion sort on array of range\n     * [start, last-1]\n     * @param {Number} start the first index of array segment to be sorted\n     * @param {Number} last  one more than last index of array to be sorted\n     */\n    function insertionSort (start, last) {\n      var i, j\n      for (i = start + 1; i < last; i++) {\n        j = i - 1\n        while (j >= 0 && comparator(array[j], array[j + 1]) > 0) {\n          swap(j, j + 1)\n          j--\n        }\n      }\n    }\n    /**\n     * @function\n     * Performs heapsort in array segment of range [start, last-1]\n     * [HeapSort](https://en.wikipedia.org/wiki/Heapsort)\n     * @param {Number} start the first index of array segment to be sorted\n     * @param {Number} last  one more than last index of array to be sorted\n     */\n    function heapSort (start, last) {\n      var x = (last + start) >> 1\n      while (x - start >= 0) {\n        heapify(x, start, last)\n        x--\n      }\n      x = last - 1\n      while (x - start > 0) {\n        swap(start, x)\n        heapify(start, start, x)\n        x--\n      }\n    }\n    /**\n     * @function Helper function to heapsort routine\n     * @param {Number} cur the index we need to heapify\n     * @param {Number} start the start index of array segment that cur belongs to\n     * @param {Number} last  one more than last index of segment that cur belongs to\n     */\n    function heapify (cur, start, last) {\n      var size = last - start\n      var max, lt, rt\n      cur = cur - start\n      while (true) {\n        max = cur\n        lt = 2 * max + 1\n        rt = 2 * max + 2\n        if (\n          lt < size &&\n          comparator(array[start + max], array[start + lt]) < 0\n        ) {\n          max = lt\n        }\n        if (\n          rt < size &&\n          comparator(array[start + max], array[start + rt]) < 0\n        ) {\n          max = rt\n        }\n        if (max !== cur) {\n          swap(start + cur, start + max)\n          cur = max\n        } else {\n          break\n        }\n      }\n    }\n  })(array, compare)\n}\n\n/**\n * @example Demo run of the sort routine\n * The data is randomly generated\n * Prints RIGHT:) if the sort routine worked as expected\n * If not prints WRONG!!\n */\n(function demo () {\n  const data = []\n  const size = 1000000\n  var i = 0\n  var temp\n  var c = function (a, b) {\n    return a - b\n  }\n  for (i = 0; i < size; i++) {\n    temp = Math.random() * Number.MAX_SAFE_INTEGER\n    data.push(temp)\n  }\n  introsort(data, c)\n  var faulty = false\n  for (i = 1; i < size; i++) {\n    if (data[i] < data[i - 1]) {\n      faulty = true\n      break\n    }\n  }\n  if (faulty) {\n    console.log('WRONG!!')\n  } else {\n    console.log('RIGHT:)')\n  }\n})();\n\n/**\n * @example Demo run of the sort routine\n * using the default compare function and\n * comparing the results with Array.sort\n */\n(function demo () {\n  const data = []\n  const data2 = []\n  const size = 1000000\n  var i = 0\n  var temp\n  for (i = 0; i < size; i++) {\n    temp = Math.random() * Number.MAX_SAFE_INTEGER\n    data.push(temp)\n    data2.push(temp)\n  }\n  introsort(data)\n  data2.sort()\n  var faulty = false\n  for (i = 1; i < size; i++) {\n    if (data[i] !== data2[i]) {\n      faulty = true\n      break\n    }\n  }\n  if (faulty) {\n    console.log('WRONG Implented Comparator!!')\n  } else {\n    console.log('Comparator Works Fine:)')\n  }\n})()\n","index":188},{"title":"Merge Sort","category":"Sorts","id":"MergeSort_Sorts","algorithm":"/**\n * Merge Sort is an algorithm where the main list is divided down into two half\n * sized lists, which then have merge sort called on these two smaller lists\n * recursively until there is only a sorted list of one.\n *\n * On the way up the recursive calls, the lists will be merged together inserting\n * the smaller value first, creating a larger sorted list.\n */\n\n/**\n * Sort and merge two given arrays\n * @param {Array} list1 - sublist to break down\n * @param {Array} list2 - sublist to break down\n * @return {Array} merged list\n */\n/*\n*  Doctests\n* > merge([5, 4],[ 1, 2, 3])\n*  [1, 2, 3, 5, 4]\n* > merge([],[1, 2])\n*  [1, 2]\n* > merge([1, 2, 3], [1])\n*  [1, 1, 2, 3]\n* > merge([], [])\n*  []\n*\n* > mergeSort([5, 4])\n*  [4, 5]\n* > mergeSort([8, 4, 10, 15, 9])\n*  [4, 8, 9, 10, 15]\n* > mergeSort([1, 2, 3])\n*  [1, 2, 3]\n* > mergeSort([ ])\n*  [ ]\n*/\n\nfunction merge (list1, list2) {\n  var results = []\n\n  while (list1.length && list2.length) {\n    if (list1[0] <= list2[0]) {\n      results.push(list1.shift())\n    } else {\n      results.push(list2.shift())\n    }\n  }\n  return results.concat(list1, list2)\n}\n\n/**\n * Break down the lists into smaller pieces to be merged\n * @param {Array} list - list to be sorted\n * @return {Array} sorted list\n */\nfunction mergeSort (list) {\n  if (list.length < 2) return list\n\n  var listHalf = Math.floor(list.length / 2)\n  var subList1 = list.slice(0, listHalf)\n  var subList2 = list.slice(listHalf, list.length)\n\n  return merge(mergeSort(subList1), mergeSort(subList2))\n}\n\n// Merge Sort Example\nvar unsortedArray = [10, 5, 3, 8, 2, 6, 4, 7, 9, 1]\nvar sortedArray = mergeSort(unsortedArray)\n\nconsole.log('Before:', unsortedArray, 'After:', sortedArray)\n","index":189},{"title":"Pigeon Hole Sort","category":"Sorts","id":"PigeonHoleSort_Sorts","algorithm":"/*\nhttps://en.wikipedia.org/wiki/Pigeonhole_sort\n\n*Pigeonhole sorting is a sorting algorithm that is suitable\n* for sorting lists of elements where the number of elements\n* (n) and the length of the range of possible key values (N)\n* are approximately the same.\n */\nfunction pigeonHoleSort (arr) {\n  let min = arr[0]\n  let max = arr[0]\n\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > max) { max = arr[i] }\n    if (arr[i] < min) { min = arr[i] }\n  }\n  console.log(max)\n  console.log(min)\n\n  const range = max - min + 1\n  const pigeonhole = Array(range).fill(0)\n\n  for (let i = 0; i < arr.length; i++) {\n    pigeonhole[arr[i] - min]++\n  }\n\n  let index = 0\n\n  for (let j = 0; j < range; j++) {\n    while (pigeonhole[j]-- > 0) {\n      arr[index++] = j + min\n    }\n  }\n}\n// Driver code\nconst arr = [8, 3, 2, 7, 4, 6, 8]\npigeonHoleSort(arr)\nconsole.log(arr)\n","index":190},{"title":"Quick Sort","category":"Sorts","id":"QuickSort_Sorts","algorithm":"/*\n* Quick sort is a comparison sorting algorithm that uses a divide and conquer strategy.\n* For more information see here: https://en.wikipedia.org/wiki/Quicksort\n*/\n\n/*\n*  Doctests\n*\n*  > quickSort([5, 4, 3, 10, 2, 1])\n*  [1, 2, 3, 4, 5, 10]\n*  > quickSort([])\n*  []\n* > quickSort([5, 4])\n*  [4, 5]\n*  > quickSort([1, 2, 3])\n*  [1, 2, 3]\n*/\n\nfunction quickSort (items) {\n  var length = items.length\n\n  if (length <= 1) {\n    return items\n  }\n  var PIVOT = items[0]\n  var GREATER = []\n  var LESSER = []\n\n  for (var i = 1; i < length; i++) {\n    if (items[i] > PIVOT) {\n      GREATER.push(items[i])\n    } else {\n      LESSER.push(items[i])\n    }\n  }\n\n  var sorted = quickSort(LESSER)\n  sorted.push(PIVOT)\n  sorted = sorted.concat(quickSort(GREATER))\n\n  return sorted\n}\n\n// Implementation of quick sort\n\nvar ar = [0, 5, 3, 2, 2]\n// Array before Sort\nconsole.log(ar)\nar = quickSort(ar)\n// Array after sort\nconsole.log(ar)\n","index":191},{"title":"Radix Sort","category":"Sorts","id":"RadixSort_Sorts","algorithm":"/*\n* Radix sorts an integer array without comparing the integers.\n* It groups the integers by their digits which share the same\n* significant position.\n* For more information see: https://en.wikipedia.org/wiki/Radix_sort\n*/\nfunction radixSort (items, RADIX) {\n  // default radix is then because we usually count to base 10\n  if (RADIX === undefined || RADIX < 1) {\n    RADIX = 10\n  }\n\n  var maxLength = false\n  var placement = 1\n\n  while (!maxLength) {\n    maxLength = true\n    var buckets = []\n\n    for (var i = 0; i < RADIX; i++) {\n      buckets.push([])\n    }\n\n    for (var j = 0; j < items.length; j++) {\n      var tmp = items[j] / placement\n      buckets[Math.floor(tmp % RADIX)].push(items[j])\n      if (maxLength && tmp > 0) {\n        maxLength = false\n      }\n    }\n\n    var a = 0\n    for (var b = 0; b < RADIX; b++) {\n      var buck = buckets[b]\n      for (var k = 0; k < buck.length; k++) {\n        items[a] = buck[k]\n        a++\n      }\n    }\n    placement *= RADIX\n  }\n  return items\n}\n\n// Implementation of radixSort\n\nvar ar = [5, 6, 7, 8, 1, 2, 12, 14]\n// Array before Sort\nconsole.log(ar)\nradixSort(ar)\n// Array after sort\nconsole.log(ar)\n","index":192},{"title":"Selection Sort","category":"Sorts","id":"SelectionSort_Sorts","algorithm":"/* The selection sort algorithm sorts an array by repeatedly finding the minimum element\n *(considering ascending order) from unsorted part and putting it at the beginning. The\n *algorithm maintains two subarrays in a given array.\n *1) The subarray which is already sorted.\n *2) Remaining subarray which is unsorted.\n *\n *In every iteration of selection sort, the minimum element (considering ascending order)\n *from the unsorted subarray is picked and moved to the sorted subarray.\n */\n\nconst selectionSort = (list) => {\n  if (!Array.isArray(list)) {\n    throw new TypeError('Given input is not an array')\n  }\n  const items = [...list] // We don't want to modify the original array\n  const length = items.length\n  for (let i = 0; i < length - 1; i++) {\n    if (typeof items[i] !== 'number') {\n      throw new TypeError('One of the items in your array is not a number')\n    }\n    // Number of passes\n    let min = i // min holds the current minimum number position for each pass; i holds the Initial min number\n    for (let j = i + 1; j < length; j++) { // Note that j = i + 1 as we only need to go through unsorted array\n      if (items[j] < items[min]) { // Compare the numbers\n        min = j // Change the current min number position if a smaller num is found\n      }\n    }\n    if (min !== i) {\n      // After each pass, if the current min num != initial min num, exchange the position.\n      // Swap the numbers\n      [items[i], items[min]] = [items[min], items[i]]\n    }\n  }\n  return items\n}\n\n/* Implementation of Selection Sort\n\n(() => {\n  let array = [5, 6, 7, 8, 1, 2, 12, 14]\n  // Array before Sort\n  console.log(array)\n  array = selectionSort(array)\n  // Array after sort\n  console.log(array)\n})()\n\n*/\n\nexport { selectionSort }\n","index":193},{"title":"Selection Sort.test","category":"Sorts","id":"SelectionSort.test_Sorts","algorithm":"import { selectionSort } from './SelectionSort'\n\ndescribe('selectionSort', () => {\n  it('expects to return the array sorted in ascending order', () => {\n    var toSort = [5, 6, 7, 8, 1, 2, 12, 14]\n    const expected = [1, 2, 5, 6, 7, 8, 12, 14]\n\n    expect(selectionSort(toSort)).toEqual(expected)\n  })\n\n  it('expects to throw if it is not a valid array', () => {\n    expect(() => selectionSort('abc')).toThrow('Given input is not an array')\n    expect(() => selectionSort(123)).toThrow('Given input is not an array')\n    expect(() => selectionSort({})).toThrow('Given input is not an array')\n    expect(() => selectionSort(null)).toThrow('Given input is not an array')\n    expect(() => selectionSort()).toThrow('Given input is not an array')\n  })\n\n  it('expects to throw if one of the elements in the array is not a number', () => {\n    expect(() => selectionSort([1, 'x', 2])).toThrow('One of the items in your array is not a number')\n  })\n})\n","index":194},{"title":"Shell Sort","category":"Sorts","id":"ShellSort_Sorts","algorithm":"/*\n * Shell Sort sorts an array based on  insertion sort algorithm\n * more information: https://en.wikipedia.org/wiki/Shellsort\n *\n */\nfunction shellSort (items) {\n  var interval = 1\n\n  while (interval < items.length / 3) {\n    interval = interval * 3 + 1\n  }\n\n  while (interval > 0) {\n    for (var outer = interval; outer < items.length; outer++) {\n      var value = items[outer]\n      var inner = outer\n\n      while (inner > interval - 1 && items[inner - interval] >= value) {\n        items[inner] = items[inner - interval]\n        inner = inner - interval\n      }\n      items[inner] = value\n    }\n    interval = (interval - 1) / 3\n  }\n  return items\n}\n\n// Implementation of shellSort\n\nvar ar = [5, 6, 7, 8, 1, 2, 12, 14]\n// Array before Sort\nconsole.log(ar)\nshellSort(ar)\n// Array after sort\nconsole.log(ar)\n","index":195},{"title":"Tim Sort","category":"Sorts","id":"TimSort_Sorts","algorithm":"/**\n  *  @function Timsort is a hybrid stable sorting algorithm, derived from merge sort and insertion sort,\n  *  designed to perform well on many kinds of real-world data.\n  *  It was implemented by Tim Peters in 2002 for use in the Python programming language.\n  *  It is also used to sort arrays of non-primitive type in Java SE 7,\n  *  on the Android platform, in GNU Octave, on V8, Swift and Rust.\n  *  1) It sorts small partitions using Insertion Sort.\n  *  2) Merges the partition using Merge Sort.\n  *  @see [Timsort](https://en.wikipedia.org/wiki/Timsort)\n  *  @param {Array} array\n  */\n\nconst Timsort = (array) => {\n  // Default size of a partition\n  const RUN = 32\n  const n = array.length\n  // Sorting the partitions using Insertion Sort\n  for (let i = 0; i < n; i += RUN) {\n    InsertionSort(array, i, Math.min(i + RUN - 1, n - 1))\n  }\n  for (let size = RUN; size < n; size *= 2) {\n    for (let left = 0; left < n; left += 2 * size) {\n      const mid = left + size - 1\n      const right = Math.min(left + 2 * size - 1, n - 1)\n      Merge(array, left, mid, right)\n    }\n  }\n}\n\n/**\n * @function performs insertion sort on the partition\n * @param {Array} array array to be sorted\n * @param {Number} left left index of partiton\n * @param {Number} right right index of partition\n */\n\nconst InsertionSort = (array, left, right) => {\n  for (let i = left + 1; i <= right; i++) {\n    const key = array[i]\n    let j = i - 1\n    while (j >= left && array[j] > key) {\n      array[j + 1] = array[j]\n      j--\n    }\n    array[j + 1] = key\n  }\n}\n\n/**\n * @function merges two sorted partitions\n * @param {Array} array array to be sorted\n * @param {Number} left left index of partition\n * @param {Number} mid mid index of partition\n * @param {Number} right right index of partition\n */\n\nconst Merge = (array, left, mid, right) => {\n  if (mid >= right) return\n  const len1 = mid - left + 1\n  const len2 = right - mid\n  const larr = Array(len1)\n  const rarr = Array(len2)\n  for (let i = 0; i < len1; i++) {\n    larr[i] = array[left + i]\n  }\n  for (let i = 0; i < len2; i++) {\n    rarr[i] = array[mid + 1 + i]\n  }\n  let i = 0; let j = 0; let k = left\n  while (i < larr.length && j < rarr.length) {\n    if (larr[i] < rarr[j]) {\n      array[k++] = larr[i++]\n    } else {\n      array[k++] = rarr[j++]\n    }\n  }\n  while (i < larr.length) {\n    array[k++] = larr[i++]\n  }\n  while (j < rarr.length) {\n    array[k++] = rarr[j++]\n  }\n}\n\n/**\n * @example Test of Timsort functions.\n * Data is randomly generated.\n * Prints \"RIGHT\" if it works as expected,\n * otherwise \"FAULTY\"\n */\n(() => {\n  const size = 1000000\n  const data = Array(size)\n  for (let i = 0; i < size; i++) {\n    data[i] = Math.random() * Number.MAX_SAFE_INTEGER\n  }\n  const isSorted = function (array) {\n    const n = array.length\n    for (let i = 0; i < n - 1; i++) {\n      if (array[i] > array[i + 1]) return false\n    }\n    return true\n  }\n  Timsort(data)\n  if (isSorted(data)) {\n    console.log('RIGHT')\n  } else {\n    console.log('FAULTY')\n  }\n})()\n","index":196},{"title":"Topological Sort","category":"Sorts","id":"TopologicalSort_Sorts","algorithm":"\nfunction TopologicalSorter () {\n  var graph = {}\n  var isVisitedNode\n  var finishTimeCount\n  var finishingTimeList\n  var nextNode\n\n  this.addOrder = function (nodeA, nodeB) {\n    nodeA = String(nodeA)\n    nodeB = String(nodeB)\n    graph[nodeA] = graph[nodeA] || []\n    graph[nodeA].push(nodeB)\n  }\n\n  this.sortAndGetOrderedItems = function () {\n    isVisitedNode = Object.create(null)\n    finishTimeCount = 0\n    finishingTimeList = []\n\n    for (var node in graph) {\n      if (Object.prototype.hasOwnProperty.call(graph, node) && !isVisitedNode[node]) {\n        dfsTraverse(node)\n      }\n    }\n\n    finishingTimeList.sort(function (item1, item2) {\n      return item1.finishTime > item2.finishTime ? -1 : 1\n    })\n\n    return finishingTimeList.map(function (value) { return value.node })\n  }\n\n  function dfsTraverse (node) {\n    isVisitedNode[node] = true\n    if (graph[node]) {\n      for (var i = 0; i < graph[node].length; i++) {\n        nextNode = graph[node][i]\n        if (isVisitedNode[nextNode]) continue\n        dfsTraverse(nextNode)\n      }\n    }\n\n    finishingTimeList.push({\n      node: node,\n      finishTime: ++finishTimeCount\n    })\n  }\n}\n\n/* TEST */\nvar topoSorter = new TopologicalSorter()\ntopoSorter.addOrder(5, 2)\ntopoSorter.addOrder(5, 0)\ntopoSorter.addOrder(4, 0)\ntopoSorter.addOrder(4, 1)\ntopoSorter.addOrder(2, 3)\ntopoSorter.addOrder(3, 1)\nconsole.log(topoSorter.sortAndGetOrderedItems())\n","index":197},{"title":"Wiggle Sort","category":"Sorts","id":"WiggleSort_Sorts","algorithm":"/*\n * Wiggle sort sorts the array into a wave like array.\n * An array ‘arr[0..n-1]’ is sorted in wave form if arr[0] >= arr[1] <= arr[2] >= arr[3] <= arr[4] >= …..\n *\n */\n\n/* eslint no-extend-native: [\"off\", { \"exceptions\": [\"Object\"] }] */\nArray.prototype.wiggleSort = function () {\n  for (let i = 0; i < this.length; ++i) {\n    const shouldNotBeLessThan = i % 2\n    const isLessThan = this[i] < this[i + 1]\n    if (shouldNotBeLessThan && isLessThan) {\n      [this[i], this[i + 1]] = [this[i + 1], this[i]]\n    }\n  }\n  return this\n}\n\n// Implementation of wiggle sort\n\nvar arr = [3, 5, 2, 1, 6, 4]\n// Array before Wiggle Sort\nconsole.log(arr) // [3, 5, 2, 1, 6, 4]\n\narr.wiggleSort()\n// Array after wiggle sort\nconsole.log(arr) // [ 3, 5, 2, 6, 1, 4 ]\n","index":198},{"title":"String","category":null,"id":"String","index":199},{"title":"Check Anagram","category":"String","id":"CheckAnagram_String","algorithm":"// Anagram check is case sensitive; i.e. Aba and aba is not a anagram.\n// inputs are strings i.e. str1 and str2\nconst checkAnagram = (str1, str2) => {\n  // check that inputs are strings.\n  if (typeof str1 !== 'string' || typeof str2 !== 'string') {\n    return 'Not string(s)'\n  }\n\n  // If both strings have not same lengths then they can not be anagram.\n  if (str1.length !== str2.length) {\n    return 'Not anagrams'\n  }\n\n  // Use hashmap to keep count of characters in str1\n\n  const str1CharCount = new Map()\n\n  for (let i = 0; i < str1.length; i++) {\n    let previousCount = 0\n    if (str1CharCount.has(str1[i])) {\n      previousCount = str1CharCount.get(str1[i])\n    }\n    str1CharCount.set(str1[i], previousCount + 1)\n  }\n\n  // Now check if second string has same characters?\n\n  for (let i = 0; i < str2.length; i++) {\n    let previousCount = 0\n    // if str1CharCount has no key for str2[i] then not anagram.\n    if (!str1CharCount.has(str2[i])) {\n      return 'Not anagrams'\n    }\n    previousCount = str1CharCount.get(str2[i])\n    str1CharCount.set(str2[i], previousCount - 1)\n  }\n\n  // Now check if all entries in hashmap has zeros.\n\n  for (const key in str1CharCount) {\n    if (str1CharCount[key] !== 0) { return 'Not anagrams' }\n  }\n\n  return 'Anagrams'\n}\n\nexport { checkAnagram }\n","index":200},{"title":"Check Palindrome","category":"String","id":"CheckPalindrome_String","algorithm":"// Palindrome check is case sensitive; i.e. Aba is not a palindrome\n// input is a string\nconst checkPalindrome = (str) => {\n  // check that input is a string\n  if (typeof str !== 'string') {\n    return 'Not a string'\n  }\n  // Store the length of the input string in a variable\n  const length = str.length\n  if (length === 0) {\n    return 'Empty string'\n  }\n  // Iterate through the length of the string\n  // Compare the first character to the last, the second character to the second last, and so on\n  for (let i = 0; i < length / 2; i++) {\n    // at the first instance of a mismatch\n    if (str[i] !== str[length - 1 - i]) {\n      return 'Not a Palindrome'\n    }\n  }\n  return 'Palindrome'\n}\n\nexport { checkPalindrome }\n","index":201},{"title":"Check Pangram","category":"String","id":"CheckPangram_String","algorithm":"/*\n  Pangram is a sentence that contains all the letters in the alphabet\n  https://en.wikipedia.org/wiki/Pangram\n */\n\nconst checkPangram = (string) => {\n  if (typeof string !== 'string') {\n    throw new TypeError('The given value is not a string')\n  }\n\n  const frequency = new Set()\n\n  for (const letter of string.toLowerCase()) {\n    if (letter >= 'a' && letter <= 'z') {\n      frequency.add(letter)\n    }\n  }\n\n  return frequency.size === 26\n}\n\nexport { checkPangram }\n","index":202},{"title":"Check Rearrange Palindrome","category":"String","id":"CheckRearrangePalindrome_String","algorithm":"/**\n  * What is a palindrome? https://en.wikipedia.org/wiki/Palindrome\n  * Receives a string and returns whether it can be rearranged to become a palindrome or not\n  * The string can only be a palindrome if the count of ALL characters is even or if the ONLY ONE character count is odd\n  * Input is a string\n  *\n  **/\n\nconst palindromeRearranging = (str) => {\n  // check that input is a string\n  if (typeof str !== 'string') {\n    return 'Not a string'\n  }\n  // Check if is a empty string\n  if (str.length === 0) {\n    return 'Empty string'\n  }\n\n  // First obtain the character count for each character in the string and store it in an object.\n  // Filter the object's values to only the odd character counts.\n  const charCounts = [...str].reduce((counts, char) => {\n    counts[char] = counts[char] ? counts[char] + 1 : 1\n    return counts\n  }, {})\n  // If the length of the resulting array is 0 or 1, the string can be a palindrome.\n  return Object.values(charCounts).filter(count => count % 2 !== 0).length <= 1\n}\n\n// testing\nconsole.log(palindromeRearranging('aaeccrr')) // true\nconsole.log(palindromeRearranging('leve')) // false\n","index":203},{"title":"Check Vowels","category":"String","id":"CheckVowels_String","algorithm":"/*\n  Given a string of words or phrases, count the number of vowels.\n  Example: input = \"hello world\" return 3\n */\n\nconst checkVowels = (value) => {\n  if (typeof value !== 'string') {\n    throw new TypeError('The first param should be a string')\n  }\n  const vowels = ['a', 'e', 'i', 'o', 'u']\n  let countVowels = 0\n  for (let i = 0; i < value.length; i++) {\n    const char = value[i].toLowerCase()\n    if (vowels.includes(char)) {\n      countVowels++\n    }\n  }\n  return countVowels\n}\n\nexport { checkVowels }\n","index":204},{"title":"Check Vowels.test","category":"String","id":"CheckVowels.test_String","algorithm":"import { checkVowels } from './CheckVowels'\n\ndescribe('Test the checkVowels function', () => {\n  it('expect throws on use wrong param', () => {\n    expect(() => checkVowels(0)).toThrow()\n  })\n  it('count the vowels in a string', () => {\n    const value = 'Mad World'\n    const countVowels = checkVowels(value)\n    expect(countVowels).toBe(2)\n  })\n})\n","index":205},{"title":"Check Word Occurrence","category":"String","id":"CheckWordOccurrence_String","algorithm":"/**\n  * Check and count occurrence of each word in a string\n  * Inputs a String eg. Madonna and Boolean\n  **/\n\nconst checkWordOccurrence = (str, isCaseSensitive = false) => {\n  if (typeof str !== 'string') {\n    throw new TypeError('The first param should be a string')\n  }\n  if (typeof isCaseSensitive !== 'boolean') {\n    throw new TypeError('The second param should be a boolean')\n  }\n\n  const result = {}\n  if (str.length > 0) {\n    for (let i = 0; i < str.length; i++) {\n      const word = isCaseSensitive ? str[i] : str[i].toUpperCase()\n      if (/\\s/.test(word)) continue\n      result[word] = (!result[word]) ? 1 : result[word] + 1\n    }\n  }\n\n  return result\n}\nexport { checkWordOccurrence }\n","index":206},{"title":"Check Word Ocurrence.test","category":"String","id":"CheckWordOcurrence.test_String","algorithm":"import { checkWordOccurrence } from './CheckWordOccurrence'\ndescribe('checkWordOccurrence', () => {\n  it('expects throw on insert wrong string', () => {\n    const value = 123\n    expect(() => checkWordOccurrence(value)).toThrow()\n  })\n  it('expect throw on insert wrong param for case sensitive', () => {\n    const value = 'hello'\n    expect(() => checkWordOccurrence(value, value)).toThrow()\n  })\n  it('check occurrence with case sensitive', () => {\n    const stringToTest = 'A Mad World'\n    const charsOccurrences = checkWordOccurrence(stringToTest, true)\n    const expectResult = { A: 1, M: 1, a: 1, d: 2, W: 1, l: 1, o: 1, r: 1 }\n    const occurrencesObjectKeys = Object.keys(charsOccurrences)\n    const expectObjectKeys = Object.keys(expectResult)\n    expect(occurrencesObjectKeys.length).toBe(expectObjectKeys.length)\n    expectObjectKeys.forEach(key => {\n      expect(expectResult[key]).toBe(charsOccurrences[key])\n    })\n  })\n  it('check occurrence with case insensitive', () => {\n    const stringToTest = 'A Mad World'\n    const charsOccurrences = checkWordOccurrence(stringToTest, false)\n    const expectResult = { A: 2, D: 2, L: 1, M: 1, O: 1, R: 1, W: 1 }\n    const occurrencesObjectKeys = Object.keys(charsOccurrences)\n    const expectObjectKeys = Object.keys(expectResult)\n    expect(occurrencesObjectKeys.length).toBe(expectObjectKeys.length)\n    expectObjectKeys.forEach(key => {\n      expect(expectResult[key]).toBe(charsOccurrences[key])\n    })\n  })\n})\n","index":207},{"title":"Format Phone Number","category":"String","id":"FormatPhoneNumber_String","algorithm":"// function that takes 10 digits and returns a string of the formatted phone number\n// e.g.: 1234567890 -> (123) 456-7890\n\nconst formatPhoneNumber = (numbers) => {\n  const numbersString = numbers.toString()\n  if ((numbersString.length !== 10) || isNaN(numbersString)) {\n    // return \"Invalid phone number.\"\n    throw new TypeError('Invalid phone number.')\n  }\n  const arr = '(XXX) XXX-XXXX'.split('')\n  Array.from(numbersString).forEach(n => {\n    arr[arr.indexOf('X')] = n\n  })\n  return arr.join('')\n}\n\nexport { formatPhoneNumber }\n","index":208},{"title":"Format Phone Number.test","category":"String","id":"FormatPhoneNumber.test_String","algorithm":"import { formatPhoneNumber } from './FormatPhoneNumber'\n\ndescribe('PhoneNumberFormatting', () => {\n  it('expects to return the formatted phone number', () => {\n    expect(formatPhoneNumber('1234567890')).toEqual('(123) 456-7890')\n  })\n\n  it('expects to return the formatted phone number', () => {\n    expect(formatPhoneNumber(1234567890)).toEqual('(123) 456-7890')\n  })\n\n  it('expects to throw a type error', () => {\n    expect(() => { formatPhoneNumber('1234567') }).toThrow('Invalid phone number.')\n  })\n\n  it('expects to throw a type error', () => {\n    expect(() => { formatPhoneNumber('123456text') }).toThrow('Invalid phone number.')\n  })\n\n  it('expects to throw a type error', () => {\n    expect(() => { formatPhoneNumber(12345) }).toThrow('Invalid phone number.')\n  })\n})\n","index":209},{"title":"Generate G U I D","category":"String","id":"GenerateGUID_String","algorithm":"/*\nGenerates a UUID/GUID in Node.Js.\nThe script uses `Math.random` in combination with the timestamp for better randomness.\nThe function generate an RFC4122 (https://www.ietf.org/rfc/rfc4122.txt) version 4 UUID/GUID\n*/\n\nconst Guid = () => {\n  const pattern = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'\n  let currentDateMilliseconds = new Date().getTime()\n  return pattern.replace(/[xy]/g, currentChar => {\n    const randomChar = (currentDateMilliseconds + Math.random() * 16) % 16 | 0\n    currentDateMilliseconds = Math.floor(currentDateMilliseconds / 16)\n    return (currentChar === 'x' ? randomChar : (randomChar & 0x7 | 0x8)).toString(16)\n  })\n}\n\nconsole.log(Guid()) // 'edc848db-3478-1760-8b55-7986003d895f'\n","index":210},{"title":"K M P Pattern Searching","category":"String","id":"KMPPatternSearching_String","algorithm":"// Implementing KMP Search Algorithm to search all the instances of pattern in\n// given text\n// Reference Book: Introduction to Algorithms, CLRS\n\n// Explanation: https://www.topcoder.com/community/competitive-programming/tutorials/introduction-to-string-searching-algorithms/\n\nconst computeLPS = (pattern) => {\n  const lps = Array(pattern.length)\n  lps[0] = 0\n  for (let i = 1; i < pattern.length; i++) {\n    let matched = lps[i - 1]\n    while (matched > 0 && pattern[i] !== pattern[matched]) {\n      matched = lps[matched - 1]\n    }\n    if (pattern[i] === pattern[matched]) {\n      matched++\n    }\n    lps[i] = matched\n  }\n  return lps\n}\n\n/**\n * Returns all indices where pattern starts in text\n * @param {*} text a big text in which pattern string is to find\n * @param {*} pattern the string to find\n */\nconst KMPSearch = (text, pattern) => {\n  if (!pattern || !text) {\n    return [] // no results\n  }\n\n  // lps[i] = length of proper prefix of pattern[0]...pattern[i-1]\n  //          which is also proper suffix of it\n  const lps = computeLPS(pattern)\n  const result = []\n\n  let matched = 0\n  for (let i = 0; i < text.length; i++) {\n    while (matched > 0 && text[i] !== pattern[matched]) {\n      matched = lps[matched - 1]\n    }\n    if (text[i] === pattern[matched]) {\n      matched++\n    }\n    if (matched === pattern.length) {\n      result.push(i - pattern.length + 1)\n      matched = lps[matched - 1]\n    }\n  }\n\n  return result\n}\n\nexport { KMPSearch }\n","index":211},{"title":"Levenshtein Distance","category":"String","id":"LevenshteinDistance_String","algorithm":"/* The Levenshtein distance (a.k.a edit distance) is a\nmeasure of similarity between two strings. It is\ndefined as the minimum number of changes required to\nconvert string a into string b (this is done by\ninserting, deleting or replacing a character in\nstring a).\nThe smaller the Levenshtein distance,\nthe more similar the strings are. This is a very\ncommon problem in the application of Dynamic Programming.\n*/\n\nconst levenshteinDistance = (a, b) => {\n  // Declaring array 'D' with rows = len(a) + 1 and columns = len(b) + 1:\n  const distanceMatrix = Array(b.length + 1)\n    .fill(null)\n    .map(() => Array(a.length + 1).fill(null))\n\n  // Initialising first column:\n  for (let i = 0; i <= a.length; i += 1) {\n    distanceMatrix[0][i] = i\n  }\n\n  // Initialising first row:\n  for (let j = 0; j <= b.length; j += 1) {\n    distanceMatrix[j][0] = j\n  }\n\n  for (let j = 1; j <= b.length; j += 1) {\n    for (let i = 1; i <= a.length; i += 1) {\n      const indicator = a[i - 1] === b[j - 1] ? 0 : 1\n      // choosing the minimum of all three, vis-a-vis:\n      distanceMatrix[j][i] = Math.min(\n        distanceMatrix[j][i - 1] + 1, // deletion\n        distanceMatrix[j - 1][i] + 1, // insertion\n        distanceMatrix[j - 1][i - 1] + indicator // substitution\n      )\n    }\n  }\n\n  console.log(\n    'Levenshtein Distance between ' +\n            a +\n            ' and ' +\n            b +\n            ' is = ' +\n            distanceMatrix[b.length][a.length]\n  )\n  return distanceMatrix[b.length][a.length]\n}\n\nexport { levenshteinDistance }\n","index":212},{"title":"Levenshtein Distance.test","category":"String","id":"LevenshteinDistance.test_String","algorithm":"import levenshteinDistance from './LevenshteinDistance'\n\ndescribe('levenshteinDistance', () => {\n  it('should calculate edit distance between two strings', () => {\n    expect(levenshteinDistance('', '')).toBe(0)\n    expect(levenshteinDistance('a', '')).toBe(1)\n    expect(levenshteinDistance('', 'a')).toBe(1)\n    expect(levenshteinDistance('abc', '')).toBe(3)\n    expect(levenshteinDistance('', 'abc')).toBe(3)\n\n    // Should just add I to the beginning.\n    expect(levenshteinDistance('igloo', 'gloo')).toBe(1)\n\n    // Should just substitute i with o, m with g and insert e at end\n    expect(levenshteinDistance('firm', 'forge')).toBe(3)\n\n    // Should just substitute i with s, g with i, h with t and delete f from front\n    expect(levenshteinDistance('fighting', 'sitting')).toBe(4)\n\n    // Should add 4 letters b, a, s and e at the beginning.\n    expect(levenshteinDistance('ball', 'baseball')).toBe(4)\n\n    // Should delete 4 letters b, a, s and e at the beginning.\n    expect(levenshteinDistance('baseball', 'foot')).toBe(4)\n  })\n})\n","index":213},{"title":"Max Character","category":"String","id":"MaxCharacter_String","algorithm":"/*\n  Given a string of characters, return the character that appears the most often.\n  Example: input = \"Hello World!\" return \"l\"\n*/\nconst maxCharacter = (value) => {\n  if (typeof value !== 'string') {\n    throw new TypeError('The param should be a string')\n  } else if (!value) {\n    throw new Error('The param should be a valid string')\n  }\n\n  const occurrences = {}\n  for (let i = 0; i < value.length; i++) {\n    const char = value[i]\n    if (/\\s/.test(char)) continue\n    occurrences[char] = occurrences[char] + 1 || 1\n  }\n  let maxCharacter = null\n  let maxCount = 0\n  Object.keys(occurrences).forEach(char => {\n    if (occurrences[char] > maxCount) {\n      maxCount = occurrences[char]\n      maxCharacter = char\n    }\n  })\n  return maxCharacter\n}\n\nexport { maxCharacter }\n","index":214},{"title":"Max Character.test","category":"String","id":"MaxCharacter.test_String","algorithm":"import { maxCharacter } from './MaxCharacter'\n\ndescribe('Testing the maxCharacter function', () => {\n  it('Expect throw with wrong arg', () => {\n    expect(() => maxCharacter(123)).toThrow()\n  })\n  it('Check the max character in string', () => {\n    const theString = 'I can\\'t do that'\n    const maxChar = maxCharacter(theString)\n    expect(maxChar).toBe('t')\n  })\n})\n","index":215},{"title":"Pattern Matching","category":"String","id":"PatternMatching_String","algorithm":"/*\nPattern matching is case insensitive as\nthe inputs are converted to lower case before the\nalgorithm is run.\n\nThe algorithm will run through the entire text and\nreturn the starting index if the given pattern is\navailable in the text\n*/\nconst checkIfPatternExists = (text, pattern) => {\n  if (typeof text !== 'string' || typeof pattern !== 'string') {\n    throw new TypeError('Given input is not a string')\n  }\n  const textLength = text.length // Store the length of the text in a variable\n  const patternLength = pattern.length // Store the length of the pattern in a variable\n\n  // Iterate through the text until the textlength - patternlength index\n  for (let i = 0; i <= textLength - patternLength; i++) {\n    // For each character in the text check if the subsequent character\n    // are matching the given pattern; if not break from the condition\n    for (let j = 0; j < textLength; j++) {\n      if (text[i + j] !== pattern[j]) break\n\n      // For each iteration of j check if the value of\n      // j + 1 is equal to the length of the pattern\n      if (j + 1 === patternLength) {\n        return `Given pattern is found at index ${i}`\n      }\n    }\n  }\n}\n\nexport { checkIfPatternExists }\n","index":216},{"title":"Permutate String","category":"String","id":"PermutateString_String","algorithm":"'use strict'\n\nconst permutate = (aString) => {\n  if (typeof aString !== 'string' || !aString) {\n    throw new Error('The arg must be a valid, non empty string')\n  }\n  const characters = aString.split('')\n  let permutations = [[characters.shift()]]\n  while (characters.length) {\n    const currentCharacter = characters.shift()\n    permutations = calculateCurrentCharacterPermutation(permutations, currentCharacter)\n  }\n  return permutations\n    .map(character => character.join(''))\n    .filter((item, index, self) => (self.indexOf(item) === index))\n    .sort()\n}\n\nconst calculateCurrentCharacterPermutation = (allPermutations, currentCharacter) => {\n  const currentPermutations = []\n  allPermutations.map(permutation => {\n    let index = 0\n    while (index <= permutation.length) {\n      const tmp = [...permutation]\n      tmp.splice(index, 0, currentCharacter)\n      currentPermutations.push(tmp)\n      index++\n    }\n  })\n  return currentPermutations\n}\n\nexport { permutate }\n","index":217},{"title":"Permutate String.test","category":"String","id":"PermutateString.test_String","algorithm":"import { permutate } from './PermutateString'\n\ndescribe('Permutate a string', () => {\n  it('expects to throw an Error with an empty string', () => {\n    expect(() => { permutate() }).toThrow('The arg must be a valid, non empty string')\n  })\n  it('expects to permute \"no\" into [no, on]', () => {\n    expect(['no', 'on']).toEqual(permutate('no'))\n  })\n  it('expects to permute \"yes\" into [esy, eys, sey, sye, yes, yse]', () => {\n    expect(['esy', 'eys', 'sey', 'sye', 'yes', 'yse']).toEqual(permutate('yes'))\n  })\n  it('expects to permute \"good\" into [dgoo dogo doog gdoo godo good odgo odog ogdo ogod oodg oogd ]', () => {\n    expect(['dgoo', 'dogo', 'doog', 'gdoo', 'godo', 'good', 'odgo', 'odog', 'ogdo', 'ogod', 'oodg', 'oogd'])\n      .toEqual(permutate('good'))\n  })\n})\n","index":218},{"title":"Reverse String","category":"String","id":"ReverseString_String","algorithm":"/**\n * A short example showing how to reverse a string\n * @flow\n */\n\n/**\n * Create a new string and append\n * @complexity O(n)\n */\n\nfunction ReverseStringIterative (string) {\n  if (typeof string !== 'string') {\n    throw new TypeError('The given value is not a string')\n  }\n  let reversedString = ''\n  let index\n\n  for (index = string.length - 1; index >= 0; index--) {\n    reversedString += string[index]\n  }\n\n  return reversedString\n}\n\n/**\n * JS disallows string mutation so we're actually a bit slower.\n *\n * @complexity: O(n)\n *\n * 'some' -> 'eoms' -> 'emos'\n */\n\nfunction ReverseStringIterativeInplace (string) {\n  if (typeof string !== 'string') {\n    throw new TypeError('The given value is not a string')\n  }\n  const _string = string.split('')\n\n  for (let i = 0; i < Math.floor(_string.length / 2); i++) {\n    const first = _string[i]\n    const second = _string[_string.length - 1 - i]\n    _string[i] = second\n    _string[_string.length - 1 - i] = first\n  }\n\n  return _string.join('')\n}\n\nexport { ReverseStringIterative, ReverseStringIterativeInplace }\n","index":219},{"title":"Reverse Words","category":"String","id":"ReverseWords_String","algorithm":"const reverseWords = (str) => {\n  if (typeof str !== 'string') {\n    throw new TypeError('The given value is not a string')\n  }\n  // Split string into words\n  // Ex. \"I Love JS\" => [\"I\", \"Love\", \"JS\"]\n  const words = str.split(' ')\n  // reverse words\n  // [\"I\", \"Love\", \"JS\"] => [\"JS\", \"Love\", \"I\"]\n  const reversedWords = words.reverse()\n  // join reversed words with space and return\n  // [\"JS\", \"Love\", \"I\"] => \"JS Love I\"\n  return reversedWords.join(' ')\n}\n\nexport { reverseWords }\n","index":220},{"title":"Validate Email","category":"String","id":"ValidateEmail_String","algorithm":"/*\n  function that takes a string input and return either it is true of false\n  a valid email address\n  e.g.: mahfoudh.arous@gmail.com -> true\n  e.g.: mahfoudh.arous@helsinki.edu -> true\n  e.g.: mahfoudh.arous.com ->false\n*/\n\nconst validateEmail = (str) => {\n  if (str === '' || str === null) {\n    throw new TypeError('Email Address String Null or Empty.')\n  }\n\n  return /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(str)\n}\n\nexport { validateEmail }\n","index":221},{"title":"Create Purmutations","category":"String","id":"createPurmutations_String","algorithm":"/*\na permutation of a set is, loosely speaking, an arrangement of its members into a sequence or linear order, or if the set is already ordered, a rearrangement of its elements.\nThe word \"permutation\" also refers to the act or process of changing the linear order of an ordered set\nMore at : https://en.wikipedia.org/wiki/Permutation\n*/\n\nconst createPermutations = (str) => {\n// convert string to array\n  const arr = str.split('')\n\n  // get array length\n  const strLen = arr.length\n  // this will hold all the permutations\n  const perms = []\n  let rest\n  let picked\n  let restPerms\n  let next\n\n  // if strLen is zero, return the same string\n  if (strLen === 0) { return [str] }\n  // loop to the length to get all permutations\n  for (let i = 0; i < strLen; i++) {\n    rest = Object.create(arr)\n    picked = rest.splice(i, 1)\n\n    restPerms = createPermutations(rest.join(''))\n\n    for (let j = 0, jLen = restPerms.length; j < jLen; j++) {\n      next = picked.concat(restPerms[j])\n      perms.push(next.join(''))\n    }\n  }\n  return perms\n}\n\nconsole.log(createPermutations('abc')) // should print [\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"]\n","index":222},{"title":"Test","category":"String","id":"test","index":223},{"title":"Check Anagram.test","category":"test","id":"CheckAnagram.test_test","algorithm":"import { checkAnagram } from '../CheckAnagram'\n\ndescribe('checkAnagram', () => {\n  it.each`\n    inputOne              | inputTwo\n    ${123456}             | ${'abcd'}\n    ${[1, 2, 3, 4, 5, 6]} | ${'abcd'}\n    ${{ test: 'test' }}   | ${'abcd'}\n    ${'abcd'}             | ${123456}\n    ${'abcd'}             | ${[1, 2, 3, 4, 5, 6]}\n    ${'abcd'}             | ${{ test: 'test' }}\n  `(\n    'expects to return \"Not string(s)\" given values $inputOne and $inputTwo',\n    ({ inputOne, inputTwo }) => {\n      const SUT = checkAnagram(inputOne, inputTwo)\n      expect(SUT).toBe('Not string(s)')\n    }\n  )\n  it('expects to return \"Not anagram\" if the arguments have different lengths', () => {\n    const SUT = checkAnagram('abs', 'abds')\n    expect(SUT).toBe('Not anagrams')\n  })\n  it('expects to return \"Not anagram\" if the arguments are not anagrams', () => {\n    const SUT = checkAnagram('abcs', 'abds')\n    expect(SUT).toBe('Not anagrams')\n  })\n  it('expects to return \"Anagram\" if the arguments are anagram', () => {\n    const SUT = checkAnagram('abcd', 'bcad')\n    expect(SUT).toBe('Anagrams')\n  })\n})\n","index":224},{"title":"Check Palindrome.test","category":"test","id":"CheckPalindrome.test_test","algorithm":"import { checkPalindrome } from '../CheckPalindrome'\n\ndescribe('checkPalindrome', () => {\n  it('expects to return \"Palindrome\" if the given string is a palindrome', () => {\n    const SUT = checkPalindrome('madam')\n    expect(SUT).toBe('Palindrome')\n  })\n  it('expects to return \"Empty string\" if the given string is empty', () => {\n    const SUT = checkPalindrome('')\n    expect(SUT).toBe('Empty string')\n  })\n  it('expects to return \"Not a string\" if the given string is not a string', () => {\n    const SUT = checkPalindrome(123)\n    expect(SUT).toBe('Not a string')\n  })\n})\n","index":225},{"title":"Check Pangram.test","category":"test","id":"CheckPangram.test_test","algorithm":"import { checkPangram } from '../CheckPangram'\n\ndescribe('checkPangram', () => {\n  it('\"The quick brown fox jumps over the lazy dog\" is a pangram', () => {\n    expect(\n      checkPangram('The quick brown fox jumps over the lazy dog')\n    ).toBeTruthy()\n  })\n\n  it('\"Waltz, bad nymph, for quick jigs vex.\" is a pangram', () => {\n    expect(checkPangram('Waltz, bad nymph, for quick jigs vex.')).toBeTruthy()\n  })\n\n  it('\"Jived fox nymph grabs quick waltz.\" is a pangram', () => {\n    expect(checkPangram('Jived fox nymph grabs quick waltz.')).toBeTruthy()\n  })\n\n  it('\"My name is Unknown\" is NOT a pangram', () => {\n    expect(checkPangram('My name is Unknown')).toBeFalsy()\n  })\n\n  it('\"The quick brown fox jumps over the la_y dog\" is NOT a pangram', () => {\n    expect(\n      checkPangram('The quick brown fox jumps over the la_y dog')\n    ).toBeFalsy()\n  })\n\n  it('Throws an error if given param is not a string', () => {\n    expect(() => {\n      checkPangram(undefined)\n    }).toThrow('The given value is not a string')\n  })\n})\n","index":226},{"title":"K M P Pattern Searching.test","category":"test","id":"KMPPatternSearching.test_test","algorithm":"import { KMPSearch } from '../KMPPatternSearching'\n\ndescribe('KMP Matcher', () => {\n  it('TC1: expects to return matching indices for pattern in text', () => {\n    const text = 'ABC ABCDAB ABCDABCDABDE'\n    const pattern = 'ABCDABD'\n    expect(KMPSearch(text, pattern)).toStrictEqual([15])\n  })\n\n  it('TC2: expects to return matching indices for pattern in text', () => {\n    const text = 'ABC ABCDABD ABCDABCDABDE'\n    const pattern = 'ABCDABD'\n    expect(KMPSearch(text, pattern)).toStrictEqual([4, 16])\n  })\n\n  it('TC3: expects to return matching indices for pattern in text', () => {\n    const text = 'AAAAA'\n    const pattern = 'AAA'\n    expect(KMPSearch(text, pattern)).toStrictEqual([0, 1, 2])\n  })\n\n  it('TC4: expects to return matching indices for pattern in text', () => {\n    const text = 'ABCD'\n    const pattern = 'BA'\n    expect(KMPSearch(text, pattern)).toStrictEqual([])\n  })\n})\n","index":227},{"title":"Pattern Matching.test","category":"test","id":"PatternMatching.test_test","algorithm":"import { checkIfPatternExists } from '../PatternMatching'\ndescribe('checkIfPatternExists', () => {\n  it('expects to find a pattern with correct input', () => {\n    const text = 'AABAACAADAABAAAABAA'\n    const pattern = 'AABA'\n    const SUT = checkIfPatternExists(text.toLowerCase(), pattern.toLowerCase())\n    expect(SUT).toBe('Given pattern is found at index 0')\n  })\n  it('expects to return a message when there is no pattern', () => {\n    const text = 'ABCDEFG'\n    const pattern = 'AEG'\n    const SUT = checkIfPatternExists(text.toLowerCase(), pattern.toLowerCase())\n    expect(SUT).toBe(undefined)\n  })\n  it('expects to find a pattern independent of casing', () => {\n    const text = 'AbCAAAAAAB'\n    const pattern = 'abc'\n    const SUT = checkIfPatternExists(text, pattern)\n    expect(SUT).toBe(undefined)\n  })\n  it('expects to throw an error message when given inpuut is not a string', () => {\n    const text = 123444456\n    const pattern = 123\n    expect(() => checkIfPatternExists(text, pattern)).toThrow(\n      'Given input is not a string'\n    )\n  })\n})\n","index":228},{"title":"Reverse String.test","category":"test","id":"ReverseString.test_test","algorithm":"import {\n  ReverseStringIterative,\n  ReverseStringIterativeInplace\n} from '../ReverseString'\n\ndescribe('ReverseStringIterative', () => {\n  it('expects to reverse a simple string', () => {\n    const SUT = ReverseStringIterative('reverse')\n    expect(SUT).toEqual('esrever')\n  })\n  it('expects to reverse a string with spaces in between', () => {\n    const SUT = ReverseStringIterative('reverse me')\n    expect(SUT).toEqual('em esrever')\n  })\n  it('expects to reverse a simple string without capitalizing the first letter', () => {\n    const SUT = ReverseStringIterative('Javascript')\n    expect(SUT).toEqual('tpircsavaJ')\n  })\n  it.each`\n    input\n    ${123456}\n    ${[1, 2, 3, 4, 5, 6]}\n    ${{ test: 'test' }}\n  `(\n    'expects to throw a type error given a value that is $input',\n    ({ input }) => {\n      expect(() => {\n        ReverseStringIterative(input)\n      }).toThrow('The given value is not a string')\n    }\n  )\n  it('expects to return a empty string with an empty string is given', () => {\n    const SUT = ReverseStringIterative('')\n    expect(SUT).toEqual('')\n  })\n})\ndescribe('ReverseStringIterativeInplace', () => {\n  it('expects to reverse a simple string', () => {\n    const SUT = ReverseStringIterativeInplace('reverse')\n    expect(SUT).toEqual('esrever')\n  })\n  it('expects to reverse a simple string without capitalizing the first letter', () => {\n    const SUT = ReverseStringIterativeInplace('Javascript')\n    expect(SUT).toEqual('tpircsavaJ')\n  })\n  it('expects to return an empty string given an empty string', () => {\n    const SUT = ReverseStringIterativeInplace('Javascript')\n    expect(SUT).toEqual('tpircsavaJ')\n  })\n  it.each`\n    input\n    ${123456}\n    ${[1, 2, 3, 4, 5, 6]}\n    ${{ test: 'test' }}\n  `(\n    'expects to throw a type error given a value that is $input',\n    ({ input }) => {\n      expect(() => {\n        ReverseStringIterativeInplace(input)\n      }).toThrow('The given value is not a string')\n    }\n  )\n})\n","index":229},{"title":"Reverse Words.test","category":"test","id":"ReverseWords.test_test","algorithm":"import { reverseWords } from '../ReverseWords'\n\ndescribe('reverseWords', () => {\n  it('expects to reverse words to return a joined word', () => {\n    const SUT = reverseWords('I Love JS')\n    expect(SUT).toBe('JS Love I')\n  })\n  it.each`\n    input\n    ${123456}\n    ${[1, 2, 3, 4, 5, 6]}\n    ${{ test: 'test' }}\n  `(\n    'expects to throw a type error given a value that is $input',\n    ({ input }) => {\n      expect(() => {\n        reverseWords(input)\n      }).toThrow('The given value is not a string')\n    }\n  )\n})\n","index":230},{"title":"Validate Email.test","category":"test","id":"ValidateEmail.test_test","algorithm":"import { validateEmail } from '../ValidateEmail'\n\ndescribe('Validation of an Email Address', () => {\n  it('expects to return false', () => {\n    expect(validateEmail('mahfoudh.arous.com')).toEqual(false)\n  })\n\n  it('expects to return false', () => {\n    expect(validateEmail('mahfoudh.arous@com')).toEqual(false)\n  })\n\n  it('expects to return true', () => {\n    expect(validateEmail('mahfoudh.arous@gmail.com')).toEqual(true)\n  })\n\n  it('expects to return true', () => {\n    expect(validateEmail('icristianbaciu@.helsinki.edu')).toEqual(true)\n  })\n\n  it('expects to throw a type error', () => {\n    expect(() => { validateEmail('') }).toThrow('Email Address String Null or Empty.')\n  })\n})\n","index":231},{"title":"Timing- Functions","category":null,"id":"Timing-Functions","index":232},{"title":"Get Month Days","category":"Timing-Functions","id":"GetMonthDays_Timing-Functions","algorithm":"/**\n  function that takes month number and its year and returns the number of days within it\n  * @param monthNumber.\n  * @param year.\n  e.g.: mahfoudh.arous@gmail.com -> true\n  e.g.: mahfoudh.arous.com ->false\n*/\n\nconst getMonthDays = (monthNumber, year) => {\n  const the31DaysMonths = [1, 3, 5, 7, 8, 10, 12]\n  const the30DaysMonths = [4, 6, 9, 11]\n\n  if (!the31DaysMonths.includes(monthNumber) && !the30DaysMonths.includes(monthNumber) &&\n    (monthNumber !== 2)\n  ) {\n    throw new TypeError('Invalid Month Number.')\n  }\n\n  if (the31DaysMonths.includes(monthNumber)) { return 31 }\n\n  if (the30DaysMonths.includes(monthNumber)) { return 30 }\n\n  // Check for Leap year\n  if (year % 4 === 0) {\n    if ((year % 100 !== 0) || (year % 100 === 0 && year % 400 === 0)) {\n      return 29\n    }\n  }\n\n  return 28\n}\n\nexport { getMonthDays }\n","index":233},{"title":"Get Month Days.test","category":"Timing-Functions","id":"GetMonthDays.test_Timing-Functions","algorithm":"import { getMonthDays } from './GetMonthDays'\n\ndescribe('Get the Days of a Month', () => {\n  it('expects to return 28', () => {\n    expect(getMonthDays(2, 2018)).toEqual(28)\n  })\n\n  it('expects to return 30', () => {\n    expect(getMonthDays(6, 254)).toEqual(30)\n  })\n\n  it('expects to return 29', () => {\n    expect(getMonthDays(2, 2024)).toEqual(29)\n  })\n\n  it('expects to throw a type error', () => {\n    expect(() => { getMonthDays(13, 2020) }).toThrow('Invalid Month Number.')\n  })\n})\n","index":234},{"title":"Interval Timer","category":"Timing-Functions","id":"IntervalTimer_Timing-Functions","algorithm":"/**\n * @author Nandan V\n * Sunday, 26 July 2020 8:33 AM\n * @description Singleton class that handles the <b>timing of tests</b> and\n *   specs. <br/> The class is singleton as <u>javascript does not support\n *   multiple timer instances<u/>.\n */\nclass IntervalTimer {\n  /**\n   * @description Constructor for Timer.\n   * @param interval Sets the interval for running the timer.\n   * @param callBack The callback function to be executed.\n   * @return {IntervalTimer} If exists, the existing object.\n   */\n  constructor (interval = 10,\n    callBack = () => {}) {\n    this.prevInterval = 0\n    if (this.instance == null) {\n      this.interval = interval\n      this.callBack = callBack\n      this.instance = this\n    } else {\n      return this.instance\n    }\n  }\n\n  /**\n   * @description Starts the timer.\n   */\n  startTimer () {\n    this.timer = setInterval(this.callBack, this.interval)\n  }\n\n  /**\n   * @description Resets the timer.\n   * @return {number} Elapsed time in milliseconds.\n   */\n  resetTimer () {\n    clearInterval(this.timer)\n    this.callBack = () => {}\n    return this.getElapsedTime()\n  }\n\n  /**\n   * @return {number} Elapsed time in milliseconds since reset.\n   */\n  getElapsedTime (offset = 0) {\n    this.timeElapsed = this.timer - this.prevInterval\n    this.prevInterval = this.timer\n    return this.timeElapsed - offset\n  }\n\n  /**\n   * @return {number} Elapsed time since start.\n   */\n  getRunTime () {\n    return this.timer\n  }\n}\n\n/**\n * @author Nandan V\n * Saturday, 01 August 2020 8:33 AM\n * @description Example usage\n */\nconst ExampleIntervalTimer = function () {\n  /**\n   * Create am object with default settings.\n   * @type {IntervalTimer} Used to get timing information.\n   */\n  const timer = new IntervalTimer()\n  timer.startTimer()\n\n  // ... Initialization code ...\n  // I generally use it for timing tests in Jasmine JS.\n\n  /**\n   * Gets the runtime till this point.\n   * Can be subtracted from ElapsedTime to offset timing of initialization code.\n   */\n  const initOffset = timer.getRunTime()\n\n  // ... A test ...\n  // The time taken to run the test.\n  console.log(timer.getElapsedTime(initOffset))\n\n  /**\n   * Returns the elapsed time and resets the timer to 0.\n   */\n  console.log(timer.resetTimer())\n}\n\nExampleIntervalTimer()\n","index":235},{"title":"Trees","category":null,"id":"Trees","index":236},{"title":"Breadth First Tree Traversal","category":"Trees","id":"BreadthFirstTreeTraversal_Trees","algorithm":"/*\n  Breadth First Tree Traversal or level order traversal implementation in javascript\n  Author: @GerardUbuntu\n*/\n\nclass Node {\n  constructor (data) {\n    this.data = data\n    this.left = null\n    this.right = null\n  }\n}\n\nclass BinaryTree {\n  constructor () {\n    this.root = null\n    this.traversal = []\n  }\n\n  breadthFirst () {\n    const h = this.getHeight(this.root)\n    for (let i = 1; i <= h; i++) {\n      this.traverseLevel(this.root, i)\n    }\n    return this.traversal.toLocaleString()\n  }\n\n  // Compputing the height of the tree\n  getHeight (node) {\n    if (node == null) {\n      return 0\n    } else {\n      const lheight = this.getHeight(node.left)\n      const rheight = this.getHeight(node.right)\n      return lheight > rheight ? lheight + 1 : rheight + 1\n    }\n  }\n\n  traverseLevel (node, level) {\n    if (level === 1 && node !== null) {\n      this.traversal.push(node.data)\n    } else {\n      if (node !== null) {\n        this.traverseLevel(node.left, level - 1)\n        this.traverseLevel(node.right, level - 1)\n      }\n    }\n  }\n}\n\nconst binaryTree = new BinaryTree()\nconst root = new Node(7)\nroot.left = new Node(5)\nroot.right = new Node(8)\nroot.left.left = new Node(3)\nroot.left.right = new Node(6)\nroot.right.right = new Node(9)\nbinaryTree.root = root\n\nconsole.log(binaryTree.breadthFirst())\n\n//            7\n//           / \\\n//          5   8\n//         / \\   \\\n//        3   6   9\n","index":237},{"title":"Depth First Search","category":"Trees","id":"DepthFirstSearch_Trees","algorithm":"/*\n * Author: Surendra Kumar\n * DFS Algorithm implementation in JavaScript\n * DFS Algorithm for traversing or searching graph data structures.\n*/\n\nfunction traverseDFS (root) {\n  const stack = [root]\n  const res = []\n\n  while (stack.length) {\n    const curr = stack.pop()\n    res.push(curr.key)\n\n    if (curr.right) {\n      stack.push(curr.right)\n    }\n\n    if (curr.left) {\n      stack.push(curr.left)\n    }\n  }\n\n  return res.reverse()\n}\n\nfunction searchDFS (tree, value) {\n  var stack = []\n\n  stack.push(tree[0])\n\n  while (stack.length !== 0) {\n    for (let i = 0; i < stack.length; i++) {\n      var node = stack.pop()\n\n      if (node.value === value) {\n        return node\n      }\n      if (node.right) {\n        stack.push(tree[node.right])\n      }\n      if (node.left) {\n        stack.push(tree[node.left])\n      }\n    }\n  }\n  return null\n}\n\nvar tree = [\n  { value: 6, left: 1, right: 2 },\n  { value: 5, left: 3, right: 4 },\n  { value: 7, left: null, right: 5 },\n  { value: 3, left: 6, right: null },\n  { value: 4, left: null, right: null },\n  { value: 9, left: 7, right: 8 },\n  { value: 2, left: 9, right: null },\n  { value: 8, left: null, right: null },\n  { value: 10, left: null, right: null },\n  { value: 1, left: null, right: null }\n]\n\nsearchDFS(tree, 9)\nsearchDFS(tree, 10)\n\ntraverseDFS(6)\n\n//            6\n//           / \\\n//          5   7\n//         / \\   \\\n//        3   4   9\n//       /       / \\\n//      2       8   10\n//     /\n//    1\n","index":238},{"title":"Web- Programming","category":null,"id":"Web-Programming","index":239},{"title":"Open Weather Maps","category":"Web-Programming","id":"OpenWeatherMaps_Web-Programming","algorithm":"const fetch = require('node-fetch')\n\nconst APPID = '' // <-- Put your OpenWeatherMap appid here!\nconst URL_BASE = 'http://api.openweathermap.org/data/2.5/'\n\nasync function currentWeather (location) {\n  const response = await fetch(`${URL_BASE}weather?q=${location}&appid=${APPID}`)\n  const data = await response.json()\n  return data\n}\n\nasync function weatherForecast (location) {\n  const response = await fetch(`${URL_BASE}forecast?q=${location}&appid=${APPID}`)\n  const data = await response.json()\n  return data\n}\n\nasync function oneCallApi (latitude, longitude) {\n  const response = await fetch(`${URL_BASE}onecall?lat=${latitude}&lon=${longitude}&appid=${APPID}`)\n  const data = await response.json()\n  return data\n}\n\ncurrentWeather('Kolkata')\n  .then(data => console.log(data))\n\nweatherForecast('Kolkata')\n  .then(data => console.log(data))\n\noneCallApi(55.68, 12.57)\n  .then(data => console.log(data))\n","index":240},{"title":"Stock Price","category":"Web-Programming","id":"StockPrice_Web-Programming","algorithm":"const fetch = require('node-fetch')\nconst jsdom = require('jsdom')\n\n// function to get the stock price from the given symbol\nasync function getStockPrice (stockSymbol) {\n  // parsing the html page body\n  const url = `https://in.finance.yahoo.com/lookup?s=$${stockSymbol}`\n  const response = await fetch(url)\n  const pageBody = await response.text()\n  const dom = new jsdom.JSDOM(pageBody, 'text/html')\n  // returning the price as a number\n  return parseFloat(dom.window.document.querySelectorAll('td')[2].textContent.replace(/,/g, ''))\n}\n\nasync function main () {\n  // Using async await to ensure synchronous behaviour\n  await getStockPrice('GOOGL')\n    .then(response => console.log(`GOOGL stock price: $ ${response}`))\n\n  await getStockPrice('AAPL')\n    .then(response => console.log(`AAPL stock price: $ ${response}`))\n\n  await getStockPrice('MSFT')\n    .then(response => console.log(`MSFT stock price: $ ${response}`))\n\n  await getStockPrice('AMZN')\n    .then(response => console.log(`AMZN stock price: $ ${response}`))\n}\n\nmain()\n","index":241}]