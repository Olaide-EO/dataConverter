[{"title":"Java-master","category":".","id":"Java-master"},{"title":"Conversions","category":null,"id":"Conversions","index":0},{"title":"Any Base To Any Base","category":"Conversions","id":"AnyBaseToAnyBase_Conversions","algorithm":"package Conversions;\n\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\n/**\n * Class for converting from \"any\" base to \"any\" other base, when \"any\" means from 2-36. Works by\n * going from base 1 to decimal to base 2. Includes auxiliary method for determining whether a\n * number is valid for a given base.\n *\n * @author Michael Rolland\n * @version 2017.10.10\n */\npublic class AnyBaseToAnyBase {\n\n  /** Smallest and largest base you want to accept as valid input */\n  static final int MINIMUM_BASE = 2;\n\n  static final int MAXIMUM_BASE = 36;\n\n  public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    String n;\n    int b1, b2;\n    while (true) {\n      try {\n        System.out.print(\"Enter number: \");\n        n = in.next();\n        System.out.print(\n            \"Enter beginning base (between \" + MINIMUM_BASE + \" and \" + MAXIMUM_BASE + \"): \");\n        b1 = in.nextInt();\n        if (b1 > MAXIMUM_BASE || b1 < MINIMUM_BASE) {\n          System.out.println(\"Invalid base!\");\n          continue;\n        }\n        if (!validForBase(n, b1)) {\n          System.out.println(\"The number is invalid for this base!\");\n          continue;\n        }\n        System.out.print(\n            \"Enter end base (between \" + MINIMUM_BASE + \" and \" + MAXIMUM_BASE + \"): \");\n        b2 = in.nextInt();\n        if (b2 > MAXIMUM_BASE || b2 < MINIMUM_BASE) {\n          System.out.println(\"Invalid base!\");\n          continue;\n        }\n        break;\n      } catch (InputMismatchException e) {\n        System.out.println(\"Invalid input.\");\n        in.next();\n      }\n    }\n    System.out.println(base2base(n, b1, b2));\n    in.close();\n  }\n\n  /** Checks if a number (as a String) is valid for a given base. */\n  public static boolean validForBase(String n, int base) {\n    char[] validDigits = {\n      '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I',\n      'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'\n    };\n    // digitsForBase contains all the valid digits for the base given\n    char[] digitsForBase = Arrays.copyOfRange(validDigits, 0, base);\n\n    // Convert character array into set for convenience of contains() method\n    HashSet<Character> digitsList = new HashSet<>();\n    for (int i = 0; i < digitsForBase.length; i++) digitsList.add(digitsForBase[i]);\n\n    // Check that every digit in n is within the list of valid digits for that base.\n    for (char c : n.toCharArray()) if (!digitsList.contains(c)) return false;\n\n    return true;\n  }\n\n  /**\n   * Method to convert any integer from base b1 to base b2. Works by converting from b1 to decimal,\n   * then decimal to b2.\n   *\n   * @param n The integer to be converted.\n   * @param b1 Beginning base.\n   * @param b2 End base.\n   * @return n in base b2.\n   */\n  public static String base2base(String n, int b1, int b2) {\n    // Declare variables: decimal value of n,\n    // character of base b1, character of base b2,\n    // and the string that will be returned.\n    int decimalValue = 0, charB2;\n    char charB1;\n    String output = \"\";\n    // Go through every character of n\n    for (int i = 0; i < n.length(); i++) {\n      // store the character in charB1\n      charB1 = n.charAt(i);\n      // if it is a non-number, convert it to a decimal value >9 and store it in charB2\n      if (charB1 >= 'A' && charB1 <= 'Z') charB2 = 10 + (charB1 - 'A');\n      // Else, store the integer value in charB2\n      else charB2 = charB1 - '0';\n      // Convert the digit to decimal and add it to the\n      // decimalValue of n\n      decimalValue = decimalValue * b1 + charB2;\n    }\n\n    // Converting the decimal value to base b2:\n    // A number is converted from decimal to another base\n    // by continuously dividing by the base and recording\n    // the remainder until the quotient is zero. The number in the\n    // new base is the remainders, with the last remainder\n    // being the left-most digit.\n    if (0 == decimalValue) return \"0\";\n    // While the quotient is NOT zero:\n    while (decimalValue != 0) {\n      // If the remainder is a digit < 10, simply add it to\n      // the left side of the new number.\n      if (decimalValue % b2 < 10) output = Integer.toString(decimalValue % b2) + output;\n      // If the remainder is >= 10, add a character with the\n      // corresponding value to the new number. (A = 10, B = 11, C = 12, ...)\n      else output = (char) ((decimalValue % b2) + 55) + output;\n      // Divide by the new base again\n      decimalValue /= b2;\n    }\n    return output;\n  }\n}\n","index":1},{"title":"Any Base To Decimal","category":"Conversions","id":"AnyBaseToDecimal_Conversions","algorithm":"package Conversions;\n\n/** @author Varun Upadhyay (https://github.com/varunu28) */\n\n// Driver program\npublic class AnyBaseToDecimal {\n  public static void main(String[] args) {\n    assert convertToDecimal(\"1010\", 2) == Integer.valueOf(\"1010\", 2);\n    assert convertToDecimal(\"777\", 8) == Integer.valueOf(\"777\", 8);\n    assert convertToDecimal(\"999\", 10) == Integer.valueOf(\"999\", 10);\n    assert convertToDecimal(\"ABCDEF\", 16) == Integer.valueOf(\"ABCDEF\", 16);\n    assert convertToDecimal(\"XYZ\", 36) == Integer.valueOf(\"XYZ\", 36);\n  }\n\n  /**\n   * Convert any radix to decimal number\n   *\n   * @param s the string to be convert\n   * @param radix the radix\n   * @return decimal of bits\n   * @throws NumberFormatException if {@code bits} or {@code radix} is invalid\n   */\n  public static int convertToDecimal(String s, int radix) {\n    int num = 0;\n    int pow = 1;\n\n    for (int i = s.length() - 1; i >= 0; i--) {\n      int digit = valOfChar(s.charAt(i));\n      if (digit >= radix) {\n        throw new NumberFormatException(\"For input string \" + s);\n      }\n      num += valOfChar(s.charAt(i)) * pow;\n      pow *= radix;\n    }\n    return num;\n  }\n\n  /**\n   * Convert character to integer\n   *\n   * @param c the character\n   * @return represented digit of given character\n   * @throws NumberFormatException if {@code ch} is not UpperCase or Digit character.\n   */\n  public static int valOfChar(char c) {\n    if (!(Character.isUpperCase(c) || Character.isDigit(c))) {\n      throw new NumberFormatException(\"invalid character :\" + c);\n    }\n    return Character.isDigit(c) ? c - '0' : c - 'A' + 10;\n  }\n}\n","index":2},{"title":"Anyto Any","category":"Conversions","id":"AnytoAny_Conversions","algorithm":"package Conversions;\n\nimport java.util.Scanner;\n// given a source number , source base, destination base, this code can give you the destination\n// number.\n// sn ,sb,db ---> ()dn  .   this is what we have to do    .\n\npublic class AnytoAny {\n\n  public static void main(String[] args) {\n    Scanner scn = new Scanner(System.in);\n    int sn = scn.nextInt();\n    int sb = scn.nextInt();\n    int db = scn.nextInt();\n    int m = 1, dec = 0, dn = 0;\n    while (sn != 0) {\n      dec = dec + (sn % 10) * m;\n      m *= sb;\n      sn /= 10;\n    }\n    m = 1;\n    while (dec != 0) {\n      dn = dn + (dec % db) * m;\n      m *= 10;\n      dec /= db;\n    }\n    System.out.println(dn);\n    scn.close();\n  }\n}\n","index":3},{"title":"Binary To Decimal","category":"Conversions","id":"BinaryToDecimal_Conversions","algorithm":"package Conversions;\n\nimport java.util.Scanner;\n\n/** This class converts a Binary number to a Decimal number */\nclass BinaryToDecimal {\n\n  /**\n   * Main Method\n   *\n   * @param args Command line arguments\n   */\n  public static void main(String args[]) {\n    Scanner sc = new Scanner(System.in);\n    int binNum, binCopy, d, s = 0, power = 0;\n    System.out.print(\"Binary number: \");\n    binNum = sc.nextInt();\n    binCopy = binNum;\n    while (binCopy != 0) {\n      d = binCopy % 10;\n      s += d * (int) Math.pow(2, power++);\n      binCopy /= 10;\n    }\n    System.out.println(\"Decimal equivalent:\" + s);\n    sc.close();\n  }\n}\n","index":4},{"title":"Binary To Hexadecimal","category":"Conversions","id":"BinaryToHexadecimal_Conversions","algorithm":"package Conversions;\n\nimport java.util.*;\n\n/**\n * Converts any Binary Number to a Hexadecimal Number\n *\n * @author Nishita Aggarwal\n */\npublic class BinaryToHexadecimal {\n\n  /**\n   * This method converts a binary number to a hexadecimal number.\n   *\n   * @param binary The binary number\n   * @return The hexadecimal number\n   */\n  static String binToHex(int binary) {\n    // hm to store hexadecimal codes for binary numbers within the range: 0000 to 1111 i.e. for\n    // decimal numbers 0 to 15\n    HashMap<Integer, String> hm = new HashMap<>();\n    // String to store hexadecimal code\n    String hex = \"\";\n    int i;\n    for (i = 0; i < 10; i++) {\n      hm.put(i, String.valueOf(i));\n    }\n    for (i = 10; i < 16; i++) hm.put(i, String.valueOf((char) ('A' + i - 10)));\n    int currbit;\n    while (binary != 0) {\n      int code4 = 0; // to store decimal equivalent of number formed by 4 decimal digits\n      for (i = 0; i < 4; i++) {\n        currbit = binary % 10;\n        binary = binary / 10;\n        code4 += currbit * Math.pow(2, i);\n      }\n      hex = hm.get(code4) + hex;\n    }\n    return hex;\n  }\n\n  /**\n   * Main method\n   *\n   * @param args Command line arguments\n   */\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    System.out.println(\"Enter binary number:\");\n    int binary = sc.nextInt();\n    String hex = binToHex(binary);\n    System.out.println(\"Hexadecimal Code:\" + hex);\n    sc.close();\n  }\n}\n","index":5},{"title":"Binary To Octal","category":"Conversions","id":"BinaryToOctal_Conversions","algorithm":"package Conversions;\n\nimport java.util.Scanner;\n\n/**\n * Converts any Binary number to an Octal Number\n *\n * @author Zachary Jones\n */\npublic class BinaryToOctal {\n\n  /**\n   * Main method\n   *\n   * @param args Command line arguments\n   */\n  public static void main(String args[]) {\n    Scanner sc = new Scanner(System.in);\n    System.out.println(\"Input the binary number: \");\n    int b = sc.nextInt();\n    System.out.println(\"Octal equivalent: \" + convertBinaryToOctal(b));\n    sc.close();\n  }\n\n  /**\n   * This method converts a binary number to an octal number.\n   *\n   * @param binary The binary number\n   * @return The octal number\n   */\n  public static String convertBinaryToOctal(int binary) {\n    String octal = \"\";\n    int currBit = 0, j = 1;\n    while (binary != 0) {\n      int code3 = 0;\n      for (int i = 0; i < 3; i++) {\n        currBit = binary % 10;\n        binary = binary / 10;\n        code3 += currBit * j;\n        j *= 2;\n      }\n      octal = code3 + octal;\n      j = 1;\n    }\n    return octal;\n  }\n}\n","index":6},{"title":"Decimal To Any Base","category":"Conversions","id":"DecimalToAnyBase_Conversions","algorithm":"package Conversions;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\n\n/** @author Varun Upadhyay (https://github.com/varunu28) */\n\n// Driver Program\npublic class DecimalToAnyBase {\n  public static void main(String[] args) throws Exception {\n    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    System.out.println(\"Enter the decimal input below: \");\n    int decInput = Integer.parseInt(br.readLine());\n    System.out.println();\n\n    System.out.println(\"Enter the base below: \");\n    int base = Integer.parseInt(br.readLine());\n    System.out.println();\n\n    System.out.println(\"Decimal Input\" + \" is: \" + decInput);\n    System.out.println(\n        \"Value of \" + decInput + \" in base \" + base + \" is: \" + convertToAnyBase(decInput, base));\n\n    br.close();\n  }\n\n  /**\n   * This method produces a String value of any given input decimal in any base\n   *\n   * @param inp Decimal of which we need the value in base in String format\n   * @return string format of the converted value in the given base\n   */\n  public static String convertToAnyBase(int inp, int base) {\n    ArrayList<Character> charArr = new ArrayList<>();\n\n    while (inp > 0) {\n      charArr.add(reVal(inp % base));\n      inp /= base;\n    }\n\n    StringBuilder str = new StringBuilder(charArr.size());\n\n    for (Character ch : charArr) {\n      str.append(ch);\n    }\n\n    return str.reverse().toString();\n  }\n\n  /**\n   * This method produces character value of the input integer and returns it\n   *\n   * @param num integer of which we need the character value of\n   * @return character value of input integer\n   */\n  public static char reVal(int num) {\n    if (num >= 0 && num <= 9) return (char) (num + '0');\n    else return (char) (num - 10 + 'A');\n  }\n}\n","index":7},{"title":"Decimal To Binary","category":"Conversions","id":"DecimalToBinary_Conversions","algorithm":"package Conversions;\n\nimport java.util.Scanner;\n\n/** This class converts a Decimal number to a Binary number */\nclass DecimalToBinary {\n\n  /**\n   * Main Method\n   *\n   * @param args Command Line Arguments\n   */\n  public static void main(String args[]) {\n    conventionalConversion();\n    bitwiseConversion();\n  }\n\n  /** This method converts a decimal number to a binary number using a conventional algorithm. */\n  public static void conventionalConversion() {\n    int n, b = 0, c = 0, d;\n    Scanner input = new Scanner(System.in);\n    System.out.printf(\"Conventional conversion.%n Enter the decimal number: \");\n    n = input.nextInt();\n    while (n != 0) {\n      d = n % 2;\n      b = b + d * (int) Math.pow(10, c++);\n      n /= 2;\n    } // converting decimal to binary\n    System.out.println(\"\\tBinary number: \" + b);\n    input.close();\n  }\n\n  /** This method converts a decimal number to a binary number using a bitwise algorithm */\n  public static void bitwiseConversion() {\n    int n, b = 0, c = 0, d;\n    Scanner input = new Scanner(System.in);\n    System.out.printf(\"Bitwise conversion.%n Enter the decimal number: \");\n    n = input.nextInt();\n    while (n != 0) {\n      d = (n & 1);\n      b += d * (int) Math.pow(10, c++);\n      n >>= 1;\n    }\n    System.out.println(\"\\tBinary number: \" + b);\n    input.close();\n  }\n}\n","index":8},{"title":"Decimal To Hexa Decimal","category":"Conversions","id":"DecimalToHexaDecimal_Conversions","algorithm":"package Conversions;\n\n// hex = [0 - 9] -> [A - F]\nclass DecimalToHexaDecimal {\n  private static final int sizeOfIntInHalfBytes = 8;\n  private static final int numberOfBitsInAHalfByte = 4;\n  private static final int halfByte = 0x0F;\n  private static final char[] hexDigits = {\n    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'\n  };\n\n  // Returns the hex value of the dec entered in the parameter.\n  public static String decToHex(int dec) {\n    StringBuilder hexBuilder = new StringBuilder(sizeOfIntInHalfBytes);\n    hexBuilder.setLength(sizeOfIntInHalfBytes);\n    for (int i = sizeOfIntInHalfBytes - 1; i >= 0; --i) {\n      int j = dec & halfByte;\n      hexBuilder.setCharAt(i, hexDigits[j]);\n      dec >>= numberOfBitsInAHalfByte;\n    }\n    return hexBuilder.toString().toLowerCase();\n  }\n\n  // Test above function.\n  public static void main(String[] args) {\n    System.out.println(\"Test...\");\n    int dec = 305445566;\n    String libraryDecToHex = Integer.toHexString(dec);\n    String decToHex = decToHex(dec);\n    System.out.println(\"Result from the library : \" + libraryDecToHex);\n    System.out.println(\"Result decToHex method : \" + decToHex);\n  }\n}\n","index":9},{"title":"Decimal To Octal","category":"Conversions","id":"DecimalToOctal_Conversions","algorithm":"package Conversions;\n\nimport java.util.Scanner;\n\n/** This class converts Decimal numbers to Octal Numbers */\npublic class DecimalToOctal {\n  /**\n   * Main Method\n   *\n   * @param args Command line Arguments\n   */\n\n  // enter in a decimal value to get Octal output\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n, k, d, s = 0, c = 0;\n    System.out.print(\"Decimal number: \");\n    n = sc.nextInt();\n    k = n;\n    while (k != 0) {\n      d = k % 8;\n      s += d * (int) Math.pow(10, c++);\n      k /= 8;\n    }\n\n    System.out.println(\"Octal equivalent:\" + s);\n    sc.close();\n  }\n}\n","index":10},{"title":"Hex To Oct","category":"Conversions","id":"HexToOct_Conversions","algorithm":"package Conversions;\n\nimport java.util.Scanner;\n\n/**\n * Converts any Hexadecimal Number to Octal\n *\n * @author Tanmay Joshi\n */\npublic class HexToOct {\n  /**\n   * This method converts a Hexadecimal number to a decimal number\n   *\n   * @param s The Hexadecimal Number\n   * @return The Decimal number\n   */\n  public static int hex2decimal(String s) {\n    String str = \"0123456789ABCDEF\";\n    s = s.toUpperCase();\n    int val = 0;\n    for (int i = 0; i < s.length(); i++) {\n      char a = s.charAt(i);\n      int n = str.indexOf(a);\n      val = 16 * val + n;\n    }\n    return val;\n  }\n\n  /**\n   * This method converts a Decimal number to a octal number\n   *\n   * @param q The Decimal Number\n   * @return The Octal number\n   */\n  public static int decimal2octal(int q) {\n    int now;\n    int i = 1;\n    int octnum = 0;\n    while (q > 0) {\n      now = q % 8;\n      octnum = (now * (int) (Math.pow(10, i))) + octnum;\n      q /= 8;\n      i++;\n    }\n    octnum /= 10;\n    return octnum;\n  }\n\n  /**\n   * Main method that gets the hex input from user and converts it into octal.\n   *\n   * @param args arguments\n   */\n  public static void main(String args[]) {\n    String hexadecnum;\n    int decnum, octalnum;\n    Scanner scan = new Scanner(System.in);\n\n    System.out.print(\"Enter Hexadecimal Number : \");\n    hexadecnum = scan.nextLine();\n\n    // first convert hexadecimal to decimal\n    decnum =\n        hex2decimal(\n            hexadecnum); // Pass the string to the hex2decimal function and get the decimal form in\n    // variable decnum\n\n    // convert decimal to octal\n    octalnum = decimal2octal(decnum);\n    System.out.println(\"Number in octal: \" + octalnum);\n    scan.close();\n  }\n}\n","index":11},{"title":"Hexa Decimal To Binary","category":"Conversions","id":"HexaDecimalToBinary_Conversions","algorithm":"package Conversions;\r\n\r\n// Hex [0-9],[A-F] -> Binary [0,1]\r\n\r\npublic class HexaDecimalToBinary {\r\n\r\n  private final int LONG_BITS = 8;\r\n\r\n  public void convert(String numHex) {\r\n    // String a HexaDecimal:\r\n    int conHex = Integer.parseInt(numHex, 16);\r\n    // Hex a Binary:\r\n    String binary = Integer.toBinaryString(conHex);\r\n    // Output:\r\n    System.out.println(numHex + \" = \" + completeDigits(binary));\r\n  }\r\n\r\n  public String completeDigits(String binNum) {\r\n    for (int i = binNum.length(); i < LONG_BITS; i++) {\r\n      binNum = \"0\" + binNum;\r\n    }\r\n    return binNum;\r\n  }\r\n\r\n  public static void main(String[] args) {\r\n\r\n    // Testing Numbers:\r\n    String[] hexNums = {\"1\", \"A1\", \"ef\", \"BA\", \"AA\", \"BB\", \"19\", \"01\", \"02\", \"03\", \"04\"};\r\n    HexaDecimalToBinary objConvert = new HexaDecimalToBinary();\r\n\r\n    for (String num : hexNums) {\r\n      objConvert.convert(num);\r\n    }\r\n  }\r\n}\r\n","index":12},{"title":"Hexa Decimal To Decimal","category":"Conversions","id":"HexaDecimalToDecimal_Conversions","algorithm":"package Conversions;\n\nimport java.util.Scanner;\n\npublic class HexaDecimalToDecimal {\n\n  // convert hexadecimal to decimal\n  public static int getHexaToDec(String hex) {\n    String digits = \"0123456789ABCDEF\";\n    hex = hex.toUpperCase();\n    int val = 0;\n    for (int i = 0; i < hex.length(); i++) {\n      int d = digits.indexOf(hex.charAt(i));\n      val = 16 * val + d;\n    }\n    return val;\n  }\n\n  // Main method gets the hexadecimal input from user and converts it into Decimal output.\n\n  public static void main(String args[]) {\n    String hexa_Input;\n    int dec_output;\n    Scanner scan = new Scanner(System.in);\n\n    System.out.print(\"Enter Hexadecimal Number : \");\n    hexa_Input = scan.nextLine();\n\n    // convert hexadecimal to decimal\n\n    dec_output = getHexaToDec(hexa_Input);\n    /*\n    Pass the string to the getHexaToDec function\n    and it returns the decimal form in the variable dec_output.\n    */\n    System.out.println(\"Number in Decimal: \" + dec_output);\n    scan.close();\n  }\n}\n","index":13},{"title":"Integer To Roman","category":"Conversions","id":"IntegerToRoman_Conversions","algorithm":"package Conversions;\n\n/**\n * Converting Integers into Roman Numerals\n *\n * <p>('I', 1); ('IV',4); ('V', 5); ('IV',9); ('X', 10); ('XL',40; ('L', 50); ('XC',90); ('C', 100);\n * ('D', 500); ('M', 1000);\n */\npublic class IntegerToRoman {\n  private static int[] allArabianRomanNumbers =\n      new int[] {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n  private static String[] allRomanNumbers =\n      new String[] {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\n\n  // Value must be > 0\n\n  public static String integerToRoman(int num) {\n    if (num <= 0) {\n      return \"\";\n    }\n\n    StringBuilder builder = new StringBuilder();\n\n    for (int a = 0; a < allArabianRomanNumbers.length; a++) {\n      int times = num / allArabianRomanNumbers[a];\n      for (int b = 0; b < times; b++) {\n        builder.append(allRomanNumbers[a]);\n      }\n\n      num -= times * allArabianRomanNumbers[a];\n    }\n\n    return builder.toString();\n  }\n\n  public static void main(String[] args) {\n    System.out.println(IntegerToRoman.integerToRoman(2131));\n  }\n}\n","index":14},{"title":"Octal To Decimal","category":"Conversions","id":"OctalToDecimal_Conversions","algorithm":"package Conversions;\n\nimport java.util.Scanner;\n\n/**\n * Converts any Octal Number to a Decimal Number\n *\n * @author Zachary Jones\n */\npublic class OctalToDecimal {\n\n  /**\n   * Main method\n   *\n   * @param args Command line arguments\n   */\n  public static void main(String args[]) {\n    Scanner sc = new Scanner(System.in);\n    System.out.print(\"Octal Input: \");\n    String inputOctal = sc.nextLine();\n    int result = convertOctalToDecimal(inputOctal);\n    if (result != -1) System.out.println(\"Result convertOctalToDecimal : \" + result);\n    sc.close();\n  }\n\n  /**\n   * This method converts an octal number to a decimal number.\n   *\n   * @param inputOctal The octal number\n   * @return The decimal number\n   */\n  public static int convertOctalToDecimal(String inputOctal) {\n\n    try {\n      // Actual conversion of Octal to Decimal:\n      Integer outputDecimal = Integer.parseInt(inputOctal, 8);\n      return outputDecimal;\n    } catch (NumberFormatException ne) {\n      // Printing a warning message if the input is not a valid octal\n      // number:\n      System.out.println(\"Invalid Input, Expecting octal number 0-7\");\n      return -1;\n    }\n  }\n}\n","index":15},{"title":"Octal To Hexadecimal","category":"Conversions","id":"OctalToHexadecimal_Conversions","algorithm":"package Conversions;\n\nimport java.util.Scanner;\n\n/**\n * Converts any Octal Number to HexaDecimal\n *\n * @author Tanmay Joshi\n */\npublic class OctalToHexadecimal {\n\n  /**\n   * This method converts a Octal number to a decimal number\n   *\n   * @param s The Octal Number\n   * @return The Decimal number\n   */\n  public static int octToDec(String s) {\n    int i = 0;\n    for (int j = 0; j < s.length(); j++) {\n      char num = s.charAt(j);\n      num -= '0';\n      i *= 8;\n      i += num;\n    }\n    return i;\n  }\n\n  /**\n   * This method converts a Decimal number to a Hexadecimal number\n   *\n   * @param d The Decimal Number\n   * @return The Hexadecimal number\n   */\n  public static String decimalToHex(int d) {\n    String digits = \"0123456789ABCDEF\";\n    if (d <= 0) return \"0\";\n    String hex = \"\";\n    while (d > 0) {\n      int digit = d % 16;\n      hex = digits.charAt(digit) + hex;\n      d = d / 16;\n    }\n    return hex;\n  }\n\n  public static void main(String args[]) {\n\n    Scanner input = new Scanner(System.in);\n    System.out.print(\"Enter the Octal number: \");\n    // Take octal number as input from user in a string\n    String oct = input.next();\n\n    // Pass the octal number to function and get converted deciaml form\n    int decimal = octToDec(oct);\n\n    // Pass the decimla number to function and get converted Hex form of the number\n    String hex = decimalToHex(decimal);\n    System.out.println(\"The Hexadecimal equivalant is: \" + hex);\n    input.close();\n  }\n}\n","index":16},{"title":"Roman To Integer","category":"Conversions","id":"RomanToInteger_Conversions","algorithm":"package Conversions;\n\nimport java.util.*;\n\npublic class RomanToInteger {\n\n  private static Map<Character, Integer> map =\n      new HashMap<Character, Integer>() {\n        /** */\n        private static final long serialVersionUID = 87605733047260530L;\n\n        {\n          put('I', 1);\n          put('V', 5);\n          put('X', 10);\n          put('L', 50);\n          put('C', 100);\n          put('D', 500);\n          put('M', 1000);\n        }\n      };\n  // Roman Number = Roman Numerals\n\n  /**\n   * This function convert Roman number into Integer\n   *\n   * @param A Roman number string\n   * @return integer\n   */\n  public static int romanToInt(String A) {\n\n    A = A.toUpperCase();\n    char prev = ' ';\n\n    int sum = 0;\n\n    int newPrev = 0;\n    for (int i = A.length() - 1; i >= 0; i--) {\n      char c = A.charAt(i);\n\n      if (prev != ' ') {\n        // checking current Number greater then previous or not\n        newPrev = map.get(prev) > newPrev ? map.get(prev) : newPrev;\n      }\n\n      int currentNum = map.get(c);\n\n      // if current number greater then prev max previous then add\n      if (currentNum >= newPrev) {\n        sum += currentNum;\n      } else {\n        // subtract upcoming number until upcoming number not greater then prev max\n        sum -= currentNum;\n      }\n\n      prev = c;\n    }\n\n    return sum;\n  }\n\n  public static void main(String[] args) {\n    int sum = romanToInt(\"MDCCCIV\");\n    System.out.println(sum);\n  }\n}\n","index":17},{"title":"Data Structures","category":null,"id":"DataStructures","index":18},{"title":"Bags","category":"DataStructures","id":"Bags","index":19},{"title":"Bag","category":"Bags","id":"Bag_Bags","algorithm":"package DataStructures.Bags;\n\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\n\n/**\n * Collection which does not allow removing elements (only collect and iterate)\n *\n * @param <Element> - the generic type of an element in this bag\n */\npublic class Bag<Element> implements Iterable<Element> {\n\n  private Node<Element> firstElement; // first element of the bag\n  private int size; // size of bag\n\n  private static class Node<Element> {\n    private Element content;\n    private Node<Element> nextElement;\n  }\n\n  /** Create an empty bag */\n  public Bag() {\n    firstElement = null;\n    size = 0;\n  }\n\n  /** @return true if this bag is empty, false otherwise */\n  public boolean isEmpty() {\n    return firstElement == null;\n  }\n\n  /** @return the number of elements */\n  public int size() {\n    return size;\n  }\n\n  /** @param element - the element to add */\n  public void add(Element element) {\n    Node<Element> oldfirst = firstElement;\n    firstElement = new Node<>();\n    firstElement.content = element;\n    firstElement.nextElement = oldfirst;\n    size++;\n  }\n\n  /**\n   * Checks if the bag contains a specific element\n   *\n   * @param element which you want to look for\n   * @return true if bag contains element, otherwise false\n   */\n  public boolean contains(Element element) {\n    Iterator<Element> iterator = this.iterator();\n    while (iterator.hasNext()) {\n      if (iterator.next().equals(element)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /** @return an iterator that iterates over the elements in this bag in arbitrary order */\n  public Iterator<Element> iterator() {\n    return new ListIterator<>(firstElement);\n  }\n\n  @SuppressWarnings(\"hiding\")\n  private class ListIterator<Element> implements Iterator<Element> {\n    private Node<Element> currentElement;\n\n    public ListIterator(Node<Element> firstElement) {\n      currentElement = firstElement;\n    }\n\n    public boolean hasNext() {\n      return currentElement != null;\n    }\n\n    /** remove is not allowed in a bag */\n    @Override\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n\n    public Element next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      Element element = currentElement.content;\n      currentElement = currentElement.nextElement;\n      return element;\n    }\n  }\n\n  /** main-method for testing */\n  public static void main(String[] args) {\n    Bag<String> bag = new Bag<>();\n\n    bag.add(\"1\");\n    bag.add(\"1\");\n    bag.add(\"2\");\n\n    System.out.println(\"size of bag = \" + bag.size());\n    for (String s : bag) {\n      System.out.println(s);\n    }\n\n    System.out.println(bag.contains(null));\n    System.out.println(bag.contains(\"1\"));\n    System.out.println(bag.contains(\"3\"));\n  }\n}\n","index":20},{"title":"Buffers","category":"DataStructures","id":"Buffers","index":21},{"title":"Circular Buffer","category":"Buffers","id":"CircularBuffer_Buffers","algorithm":"package DataStructures.Buffers;\n\nimport java.util.Random;\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class CircularBuffer {\n  private char[] _buffer;\n  public final int _buffer_size;\n  private int _write_index = 0;\n  private int _read_index = 0;\n  private AtomicInteger _readable_data = new AtomicInteger(0);\n\n  public CircularBuffer(int buffer_size) {\n    if (!IsPowerOfTwo(buffer_size)) {\n      throw new IllegalArgumentException();\n    }\n    this._buffer_size = buffer_size;\n    _buffer = new char[buffer_size];\n  }\n\n  private boolean IsPowerOfTwo(int i) {\n    return (i & (i - 1)) == 0;\n  }\n\n  private int getTrueIndex(int i) {\n    return i % _buffer_size;\n  }\n\n  public Character readOutChar() {\n    Character result = null;\n\n    // if we have data to read\n    if (_readable_data.get() > 0) {\n\n      result = Character.valueOf(_buffer[getTrueIndex(_read_index)]);\n      _readable_data.decrementAndGet();\n      _read_index++;\n    }\n\n    return result;\n  }\n\n  public boolean writeToCharBuffer(char c) {\n    boolean result = false;\n\n    // if we can write to the buffer\n    if (_readable_data.get() < _buffer_size) {\n      // write to buffer\n      _buffer[getTrueIndex(_write_index)] = c;\n      _readable_data.incrementAndGet();\n      _write_index++;\n      result = true;\n    }\n\n    return result;\n  }\n\n  private static class TestWriteWorker implements Runnable {\n    String _alphabet = \"abcdefghijklmnopqrstuvwxyz0123456789\";\n    Random _random = new Random();\n    CircularBuffer _buffer;\n\n    public TestWriteWorker(CircularBuffer cb) {\n      this._buffer = cb;\n    }\n\n    private char getRandomChar() {\n      return _alphabet.charAt(_random.nextInt(_alphabet.length()));\n    }\n\n    public void run() {\n      while (!Thread.interrupted()) {\n        if (!_buffer.writeToCharBuffer(getRandomChar())) {\n          Thread.yield();\n          try {\n            Thread.sleep(10);\n          } catch (InterruptedException e) {\n            return;\n          }\n        }\n      }\n    }\n  }\n\n  private static class TestReadWorker implements Runnable {\n    CircularBuffer _buffer;\n\n    public TestReadWorker(CircularBuffer cb) {\n      this._buffer = cb;\n    }\n\n    @Override\n    public void run() {\n      System.out.println(\"Printing Buffer:\");\n      while (!Thread.interrupted()) {\n        Character c = _buffer.readOutChar();\n        if (c != null) {\n          System.out.print(c.charValue());\n        } else {\n          Thread.yield();\n          try {\n            Thread.sleep(10);\n          } catch (InterruptedException e) {\n            System.out.println();\n            return;\n          }\n        }\n      }\n    }\n  }\n\n  public static void main(String[] args) throws InterruptedException {\n    int buffer_size = 1024;\n    // create circular buffer\n    CircularBuffer cb = new CircularBuffer(buffer_size);\n\n    // create threads that read and write the buffer.\n    Thread write_thread = new Thread(new TestWriteWorker(cb));\n    Thread read_thread = new Thread(new TestReadWorker(cb));\n    read_thread.start();\n    write_thread.start();\n\n    // wait some amount of time\n    Thread.sleep(10000);\n\n    // interrupt threads and exit\n    write_thread.interrupt();\n    read_thread.interrupt();\n  }\n}\n","index":22},{"title":"Dynamic Array","category":"DataStructures","id":"DynamicArray","index":23},{"title":"Dynamic Array","category":"DynamicArray","id":"DynamicArray_DynamicArray","algorithm":"package DataStructures.DynamicArray;\n\nimport java.util.*;\nimport java.util.function.Consumer;\nimport java.util.stream.Stream;\nimport java.util.stream.StreamSupport;\n\n/**\n * This class implements a dynamic array\n *\n * @param <E> the type that each index of the array will hold\n */\npublic class DynamicArray<E> implements Iterable<E> {\n\n  private int capacity;\n  private int size;\n  private Object[] elements;\n\n  /**\n   * constructor\n   *\n   * @param capacity the starting length of the desired array\n   */\n  public DynamicArray(final int capacity) {\n    this.size = 0;\n    this.capacity = capacity;\n    this.elements = new Object[this.capacity];\n  }\n\n  /** No-args constructor */\n  public DynamicArray() {\n    this.size = 0;\n    this.capacity = 10;\n    this.elements = new Object[this.capacity];\n  }\n\n  /**\n   * Doubles the capacity of the array\n   *\n   * @return int the new capacity of the array\n   */\n  public int newCapacity() {\n    this.capacity *= 2;\n    // changed from this.capacity <<= 1; now much easier to understand\n    return this.capacity;\n  }\n\n  /**\n   * Adds an element to the array If full, creates a copy array twice the size of the current one\n   *\n   * @param element the element of type <E> to be added to the array\n   */\n  public void add(final E element) {\n    if (this.size == this.elements.length) {\n      this.elements = Arrays.copyOf(this.elements, newCapacity());\n    }\n\n    this.elements[this.size] = element;\n    size++;\n  }\n\n  /**\n   * Places element of type <E> at the desired index\n   *\n   * @param index the index for the element to be placed\n   * @param element the element to be inserted\n   */\n  public void put(final int index, E element) {\n    this.elements[index] = element;\n  }\n\n  /**\n   * get method for element at a given index returns null if the index is empty\n   *\n   * @param index the desired index of the element\n   * @return <E> the element at the specified index\n   */\n  public E get(final int index) {\n    return getElement(index);\n  }\n\n  /**\n   * Removes an element from the array\n   *\n   * @param index the index of the element to be removed\n   * @return <E> the element removed\n   */\n  public E remove(final int index) {\n    final E oldElement = getElement(index);\n    fastRemove(this.elements, index);\n\n    return oldElement;\n  }\n\n  /**\n   * get method for size field\n   *\n   * @return int size\n   */\n  public int getSize() {\n    return this.size;\n  }\n\n  /**\n   * isEmpty helper method\n   *\n   * @return boolean true if the array contains no elements, false otherwise\n   */\n  public boolean isEmpty() {\n    return this.size == 0;\n  }\n\n  public Stream<E> stream() {\n    return StreamSupport.stream(spliterator(), false);\n  }\n\n  private void fastRemove(final Object[] elements, final int index) {\n    final int newSize = this.size - 1;\n\n    if (newSize > index) {\n      System.arraycopy(elements, index + 1, elements, index, newSize - index);\n    }\n\n    elements[this.size = newSize] = null;\n  }\n\n  private E getElement(final int index) {\n    return (E) this.elements[index];\n  }\n\n  /**\n   * returns a String representation of this object\n   *\n   * @return String a String representing the array\n   */\n  @Override\n  public String toString() {\n    return Arrays.toString(Arrays.stream(this.elements).filter(Objects::nonNull).toArray());\n  }\n\n  /**\n   * Creates and returns a new Dynamic Array Iterator\n   *\n   * @return Iterator a Dynamic Array Iterator\n   */\n  @Override\n  public Iterator iterator() {\n    return new DynamicArrayIterator();\n  }\n\n  private class DynamicArrayIterator implements Iterator<E> {\n\n    private int cursor;\n\n    @Override\n    public boolean hasNext() {\n      return this.cursor != size;\n    }\n\n    @Override\n    public E next() {\n      if (this.cursor > DynamicArray.this.size) throw new NoSuchElementException();\n\n      if (this.cursor > DynamicArray.this.elements.length)\n        throw new ConcurrentModificationException();\n\n      final E element = DynamicArray.this.getElement(this.cursor);\n      this.cursor++;\n\n      return element;\n    }\n\n    @Override\n    public void remove() {\n      if (this.cursor < 0) throw new IllegalStateException();\n\n      DynamicArray.this.remove(this.cursor);\n      this.cursor--;\n    }\n\n    @Override\n    public void forEachRemaining(Consumer<? super E> action) {\n      Objects.requireNonNull(action);\n\n      for (int i = 0; i < DynamicArray.this.size; i++) {\n        action.accept(DynamicArray.this.getElement(i));\n      }\n    }\n  }\n\n  /**\n   * This class is the driver for the DynamicArray<E> class it tests a variety of methods and prints\n   * the output\n   */\n  public static void main(String[] args) {\n    DynamicArray<String> names = new DynamicArray<>();\n    names.add(\"Peubes\");\n    names.add(\"Marley\");\n\n    for (String name : names) {\n      System.out.println(name);\n    }\n\n    names.stream().forEach(System.out::println);\n\n    System.out.println(names);\n\n    System.out.println(names.getSize());\n\n    names.remove(0);\n\n    for (String name : names) {\n      System.out.println(name);\n    }\n  }\n}\n","index":24},{"title":"Graphs","category":"DataStructures","id":"Graphs","index":25},{"title":"A_ Star","category":"Graphs","id":"A_Star_Graphs","algorithm":"/*\n\tTime Complexity = O(E), where E is equal to the number of edges\n*/\n\npackage A_Star;\n\nimport java.util.*;\n\npublic class A_Star {\n\n  private static class Graph {\n    // Graph's structure can be changed only applying changes to this class.\n    private ArrayList<Edge>[] graph;\n\n    // Initialise ArrayLists in Constructor\n    public Graph(int size) {\n      this.graph = new ArrayList[size];\n      for (int i = 0; i < size; i++) {\n        this.graph[i] = new ArrayList<>();\n      }\n    }\n\n    private ArrayList<Edge> getNeighbours(int from) {\n      return this.graph[from];\n    }\n\n    // Graph is bidirectional, for just one direction remove second instruction of this method.\n    private void addEdge(Edge edge) {\n      this.graph[edge.getFrom()].add(new Edge(edge.getFrom(), edge.getTo(), edge.getWeight()));\n      this.graph[edge.getTo()].add(new Edge(edge.getTo(), edge.getFrom(), edge.getWeight()));\n    }\n  }\n\n  private static class Edge {\n    private int from;\n    private int to;\n    private int weight;\n\n    public Edge(int from, int to, int weight) {\n      this.from = from;\n      this.to = to;\n      this.weight = weight;\n    }\n\n    public int getFrom() {\n      return from;\n    }\n\n    public int getTo() {\n      return to;\n    }\n\n    public int getWeight() {\n      return weight;\n    }\n  }\n\n  // class to iterate during the algorithm execution, and also used to return the solution.\n  private static class PathAndDistance {\n    private int distance; // distance advanced so far.\n    private ArrayList<Integer> path; // list of visited nodes in this path.\n    private int\n        estimated; // heuristic value associated to the last node od the path (current node).\n\n    public PathAndDistance(int distance, ArrayList<Integer> path, int estimated) {\n      this.distance = distance;\n      this.path = path;\n      this.estimated = estimated;\n    }\n\n    public int getDistance() {\n      return distance;\n    }\n\n    public ArrayList<Integer> getPath() {\n      return path;\n    }\n\n    public int getEstimated() {\n      return estimated;\n    }\n\n    private void printSolution() {\n      if (this.path != null)\n        System.out.println(\n            \"Optimal path: \" + this.path.toString() + \", distance: \" + this.distance);\n      else System.out.println(\"There is no path available to connect the points\");\n    }\n  }\n\n  private static void initializeGraph(Graph graph, ArrayList<Integer> data) {\n    for (int i = 0; i < data.size(); i += 4) {\n      graph.addEdge(new Edge(data.get(i), data.get(i + 1), data.get(i + 2)));\n    }\n    /*\n    .x. node\n    (y) cost\n    - or | or / bidirectional connection\n\n                          ( 98)- .7. -(86)- .4.\n                            |\n                    ( 85)- .17. -(142)- .18. -(92)- .8. -(87)- .11.\n                      |\n                     . 1. -------------------- (160)\n                      |  \\                       |\n                    (211) \\                     .6.\n                      |    \\                     |\n                     . 5.  (101)-.13. -(138)   (115)\n                      |           |     |     /\n                    ( 99)       ( 97)   |    /\n                      |           |     |   /\n        .12. -(151)- .15. -(80)- .14.   |  /\n         |            |           |     | /\n       ( 71)        (140)       (146)- .2. -(120)\n         |            |                       |\n        .19. -( 75)- . 0.        .10. -(75)- .3.\n                      |            |\n                    (118)        ( 70)\n                      |            |\n                     .16. -(111)- .9.\n     */\n  }\n\n  public static void main(String[] args) {\n    // heuristic function optimistic values\n    int[] heuristic = {\n      366, 0, 160, 242, 161, 178, 77, 151, 226, 244, 241, 234, 380, 98, 193, 253, 329, 80, 199, 374\n    };\n\n    Graph graph = new Graph(20);\n    ArrayList<Integer> graphData =\n        new ArrayList<>(\n            Arrays.asList(\n                0, 19, 75, null, 0, 15, 140, null, 0, 16, 118, null, 19, 12, 71, null, 12, 15, 151,\n                null, 16, 9, 111, null, 9, 10, 70, null, 10, 3, 75, null, 3, 2, 120, null, 2, 14,\n                146, null, 2, 13, 138, null, 2, 6, 115, null, 15, 14, 80, null, 15, 5, 99, null, 14,\n                13, 97, null, 5, 1, 211, null, 13, 1, 101, null, 6, 1, 160, null, 1, 17, 85, null,\n                17, 7, 98, null, 7, 4, 86, null, 17, 18, 142, null, 18, 8, 92, null, 8, 11, 87));\n    initializeGraph(graph, graphData);\n\n    PathAndDistance solution = aStar(3, 1, graph, heuristic);\n    solution.printSolution();\n  }\n\n  public static PathAndDistance aStar(int from, int to, Graph graph, int[] heuristic) {\n    // nodes are prioritised by the less value of the current distance of their paths, and the\n    // estimated value\n    // given by the heuristic function to reach the destination point from the current point.\n    PriorityQueue<PathAndDistance> queue =\n        new PriorityQueue<>(Comparator.comparingInt(a -> (a.getDistance() + a.getEstimated())));\n\n    // dummy data to start the algorithm from the beginning point\n    queue.add(new PathAndDistance(0, new ArrayList<>(Arrays.asList(from)), 0));\n\n    boolean solutionFound = false;\n    PathAndDistance currentData = new PathAndDistance(-1, null, -1);\n    while (!queue.isEmpty() && !solutionFound) {\n      currentData = queue.poll(); // first in the queue, best node so keep exploring.\n      int currentPosition =\n          currentData.getPath().get(currentData.getPath().size() - 1); // current node.\n      if (currentPosition == to) solutionFound = true;\n      else\n        for (Edge edge : graph.getNeighbours(currentPosition))\n          if (!currentData.getPath().contains(edge.getTo())) { // Avoid Cycles\n            ArrayList<Integer> updatedPath = new ArrayList<>(currentData.getPath());\n            updatedPath.add(edge.getTo()); // Add the new node to the path, update the distance,\n            // and the heuristic function value associated to that path.\n            queue.add(\n                new PathAndDistance(\n                    currentData.getDistance() + edge.getWeight(),\n                    updatedPath,\n                    heuristic[edge.getTo()]));\n          }\n    }\n    return (solutionFound) ? currentData : new PathAndDistance(-1, null, -1);\n    // Out of while loop, if there is a solution, the current Data stores the optimal path, and its\n    // distance\n  }\n}\n","index":26},{"title":"Bellman Ford","category":"Graphs","id":"BellmanFord_Graphs","algorithm":"package DataStructures.Graphs;\n\nimport java.util.*;\n\nclass BellmanFord\n/*Implementation of Bellman ford to detect negative cycles. Graph accepts inputs in form of edges which have\nstart vertex, end vertes and weights. Vertices should be labelled with a number between 0 and total number of vertices-1,both inclusive*/\n{\n  int vertex, edge;\n  private Edge edges[];\n  private int index = 0;\n\n  BellmanFord(int v, int e) {\n    vertex = v;\n    edge = e;\n    edges = new Edge[e];\n  }\n\n  class Edge {\n    int u, v;\n    int w;\n    /**\n     * @param u Source Vertex\n     * @param v End vertex\n     * @param c Weight\n     */\n    public Edge(int a, int b, int c) {\n      u = a;\n      v = b;\n      w = c;\n    }\n  }\n  /**\n   * @param p[] Parent array which shows updates in edges\n   * @param i Current vertex under consideration\n   */\n  void printPath(int p[], int i) {\n    if (p[i] == -1) // Found the path back to parent\n    return;\n    printPath(p, p[i]);\n    System.out.print(i + \" \");\n  }\n\n  public static void main(String args[]) {\n    BellmanFord obj = new BellmanFord(0, 0); // Dummy object to call nonstatic variables\n    obj.go();\n  }\n\n  public void\n      go() // Interactive run for understanding the class first time. Assumes source vertex is 0 and\n        // shows distaance to all vertices\n      {\n    Scanner sc = new Scanner(System.in); // Grab scanner object for user input\n    int i, v, e, u, ve, w, j, neg = 0;\n    System.out.println(\"Enter no. of vertices and edges please\");\n    v = sc.nextInt();\n    e = sc.nextInt();\n    Edge arr[] = new Edge[e]; // Array of edges\n    System.out.println(\"Input edges\");\n    for (i = 0; i < e; i++) {\n      u = sc.nextInt();\n      ve = sc.nextInt();\n      w = sc.nextInt();\n      arr[i] = new Edge(u, ve, w);\n    }\n    int dist[] =\n        new int\n            [v]; // Distance array for holding the finalized shortest path distance between source\n    // and all vertices\n    int p[] = new int[v]; // Parent array for holding the paths\n    for (i = 0; i < v; i++) dist[i] = Integer.MAX_VALUE; // Initializing distance values\n    dist[0] = 0;\n    p[0] = -1;\n    for (i = 0; i < v - 1; i++) {\n      for (j = 0; j < e; j++) {\n        if ((int) dist[arr[j].u] != Integer.MAX_VALUE\n            && dist[arr[j].v] > dist[arr[j].u] + arr[j].w) {\n          dist[arr[j].v] = dist[arr[j].u] + arr[j].w; // Update\n          p[arr[j].v] = arr[j].u;\n        }\n      }\n    }\n    // Final cycle for negative checking\n    for (j = 0; j < e; j++)\n      if ((int) dist[arr[j].u] != Integer.MAX_VALUE && dist[arr[j].v] > dist[arr[j].u] + arr[j].w) {\n        neg = 1;\n        System.out.println(\"Negative cycle\");\n        break;\n      }\n    if (neg == 0) // Go ahead and show results of computaion\n    {\n      System.out.println(\"Distances are: \");\n      for (i = 0; i < v; i++) System.out.println(i + \" \" + dist[i]);\n      System.out.println(\"Path followed:\");\n      for (i = 0; i < v; i++) {\n        System.out.print(\"0 \");\n        printPath(p, i);\n        System.out.println();\n      }\n    }\n    sc.close();\n  }\n  /**\n   * @param source Starting vertex\n   * @param end Ending vertex\n   * @param Edge Array of edges\n   */\n  public void show(\n      int source,\n      int end,\n      Edge arr[]) // Just shows results of computation, if graph is passed to it. The graph should\n        // be created by using addEdge() method and passed by calling getEdgeArray() method\n      {\n    int i, j, v = vertex, e = edge, neg = 0;\n    double dist[] =\n        new double\n            [v]; // Distance array for holding the finalized shortest path distance between source\n    // and all vertices\n    int p[] = new int[v]; // Parent array for holding the paths\n    for (i = 0; i < v; i++) dist[i] = Integer.MAX_VALUE; // Initializing distance values\n    dist[source] = 0;\n    p[source] = -1;\n    for (i = 0; i < v - 1; i++) {\n      for (j = 0; j < e; j++) {\n        if ((int) dist[arr[j].u] != Integer.MAX_VALUE\n            && dist[arr[j].v] > dist[arr[j].u] + arr[j].w) {\n          dist[arr[j].v] = dist[arr[j].u] + arr[j].w; // Update\n          p[arr[j].v] = arr[j].u;\n        }\n      }\n    }\n    // Final cycle for negative checking\n    for (j = 0; j < e; j++)\n      if ((int) dist[arr[j].u] != Integer.MAX_VALUE && dist[arr[j].v] > dist[arr[j].u] + arr[j].w) {\n        neg = 1;\n        System.out.println(\"Negative cycle\");\n        break;\n      }\n    if (neg == 0) // Go ahead and show results of computaion\n    {\n      System.out.println(\"Distance is: \" + dist[end]);\n      System.out.println(\"Path followed:\");\n      System.out.print(source + \" \");\n      printPath(p, end);\n      System.out.println();\n    }\n  }\n  /**\n   * @param x Source Vertex\n   * @param y End vertex\n   * @param z Weight\n   */\n  public void addEdge(int x, int y, int z) // Adds unidirectionl Edge\n      {\n    edges[index++] = new Edge(x, y, z);\n  }\n\n  public Edge[] getEdgeArray() {\n    return edges;\n  }\n}\n","index":27},{"title":"Connected Component","category":"Graphs","id":"ConnectedComponent_Graphs","algorithm":"package DataStructures.Graphs;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.HashSet;\r\nimport java.util.Set;\r\n\r\n/**\r\n * A class that counts the number of different connected components in a graph\r\n *\r\n * @author Lukas Keul, Florian Mercks\r\n */\r\nclass Graph<E extends Comparable<E>> {\r\n\r\n  class Node {\r\n    E name;\r\n\r\n    public Node(E name) {\r\n      this.name = name;\r\n    }\r\n  }\r\n\r\n  class Edge {\r\n    Node startNode, endNode;\r\n\r\n    public Edge(Node startNode, Node endNode) {\r\n      this.startNode = startNode;\r\n      this.endNode = endNode;\r\n    }\r\n  }\r\n\r\n  ArrayList<Edge> edgeList;\r\n  ArrayList<Node> nodeList;\r\n\r\n  public Graph() {\r\n    edgeList = new ArrayList<Edge>();\r\n    nodeList = new ArrayList<Node>();\r\n  }\r\n\r\n  /**\r\n   * Adds a new Edge to the graph. If the nodes aren't yet in nodeList, they will be added to it.\r\n   *\r\n   * @param startNode the starting Node from the edge\r\n   * @param endNode the ending Node from the edge\r\n   */\r\n  public void addEdge(E startNode, E endNode) {\r\n    Node start = null, end = null;\r\n    for (Node node : nodeList) {\r\n      if (startNode.compareTo(node.name) == 0) {\r\n        start = node;\r\n      } else if (endNode.compareTo(node.name) == 0) {\r\n        end = node;\r\n      }\r\n    }\r\n    if (start == null) {\r\n      start = new Node(startNode);\r\n      nodeList.add(start);\r\n    }\r\n    if (end == null) {\r\n      end = new Node(endNode);\r\n      nodeList.add(end);\r\n    }\r\n\r\n    edgeList.add(new Edge(start, end));\r\n  }\r\n\r\n  /**\r\n   * Main method used for counting the connected components. Iterates through the array of nodes to\r\n   * do a depth first search to get all nodes of the graph from the actual node. These nodes are\r\n   * added to the array markedNodes and will be ignored if they are chosen in the nodeList.\r\n   *\r\n   * @return returns the amount of unconnected graphs\r\n   */\r\n  public int countGraphs() {\r\n    int count = 0;\r\n    Set<Node> markedNodes = new HashSet<Node>();\r\n\r\n    for (Node n : nodeList) {\r\n      if (!markedNodes.contains(n)) {\r\n        markedNodes.add(n);\r\n        markedNodes.addAll(depthFirstSearch(n, new ArrayList<Node>()));\r\n        count++;\r\n      }\r\n    }\r\n\r\n    return count;\r\n  }\r\n\r\n  /**\r\n   * Implementation of depth first search.\r\n   *\r\n   * @param n the actual visiting node\r\n   * @param visited A list of already visited nodes in the depth first search\r\n   * @return returns a set of visited nodes\r\n   */\r\n  public ArrayList<Node> depthFirstSearch(Node n, ArrayList<Node> visited) {\r\n    visited.add(n);\r\n    for (Edge e : edgeList) {\r\n      if (e.startNode.equals(n) && !visited.contains(e.endNode)) {\r\n        depthFirstSearch(e.endNode, visited);\r\n      }\r\n    }\r\n    return visited;\r\n  }\r\n}\r\n\r\npublic class ConnectedComponent {\r\n\r\n  public static void main(String[] args) {\r\n    Graph<Character> graphChars = new Graph<>();\r\n\r\n    // Graph 1\r\n    graphChars.addEdge('a', 'b');\r\n    graphChars.addEdge('a', 'e');\r\n    graphChars.addEdge('b', 'e');\r\n    graphChars.addEdge('b', 'c');\r\n    graphChars.addEdge('c', 'd');\r\n    graphChars.addEdge('d', 'a');\r\n\r\n    graphChars.addEdge('x', 'y');\r\n    graphChars.addEdge('x', 'z');\r\n\r\n    graphChars.addEdge('w', 'w');\r\n\r\n    Graph<Integer> graphInts = new Graph<>();\r\n\r\n    // Graph 2\r\n    graphInts.addEdge(1, 2);\r\n    graphInts.addEdge(2, 3);\r\n    graphInts.addEdge(2, 4);\r\n    graphInts.addEdge(3, 5);\r\n\r\n    graphInts.addEdge(7, 8);\r\n    graphInts.addEdge(8, 10);\r\n    graphInts.addEdge(10, 8);\r\n\r\n    System.out.println(\"Amount of different char-graphs: \" + graphChars.countGraphs());\r\n    System.out.println(\"Amount of different int-graphs: \" + graphInts.countGraphs());\r\n  }\r\n}\r\n","index":28},{"title":"Cycles","category":"Graphs","id":"Cycles_Graphs","algorithm":"package DataStructures.Graphs;\n\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\nclass Cycle {\n\n  private int nodes, edges;\n  private int[][] adjacencyMatrix;\n  private boolean[] visited;\n  ArrayList<ArrayList<Integer>> cycles = new ArrayList<ArrayList<Integer>>();\n\n  public Cycle() {\n    Scanner in = new Scanner(System.in);\n    System.out.print(\"Enter the no. of nodes: \");\n    nodes = in.nextInt();\n    System.out.print(\"Enter the no. of Edges: \");\n    edges = in.nextInt();\n\n    adjacencyMatrix = new int[nodes][nodes];\n    visited = new boolean[nodes];\n\n    for (int i = 0; i < nodes; i++) {\n      visited[i] = false;\n    }\n\n    System.out.println(\"Enter the details of each edges <Start Node> <End Node>\");\n\n    for (int i = 0; i < edges; i++) {\n      int start, end;\n      start = in.nextInt();\n      end = in.nextInt();\n      adjacencyMatrix[start][end] = 1;\n    }\n    in.close();\n  }\n\n  public void start() {\n    for (int i = 0; i < nodes; i++) {\n      ArrayList<Integer> temp = new ArrayList<>();\n      dfs(i, i, temp);\n      for (int j = 0; j < nodes; j++) {\n        adjacencyMatrix[i][j] = 0;\n        adjacencyMatrix[j][i] = 0;\n      }\n    }\n  }\n\n  private void dfs(Integer start, Integer curr, ArrayList<Integer> temp) {\n    temp.add(curr);\n    visited[curr] = true;\n    for (int i = 0; i < nodes; i++) {\n      if (adjacencyMatrix[curr][i] == 1) {\n        if (i == start) {\n          cycles.add(new ArrayList<Integer>(temp));\n        } else {\n          if (!visited[i]) {\n            dfs(start, i, temp);\n          }\n        }\n      }\n    }\n\n    if (temp.size() > 0) {\n      temp.remove(temp.size() - 1);\n    }\n    visited[curr] = false;\n  }\n\n  public void printAll() {\n    for (int i = 0; i < cycles.size(); i++) {\n      for (int j = 0; j < cycles.get(i).size(); j++) {\n        System.out.print(cycles.get(i).get(j) + \" -> \");\n      }\n      System.out.println(cycles.get(i).get(0));\n      System.out.println();\n    }\n  }\n}\n\npublic class Cycles {\n  public static void main(String[] args) {\n    Cycle c = new Cycle();\n    c.start();\n    c.printAll();\n  }\n}\n","index":29},{"title":"Floyd Warshall","category":"Graphs","id":"FloydWarshall_Graphs","algorithm":"package DataStructures.Graphs;\n\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class FloydWarshall {\n  private int DistanceMatrix[][];\n  private int numberofvertices; // number of vertices in the graph\n  public static final int INFINITY = 999;\n\n  public FloydWarshall(int numberofvertices) {\n    DistanceMatrix =\n        new int[numberofvertices + 1]\n            [numberofvertices\n                + 1]; // stores the value of distance from all the possible path form the source\n    // vertex to destination vertex\n    Arrays.fill(DistanceMatrix, 0);\n    this.numberofvertices = numberofvertices;\n  }\n\n  public void floydwarshall(\n      int AdjacencyMatrix[][]) // calculates all the distances from source to destination vertex\n      {\n    for (int source = 1; source <= numberofvertices; source++) {\n      for (int destination = 1; destination <= numberofvertices; destination++) {\n        DistanceMatrix[source][destination] = AdjacencyMatrix[source][destination];\n      }\n    }\n    for (int intermediate = 1; intermediate <= numberofvertices; intermediate++) {\n      for (int source = 1; source <= numberofvertices; source++) {\n        for (int destination = 1; destination <= numberofvertices; destination++) {\n          if (DistanceMatrix[source][intermediate] + DistanceMatrix[intermediate][destination]\n              < DistanceMatrix[source][destination])\n          // if the new distance calculated is less then the earlier shortest\n          // calculated distance it get replaced as new shortest distance\n          {\n            DistanceMatrix[source][destination] =\n                DistanceMatrix[source][intermediate] + DistanceMatrix[intermediate][destination];\n          }\n        }\n      }\n    }\n    for (int source = 1; source <= numberofvertices; source++) System.out.print(\"\\t\" + source);\n    System.out.println();\n    for (int source = 1; source <= numberofvertices; source++) {\n      System.out.print(source + \"\\t\");\n      for (int destination = 1; destination <= numberofvertices; destination++) {\n        System.out.print(DistanceMatrix[source][destination] + \"\\t\");\n      }\n      System.out.println();\n    }\n  }\n\n  public static void main(String... arg) {\n    Scanner scan = new Scanner(System.in);\n    System.out.println(\"Enter the number of vertices\");\n    int numberOfVertices = scan.nextInt();\n    int[][] adjacencyMatrix = new int[numberOfVertices + 1][numberOfVertices + 1];\n    System.out.println(\"Enter the Weighted Matrix for the graph\");\n    for (int source = 1; source <= numberOfVertices; source++) {\n      for (int destination = 1; destination <= numberOfVertices; destination++) {\n        adjacencyMatrix[source][destination] = scan.nextInt();\n        if (source == destination) {\n          adjacencyMatrix[source][destination] = 0;\n          continue;\n        }\n        if (adjacencyMatrix[source][destination] == 0) {\n          adjacencyMatrix[source][destination] = INFINITY;\n        }\n      }\n    }\n    System.out.println(\"The Transitive Closure of the Graph\");\n    FloydWarshall floydwarshall = new FloydWarshall(numberOfVertices);\n    floydwarshall.floydwarshall(adjacencyMatrix);\n    scan.close();\n  }\n}\n","index":30},{"title":"Graphs","category":"Graphs","id":"Graphs_Graphs","algorithm":"package DataStructures.Graphs;\n\nimport java.util.ArrayList;\n\nclass AdjacencyListGraph<E extends Comparable<E>> {\n\n  ArrayList<Vertex> verticies;\n\n  public AdjacencyListGraph() {\n    verticies = new ArrayList<>();\n  }\n\n  private class Vertex {\n    E data;\n    ArrayList<Vertex> adjacentVerticies;\n\n    public Vertex(E data) {\n      adjacentVerticies = new ArrayList<>();\n      this.data = data;\n    }\n\n    public boolean addAdjacentVertex(Vertex to) {\n      for (Vertex v : adjacentVerticies) {\n        if (v.data.compareTo(to.data) == 0) {\n          return false; // the edge already exists\n        }\n      }\n      return adjacentVerticies.add(to); // this will return true;\n    }\n\n    public boolean removeAdjacentVertex(E to) {\n      // use indexes here so it is possible to\n      // remove easily without implementing\n      // equals method that ArrayList.remove(Object o) uses\n      for (int i = 0; i < adjacentVerticies.size(); i++) {\n        if (adjacentVerticies.get(i).data.compareTo(to) == 0) {\n          adjacentVerticies.remove(i);\n          return true;\n        }\n      }\n      return false;\n    }\n  }\n\n  /**\n   * this method removes an edge from the graph between two specified verticies\n   *\n   * @param from the data of the vertex the edge is from\n   * @param to the data of the vertex the edge is going to\n   * @return returns false if the edge doesn't exist, returns true if the edge exists and is removed\n   */\n  public boolean removeEdge(E from, E to) {\n    Vertex fromV = null;\n    for (Vertex v : verticies) {\n      if (from.compareTo(v.data) == 0) {\n        fromV = v;\n        break;\n      }\n    }\n    if (fromV == null) return false;\n    return fromV.removeAdjacentVertex(to);\n  }\n\n  /**\n   * this method adds an edge to the graph between two specified verticies\n   *\n   * @param from the data of the vertex the edge is from\n   * @param to the data of the vertex the edge is going to\n   * @return returns true if the edge did not exist, return false if it already did\n   */\n  public boolean addEdge(E from, E to) {\n    Vertex fromV = null, toV = null;\n    for (Vertex v : verticies) {\n      if (from.compareTo(v.data) == 0) { // see if from vertex already exists\n        fromV = v;\n      } else if (to.compareTo(v.data) == 0) { // see if to vertex already exists\n        toV = v;\n      }\n      if (fromV != null && toV != null) break; // both nodes exist so stop searching\n    }\n    if (fromV == null) {\n      fromV = new Vertex(from);\n      verticies.add(fromV);\n    }\n    if (toV == null) {\n      toV = new Vertex(to);\n      verticies.add(toV);\n    }\n    return fromV.addAdjacentVertex(toV);\n  }\n\n  /**\n   * this gives a list of verticies in the graph and their adjacencies\n   *\n   * @return returns a string describing this graph\n   */\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    for (Vertex v : verticies) {\n      sb.append(\"Vertex: \");\n      sb.append(v.data);\n      sb.append(\"\\n\");\n      sb.append(\"Adjacent verticies: \");\n      for (Vertex v2 : v.adjacentVerticies) {\n        sb.append(v2.data);\n        sb.append(\" \");\n      }\n      sb.append(\"\\n\");\n    }\n    return sb.toString();\n  }\n}\n\npublic class Graphs {\n\n  public static void main(String args[]) {\n    AdjacencyListGraph<Integer> graph = new AdjacencyListGraph<>();\n    assert graph.addEdge(1, 2);\n    assert graph.addEdge(1, 5);\n    assert graph.addEdge(2, 5);\n    assert !graph.addEdge(1, 2);\n    assert graph.addEdge(2, 3);\n    assert graph.addEdge(3, 4);\n    assert graph.addEdge(4, 1);\n    assert !graph.addEdge(2, 3);\n    System.out.println(graph);\n  }\n}\n","index":31},{"title":"Kruskal","category":"Graphs","id":"Kruskal_Graphs","algorithm":"// Problem -> Connect all the edges with the minimum cost.\n// Possible Solution -> Kruskal Algorithm (KA), KA finds the minimum-spanning-tree, which means, the\n// group of edges with the minimum sum of their weights that connect the whole graph.\n// The graph needs to be connected, because if there are nodes impossible to reach, there are no\n// edges that could connect every node in the graph.\n// KA is a Greedy Algorithm, because edges are analysed based on their weights, that is why a\n// Priority Queue is used, to take first those less weighted.\n// This implementations below has some changes compared to conventional ones, but they are explained\n// all along the code.\n\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.PriorityQueue;\n\npublic class Kruskal {\n\n  // Complexity: O(E log V) time, where E is the number of edges in the graph and V is the number of\n  // vertices\n\n  private static class Edge {\n    private int from;\n    private int to;\n    private int weight;\n\n    public Edge(int from, int to, int weight) {\n      this.from = from;\n      this.to = to;\n      this.weight = weight;\n    }\n  }\n\n  private static void addEdge(HashSet<Edge>[] graph, int from, int to, int weight) {\n    graph[from].add(new Edge(from, to, weight));\n  }\n\n  public static void main(String[] args) {\n    HashSet<Edge>[] graph = new HashSet[7];\n    for (int i = 0; i < graph.length; i++) {\n      graph[i] = new HashSet<>();\n    }\n    addEdge(graph, 0, 1, 2);\n    addEdge(graph, 0, 2, 3);\n    addEdge(graph, 0, 3, 3);\n    addEdge(graph, 1, 2, 4);\n    addEdge(graph, 2, 3, 5);\n    addEdge(graph, 1, 4, 3);\n    addEdge(graph, 2, 4, 1);\n    addEdge(graph, 3, 5, 7);\n    addEdge(graph, 4, 5, 8);\n    addEdge(graph, 5, 6, 9);\n\n    System.out.println(\"Initial Graph: \");\n    for (int i = 0; i < graph.length; i++) {\n      for (Edge edge : graph[i]) {\n        System.out.println(i + \" <-- weight \" + edge.weight + \" --> \" + edge.to);\n      }\n    }\n\n    Kruskal k = new Kruskal();\n    HashSet<Edge>[] solGraph = k.kruskal(graph);\n\n    System.out.println(\"\\nMinimal Graph: \");\n    for (int i = 0; i < solGraph.length; i++) {\n      for (Edge edge : solGraph[i]) {\n        System.out.println(i + \" <-- weight \" + edge.weight + \" --> \" + edge.to);\n      }\n    }\n  }\n\n  public HashSet<Edge>[] kruskal(HashSet<Edge>[] graph) {\n    int nodes = graph.length;\n    int[] captain = new int[nodes];\n    // captain of i, stores the set with all the connected nodes to i\n    HashSet<Integer>[] connectedGroups = new HashSet[nodes];\n    HashSet<Edge>[] minGraph = new HashSet[nodes];\n    PriorityQueue<Edge> edges = new PriorityQueue<>((Comparator.comparingInt(edge -> edge.weight)));\n    for (int i = 0; i < nodes; i++) {\n      minGraph[i] = new HashSet<>();\n      connectedGroups[i] = new HashSet<>();\n      connectedGroups[i].add(i);\n      captain[i] = i;\n      edges.addAll(graph[i]);\n    }\n    int connectedElements = 0;\n    // as soon as two sets merge all the elements, the algorithm must stop\n    while (connectedElements != nodes && !edges.isEmpty()) {\n      Edge edge = edges.poll();\n      // This if avoids cycles\n      if (!connectedGroups[captain[edge.from]].contains(edge.to)\n          && !connectedGroups[captain[edge.to]].contains(edge.from)) {\n        // merge sets of the captains of each point connected by the edge\n        connectedGroups[captain[edge.from]].addAll(connectedGroups[captain[edge.to]]);\n        // update captains of the elements merged\n        connectedGroups[captain[edge.from]].forEach(i -> captain[i] = captain[edge.from]);\n        // add Edge to minimal graph\n        addEdge(minGraph, edge.from, edge.to, edge.weight);\n        // count how many elements have been merged\n        connectedElements = connectedGroups[captain[edge.from]].size();\n      }\n    }\n    return minGraph;\n  }\n}\n","index":32},{"title":"Matrix Graphs","category":"Graphs","id":"MatrixGraphs_Graphs","algorithm":"package DataStructures.Graphs;\n\npublic class MatrixGraphs {\n\n  public static void main(String args[]) {\n    AdjacencyMatrixGraph graph = new AdjacencyMatrixGraph(10);\n    graph.addEdge(1, 2);\n    graph.addEdge(1, 5);\n    graph.addEdge(2, 5);\n    graph.addEdge(1, 2);\n    graph.addEdge(2, 3);\n    graph.addEdge(3, 4);\n    graph.addEdge(4, 1);\n    graph.addEdge(2, 3);\n    System.out.println(graph);\n  }\n}\n\nclass AdjacencyMatrixGraph {\n  private int _numberOfVertices;\n  private int _numberOfEdges;\n  private int[][] _adjacency;\n\n  static final int EDGE_EXIST = 1;\n  static final int EDGE_NONE = 0;\n\n  public AdjacencyMatrixGraph(int givenNumberOfVertices) {\n    this.setNumberOfVertices(givenNumberOfVertices);\n    this.setNumberOfEdges(0);\n    this.setAdjacency(new int[givenNumberOfVertices][givenNumberOfVertices]);\n    for (int i = 0; i < givenNumberOfVertices; i++) {\n      for (int j = 0; j < givenNumberOfVertices; j++) {\n        this.adjacency()[i][j] = AdjacencyMatrixGraph.EDGE_NONE;\n      }\n    }\n  }\n\n  private void setNumberOfVertices(int newNumberOfVertices) {\n    this._numberOfVertices = newNumberOfVertices;\n  }\n\n  public int numberOfVertices() {\n    return this._numberOfVertices;\n  }\n\n  private void setNumberOfEdges(int newNumberOfEdges) {\n    this._numberOfEdges = newNumberOfEdges;\n  }\n\n  public int numberOfEdges() {\n    return this._numberOfEdges;\n  }\n\n  private void setAdjacency(int[][] newAdjacency) {\n    this._adjacency = newAdjacency;\n  }\n\n  private int[][] adjacency() {\n    return this._adjacency;\n  }\n\n  private boolean adjacencyOfEdgeDoesExist(int from, int to) {\n    return (this.adjacency()[from][to] != AdjacencyMatrixGraph.EDGE_NONE);\n  }\n\n  public boolean vertexDoesExist(int aVertex) {\n    if (aVertex >= 0 && aVertex < this.numberOfVertices()) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  public boolean edgeDoesExist(int from, int to) {\n    if (this.vertexDoesExist(from) && this.vertexDoesExist(to)) {\n      return (this.adjacencyOfEdgeDoesExist(from, to));\n    }\n\n    return false;\n  }\n\n  /**\n   * This method adds an edge to the graph between two specified vertices\n   *\n   * @param from the data of the vertex the edge is from\n   * @param to the data of the vertex the edge is going to\n   * @return returns true if the edge did not exist, return false if it already did\n   */\n  public boolean addEdge(int from, int to) {\n    if (this.vertexDoesExist(from) && this.vertexDoesExist(to)) {\n      if (!this.adjacencyOfEdgeDoesExist(from, to)) {\n        this.adjacency()[from][to] = AdjacencyMatrixGraph.EDGE_EXIST;\n        this.adjacency()[to][from] = AdjacencyMatrixGraph.EDGE_EXIST;\n        this.setNumberOfEdges(this.numberOfEdges() + 1);\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * this method removes an edge from the graph between two specified vertices\n   *\n   * @param from the data of the vertex the edge is from\n   * @param to the data of the vertex the edge is going to\n   * @return returns false if the edge doesn't exist, returns true if the edge exists and is removed\n   */\n  public boolean removeEdge(int from, int to) {\n    if (!this.vertexDoesExist(from) || !this.vertexDoesExist(to)) {\n      if (this.adjacencyOfEdgeDoesExist(from, to)) {\n        this.adjacency()[from][to] = AdjacencyMatrixGraph.EDGE_NONE;\n        this.adjacency()[to][from] = AdjacencyMatrixGraph.EDGE_NONE;\n        this.setNumberOfEdges(this.numberOfEdges() - 1);\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * this gives a list of vertices in the graph and their adjacencies\n   *\n   * @return returns a string describing this graph\n   */\n  public String toString() {\n    String s = \"    \";\n    for (int i = 0; i < this.numberOfVertices(); i++) {\n      s = s + String.valueOf(i) + \" \";\n    }\n    s = s + \" \\n\";\n\n    for (int i = 0; i < this.numberOfVertices(); i++) {\n      s = s + String.valueOf(i) + \" : \";\n      for (int j = 0; j < this.numberOfVertices(); j++) {\n        s = s + String.valueOf(this._adjacency[i][j]) + \" \";\n      }\n      s = s + \"\\n\";\n    }\n    return s;\n  }\n}\n","index":33},{"title":"Prim M S T","category":"Graphs","id":"PrimMST_Graphs","algorithm":"package DataStructures.Graphs;\n\n/**\n * A Java program for Prim's Minimum Spanning Tree (MST) algorithm. adjacency matrix representation\n * of the graph\n */\nclass PrimMST {\n  // Number of vertices in the graph\n  private static final int V = 5;\n\n  // A utility function to find the vertex with minimum key\n  // value, from the set of vertices not yet included in MST\n  int minKey(int key[], Boolean mstSet[]) {\n    // Initialize min value\n    int min = Integer.MAX_VALUE, min_index = -1;\n\n    for (int v = 0; v < V; v++)\n      if (mstSet[v] == false && key[v] < min) {\n        min = key[v];\n        min_index = v;\n      }\n\n    return min_index;\n  }\n\n  // A utility function to print the constructed MST stored in\n  // parent[]\n  void printMST(int parent[], int n, int graph[][]) {\n    System.out.println(\"Edge   Weight\");\n    for (int i = 1; i < V; i++)\n      System.out.println(parent[i] + \" - \" + i + \"    \" + graph[i][parent[i]]);\n  }\n\n  // Function to construct and print MST for a graph represented\n  //  using adjacency matrix representation\n  void primMST(int graph[][]) {\n    // Array to store constructed MST\n    int parent[] = new int[V];\n\n    // Key values used to pick minimum weight edge in cut\n    int key[] = new int[V];\n\n    // To represent set of vertices not yet included in MST\n    Boolean mstSet[] = new Boolean[V];\n\n    // Initialize all keys as INFINITE\n    for (int i = 0; i < V; i++) {\n      key[i] = Integer.MAX_VALUE;\n      mstSet[i] = false;\n    }\n\n    // Always include first 1st vertex in MST.\n    key[0] = 0; // Make key 0 so that this vertex is\n    // picked as first vertex\n    parent[0] = -1; // First node is always root of MST\n\n    // The MST will have V vertices\n    for (int count = 0; count < V - 1; count++) {\n      // Pick thd minimum key vertex from the set of vertices\n      // not yet included in MST\n      int u = minKey(key, mstSet);\n\n      // Add the picked vertex to the MST Set\n      mstSet[u] = true;\n\n      // Update key value and parent index of the adjacent\n      // vertices of the picked vertex. Consider only those\n      // vertices which are not yet included in MST\n      for (int v = 0; v < V; v++)\n\n        // graph[u][v] is non zero only for adjacent vertices of m\n        // mstSet[v] is false for vertices not yet included in MST\n        // Update the key only if graph[u][v] is smaller than key[v]\n        if (graph[u][v] != 0 && mstSet[v] == false && graph[u][v] < key[v]) {\n          parent[v] = u;\n          key[v] = graph[u][v];\n        }\n    }\n\n    // print the constructed MST\n    printMST(parent, V, graph);\n  }\n\n  public static void main(String[] args) {\n    /* Let us create the following graph\n       2    3\n    (0)--(1)--(2)\n    |    / \\   |\n    6| 8/   \\5 |7\n    | /      \\ |\n    (3)-------(4)\n         9          */\n    PrimMST t = new PrimMST();\n    int graph[][] =\n        new int[][] {\n          {0, 2, 0, 6, 0}, {2, 0, 3, 8, 5}, {0, 3, 0, 0, 7}, {6, 8, 0, 0, 9}, {0, 5, 7, 9, 0},\n        };\n\n    // Print the solution\n    t.primMST(graph);\n  }\n}\n","index":34},{"title":"Hash Map","category":"DataStructures","id":"HashMap","index":35},{"title":"Hashing","category":"HashMap","id":"Hashing","index":36},{"title":"Hash Map","category":"Hashing","id":"HashMap_Hashing","algorithm":"package DataStructures.HashMap.Hashing;\n\npublic class HashMap {\n  private int hsize;\n  private LinkedList[] buckets;\n\n  public HashMap(int hsize) {\n    buckets = new LinkedList[hsize];\n    for (int i = 0; i < hsize; i++) {\n      buckets[i] = new LinkedList();\n      // Java requires explicit initialisaton of each object\n    }\n    this.hsize = hsize;\n  }\n\n  public int hashing(int key) {\n    int hash = key % hsize;\n    if (hash < 0) hash += hsize;\n    return hash;\n  }\n\n  public void insertHash(int key) {\n    int hash = hashing(key);\n    buckets[hash].insert(key);\n  }\n\n  public void deleteHash(int key) {\n    int hash = hashing(key);\n\n    buckets[hash].delete(key);\n  }\n\n  public void displayHashtable() {\n    for (int i = 0; i < hsize; i++) {\n      System.out.printf(\"Bucket %d :\", i);\n      System.out.println(buckets[i].display());\n    }\n  }\n\n  public static class LinkedList {\n    private Node first;\n\n    public LinkedList() {\n      first = null;\n    }\n\n    public void insert(int key) {\n      if (isEmpty()) {\n        first = new Node(key);\n        return;\n      }\n\n      Node temp = findEnd(first);\n      temp.setNext(new Node(key));\n    }\n\n    private Node findEnd(Node n) {\n      if (n.getNext() == null) {\n        return n;\n      } else {\n        return findEnd(n.getNext());\n      }\n    }\n\n    public Node findKey(int key) {\n      if (!isEmpty()) {\n        return findKey(first, key);\n      } else {\n        System.out.println(\"List is empty\");\n        return null;\n      }\n    }\n\n    private Node findKey(Node n, int key) {\n      if (n.getKey() == key) {\n        return n;\n      } else if (n.getNext() == null) {\n        System.out.println(\"Key not found\");\n        return null;\n      } else {\n        return findKey(n.getNext(), key);\n      }\n    }\n\n    public void delete(int key) {\n      if (!isEmpty()) {\n        if (first.getKey() == key) {\n          first = null;\n        } else {\n          delete(first, key);\n        }\n      } else {\n        System.out.println(\"List is empty\");\n      }\n    }\n\n    private void delete(Node n, int key) {\n      if (n.getNext().getKey() == key) {\n        if (n.getNext().getNext() == null) {\n          n.setNext(null);\n        } else {\n          n.setNext(n.getNext().getNext());\n        }\n      }\n    }\n\n    public String display() {\n      return display(first);\n    }\n\n    private String display(Node n) {\n      if (n == null) {\n        return \"null\";\n      } else {\n        return n.getKey() + \"->\" + display(n.getNext());\n      }\n    }\n\n    public boolean isEmpty() {\n      return first == null;\n    }\n  }\n\n  public static class Node {\n    private Node next;\n    private int key;\n\n    public Node(int key) {\n      next = null;\n      this.key = key;\n    }\n\n    public Node getNext() {\n      return next;\n    }\n\n    public int getKey() {\n      return key;\n    }\n\n    public void setNext(Node next) {\n      this.next = next;\n    }\n  }\n}\n","index":37},{"title":"Hash Map Linear Probing","category":"Hashing","id":"HashMapLinearProbing_Hashing","algorithm":"package DataStructures.HashMap.Hashing;\n\nimport java.util.*;\n\n/**\n * This class is an implementation of a hash table using linear probing It uses a dynamic array to\n * lengthen the size of the hash table when load factor > .7\n */\npublic class HashMapLinearProbing {\n  private int hsize; // size of the hash table\n  private Integer[] buckets; // array representing the table\n  private Integer AVAILABLE;\n  private int size; // amount of elements in the hash table\n\n  /**\n   * Constructor initializes buckets array, hsize, and creates dummy object for AVAILABLE\n   *\n   * @param hsize the desired size of the hash map\n   */\n  public HashMapLinearProbing(int hsize) {\n    this.buckets = new Integer[hsize];\n    this.hsize = hsize;\n    this.AVAILABLE = new Integer(Integer.MIN_VALUE);\n    this.size = 0;\n  }\n\n  /**\n   * The Hash Function takes a given key and finds an index based on its data\n   *\n   * @param key the desired key to be converted\n   * @return int an index corresponding to the key\n   */\n  public int hashing(int key) {\n    int hash = key % hsize;\n    if (hash < 0) {\n      hash += hsize;\n    }\n    return hash;\n  }\n\n  /**\n   * inserts the key into the hash map by wrapping it as an Integer object\n   *\n   * @param key the desired key to be inserted in the hash map\n   */\n  public void insertHash(int key) {\n    Integer wrappedInt = new Integer(key);\n    int hash = hashing(key);\n\n    if (isFull()) {\n      System.out.println(\"Hash table is full\");\n      return;\n    }\n\n    for (int i = 0; i < hsize; i++) {\n      if (buckets[hash] == null || buckets[hash] == AVAILABLE) {\n        buckets[hash] = wrappedInt;\n        size++;\n        return;\n      }\n\n      if (hash + 1 < hsize) {\n        hash++;\n      } else {\n        hash = 0;\n      }\n    }\n  }\n\n  /**\n   * deletes a key from the hash map and adds an available placeholder\n   *\n   * @param key the desired key to be deleted\n   */\n  public void deleteHash(int key) {\n    Integer wrappedInt = new Integer(key);\n    int hash = hashing(key);\n\n    if (isEmpty()) {\n      System.out.println(\"Table is empty\");\n      return;\n    }\n\n    for (int i = 0; i < hsize; i++) {\n      if (buckets[hash] != null && buckets[hash].equals(wrappedInt)) {\n        buckets[hash] = AVAILABLE;\n        size--;\n        return;\n      }\n\n      if (hash + 1 < hsize) {\n        hash++;\n      } else {\n        hash = 0;\n      }\n    }\n    System.out.println(\"Key \" + key + \" not found\");\n  }\n\n  /** Displays the hash table line by line */\n  public void displayHashtable() {\n    for (int i = 0; i < hsize; i++) {\n      if (buckets[i] == null || buckets[i] == AVAILABLE) {\n        System.out.println(\"Bucket \" + i + \": Empty\");\n      } else {\n        System.out.println(\"Bucket \" + i + \": \" + buckets[i].toString());\n      }\n    }\n  }\n\n  /**\n   * Finds the index of location based on an inputed key\n   *\n   * @param key the desired key to be found\n   * @return int the index where the key is located\n   */\n  public int findHash(int key) {\n    Integer wrappedInt = new Integer(key);\n    int hash = hashing(key);\n\n    if (isEmpty()) {\n      System.out.println(\"Table is empty\");\n      return -1;\n    }\n\n    for (int i = 0; i < hsize; i++) {\n      try {\n        if (buckets[hash].equals(wrappedInt)) {\n          buckets[hash] = AVAILABLE;\n          return hash;\n        }\n      } catch (Exception E) {\n      }\n\n      if (hash + 1 < hsize) {\n        hash++;\n      } else {\n        hash = 0;\n      }\n    }\n    System.out.println(\"Key \" + key + \" not found\");\n    return -1;\n  }\n\n  private void lengthenTable() {\n    buckets = Arrays.copyOf(buckets, hsize * 2);\n    hsize *= 2;\n    System.out.println(\"Table size is now: \" + hsize);\n  }\n\n  /**\n   * Checks the load factor of the hash table if greater than .7, automatically lengthens table to\n   * prevent further collisions\n   */\n  public void checkLoadFactor() {\n    double factor = (double) size / hsize;\n    if (factor > .7) {\n      System.out.println(\"Load factor is \" + factor + \",  lengthening table\");\n      lengthenTable();\n    } else {\n      System.out.println(\"Load factor is \" + factor);\n    }\n  }\n\n  /**\n   * isFull returns true if the hash map is full and false if not full\n   *\n   * @return boolean is Empty\n   */\n  public boolean isFull() {\n    boolean response = true;\n    for (int i = 0; i < hsize; i++) {\n      if (buckets[i] == null || buckets[i] == AVAILABLE) {\n        response = false;\n        break;\n      }\n    }\n    return response;\n  }\n\n  /**\n   * isEmpty returns true if the hash map is empty and false if not empty\n   *\n   * @return boolean is Empty\n   */\n  public boolean isEmpty() {\n    boolean response = true;\n    for (int i = 0; i < hsize; i++) {\n      if (buckets[i] != null) {\n        response = false;\n        break;\n      }\n    }\n    return response;\n  }\n}\n","index":38},{"title":"Main","category":"Hashing","id":"Main_Hashing","algorithm":"package DataStructures.HashMap.Hashing;\n\nimport java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n\n    int choice, key;\n\n    HashMap h = new HashMap(7);\n    Scanner In = new Scanner(System.in);\n\n    while (true) {\n      System.out.println(\"Enter your Choice :\");\n      System.out.println(\"1. Add Key\");\n      System.out.println(\"2. Delete Key\");\n      System.out.println(\"3. Print Table\");\n      System.out.println(\"4. Exit\");\n\n      choice = In.nextInt();\n\n      switch (choice) {\n        case 1:\n          {\n            System.out.println(\"Enter the Key: \");\n            key = In.nextInt();\n            h.insertHash(key);\n            break;\n          }\n        case 2:\n          {\n            System.out.println(\"Enter the Key delete:  \");\n            key = In.nextInt();\n            h.deleteHash(key);\n            break;\n          }\n        case 3:\n          {\n            System.out.println(\"Print table\");\n            h.displayHashtable();\n            break;\n          }\n        case 4:\n          {\n            In.close();\n            return;\n          }\n      }\n    }\n  }\n}\n","index":39},{"title":"Main Linear Probing","category":"Hashing","id":"MainLinearProbing_Hashing","algorithm":"package DataStructures.HashMap.Hashing;\n\nimport java.util.Scanner;\n\npublic class MainLinearProbing {\n  public static void main(String[] args) {\n\n    int choice, key;\n\n    HashMapLinearProbing h = new HashMapLinearProbing(7);\n    Scanner In = new Scanner(System.in);\n\n    while (true) {\n      System.out.println(\"Enter your Choice :\");\n      System.out.println(\"1. Add Key\");\n      System.out.println(\"2. Delete Key\");\n      System.out.println(\"3. Print Table\");\n      System.out.println(\"4. Exit\");\n      System.out.println(\"5. Search and print key index\");\n      System.out.println(\"6. Check load factor\");\n\n      choice = In.nextInt();\n\n      switch (choice) {\n        case 1:\n          {\n            System.out.println(\"Enter the Key: \");\n            key = In.nextInt();\n            h.insertHash(key);\n            break;\n          }\n        case 2:\n          {\n            System.out.println(\"Enter the Key delete:  \");\n            key = In.nextInt();\n            h.deleteHash(key);\n            break;\n          }\n        case 3:\n          {\n            System.out.println(\"Print table\");\n            h.displayHashtable();\n            break;\n          }\n        case 4:\n          {\n            In.close();\n            return;\n          }\n        case 5:\n          {\n            System.out.println(\"Enter the Key to find and print:  \");\n            key = In.nextInt();\n            System.out.println(\"Key: \" + key + \" is at index: \" + h.findHash(key));\n            break;\n          }\n        case 6:\n          {\n            h.checkLoadFactor();\n            break;\n          }\n      }\n    }\n  }\n}\n","index":40},{"title":"Heaps","category":"DataStructures","id":"Heaps","index":41},{"title":"Empty Heap Exception","category":"Heaps","id":"EmptyHeapException_Heaps","algorithm":"package DataStructures.Heaps;\n\n/**\n * @author Nicolas Renard Exception to be thrown if the getElement method is used on an empty heap.\n */\n@SuppressWarnings(\"serial\")\npublic class EmptyHeapException extends Exception {\n\n  public EmptyHeapException(String message) {\n    super(message);\n  }\n}\n","index":42},{"title":"Heap","category":"Heaps","id":"Heap_Heaps","algorithm":"package DataStructures.Heaps;\n\n/**\n * Interface common to heap data structures.<br>\n *\n * <p>Heaps are tree-like data structures that allow storing elements in a specific way. Each node\n * corresponds to an element and has one parent node (except for the root) and at most two children\n * nodes. Every element contains a key, and those keys indicate how the tree shall be built. For\n * instance, for a min-heap, the key of a node shall be greater than or equal to its parent's and\n * lower than or equal to its children's (the opposite rule applies to a max-heap).\n *\n * <p>All heap-related operations (inserting or deleting an element, extracting the min or max) are\n * performed in O(log n) time.\n *\n * @author Nicolas Renard\n */\npublic interface Heap {\n\n  /**\n   * @return the top element in the heap, the one with lowest key for min-heap or with the highest\n   *     key for max-heap\n   * @throws EmptyHeapException if heap is empty\n   */\n  HeapElement getElement() throws EmptyHeapException;\n\n  /**\n   * Inserts an element in the heap. Adds it to then end and toggle it until it finds its right\n   * position.\n   *\n   * @param element an instance of the HeapElement class.\n   */\n  void insertElement(HeapElement element);\n\n  /**\n   * Delete an element in the heap.\n   *\n   * @param elementIndex int containing the position in the heap of the element to be deleted.\n   */\n  void deleteElement(int elementIndex);\n}\n","index":43},{"title":"Heap Element","category":"Heaps","id":"HeapElement_Heaps","algorithm":"package DataStructures.Heaps;\n\n/**\n * Class for heap elements.<br>\n *\n * <p>A heap element contains two attributes: a key which will be used to build the tree (int or\n * double, either primitive type or object) and any kind of IMMUTABLE object the user sees fit to\n * carry any information he/she likes. Be aware that the use of a mutable object might jeopardize\n * the integrity of this information.\n *\n * @author Nicolas Renard\n */\npublic class HeapElement {\n  private final double key;\n  private final Object additionalInfo;\n\n  // Constructors\n\n  /**\n   * @param key : a number of primitive type 'double'\n   * @param info : any kind of IMMUTABLE object. May be null, since the purpose is only to carry\n   *     additional information of use for the user\n   */\n  public HeapElement(double key, Object info) {\n    this.key = key;\n    this.additionalInfo = info;\n  }\n\n  /**\n   * @param key : a number of primitive type 'int'\n   * @param info : any kind of IMMUTABLE object. May be null, since the purpose is only to carry\n   *     additional information of use for the user\n   */\n  public HeapElement(int key, Object info) {\n    this.key = key;\n    this.additionalInfo = info;\n  }\n\n  /**\n   * @param key : a number of object type 'Integer'\n   * @param info : any kind of IMMUTABLE object. May be null, since the purpose is only to carry\n   *     additional information of use for the user\n   */\n  public HeapElement(Integer key, Object info) {\n    this.key = key;\n    this.additionalInfo = info;\n  }\n\n  /**\n   * @param key : a number of object type 'Double'\n   * @param info : any kind of IMMUTABLE object. May be null, since the purpose is only to carry\n   *     additional information of use for the user\n   */\n  public HeapElement(Double key, Object info) {\n    this.key = key;\n    this.additionalInfo = info;\n  }\n\n  /** @param key : a number of primitive type 'double' */\n  public HeapElement(double key) {\n    this.key = key;\n    this.additionalInfo = null;\n  }\n\n  /** @param key : a number of primitive type 'int' */\n  public HeapElement(int key) {\n    this.key = key;\n    this.additionalInfo = null;\n  }\n\n  /** @param key : a number of object type 'Integer' */\n  public HeapElement(Integer key) {\n    this.key = key;\n    this.additionalInfo = null;\n  }\n\n  /** @param key : a number of object type 'Double' */\n  public HeapElement(Double key) {\n    this.key = key;\n    this.additionalInfo = null;\n  }\n\n  // Getters\n\n  /** @return the object containing the additional info provided by the user. */\n  public Object getInfo() {\n    return additionalInfo;\n  }\n\n  /** @return the key value of the element */\n  public double getKey() {\n    return key;\n  }\n\n  // Overridden object methods\n\n  public String toString() {\n    return \"Key: \" + key + \" - \" + additionalInfo.toString();\n  }\n\n  /**\n   * @param otherHeapElement\n   * @return true if the keys on both elements are identical and the additional info objects are\n   *     identical.\n   */\n  @Override\n  public boolean equals(Object o) {\n    if (o != null) {\n      if (!(o instanceof HeapElement)) return false;\n      HeapElement otherHeapElement = (HeapElement) o;\n      return (this.key == otherHeapElement.key)\n          && (this.additionalInfo.equals(otherHeapElement.additionalInfo));\n    }\n    return false;\n  }\n\n  @Override\n  public int hashCode() {\n    int result = 0;\n    result = 31 * result + (int) key;\n    result = 31 * result + (additionalInfo != null ? additionalInfo.hashCode() : 0);\n    return result;\n  }\n}\n","index":44},{"title":"Max Heap","category":"Heaps","id":"MaxHeap_Heaps","algorithm":"package DataStructures.Heaps;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Heap tree where a node's key is higher than or equal to its parent's and lower than or equal to\n * its children's.\n *\n * @author Nicolas Renard\n */\npublic class MaxHeap implements Heap {\n\n  private final List<HeapElement> maxHeap;\n\n  public MaxHeap(List<HeapElement> listElements) {\n    maxHeap = new ArrayList<>();\n    for (HeapElement heapElement : listElements) {\n      if (heapElement != null) insertElement(heapElement);\n      else System.out.println(\"Null element. Not added to heap\");\n    }\n    if (maxHeap.size() == 0) System.out.println(\"No element has been added, empty heap.\");\n  }\n\n  /**\n   * Get the element at a given index. The key for the list is equal to index value - 1\n   *\n   * @param elementIndex index\n   * @return heapElement\n   */\n  public HeapElement getElement(int elementIndex) {\n    if ((elementIndex <= 0) || (elementIndex > maxHeap.size()))\n      throw new IndexOutOfBoundsException(\"Index out of heap range\");\n    return maxHeap.get(elementIndex - 1);\n  }\n\n  // Get the key of the element at a given index\n  private double getElementKey(int elementIndex) {\n    return maxHeap.get(elementIndex - 1).getKey();\n  }\n\n  // Swaps two elements in the heap\n  private void swap(int index1, int index2) {\n    HeapElement temporaryElement = maxHeap.get(index1 - 1);\n    maxHeap.set(index1 - 1, maxHeap.get(index2 - 1));\n    maxHeap.set(index2 - 1, temporaryElement);\n  }\n\n  // Toggle an element up to its right place as long as its key is lower than its parent's\n  private void toggleUp(int elementIndex) {\n    double key = maxHeap.get(elementIndex - 1).getKey();\n    while (getElementKey((int) Math.floor(elementIndex / 2.0)) < key) {\n      swap(elementIndex, (int) Math.floor(elementIndex / 2.0));\n      elementIndex = (int) Math.floor(elementIndex / 2.0);\n    }\n  }\n\n  // Toggle an element down to its right place as long as its key is higher\n  // than any of its children's\n  private void toggleDown(int elementIndex) {\n    double key = maxHeap.get(elementIndex - 1).getKey();\n    boolean wrongOrder =\n        (key < getElementKey(elementIndex * 2))\n            || (key < getElementKey(Math.min(elementIndex * 2, maxHeap.size())));\n    while ((2 * elementIndex <= maxHeap.size()) && wrongOrder) {\n      // Check whether it shall swap the element with its left child or its right one if any.\n      if ((2 * elementIndex < maxHeap.size())\n          && (getElementKey(elementIndex * 2 + 1) > getElementKey(elementIndex * 2))) {\n        swap(elementIndex, 2 * elementIndex + 1);\n        elementIndex = 2 * elementIndex + 1;\n      } else {\n        swap(elementIndex, 2 * elementIndex);\n        elementIndex = 2 * elementIndex;\n      }\n      wrongOrder =\n          (key < getElementKey(elementIndex * 2))\n              || (key < getElementKey(Math.min(elementIndex * 2, maxHeap.size())));\n    }\n  }\n\n  private HeapElement extractMax() {\n    HeapElement result = maxHeap.get(0);\n    deleteElement(0);\n    return result;\n  }\n\n  @Override\n  public void insertElement(HeapElement element) {\n    maxHeap.add(element);\n    toggleUp(maxHeap.size());\n  }\n\n  @Override\n  public void deleteElement(int elementIndex) {\n    if (maxHeap.isEmpty())\n      try {\n        throw new EmptyHeapException(\"Attempt to delete an element from an empty heap\");\n      } catch (EmptyHeapException e) {\n        e.printStackTrace();\n      }\n    if ((elementIndex > maxHeap.size()) || (elementIndex <= 0))\n      throw new IndexOutOfBoundsException(\"Index out of heap range\");\n    // The last element in heap replaces the one to be deleted\n    maxHeap.set(elementIndex - 1, getElement(maxHeap.size()));\n    maxHeap.remove(maxHeap.size());\n    // Shall the new element be moved up...\n    if (getElementKey(elementIndex) > getElementKey((int) Math.floor(elementIndex / 2.0)))\n      toggleUp(elementIndex);\n    // ... or down ?\n    else if (((2 * elementIndex <= maxHeap.size())\n            && (getElementKey(elementIndex) < getElementKey(elementIndex * 2)))\n        || ((2 * elementIndex < maxHeap.size())\n            && (getElementKey(elementIndex) < getElementKey(elementIndex * 2))))\n      toggleDown(elementIndex);\n  }\n\n  @Override\n  public HeapElement getElement() throws EmptyHeapException {\n    try {\n      return extractMax();\n    } catch (Exception e) {\n      throw new EmptyHeapException(\"Heap is empty. Error retrieving element\");\n    }\n  }\n}\n","index":45},{"title":"Min Heap","category":"Heaps","id":"MinHeap_Heaps","algorithm":"package DataStructures.Heaps;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Heap tree where a node's key is higher than or equal to its parent's and lower than or equal to\n * its children's.\n *\n * @author Nicolas Renard\n */\npublic class MinHeap implements Heap {\n\n  private final List<HeapElement> minHeap;\n\n  public MinHeap(List<HeapElement> listElements) {\n    minHeap = new ArrayList<>();\n    for (HeapElement heapElement : listElements) {\n      if (heapElement != null) insertElement(heapElement);\n      else System.out.println(\"Null element. Not added to heap\");\n    }\n    if (minHeap.size() == 0) System.out.println(\"No element has been added, empty heap.\");\n  }\n\n  // Get the element at a given index. The key for the list is equal to index value - 1\n  public HeapElement getElement(int elementIndex) {\n    if ((elementIndex <= 0) || (elementIndex > minHeap.size()))\n      throw new IndexOutOfBoundsException(\"Index out of heap range\");\n    return minHeap.get(elementIndex - 1);\n  }\n\n  // Get the key of the element at a given index\n  private double getElementKey(int elementIndex) {\n    return minHeap.get(elementIndex - 1).getKey();\n  }\n\n  // Swaps two elements in the heap\n  private void swap(int index1, int index2) {\n    HeapElement temporaryElement = minHeap.get(index1 - 1);\n    minHeap.set(index1 - 1, minHeap.get(index2 - 1));\n    minHeap.set(index2 - 1, temporaryElement);\n  }\n\n  // Toggle an element up to its right place as long as its key is lower than its parent's\n  private void toggleUp(int elementIndex) {\n    double key = minHeap.get(elementIndex - 1).getKey();\n    while (getElementKey((int) Math.floor(elementIndex / 2.0)) > key) {\n      swap(elementIndex, (int) Math.floor(elementIndex / 2.0));\n      elementIndex = (int) Math.floor(elementIndex / 2.0);\n    }\n  }\n\n  // Toggle an element down to its right place as long as its key is higher\n  // than any of its children's\n  private void toggleDown(int elementIndex) {\n    double key = minHeap.get(elementIndex - 1).getKey();\n    boolean wrongOrder =\n        (key > getElementKey(elementIndex * 2))\n            || (key > getElementKey(Math.min(elementIndex * 2, minHeap.size())));\n    while ((2 * elementIndex <= minHeap.size()) && wrongOrder) {\n      // Check whether it shall swap the element with its left child or its right one if any.\n      if ((2 * elementIndex < minHeap.size())\n          && (getElementKey(elementIndex * 2 + 1) < getElementKey(elementIndex * 2))) {\n        swap(elementIndex, 2 * elementIndex + 1);\n        elementIndex = 2 * elementIndex + 1;\n      } else {\n        swap(elementIndex, 2 * elementIndex);\n        elementIndex = 2 * elementIndex;\n      }\n      wrongOrder =\n          (key > getElementKey(elementIndex * 2))\n              || (key > getElementKey(Math.min(elementIndex * 2, minHeap.size())));\n    }\n  }\n\n  private HeapElement extractMin() {\n    HeapElement result = minHeap.get(0);\n    deleteElement(0);\n    return result;\n  }\n\n  @Override\n  public void insertElement(HeapElement element) {\n    minHeap.add(element);\n    toggleUp(minHeap.size());\n  }\n\n  @Override\n  public void deleteElement(int elementIndex) {\n    if (minHeap.isEmpty())\n      try {\n        throw new EmptyHeapException(\"Attempt to delete an element from an empty heap\");\n      } catch (EmptyHeapException e) {\n        e.printStackTrace();\n      }\n    if ((elementIndex > minHeap.size()) || (elementIndex <= 0))\n      throw new IndexOutOfBoundsException(\"Index out of heap range\");\n    // The last element in heap replaces the one to be deleted\n    minHeap.set(elementIndex - 1, getElement(minHeap.size()));\n    minHeap.remove(minHeap.size());\n    // Shall the new element be moved up...\n    if (getElementKey(elementIndex) < getElementKey((int) Math.floor(elementIndex / 2.0)))\n      toggleUp(elementIndex);\n    // ... or down ?\n    else if (((2 * elementIndex <= minHeap.size())\n            && (getElementKey(elementIndex) > getElementKey(elementIndex * 2)))\n        || ((2 * elementIndex < minHeap.size())\n            && (getElementKey(elementIndex) > getElementKey(elementIndex * 2))))\n      toggleDown(elementIndex);\n  }\n\n  @Override\n  public HeapElement getElement() throws EmptyHeapException {\n    try {\n      return extractMin();\n    } catch (Exception e) {\n      throw new EmptyHeapException(\"Heap is empty. Error retrieving element\");\n    }\n  }\n}\n","index":46},{"title":"Min Priority Queue","category":"Heaps","id":"MinPriorityQueue_Heaps","algorithm":"package DataStructures.Heaps;\n\n/**\n * Minimum Priority Queue It is a part of heap data structure A heap is a specific tree based data\n * structure in which all the nodes of tree are in a specific order. that is the children are\n * arranged in some respect of their parents, can either be greater or less than the parent. This\n * makes it a min priority queue or max priority queue.\n *\n * <p>\n *\n * <p>Functions: insert, delete, peek, isEmpty, print, heapSort, sink\n */\npublic class MinPriorityQueue {\n  private int[] heap;\n  private int capacity;\n  private int size;\n\n  // calss the constructor and initializes the capacity\n  MinPriorityQueue(int c) {\n    this.capacity = c;\n    this.size = 0;\n    this.heap = new int[c + 1];\n  }\n\n  // inserts the key at the end and rearranges it\n  // so that the binary heap is in appropriate order\n  public void insert(int key) {\n    if (this.isFull()) return;\n    this.heap[this.size + 1] = key;\n    int k = this.size + 1;\n    while (k > 1) {\n      if (this.heap[k] < this.heap[k / 2]) {\n        int temp = this.heap[k];\n        this.heap[k] = this.heap[k / 2];\n        this.heap[k / 2] = temp;\n      }\n      k = k / 2;\n    }\n    this.size++;\n  }\n\n  // returns the highest priority value\n  public int peek() {\n    return this.heap[1];\n  }\n\n  // returns boolean value whether the heap is empty or not\n  public boolean isEmpty() {\n    if (0 == this.size) return true;\n    return false;\n  }\n\n  // returns boolean value whether the heap is full or not\n  public boolean isFull() {\n    if (this.size == this.capacity) return true;\n    return false;\n  }\n\n  // prints the heap\n  public void print() {\n    for (int i = 1; i <= this.capacity; i++) System.out.print(this.heap[i] + \" \");\n    System.out.println();\n  }\n\n  // heap sorting can be done by performing\n  // delete function to the number of times of the size of the heap\n  // it returns reverse sort because it is a min priority queue\n  public void heapSort() {\n    for (int i = 1; i < this.capacity; i++) this.delete();\n  }\n\n  // this function reorders the heap after every delete function\n  private void sink() {\n    int k = 1;\n    while (2 * k <= this.size || 2 * k + 1 <= this.size) {\n      int minIndex;\n      if (this.heap[2 * k] >= this.heap[k]) {\n        if (2 * k + 1 <= this.size && this.heap[2 * k + 1] >= this.heap[k]) {\n          break;\n        } else if (2 * k + 1 > this.size) {\n          break;\n        }\n      }\n      if (2 * k + 1 > this.size) {\n        minIndex = this.heap[2 * k] < this.heap[k] ? 2 * k : k;\n      } else {\n        if (this.heap[k] > this.heap[2 * k] || this.heap[k] > this.heap[2 * k + 1]) {\n          minIndex = this.heap[2 * k] < this.heap[2 * k + 1] ? 2 * k : 2 * k + 1;\n        } else {\n          minIndex = k;\n        }\n      }\n      int temp = this.heap[k];\n      this.heap[k] = this.heap[minIndex];\n      this.heap[minIndex] = temp;\n      k = minIndex;\n    }\n  }\n\n  // deletes the highest priority value from the heap\n  public int delete() {\n    int min = this.heap[1];\n    this.heap[1] = this.heap[this.size];\n    this.heap[this.size] = min;\n    this.size--;\n    this.sink();\n    return min;\n  }\n\n  public static void main(String[] args) {\n    // testing\n    MinPriorityQueue q = new MinPriorityQueue(8);\n    q.insert(5);\n    q.insert(2);\n    q.insert(4);\n    q.insert(1);\n    q.insert(7);\n    q.insert(6);\n    q.insert(3);\n    q.insert(8);\n    q.print(); // [ 1, 2, 3, 5, 7, 6, 4, 8 ]\n    q.heapSort();\n    q.print(); // [ 8, 7, 6, 5, 4, 3, 2, 1 ]\n  }\n}\n","index":47},{"title":"Lists","category":"DataStructures","id":"Lists","index":48},{"title":"Circle Linked List","category":"Lists","id":"CircleLinkedList_Lists","algorithm":"package DataStructures.Lists;\n\npublic class CircleLinkedList<E> {\n  private static class Node<E> {\n    Node<E> next;\n    E value;\n\n    private Node(E value, Node<E> next) {\n      this.value = value;\n      this.next = next;\n    }\n  }\n\n  // For better O.O design this should be private allows for better black box design\n  private int size;\n  // this will point to dummy node;\n  private Node<E> head = null;\n\n  // constructer for class.. here we will make a dummy node for circly linked list implementation\n  // with reduced error catching as our list will never be empty;\n  public CircleLinkedList() {\n    // creation of the dummy node\n    head = new Node<E>(null, head);\n    size = 0;\n  }\n\n  // getter for the size... needed because size is private.\n  public int getSize() {\n    return size;\n  }\n\n  // for the sake of simplistiy this class will only contain the append function or addLast other\n  // add functions can be implemented however this is the basses of them all really.\n  public void append(E value) {\n    if (value == null) {\n      // we do not want to add null elements to the list.\n      throw new NullPointerException(\"Cannot add null element to the list\");\n    }\n    // head.next points to the last element;\n    head.next = new Node<E>(value, head);\n    size++;\n  }\n\n  public E remove(int pos) {\n    if (pos > size || pos < 0) {\n      // catching errors\n      throw new IndexOutOfBoundsException(\"position cannot be greater than size or negative\");\n    }\n    // we need to keep track of the element before the element we want to remove we can see why\n    // bellow.\n    Node<E> before = head;\n    for (int i = 1; i <= pos; i++) {\n      before = before.next;\n    }\n    Node<E> destroy = before.next;\n    E saved = destroy.value;\n    // assigning the next reference to the the element following the element we want to remove...\n    // the last element will be assigned to the head.\n    before.next = before.next.next;\n    // scrubbing\n    destroy = null;\n    size--;\n    return saved;\n  }\n}\n","index":49},{"title":"Count Singly Linked List Recursion","category":"Lists","id":"CountSinglyLinkedListRecursion_Lists","algorithm":"package DataStructures.Lists;\n\npublic class CountSinglyLinkedListRecursion extends SinglyLinkedList {\n  public static void main(String[] args) {\n    CountSinglyLinkedListRecursion list = new CountSinglyLinkedListRecursion();\n    for (int i = 1; i <= 5; ++i) {\n      list.insert(i);\n    }\n    assert list.count() == 5;\n  }\n\n  /**\n   * Calculate the count of the list manually using recursion.\n   *\n   * @param head head of the list.\n   * @return count of the list.\n   */\n  private int countRecursion(Node head) {\n    return head == null ? 0 : 1 + countRecursion(head.next);\n  }\n\n  @Override\n  public int count() {\n    return countRecursion(getHead());\n  }\n}\n","index":50},{"title":"Cursor Linked List","category":"Lists","id":"CursorLinkedList_Lists","algorithm":"package DataStructures.Lists;\n\nimport java.util.Objects;\n\npublic class CursorLinkedList<T> {\n\n  private static class Node<T> {\n\n    T element;\n    int next;\n\n    Node(T element, int next) {\n      this.element = element;\n      this.next = next;\n    }\n  }\n\n  private final int os;\n  private int head;\n  private final Node<T>[] cursorSpace;\n  private int count;\n  private static final int CURSOR_SPACE_SIZE = 100;\n\n  {\n    // init at loading time\n    cursorSpace = new Node[CURSOR_SPACE_SIZE];\n    for (int i = 0; i < CURSOR_SPACE_SIZE; i++) {\n      cursorSpace[i] = new Node<>(null, i + 1);\n    }\n    cursorSpace[CURSOR_SPACE_SIZE - 1].next = 0;\n  }\n\n  public CursorLinkedList() {\n    os = 0;\n    count = 0;\n    head = -1;\n  }\n\n  public void printList() {\n\n    if (head != -1) {\n\n      int start = head;\n      while (start != -1) {\n\n        T element = cursorSpace[start].element;\n        System.out.println(element.toString());\n        start = cursorSpace[start].next;\n      }\n    }\n  }\n\n  /**\n   * @return the logical index of the element within the list , not the actual index of the\n   *     [cursorSpace] array\n   */\n  public int indexOf(T element) {\n\n    Objects.requireNonNull(element);\n    Node<T> iterator = cursorSpace[head];\n    for (int i = 0; i < count; i++) {\n      if (iterator.element.equals(element)) {\n        return i;\n      }\n      iterator = cursorSpace[iterator.next];\n    }\n\n    return -1;\n  }\n\n  /**\n   * @param position , the logical index of the element , not the actual one within the\n   *     [cursorSpace] array . this method should be used to get the index give by indexOf() method.\n   * @return\n   */\n  public T get(int position) {\n\n    if (position >= 0 && position < count) {\n\n      int start = head;\n      int counter = 0;\n      while (start != -1) {\n\n        T element = cursorSpace[start].element;\n        if (counter == position) {\n          return element;\n        }\n\n        start = cursorSpace[start].next;\n        counter++;\n      }\n    }\n\n    return null;\n  }\n\n  public void removeByIndex(int index) {\n\n    if (index >= 0 && index < count) {\n\n      T element = get(index);\n      remove(element);\n    }\n  }\n\n  public void remove(T element) {\n\n    Objects.requireNonNull(element);\n\n    // case element is in the head\n    T temp_element = cursorSpace[head].element;\n    int temp_next = cursorSpace[head].next;\n    if (temp_element.equals(element)) {\n      free(head);\n      head = temp_next;\n    } else { // otherwise cases\n\n      int prev_index = head;\n      int current_index = cursorSpace[prev_index].next;\n\n      while (current_index != -1) {\n\n        T current_element = cursorSpace[current_index].element;\n        if (current_element.equals(element)) {\n          cursorSpace[prev_index].next = cursorSpace[current_index].next;\n          free(current_index);\n          break;\n        }\n\n        prev_index = current_index;\n        current_index = cursorSpace[prev_index].next;\n      }\n    }\n\n    count--;\n  }\n\n  private void free(int index) {\n\n    Node os_node = cursorSpace[os];\n    int os_next = os_node.next;\n    cursorSpace[os].next = index;\n    cursorSpace[index].element = null;\n    cursorSpace[index].next = os_next;\n  }\n\n  public void append(T element) {\n\n    Objects.requireNonNull(element);\n    int availableIndex = alloc();\n    cursorSpace[availableIndex].element = element;\n\n    if (head == -1) {\n      head = availableIndex;\n    }\n\n    int iterator = head;\n    while (cursorSpace[iterator].next != -1) {\n      iterator = cursorSpace[iterator].next;\n    }\n\n    cursorSpace[iterator].next = availableIndex;\n    cursorSpace[availableIndex].next = -1;\n\n    count++;\n  }\n\n  /** @return the index of the next available node */\n  private int alloc() {\n\n    // 1- get the index at which the os is pointing\n    int availableNodeIndex = cursorSpace[os].next;\n\n    if (availableNodeIndex == 0) {\n      throw new OutOfMemoryError();\n    }\n\n    // 2- make the os point to the next of the  @var{availableNodeIndex}\n    int availableNext = cursorSpace[availableNodeIndex].next;\n    cursorSpace[os].next = availableNext;\n\n    // this to indicate an end of the list , helpful at testing since any err\n    // would throw an outOfBoundException\n    cursorSpace[availableNodeIndex].next = -1;\n\n    return availableNodeIndex;\n  }\n}\n","index":51},{"title":"Doubly Linked List","category":"Lists","id":"DoublyLinkedList_Lists","algorithm":"package DataStructures.Lists;\n\n/**\n * This class implements a DoublyLinkedList. This is done using the classes LinkedList and Link.\n *\n * <p>A linked list is similar to an array, it holds values. However, links in a linked list do not\n * have indexes. With a linked list you do not need to predetermine it's size as it grows and\n * shrinks as it is edited. This is an example of a double ended, doubly linked list. Each link\n * references the next link and the previous one.\n *\n * @author Unknown\n */\npublic class DoublyLinkedList {\n  /** Head refers to the front of the list */\n  private Link head;\n  /** Tail refers to the back of the list */\n  private Link tail;\n\n  /** Size refers to the number of elements present in the list */\n  private int size;\n\n  /** Default Constructor */\n  public DoublyLinkedList() {\n    head = null;\n    tail = null;\n    size = 0;\n  }\n\n  /**\n   * Constructs a list containing the elements of the array\n   *\n   * @param array the array whose elements are to be placed into this list\n   * @throws NullPointerException if the specified collection is null\n   */\n  public DoublyLinkedList(int[] array) {\n    if (array == null) throw new NullPointerException();\n    for (int i : array) {\n      insertTail(i);\n    }\n    size = array.length;\n  }\n\n  /**\n   * Insert an element at the head\n   *\n   * @param x Element to be inserted\n   */\n  public void insertHead(int x) {\n    Link newLink = new Link(x); // Create a new link with a value attached to it\n    if (isEmpty()) // Set the first element added to be the tail\n    tail = newLink;\n    else head.previous = newLink; // newLink <-- currenthead(head)\n    newLink.next = head; // newLink <--> currenthead(head)\n    head = newLink; // newLink(head) <--> oldhead\n    ++size;\n  }\n\n  /**\n   * Insert an element at the tail\n   *\n   * @param x Element to be inserted\n   */\n  public void insertTail(int x) {\n    Link newLink = new Link(x);\n    newLink.next = null; // currentTail(tail)     newlink -->\n    if (isEmpty()) { // Check if there are no elements in list then it adds first element\n      tail = newLink;\n      head = tail;\n    } else {\n      tail.next = newLink; // currentTail(tail) --> newLink -->\n      newLink.previous = tail; // currentTail(tail) <--> newLink -->\n      tail = newLink; // oldTail <--> newLink(tail) -->\n    }\n    ++size;\n  }\n\n  /**\n   * Insert an element at the index\n   *\n   * @param x Element to be inserted\n   * @param index Index(from start) at which the element x to be inserted\n   */\n  public void insertElementByIndex(int x, int index) {\n    if (index > size) throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size: \" + size);\n    if (index == 0) {\n      insertHead(x);\n    } else {\n      if (index == size) {\n        insertTail(x);\n      } else {\n        Link newLink = new Link(x);\n        Link previousLink = head; //\n        for (int i = 1; i < index; i++) { // Loop to reach the index\n          previousLink = previousLink.next;\n        }\n        // previousLink is the Link at index - 1 from start\n        previousLink.next.previous = newLink;\n        newLink.next = previousLink.next;\n        newLink.previous = previousLink;\n        previousLink.next = newLink;\n      }\n    }\n    ++size;\n  }\n\n  /**\n   * Delete the element at the head\n   *\n   * @return The new head\n   */\n  public Link deleteHead() {\n    Link temp = head;\n    head = head.next; // oldHead <--> 2ndElement(head)\n\n    if (head == null) {\n      tail = null;\n    } else {\n      head.previous =\n          null; // oldHead --> 2ndElement(head) nothing pointing at old head so will be removed\n    }\n    --size;\n    return temp;\n  }\n\n  /**\n   * Delete the element at the tail\n   *\n   * @return The new tail\n   */\n  public Link deleteTail() {\n    Link temp = tail;\n    tail = tail.previous; // 2ndLast(tail) <--> oldTail --> null\n\n    if (tail == null) {\n      head = null;\n    } else {\n      tail.next = null; // 2ndLast(tail) --> null\n    }\n    --size;\n    return temp;\n  }\n\n  /**\n   * Delete the element from somewhere in the list\n   *\n   * @param x element to be deleted\n   * @return Link deleted\n   */\n  public void delete(int x) {\n    Link current = head;\n\n    while (current.value != x) { // Find the position to delete\n      if (current != tail) {\n        current = current.next;\n      } else { // If we reach the tail and the element is still not found\n        throw new RuntimeException(\"The element to be deleted does not exist!\");\n      }\n    }\n\n    if (current == head) deleteHead();\n    else if (current == tail) deleteTail();\n    else { // Before: 1 <--> 2(current) <--> 3\n      current.previous.next = current.next; // 1 --> 3\n      current.next.previous = current.previous; // 1 <--> 3\n    }\n    --size;\n  }\n\n  /**\n   * Inserts element and reorders\n   *\n   * @param x Element to be added\n   */\n  public void insertOrdered(int x) {\n    Link newLink = new Link(x);\n    Link current = head;\n    while (current != null && x > current.value) // Find the position to insert\n    current = current.next;\n\n    if (current == head) insertHead(x);\n    else if (current == null) insertTail(x);\n    else { // Before: 1 <--> 2(current) <--> 3\n      newLink.previous = current.previous; // 1 <-- newLink\n      current.previous.next = newLink; // 1 <--> newLink\n      newLink.next = current; // 1 <--> newLink --> 2(current) <--> 3\n      current.previous = newLink; // 1 <--> newLink <--> 2(current) <--> 3\n    }\n    ++size;\n  }\n\n  /**\n   * Deletes the passed node from the current list\n   *\n   * @param z Element to be deleted\n   */\n  public void deleteNode(Link z) {\n    if (z.next == null) {\n      deleteTail();\n    } else if (z == head) {\n      deleteHead();\n    } else { // before <-- 1 <--> 2(z) <--> 3 -->\n      z.previous.next = z.next; // 1 --> 3\n      z.next.previous = z.previous; // 1 <--> 3\n    }\n    --size;\n  }\n\n  public static void removeDuplicates(DoublyLinkedList l) {\n    Link linkOne = l.head;\n    while (linkOne.next != null) { // list is present\n      Link linkTwo = linkOne.next; // second link for comparison\n      while (linkTwo.next != null) {\n        if (linkOne.value == linkTwo.value) // if there are duplicates values then\n        l.delete(linkTwo.value); // delete the link\n        linkTwo = linkTwo.next; // go to next link\n      }\n      linkOne = linkOne.next; // go to link link to iterate the whole list again\n    }\n  }\n\n  /** Clears List */\n  public void clearList() {\n    head = null;\n    tail = null;\n    size = 0;\n  }\n\n  /**\n   * Returns true if list is empty\n   *\n   * @return true if list is empty\n   */\n  public boolean isEmpty() {\n    return (head == null);\n  }\n\n  /** Prints contents of the list */\n  public void display() { // Prints contents of the list\n    Link current = head;\n    while (current != null) {\n      current.displayLink();\n      current = current.next;\n    }\n    System.out.println();\n  }\n}\n\n/**\n * This class is used to implement the nodes of the linked list.\n *\n * @author Unknown\n */\nclass Link {\n  /** Value of node */\n  public int value;\n  /** This points to the link in front of the new link */\n  public Link next;\n  /** This points to the link behind the new link */\n  public Link previous;\n\n  /**\n   * Constructor\n   *\n   * @param value Value of node\n   */\n  public Link(int value) {\n    this.value = value;\n  }\n\n  /** Displays the node */\n  public void displayLink() {\n    System.out.print(value + \" \");\n  }\n\n  /**\n   * Main Method\n   *\n   * @param args Command line arguments\n   */\n  public static void main(String args[]) {\n    DoublyLinkedList myList = new DoublyLinkedList();\n    myList.insertHead(13);\n    myList.insertHead(7);\n    myList.insertHead(10);\n    myList.display(); // <-- 10(head) <--> 7 <--> 13(tail) -->\n\n    myList.insertTail(11);\n    myList.display(); // <-- 10(head) <--> 7 <--> 13 <--> 11(tail) -->\n\n    myList.deleteTail();\n    myList.display(); // <-- 10(head) <--> 7 <--> 13(tail) -->\n\n    myList.delete(7);\n    myList.display(); // <-- 10(head) <--> 13(tail) -->\n\n    myList.insertOrdered(23);\n    myList.insertOrdered(67);\n    myList.insertOrdered(3);\n    myList.display(); // <-- 3(head) <--> 10 <--> 13 <--> 23 <--> 67(tail) -->\n    myList.insertElementByIndex(5, 1);\n    myList.display(); // <-- 3(head) <--> 5 <--> 10 <--> 13 <--> 23 <--> 67(tail) -->\n    myList.clearList();\n    myList.display();\n    myList.insertHead(20);\n    myList.display();\n  }\n}\n","index":52},{"title":"Merge Sorted Array List","category":"Lists","id":"MergeSortedArrayList_Lists","algorithm":"package DataStructures.Lists;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/** @author https://github.com/shellhub */\npublic class MergeSortedArrayList {\n  public static void main(String[] args) {\n    List<Integer> listA = new ArrayList<>();\n    List<Integer> listB = new ArrayList<>();\n    List<Integer> listC = new ArrayList<>();\n\n    /* init ListA and List B */\n    for (int i = 1; i <= 10; i += 2) {\n      listA.add(i); /* listA: [1, 3, 5, 7, 9]  */\n      listB.add(i + 1); /* listB: [2, 4, 6, 8, 10] */\n    }\n\n    /* merge listA and listB to listC */\n    merge(listA, listB, listC);\n\n    System.out.println(\"listA: \" + listA);\n    System.out.println(\"listB: \" + listB);\n    System.out.println(\"listC: \" + listC);\n  }\n\n  /**\n   * merge two sorted ArrayList\n   *\n   * @param listA the first list to merge\n   * @param listB the second list to merge\n   * @param listC the result list after merging\n   */\n  public static void merge(List<Integer> listA, List<Integer> listB, List<Integer> listC) {\n    int pa = 0; /* the index of listA */\n    int pb = 0; /* the index of listB */\n\n    while (pa < listA.size() && pb < listB.size()) {\n      if (listA.get(pa) <= listB.get(pb)) {\n        listC.add(listA.get(pa++));\n      } else {\n        listC.add(listB.get(pb++));\n      }\n    }\n\n    /* copy left element of listA to listC */\n    while (pa < listA.size()) {\n      listC.add(listA.get(pa++));\n    }\n\n    /* copy left element of listB to listC */\n    while (pb < listB.size()) {\n      listC.add(listB.get(pb++));\n    }\n  }\n}\n","index":53},{"title":"Merge Sorted Singly Linked List","category":"Lists","id":"MergeSortedSinglyLinkedList_Lists","algorithm":"package DataStructures.Lists;\n\npublic class MergeSortedSinglyLinkedList extends SinglyLinkedList {\n\n  public static void main(String[] args) {\n    SinglyLinkedList listA = new SinglyLinkedList();\n    SinglyLinkedList listB = new SinglyLinkedList();\n\n    for (int i = 2; i <= 10; i += 2) {\n      listA.insert(i);\n      listB.insert(i - 1);\n    }\n    assert listA.toString().equals(\"2->4->6->8->10\");\n    assert listB.toString().equals(\"1->3->5->7->9\");\n    assert merge(listA, listB).toString().equals(\"1->2->3->4->5->6->7->8->9->10\");\n  }\n\n  /**\n   * Merge two sorted SingleLinkedList\n   *\n   * @param listA the first sorted list\n   * @param listB the second sored list\n   * @return merged sorted list\n   */\n  public static SinglyLinkedList merge(SinglyLinkedList listA, SinglyLinkedList listB) {\n    Node headA = listA.getHead();\n    Node headB = listB.getHead();\n\n    int size = listA.size() + listB.size();\n\n    Node head = new Node();\n    Node tail = head;\n    while (headA != null && headB != null) {\n      if (headA.value <= headB.value) {\n        tail.next = headA;\n        headA = headA.next;\n      } else {\n        tail.next = headB;\n        headB = headB.next;\n      }\n      tail = tail.next;\n    }\n    if (headA == null) {\n      tail.next = headB;\n    }\n    if (headB == null) {\n      tail.next = headA;\n    }\n    return new SinglyLinkedList(head.next, size);\n  }\n}\n","index":54},{"title":"Merge_ K_ Sorted Linkedlist","category":"Lists","id":"Merge_K_SortedLinkedlist_Lists","algorithm":"package DataStructures.Lists;\n\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\n\n/** @author Arun Pandey (https://github.com/pandeyarun709) */\npublic class Merge_K_SortedLinkedlist {\n\n  /**\n   * This function merge K sorted LinkedList\n   *\n   * @param a array of LinkedList\n   * @param N size of array\n   * @return node\n   */\n  Node mergeKList(Node[] a, int N) {\n    // Min Heap\n    PriorityQueue<Node> min = new PriorityQueue<>(Comparator.comparingInt(x -> x.data));\n\n    // adding head of all linkedList in min heap\n    min.addAll(Arrays.asList(a).subList(0, N));\n\n    // Make new head among smallest heads in K linkedList\n    Node head = min.poll();\n    min.add(head.next);\n    Node curr = head;\n\n    // merging LinkedList\n    while (!min.isEmpty()) {\n\n      Node temp = min.poll();\n      curr.next = temp;\n      curr = temp;\n\n      // Add Node in min Heap only if temp.next is not null\n      if (temp.next != null) {\n        min.add(temp.next);\n      }\n    }\n\n    return head;\n  }\n\n  private class Node {\n    private int data;\n    private Node next;\n\n    public Node(int d) {\n      this.data = d;\n      next = null;\n    }\n  }\n}\n","index":55},{"title":"Search Singly Linked List Recursion","category":"Lists","id":"SearchSinglyLinkedListRecursion_Lists","algorithm":"package DataStructures.Lists;\n\npublic class SearchSinglyLinkedListRecursion extends SinglyLinkedList {\n  public static void main(String[] args) {\n    SearchSinglyLinkedListRecursion list = new SearchSinglyLinkedListRecursion();\n    for (int i = 1; i <= 10; ++i) {\n      list.insert(i);\n    }\n\n    for (int i = 1; i <= 10; ++i) {\n      assert list.search(i);\n    }\n    assert !list.search(-1) && !list.search(100);\n  }\n\n  /**\n   * Test if the value key is present in the list using recursion.\n   *\n   * @param node the head node.\n   * @param key the value to be searched.\n   * @return {@code true} if key is present in the list, otherwise {@code false}.\n   */\n  private boolean searchRecursion(Node node, int key) {\n    return node != null && (node.value == key || searchRecursion(node.next, key));\n  }\n\n  @Override\n  public boolean search(int key) {\n    return searchRecursion(getHead(), key);\n  }\n}\n","index":56},{"title":"Singly Linked List","category":"Lists","id":"SinglyLinkedList_Lists","algorithm":"package DataStructures.Lists;\n\nimport java.util.StringJoiner;\n\n/** https://en.wikipedia.org/wiki/Linked_list */\npublic class SinglyLinkedList {\n  /** Head refer to the front of the list */\n  private Node head;\n\n  /** Size of SinglyLinkedList */\n  private int size;\n\n  /** Init SinglyLinkedList */\n  public SinglyLinkedList() {\n    head = null;\n    size = 0;\n  }\n\n  /**\n   * Init SinglyLinkedList with specified head node and size\n   *\n   * @param head the head node of list\n   * @param size the size of list\n   */\n  public SinglyLinkedList(Node head, int size) {\n    this.head = head;\n    this.size = size;\n  }\n\n  /**\n   * Inserts an element at the head of the list\n   *\n   * @param x element to be added\n   */\n  public void insertHead(int x) {\n    insertNth(x, 0);\n  }\n\n  /**\n   * Insert an element at the tail of the list\n   *\n   * @param data element to be added\n   */\n  public void insert(int data) {\n    insertNth(data, size);\n  }\n\n  /**\n   * Inserts a new node at a specified position of the list\n   *\n   * @param data data to be stored in a new node\n   * @param position position at which a new node is to be inserted\n   */\n  public void insertNth(int data, int position) {\n    checkBounds(position, 0, size);\n    Node newNode = new Node(data);\n    if (head == null) {\n      /* the list is empty */\n      head = newNode;\n      size++;\n      return;\n    } else if (position == 0) {\n      /* insert at the head of the list */\n      newNode.next = head;\n      head = newNode;\n      size++;\n      return;\n    }\n    Node cur = head;\n    for (int i = 0; i < position - 1; ++i) {\n      cur = cur.next;\n    }\n    newNode.next = cur.next;\n    cur.next = newNode;\n    size++;\n  }\n\n  /** Deletes a node at the head */\n  public void deleteHead() {\n    deleteNth(0);\n  }\n\n  /** Deletes an element at the tail */\n  public void delete() {\n    deleteNth(size - 1);\n  }\n\n  /** Deletes an element at Nth position */\n  public void deleteNth(int position) {\n    checkBounds(position, 0, size - 1);\n    if (position == 0) {\n      Node destroy = head;\n      head = head.next;\n      destroy = null; /* clear to let GC do its work */\n      size--;\n      return;\n    }\n    Node cur = head;\n    for (int i = 0; i < position - 1; ++i) {\n      cur = cur.next;\n    }\n\n    Node destroy = cur.next;\n    cur.next = cur.next.next;\n    destroy = null; // clear to let GC do its work\n\n    size--;\n  }\n\n  /**\n   * @param position to check position\n   * @param low low index\n   * @param high high index\n   * @throws IndexOutOfBoundsException if {@code position} not in range {@code low} to {@code high}\n   */\n  public void checkBounds(int position, int low, int high) {\n    if (position > high || position < low) {\n      throw new IndexOutOfBoundsException(position + \"\");\n    }\n  }\n\n  /** Clear all nodes in the list */\n  public void clear() {\n    Node cur = head;\n    while (cur != null) {\n      Node prev = cur;\n      cur = cur.next;\n      prev = null; // clear to let GC do its work\n    }\n    head = null;\n    size = 0;\n  }\n\n  /**\n   * Checks if the list is empty\n   *\n   * @return {@code true} if list is empty, otherwise {@code false}.\n   */\n  public boolean isEmpty() {\n    return size == 0;\n  }\n\n  /**\n   * Returns the size of the linked list.\n   *\n   * @return the size of the list.\n   */\n  public int size() {\n    return size;\n  }\n\n  /**\n   * Get head of the list.\n   *\n   * @return head of the list.\n   */\n  public Node getHead() {\n    return head;\n  }\n\n  /**\n   * Calculate the count of the list manually\n   *\n   * @return count of the list\n   */\n  public int count() {\n    int count = 0;\n    Node cur = head;\n    while (cur != null) {\n      cur = cur.next;\n      count++;\n    }\n    return count;\n  }\n\n  /**\n   * Test if the value key is present in the list.\n   *\n   * @param key the value to be searched.\n   * @return {@code true} if key is present in the list, otherwise {@code false}.\n   */\n  public boolean search(int key) {\n    Node cur = head;\n    while (cur != null) {\n      if (cur.value == key) {\n        return true;\n      }\n      cur = cur.next;\n    }\n    return false;\n  }\n\n  /**\n   * Return element at special index.\n   *\n   * @param index given index of element\n   * @return element at special index.\n   */\n  public int getNth(int index) {\n    checkBounds(index, 0, size - 1);\n    Node cur = head;\n    for (int i = 0; i < index; ++i) {\n      cur = cur.next;\n    }\n    return cur.value;\n  }\n\n  @Override\n  public String toString() {\n    StringJoiner joiner = new StringJoiner(\"->\");\n    Node cur = head;\n    while (cur != null) {\n      joiner.add(cur.value + \"\");\n      cur = cur.next;\n    }\n    return joiner.toString();\n  }\n\n  /** Driver Code */\n  public static void main(String[] arg) {\n    SinglyLinkedList list = new SinglyLinkedList();\n    assert list.isEmpty();\n    assert list.size() == 0 && list.count() == 0;\n    assert list.toString().equals(\"\");\n\n    /* Test insert function */\n    list.insertHead(5);\n    list.insertHead(7);\n    list.insertHead(10);\n    list.insert(3);\n    list.insertNth(1, 4);\n    assert list.toString().equals(\"10->7->5->3->1\");\n\n    /* Test search function */\n    assert list.search(10) && list.search(5) && list.search(1) && !list.search(100);\n\n    /* Test get function */\n    assert list.getNth(0) == 10 && list.getNth(2) == 5 && list.getNth(4) == 1;\n\n    /* Test delete function */\n    list.deleteHead();\n    list.deleteNth(1);\n    list.delete();\n    assert list.toString().equals(\"7->3\");\n\n    assert list.size == 2 && list.size() == list.count();\n\n    list.clear();\n    assert list.isEmpty();\n\n    try {\n      list.delete();\n      assert false; /* this should not happen */\n    } catch (Exception e) {\n      assert true; /* this should happen */\n    }\n  }\n}\n\n/**\n * This class is the nodes of the SinglyLinked List. They consist of a value and a pointer to the\n * node after them.\n */\nclass Node {\n  /** The value of the node */\n  int value;\n\n  /** Point to the next node */\n  Node next;\n\n  Node() {}\n\n  /**\n   * Constructor\n   *\n   * @param value Value to be put in the node\n   */\n  Node(int value) {\n    this(value, null);\n  }\n\n  /**\n   * Constructor\n   *\n   * @param value Value to be put in the node\n   * @param next Reference to the next node\n   */\n  Node(int value, Node next) {\n    this.value = value;\n    this.next = next;\n  }\n}\n","index":57},{"title":"Queues","category":"DataStructures","id":"Queues","index":58},{"title":"Generic Array List Queue","category":"Queues","id":"GenericArrayListQueue_Queues","algorithm":"package DataStructures.Queues;\n\nimport java.util.ArrayList;\n\n/**\n * This class implements a GenericArrayListQueue.\n *\n * <p>A GenericArrayListQueue data structure functions the same as any specific-typed queue. The\n * GenericArrayListQueue holds elemets of types to-be-specified at runtime. The elements that are\n * added first are the first to be removed (FIFO) New elements are added to the back/rear of the\n * queue.\n */\npublic class GenericArrayListQueue<T> {\n  /** The generic ArrayList for the queue T is the generic element */\n  ArrayList<T> _queue = new ArrayList<T>();\n\n  /**\n   * Checks if the queue has elements (not empty)\n   *\n   * @return True if the queue has elements. False otherwise.\n   */\n  private boolean hasElements() {\n    return !_queue.isEmpty();\n  }\n\n  /**\n   * Checks what's at the front of the queue\n   *\n   * @return If queue is not empty, element at the front of the queue. Otherwise, null\n   */\n  public T peek() {\n    T result = null;\n    if (this.hasElements()) {\n      result = _queue.get(0);\n    }\n    return result;\n  }\n\n  /**\n   * Inserts an element of type T to the queue.\n   *\n   * @param element of type T to be added\n   * @return True if the element was added successfully\n   */\n  public boolean add(T element) {\n    return _queue.add(element);\n  }\n\n  /**\n   * Retrieve what's at the front of the queue\n   *\n   * @return If queue is not empty, element retrieved. Otherwise, null\n   */\n  public T poll() {\n    T result = null;\n    if (this.hasElements()) {\n      result = _queue.remove(0);\n    }\n    return result;\n  }\n\n  /**\n   * Main method\n   *\n   * @param args Command line arguments\n   */\n  public static void main(String[] args) {\n    GenericArrayListQueue<Integer> queue = new GenericArrayListQueue<Integer>();\n    System.out.println(\"Running...\");\n    assert queue.peek() == null;\n    assert queue.poll() == null;\n    assert queue.add(1) == true;\n    assert queue.peek() == 1;\n    assert queue.add(2) == true;\n    assert queue.peek() == 1;\n    assert queue.poll() == 1;\n    assert queue.peek() == 2;\n    assert queue.poll() == 2;\n    assert queue.peek() == null;\n    assert queue.poll() == null;\n    System.out.println(\"Finished.\");\n  }\n}\n","index":59},{"title":"Linked Queue","category":"Queues","id":"LinkedQueue_Queues","algorithm":"package DataStructures.Queues;\n\nimport java.util.NoSuchElementException;\n\npublic class LinkedQueue {\n  class Node {\n    int data;\n    Node next;\n\n    public Node() {\n      this(0);\n    }\n\n    public Node(int data) {\n      this(data, null);\n    }\n\n    public Node(int data, Node next) {\n      this.data = data;\n      this.next = next;\n    }\n  }\n\n  /** Front of Queue */\n  private Node front;\n\n  /** Rear of Queue */\n  private Node rear;\n\n  /** Size of Queue */\n  private int size;\n\n  /** Init LinkedQueue */\n  public LinkedQueue() {\n    front = rear = new Node();\n  }\n\n  /**\n   * Check if queue is empty\n   *\n   * @return <tt>true</tt> if queue is empty, otherwise <tt>false</tt>\n   */\n  public boolean isEmpty() {\n    return size == 0;\n  }\n\n  /**\n   * Add element to rear of queue\n   *\n   * @param data insert value\n   * @return <tt>true</tt> if add successfully\n   */\n  public boolean enqueue(int data) {\n    Node newNode = new Node(data);\n    rear.next = newNode;\n    rear = newNode; /* make rear point at last node */\n    size++;\n    return true;\n  }\n\n  /**\n   * Remove element at the front of queue\n   *\n   * @return element at the front of queue\n   */\n  public int dequeue() {\n    if (isEmpty()) {\n      throw new NoSuchElementException(\"queue is empty\");\n    }\n    Node destroy = front.next;\n    int retValue = destroy.data;\n    front.next = front.next.next;\n    destroy = null; /* clear let GC do it's work */\n    size--;\n\n    if (isEmpty()) {\n      front = rear;\n    }\n\n    return retValue;\n  }\n\n  /**\n   * Peek element at the front of queue without removing\n   *\n   * @return element at the front\n   */\n  public int peekFront() {\n    if (isEmpty()) {\n      throw new NoSuchElementException(\"queue is empty\");\n    }\n    return front.next.data;\n  }\n\n  /**\n   * Peek element at the rear of queue without removing\n   *\n   * @return element at the front\n   */\n  public int peekRear() {\n    if (isEmpty()) {\n      throw new NoSuchElementException(\"queue is empty\");\n    }\n    return rear.data;\n  }\n\n  /**\n   * Return size of queue\n   *\n   * @return size of queue\n   */\n  public int size() {\n    return size;\n  }\n\n  /** Clear all nodes in queue */\n  public void clear() {\n    while (!isEmpty()) {\n      dequeue();\n    }\n  }\n\n  @Override\n  public String toString() {\n    if (isEmpty()) {\n      return \"[]\";\n    }\n    StringBuilder builder = new StringBuilder();\n    Node cur = front.next;\n    builder.append(\"[\");\n    while (cur != null) {\n      builder.append(cur.data).append(\", \");\n      cur = cur.next;\n    }\n    builder.replace(builder.length() - 2, builder.length(), \"]\");\n    return builder.toString();\n  }\n\n  /* Driver Code */\n  public static void main(String[] args) {\n    LinkedQueue queue = new LinkedQueue();\n    assert queue.isEmpty();\n\n    queue.enqueue(1); /* 1 */\n    queue.enqueue(2); /* 1 2 */\n    queue.enqueue(3); /* 1 2 3 */\n    System.out.println(queue); /* [1, 2, 3] */\n\n    assert queue.size() == 3;\n    assert queue.dequeue() == 1;\n    assert queue.peekFront() == 2;\n    assert queue.peekRear() == 3;\n\n    queue.clear();\n    assert queue.isEmpty();\n\n    System.out.println(queue); /* [] */\n  }\n}\n","index":60},{"title":"Priority Queues","category":"Queues","id":"PriorityQueues_Queues","algorithm":"package DataStructures.Queues;\n\n/**\n * This class implements a PriorityQueue.\n *\n * <p>A priority queue adds elements into positions based on their priority. So the most important\n * elements are placed at the front/on the top. In this example I give numbers that are bigger, a\n * higher priority. Queues in theory have no fixed size but when using an array implementation it\n * does.\n */\nclass PriorityQueue {\n  /** The max size of the queue */\n  private int maxSize;\n  /** The array for the queue */\n  private int[] queueArray;\n  /** How many items are in the queue */\n  private int nItems;\n\n  /**\n   * Constructor\n   *\n   * @param size Size of the queue\n   */\n  public PriorityQueue(int size) {\n    maxSize = size;\n    queueArray = new int[size];\n    nItems = 0;\n  }\n\n  /**\n   * Inserts an element in it's appropriate place\n   *\n   * @param value Value to be inserted\n   */\n  public void insert(int value) {\n    if (isFull()) {\n      throw new RuntimeException(\"Queue is full\");\n    } else {\n      int j = nItems - 1; // index of last element\n      while (j >= 0 && queueArray[j] > value) {\n        queueArray[j + 1] = queueArray[j]; // Shifts every element up to make room for insertion\n        j--;\n      }\n      queueArray[j + 1] = value; // Once the correct position is found the value is inserted\n      nItems++;\n    }\n  }\n\n  /**\n   * Remove the element from the front of the queue\n   *\n   * @return The element removed\n   */\n  public int remove() {\n    return queueArray[--nItems];\n  }\n\n  /**\n   * Checks what's at the front of the queue\n   *\n   * @return element at the front of the queue\n   */\n  public int peek() {\n    return queueArray[nItems - 1];\n  }\n\n  /**\n   * Returns true if the queue is empty\n   *\n   * @return true if the queue is empty\n   */\n  public boolean isEmpty() {\n    return (nItems == 0);\n  }\n\n  /**\n   * Returns true if the queue is full\n   *\n   * @return true if the queue is full\n   */\n  public boolean isFull() {\n    return (nItems == maxSize);\n  }\n\n  /**\n   * Returns the number of elements in the queue\n   *\n   * @return number of elements in the queue\n   */\n  public int getSize() {\n    return nItems;\n  }\n}\n\n/**\n * This class implements the PriorityQueue class above.\n *\n * @author Unknown\n */\npublic class PriorityQueues {\n  /**\n   * Main method\n   *\n   * @param args Command Line Arguments\n   */\n  public static void main(String[] args) {\n    PriorityQueue myQueue = new PriorityQueue(4);\n    myQueue.insert(10);\n    myQueue.insert(2);\n    myQueue.insert(5);\n    myQueue.insert(3);\n    // [2, 3, 5, 10] Here higher numbers have higher priority, so they are on the top\n\n    for (int i = 3; i >= 0; i--)\n      System.out.print(\n          myQueue.remove() + \" \"); // will print the queue in reverse order [10, 5, 3, 2]\n\n    // As you can see, a Priority Queue can be used as a sorting algotithm\n  }\n}\n","index":61},{"title":"Queues","category":"Queues","id":"Queues_Queues","algorithm":"package DataStructures.Queues;\n\n/**\n * This implements Queues by using the class Queue.\n *\n * <p>A queue data structure functions the same as a real world queue. The elements that are added\n * first are the first to be removed. New elements are added to the back/rear of the queue.\n */\nclass Queue {\n  /** Default initial capacity. */\n  private static final int DEFAULT_CAPACITY = 10;\n\n  /** Max size of the queue */\n  private int maxSize;\n  /** The array representing the queue */\n  private int[] queueArray;\n  /** Front of the queue */\n  private int front;\n  /** Rear of the queue */\n  private int rear;\n  /** How many items are in the queue */\n  private int nItems;\n\n  /** init with DEFAULT_CAPACITY */\n  public Queue() {\n    this(DEFAULT_CAPACITY);\n  }\n\n  /**\n   * Constructor\n   *\n   * @param size Size of the new queue\n   */\n  public Queue(int size) {\n    maxSize = size;\n    queueArray = new int[size];\n    front = 0;\n    rear = -1;\n    nItems = 0;\n  }\n\n  /**\n   * Inserts an element at the rear of the queue\n   *\n   * @param x element to be added\n   * @return True if the element was added successfully\n   */\n  public boolean insert(int x) {\n    if (isFull()) return false;\n    // If the back of the queue is the end of the array wrap around to the front\n    rear = (rear + 1) % maxSize;\n    queueArray[rear] = x;\n    nItems++;\n    return true;\n  }\n\n  /**\n   * Remove an element from the front of the queue\n   *\n   * @return the new front of the queue\n   */\n  public int remove() {\n    if (isEmpty()) {\n      return -1;\n    }\n    int temp = queueArray[front];\n    front = (front + 1) % maxSize;\n    nItems--;\n    return temp;\n  }\n\n  /**\n   * Checks what's at the front of the queue\n   *\n   * @return element at the front of the queue\n   */\n  public int peekFront() {\n    return queueArray[front];\n  }\n\n  /**\n   * Checks what's at the rear of the queue\n   *\n   * @return element at the rear of the queue\n   */\n  public int peekRear() {\n    return queueArray[rear];\n  }\n\n  /**\n   * Returns true if the queue is empty\n   *\n   * @return true if the queue is empty\n   */\n  public boolean isEmpty() {\n    return nItems == 0;\n  }\n\n  /**\n   * Returns true if the queue is full\n   *\n   * @return true if the queue is full\n   */\n  public boolean isFull() {\n    return nItems == maxSize;\n  }\n\n  /**\n   * Returns the number of elements in the queue\n   *\n   * @return number of elements in the queue\n   */\n  public int getSize() {\n    return nItems;\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"[\");\n    for (int i = front; ; i = ++i % maxSize) {\n      sb.append(queueArray[i]).append(\", \");\n      if (i == rear) {\n        break;\n      }\n    }\n    sb.replace(sb.length() - 2, sb.length(), \"]\");\n    return sb.toString();\n  }\n}\n\n/**\n * This class is the example for the Queue class\n *\n * @author Unknown\n */\npublic class Queues {\n  /**\n   * Main method\n   *\n   * @param args Command line arguments\n   */\n  public static void main(String[] args) {\n    Queue myQueue = new Queue(4);\n    myQueue.insert(10);\n    myQueue.insert(2);\n    myQueue.insert(5);\n    myQueue.insert(3);\n    // [10(front), 2, 5, 3(rear)]\n\n    System.out.println(myQueue.isFull()); // Will print true\n\n    myQueue.remove(); // Will make 2 the new front, making 10 no longer part of the queue\n    // [10, 2(front), 5, 3(rear)]\n\n    myQueue.insert(7); // Insert 7 at the rear which will be index 0 because of wrap around\n    // [7(rear), 2(front), 5, 3]\n\n    System.out.println(myQueue.peekFront()); // Will print 2\n    System.out.println(myQueue.peekRear()); // Will print 7\n    System.out.println(myQueue.toString()); // Will print [2, 5, 3, 7]\n  }\n}\n","index":62},{"title":"Stacks","category":"DataStructures","id":"Stacks","index":63},{"title":"Balanced Brackets","category":"Stacks","id":"BalancedBrackets_Stacks","algorithm":"package DataStructures.Stacks;\n\nimport java.util.Stack;\n\n/**\n * The nested brackets problem is a problem that determines if a sequence of brackets are properly\n * nested. A sequence of brackets s is considered properly nested if any of the following conditions\n * are true: - s is empty - s has the form (U) or [U] or {U} where U is a properly nested string - s\n * has the form VW where V and W are properly nested strings For example, the string \"()()[()]\" is\n * properly nested but \"[(()]\" is not. The function called is_balanced takes as input a string S\n * which is a sequence of brackets and returns true if S is nested and false otherwise.\n *\n * @author akshay sharma\n * @author <a href=\"https://github.com/khalil2535\">khalil2535<a>\n * @author shellhub\n */\nclass BalancedBrackets {\n\n  /**\n   * Check if {@code leftBracket} and {@code rightBracket} is paired or not\n   *\n   * @param leftBracket left bracket\n   * @param rightBracket right bracket\n   * @return {@code true} if {@code leftBracket} and {@code rightBracket} is paired, otherwise\n   *     {@code false}\n   */\n  public static boolean isPaired(char leftBracket, char rightBracket) {\n    char[][] pairedBrackets = {\n      {'(', ')'},\n      {'[', ']'},\n      {'{', '}'},\n      {'<', '>'}\n    };\n    for (char[] pairedBracket : pairedBrackets) {\n      if (pairedBracket[0] == leftBracket && pairedBracket[1] == rightBracket) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Check if {@code brackets} is balanced\n   *\n   * @param brackets the brackets\n   * @return {@code true} if {@code brackets} is balanced, otherwise {@code false}\n   */\n  public static boolean isBalanced(String brackets) {\n    if (brackets == null) {\n      throw new IllegalArgumentException(\"brackets is null\");\n    }\n    Stack<Character> bracketsStack = new Stack<>();\n    for (char bracket : brackets.toCharArray()) {\n      switch (bracket) {\n        case '(':\n        case '[':\n        case '{':\n          bracketsStack.push(bracket);\n          break;\n        case ')':\n        case ']':\n        case '}':\n          if (bracketsStack.isEmpty() || !isPaired(bracketsStack.pop(), bracket)) {\n            return false;\n          }\n          break;\n        default: /* other character is invalid */\n          return false;\n      }\n    }\n    return bracketsStack.isEmpty();\n  }\n\n  public static void main(String[] args) {\n    assert isBalanced(\"[()]{}{[()()]()}\");\n    assert !isBalanced(\"[(])\");\n  }\n}\n","index":64},{"title":"Decimal To Any Using Stack","category":"Stacks","id":"DecimalToAnyUsingStack_Stacks","algorithm":"package DataStructures.Stacks;\n\nimport java.util.Stack;\n\npublic class DecimalToAnyUsingStack {\n  public static void main(String[] args) {\n    assert convert(0, 2).equals(\"0\");\n    assert convert(30, 2).equals(\"11110\");\n    assert convert(30, 8).equals(\"36\");\n    assert convert(30, 10).equals(\"30\");\n    assert convert(30, 16).equals(\"1E\");\n  }\n\n  /**\n   * Convert decimal number to another radix\n   *\n   * @param number the number to be converted\n   * @param radix the radix\n   * @return another radix\n   * @throws ArithmeticException if <tt>number</tt> or <tt>radius</tt> is invalid\n   */\n  private static String convert(int number, int radix) {\n    if (radix < 2 || radix > 16) {\n      throw new ArithmeticException(\n          String.format(\"Invalid input -> number:%d,radius:%d\", number, radix));\n    }\n    char[] tables = {\n      '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'\n    };\n    Stack<Character> bits = new Stack<>();\n    do {\n      bits.push(tables[number % radix]);\n      number = number / radix;\n    } while (number != 0);\n\n    StringBuilder result = new StringBuilder();\n    while (!bits.isEmpty()) {\n      result.append(bits.pop());\n    }\n    return result.toString();\n  }\n}\n","index":65},{"title":"Infix To Postfix","category":"Stacks","id":"InfixToPostfix_Stacks","algorithm":"package DataStructures.Stacks;\n\nimport java.util.Stack;\n\npublic class InfixToPostfix {\n  public static void main(String[] args) throws Exception {\n    assert \"32+\".equals(infix2PostFix(\"3+2\"));\n    assert \"123++\".equals(infix2PostFix(\"1+(2+3)\"));\n    assert \"34+5*6-\".equals(infix2PostFix(\"(3+4)*5-6\"));\n  }\n\n  public static String infix2PostFix(String infixExpression) throws Exception {\n    if (!BalancedBrackets.isBalanced(infixExpression)) {\n      throw new Exception(\"invalid expression\");\n    }\n    StringBuilder output = new StringBuilder();\n    Stack<Character> stack = new Stack<>();\n    for (char element : infixExpression.toCharArray()) {\n      if (Character.isLetterOrDigit(element)) {\n        output.append(element);\n      } else if (element == '(') {\n        stack.push(element);\n      } else if (element == ')') {\n        while (!stack.isEmpty() && stack.peek() != '(') {\n          output.append(stack.pop());\n        }\n        stack.pop();\n      } else {\n        while (!stack.isEmpty() && precedence(element) <= precedence(stack.peek())) {\n          output.append(stack.pop());\n        }\n        stack.push(element);\n      }\n    }\n    while (!stack.isEmpty()) {\n      output.append(stack.pop());\n    }\n    return output.toString();\n  }\n\n  private static int precedence(char operator) {\n    switch (operator) {\n      case '+':\n      case '-':\n        return 0;\n      case '*':\n      case '/':\n        return 1;\n      case '^':\n        return 2;\n      default:\n        return -1;\n    }\n  }\n}\n","index":66},{"title":"Node Stack","category":"Stacks","id":"NodeStack_Stacks","algorithm":"package DataStructures.Stacks;\n/**\n * Implementation of a stack using nodes. Unlimited size, no arraylist.\n *\n * @author Kyler Smith, 2017\n */\npublic class NodeStack<Item> {\n\n  /** Entry point for the program. */\n  public static void main(String[] args) {\n    NodeStack<Integer> Stack = new NodeStack<Integer>();\n\n    Stack.push(3);\n    Stack.push(4);\n    Stack.push(5);\n    System.out.println(\"Testing :\");\n    Stack.print(); // prints : 5 4 3\n\n    Integer x = Stack.pop(); // x = 5\n    Stack.push(1);\n    Stack.push(8);\n    Integer y = Stack.peek(); // y = 8\n    System.out.println(\"Testing :\");\n    Stack.print(); // prints : 8 1 4 3\n\n    System.out.println(\"Testing :\");\n    System.out.println(\"x : \" + x);\n    System.out.println(\"y : \" + y);\n  }\n\n  /**\n   * Information each node should contain.\n   *\n   * @value data : information of the value in the node\n   * @value head : the head of the stack\n   * @value next : the next value from this node\n   * @value previous : the last value from this node\n   * @value size : size of the stack\n   */\n  private Item data;\n\n  private static NodeStack<?> head;\n  private NodeStack<?> next;\n  private NodeStack<?> previous;\n  private static int size = 0;\n\n  /** Constructors for the NodeStack. */\n  public NodeStack() {}\n\n  private NodeStack(Item item) {\n    this.data = item;\n  }\n\n  /**\n   * Put a value onto the stack.\n   *\n   * @param item : value to be put on the stack.\n   */\n  public void push(Item item) {\n\n    NodeStack<Item> newNs = new NodeStack<Item>(item);\n\n    if (this.isEmpty()) {\n      NodeStack.setHead(new NodeStack<>(item));\n      newNs.setNext(null);\n      newNs.setPrevious(null);\n    } else {\n      newNs.setPrevious(NodeStack.head);\n      NodeStack.head.setNext(newNs);\n      NodeStack.head.setHead(newNs);\n    }\n\n    NodeStack.setSize(NodeStack.getSize() + 1);\n  }\n\n  /**\n   * Value to be taken off the stack.\n   *\n   * @return item : value that is returned.\n   */\n  public Item pop() {\n\n    Item item = (Item) NodeStack.head.getData();\n\n    NodeStack.head.setHead(NodeStack.head.getPrevious());\n    NodeStack.head.setNext(null);\n\n    NodeStack.setSize(NodeStack.getSize() - 1);\n\n    return item;\n  }\n\n  /**\n   * Value that is next to be taken off the stack.\n   *\n   * @return item : the next value that would be popped off the stack.\n   */\n  public Item peek() {\n    return (Item) NodeStack.head.getData();\n  }\n\n  /**\n   * If the stack is empty or there is a value in.\n   *\n   * @return boolean : whether or not the stack has anything in it.\n   */\n  public boolean isEmpty() {\n    return NodeStack.getSize() == 0;\n  }\n\n  /**\n   * Returns the size of the stack.\n   *\n   * @return int : number of values in the stack.\n   */\n  public int size() {\n    return NodeStack.getSize();\n  }\n\n  /**\n   * Print the contents of the stack in the following format.\n   *\n   * <p>x <- head (next out) y z <- tail (first in) . . .\n   */\n  public void print() {\n    for (NodeStack<?> n = NodeStack.head; n != null; n = n.previous) {\n      System.out.println(n.getData().toString());\n    }\n  }\n\n  /** Getters and setters (private) */\n  private NodeStack<?> getHead() {\n    return NodeStack.head;\n  }\n\n  private static void setHead(NodeStack<?> ns) {\n    NodeStack.head = ns;\n  }\n\n  private NodeStack<?> getNext() {\n    return next;\n  }\n\n  private void setNext(NodeStack<?> next) {\n    this.next = next;\n  }\n\n  private NodeStack<?> getPrevious() {\n    return previous;\n  }\n\n  private void setPrevious(NodeStack<?> previous) {\n    this.previous = previous;\n  }\n\n  private static int getSize() {\n    return size;\n  }\n\n  private static void setSize(int size) {\n    NodeStack.size = size;\n  }\n\n  private Item getData() {\n    return this.data;\n  }\n\n  private void setData(Item item) {\n    this.data = item;\n  }\n}\n","index":67},{"title":"Stack Array","category":"Stacks","id":"StackArray_Stacks","algorithm":"package DataStructures.Stacks;\n\n/**\n * This class implements a Stack using a regular array.\n *\n * <p>A stack is exactly what it sounds like. An element gets added to the top of the stack and only\n * the element on the top may be removed. This is an example of an array implementation of a Stack.\n * So an element can only be added/removed from the end of the array. In theory stack have no fixed\n * size, but with an array implementation it does.\n */\npublic class StackArray {\n\n  /** Driver Code */\n  public static void main(String[] args) {\n    // Declare a stack of maximum size 4\n    StackArray myStackArray = new StackArray(4);\n\n    assert myStackArray.isEmpty();\n    assert !myStackArray.isFull();\n\n    // Populate the stack\n    myStackArray.push(5);\n    myStackArray.push(8);\n    myStackArray.push(2);\n    myStackArray.push(9);\n\n    assert !myStackArray.isEmpty();\n    assert myStackArray.isFull();\n    assert myStackArray.peek() == 9;\n    assert myStackArray.pop() == 9;\n    assert myStackArray.peek() == 2;\n    assert myStackArray.size() == 3;\n  }\n\n  /** Default initial capacity. */\n  private static final int DEFAULT_CAPACITY = 10;\n\n  /** The max size of the Stack */\n  private int maxSize;\n\n  /** The array representation of the Stack */\n  private int[] stackArray;\n\n  /** The top of the stack */\n  private int top;\n\n  /** init Stack with DEFAULT_CAPACITY */\n  public StackArray() {\n    this(DEFAULT_CAPACITY);\n  }\n\n  /**\n   * Constructor\n   *\n   * @param size Size of the Stack\n   */\n  public StackArray(int size) {\n    maxSize = size;\n    stackArray = new int[maxSize];\n    top = -1;\n  }\n\n  /**\n   * Adds an element to the top of the stack\n   *\n   * @param value The element added\n   */\n  public void push(int value) {\n    if (!isFull()) { // Checks for a full stack\n      top++;\n      stackArray[top] = value;\n    } else {\n      resize(maxSize * 2);\n      push(value); // don't forget push after resizing\n    }\n  }\n\n  /**\n   * Removes the top element of the stack and returns the value you've removed\n   *\n   * @return value popped off the Stack\n   */\n  public int pop() {\n    if (!isEmpty()) { // Checks for an empty stack\n      return stackArray[top--];\n    }\n\n    if (top < maxSize / 4) {\n      resize(maxSize / 2);\n      return pop(); // don't forget pop after resizing\n    } else {\n      System.out.println(\"The stack is already empty\");\n      return -1;\n    }\n  }\n\n  /**\n   * Returns the element at the top of the stack\n   *\n   * @return element at the top of the stack\n   */\n  public int peek() {\n    if (!isEmpty()) { // Checks for an empty stack\n      return stackArray[top];\n    } else {\n      System.out.println(\"The stack is empty, cant peek\");\n      return -1;\n    }\n  }\n\n  private void resize(int newSize) {\n    int[] transferArray = new int[newSize];\n\n    for (int i = 0; i < stackArray.length; i++) {\n      transferArray[i] = stackArray[i];\n    }\n    // This reference change might be nice in here\n    stackArray = transferArray;\n    maxSize = newSize;\n  }\n\n  /**\n   * Returns true if the stack is empty\n   *\n   * @return true if the stack is empty\n   */\n  public boolean isEmpty() {\n    return (top == -1);\n  }\n\n  /**\n   * Returns true if the stack is full\n   *\n   * @return true if the stack is full\n   */\n  public boolean isFull() {\n    return (top + 1 == maxSize);\n  }\n\n  /**\n   * Deletes everything in the Stack\n   *\n   * <p>Doesn't delete elements in the array but if you call push method after calling makeEmpty it\n   * will overwrite previous values\n   */\n  public void makeEmpty() { // Doesn't delete elements in the array but if you call\n    top = -1; // push method after calling makeEmpty it will overwrite previous values\n  }\n\n  /**\n   * Return size of stack\n   *\n   * @return size of stack\n   */\n  public int size() {\n    return top + 1;\n  }\n}\n","index":68},{"title":"Stack Array List","category":"Stacks","id":"StackArrayList_Stacks","algorithm":"package DataStructures.Stacks;\n\nimport java.util.ArrayList;\nimport java.util.EmptyStackException;\n\n/**\n * This class implements a Stack using an ArrayList.\n *\n * <p>A stack is exactly what it sounds like. An element gets added to the top of the stack and only\n * the element on the top may be removed.\n *\n * <p>This is an ArrayList Implementation of a stack, where size is not a problem we can extend the\n * stack as much as we want.\n */\npublic class StackArrayList {\n\n  /** Driver Code */\n  public static void main(String[] args) {\n    StackArrayList stack = new StackArrayList();\n    assert stack.isEmpty();\n\n    for (int i = 1; i <= 5; ++i) {\n      stack.push(i);\n      assert stack.size() == i;\n    }\n\n    assert stack.size() == 5;\n    assert stack.peek() == 5 && stack.pop() == 5 && stack.peek() == 4;\n\n    /* pop elements at the top of this stack one by one */\n    while (!stack.isEmpty()) {\n      stack.pop();\n    }\n    assert stack.isEmpty();\n\n    try {\n      stack.pop();\n      assert false; /* this should not happen */\n    } catch (EmptyStackException e) {\n      assert true; /* this should happen */\n    }\n  }\n\n  /** ArrayList representation of the stack */\n  private ArrayList<Integer> stack;\n\n  /** Constructor */\n  public StackArrayList() {\n    stack = new ArrayList<>();\n  }\n\n  /**\n   * Adds value to the end of list which is the top for stack\n   *\n   * @param value value to be added\n   */\n  public void push(int value) {\n    stack.add(value);\n  }\n\n  /**\n   * Removes the element at the top of this stack and returns\n   *\n   * @return Element popped\n   * @throws EmptyStackException if the stack is empty.\n   */\n  public int pop() {\n    if (isEmpty()) {\n      throw new EmptyStackException();\n    }\n\n    /* remove the element on the top of the stack */\n    return stack.remove(stack.size() - 1);\n  }\n\n  /**\n   * Test if the stack is empty.\n   *\n   * @return {@code true} if this stack is empty, {@code false} otherwise.\n   */\n  public boolean isEmpty() {\n    return stack.isEmpty();\n  }\n\n  /**\n   * Return the element at the top of this stack without removing it from the stack.\n   *\n   * @return the element at the top of this stack.\n   */\n  public int peek() {\n    if (isEmpty()) {\n      throw new EmptyStackException();\n    }\n    return stack.get(stack.size() - 1);\n  }\n\n  /**\n   * Return size of this stack.\n   *\n   * @return size of this stack.\n   */\n  public int size() {\n    return stack.size();\n  }\n}\n","index":69},{"title":"Stack Of Linked List","category":"Stacks","id":"StackOfLinkedList_Stacks","algorithm":"package DataStructures.Stacks;\n\nimport java.util.NoSuchElementException;\n\n/** @author Varun Upadhyay (https://github.com/varunu28) */\n\n// An implementation of a Stack using a Linked List\n\nclass StackOfLinkedList {\n\n  public static void main(String[] args) {\n\n    LinkedListStack stack = new LinkedListStack();\n    stack.push(1);\n    stack.push(2);\n    stack.push(3);\n    stack.push(4);\n    stack.push(5);\n\n    System.out.println(stack);\n\n    System.out.println(\"Size of stack currently is: \" + stack.getSize());\n\n    assert stack.pop() == 5;\n    assert stack.pop() == 4;\n\n    System.out.println(\"Top element of stack currently is: \" + stack.peek());\n  }\n}\n\n// A node class\n\nclass Node {\n  public int data;\n  public Node next;\n\n  public Node(int data) {\n    this.data = data;\n    this.next = null;\n  }\n}\n\n/**\n * A class which implements a stack using a linked list\n *\n * <p>Contains all the stack methods : push, pop, printStack, isEmpty\n */\nclass LinkedListStack {\n\n  /** Top of stack */\n  Node head;\n\n  /** Size of stack */\n  private int size;\n\n  /** Init properties */\n  public LinkedListStack() {\n    head = null;\n    size = 0;\n  }\n\n  /**\n   * Add element at top\n   *\n   * @param x to be added\n   * @return <tt>true</tt> if add successfully\n   */\n  public boolean push(int x) {\n    Node newNode = new Node(x);\n    newNode.next = head;\n    head = newNode;\n    size++;\n    return true;\n  }\n\n  /**\n   * Pop element at top of stack\n   *\n   * @return element at top of stack\n   * @throws NoSuchElementException if stack is empty\n   */\n  public int pop() {\n    if (size == 0) {\n      throw new NoSuchElementException(\"Empty stack. Nothing to pop\");\n    }\n    Node destroy = head;\n    head = head.next;\n    int retValue = destroy.data;\n    destroy = null; // clear to let GC do it's work\n    size--;\n    return retValue;\n  }\n\n  /**\n   * Peek element at top of stack\n   *\n   * @return element at top of stack\n   * @throws NoSuchElementException if stack is empty\n   */\n  public int peek() {\n    if (size == 0) {\n      throw new NoSuchElementException(\"Empty stack. Nothing to pop\");\n    }\n    return head.data;\n  }\n\n  @Override\n  public String toString() {\n    Node cur = head;\n    StringBuilder builder = new StringBuilder();\n    while (cur != null) {\n      builder.append(cur.data).append(\"->\");\n      cur = cur.next;\n    }\n    return builder.replace(builder.length() - 2, builder.length(), \"\").toString();\n  }\n\n  /**\n   * Check if stack is empty\n   *\n   * @return <tt>true</tt> if stack is empty, otherwise <tt>false</tt>\n   */\n  public boolean isEmpty() {\n    return size == 0;\n  }\n\n  /**\n   * Return size of stack\n   *\n   * @return size of stack\n   */\n  public int getSize() {\n    return size;\n  }\n}\n","index":70},{"title":"Trees","category":"DataStructures","id":"Trees","index":71},{"title":"A V L Tree","category":"Trees","id":"AVLTree_Trees","algorithm":"package DataStructures.Trees;\n\npublic class AVLTree {\n\n  private Node root;\n\n  private class Node {\n    private int key;\n    private int balance;\n    private int height;\n    private Node left, right, parent;\n\n    Node(int k, Node p) {\n      key = k;\n      parent = p;\n    }\n  }\n\n  public boolean insert(int key) {\n    if (root == null) root = new Node(key, null);\n    else {\n      Node n = root;\n      Node parent;\n      while (true) {\n        if (n.key == key) return false;\n\n        parent = n;\n\n        boolean goLeft = n.key > key;\n        n = goLeft ? n.left : n.right;\n\n        if (n == null) {\n          if (goLeft) {\n            parent.left = new Node(key, parent);\n          } else {\n            parent.right = new Node(key, parent);\n          }\n          rebalance(parent);\n          break;\n        }\n      }\n    }\n    return true;\n  }\n\n  private void delete(Node node) {\n    if (node.left == null && node.right == null) {\n      if (node.parent == null) root = null;\n      else {\n        Node parent = node.parent;\n        if (parent.left == node) {\n          parent.left = null;\n        } else parent.right = null;\n        rebalance(parent);\n      }\n      return;\n    }\n    if (node.left != null) {\n      Node child = node.left;\n      while (child.right != null) child = child.right;\n      node.key = child.key;\n      delete(child);\n    } else {\n      Node child = node.right;\n      while (child.left != null) child = child.left;\n      node.key = child.key;\n      delete(child);\n    }\n  }\n\n  public void delete(int delKey) {\n    if (root == null) return;\n    Node node = root;\n    Node child = root;\n\n    while (child != null) {\n      node = child;\n      child = delKey >= node.key ? node.right : node.left;\n      if (delKey == node.key) {\n        delete(node);\n        return;\n      }\n    }\n  }\n\n  private void rebalance(Node n) {\n    setBalance(n);\n\n    if (n.balance == -2) {\n      if (height(n.left.left) >= height(n.left.right)) n = rotateRight(n);\n      else n = rotateLeftThenRight(n);\n\n    } else if (n.balance == 2) {\n      if (height(n.right.right) >= height(n.right.left)) n = rotateLeft(n);\n      else n = rotateRightThenLeft(n);\n    }\n\n    if (n.parent != null) {\n      rebalance(n.parent);\n    } else {\n      root = n;\n    }\n  }\n\n  private Node rotateLeft(Node a) {\n\n    Node b = a.right;\n    b.parent = a.parent;\n\n    a.right = b.left;\n\n    if (a.right != null) a.right.parent = a;\n\n    b.left = a;\n    a.parent = b;\n\n    if (b.parent != null) {\n      if (b.parent.right == a) {\n        b.parent.right = b;\n      } else {\n        b.parent.left = b;\n      }\n    }\n\n    setBalance(a, b);\n\n    return b;\n  }\n\n  private Node rotateRight(Node a) {\n\n    Node b = a.left;\n    b.parent = a.parent;\n\n    a.left = b.right;\n\n    if (a.left != null) a.left.parent = a;\n\n    b.right = a;\n    a.parent = b;\n\n    if (b.parent != null) {\n      if (b.parent.right == a) {\n        b.parent.right = b;\n      } else {\n        b.parent.left = b;\n      }\n    }\n\n    setBalance(a, b);\n\n    return b;\n  }\n\n  private Node rotateLeftThenRight(Node n) {\n    n.left = rotateLeft(n.left);\n    return rotateRight(n);\n  }\n\n  private Node rotateRightThenLeft(Node n) {\n    n.right = rotateRight(n.right);\n    return rotateLeft(n);\n  }\n\n  private int height(Node n) {\n    if (n == null) return -1;\n    return n.height;\n  }\n\n  private void setBalance(Node... nodes) {\n    for (Node n : nodes) {\n      reheight(n);\n      n.balance = height(n.right) - height(n.left);\n    }\n  }\n\n  public void printBalance() {\n    printBalance(root);\n  }\n\n  private void printBalance(Node n) {\n    if (n != null) {\n      printBalance(n.left);\n      System.out.printf(\"%s \", n.balance);\n      printBalance(n.right);\n    }\n  }\n\n  private void reheight(Node node) {\n    if (node != null) {\n      node.height = 1 + Math.max(height(node.left), height(node.right));\n    }\n  }\n\n  public boolean search(int key) {\n    Node result = searchHelper(this.root, key);\n    if (result != null) return true;\n\n    return false;\n  }\n\n  private Node searchHelper(Node root, int key) {\n    // root is null or key is present at root\n    if (root == null || root.key == key) return root;\n\n    // key is greater than root's key\n    if (root.key > key)\n      return searchHelper(root.left, key); // call the function on the node's left child\n\n    // key is less than root's key then\n    // call the function on the node's right child as it is greater\n    return searchHelper(root.right, key);\n  }\n\n  public static void main(String[] args) {\n    AVLTree tree = new AVLTree();\n\n    System.out.println(\"Inserting values 1 to 10\");\n    for (int i = 1; i < 10; i++) tree.insert(i);\n\n    System.out.print(\"Printing balance: \");\n    tree.printBalance();\n  }\n}\n","index":72},{"title":"B S T Iterative","category":"Trees","id":"BSTIterative_Trees","algorithm":"/**\n *\n *\n * <h1>Binary Search Tree (Iterative)</h1>\n *\n * <p>An implementation of BST iteratively. Binary Search Tree is a binary tree which satisfies\n * three properties: left child is less than root node, right child is grater than root node, both\n * left and right childs must themselves be a BST.\n *\n * @author [Lakhan Nad](https://github.com/Lakhan-Nad)\n */\nimport java.util.Stack;\n\npublic class BSTIterative {\n  /** Reference for the node of BST. */\n  private Node root;\n\n  /** Default Constructor Initializes the root of BST with null. */\n  BSTIterative() {\n    root = null;\n  }\n\n  /** main function for tests */\n  public static void main(String[] args) {\n    BSTIterative tree = new BSTIterative();\n    tree.add(3);\n    tree.add(2);\n    tree.add(9);\n    assert !tree.find(4) : \"4 is not yet present in BST\";\n    assert tree.find(2) : \"2 should be present in BST\";\n    tree.remove(2);\n    assert !tree.find(2) : \"2 was just deleted from BST\";\n    tree.remove(1);\n    assert !tree.find(1) : \"Since 1 was not present so find deleting would do no change\";\n    tree.add(30);\n    tree.add(40);\n    assert tree.find(40) : \"40 was inserted but not found\";\n    /*\n       Will print following order\n       3 9 30 40\n    */\n    tree.inorder();\n  }\n\n  /**\n   * A method to insert a new value in BST. If the given value is already present in BST the\n   * insertion is ignored.\n   *\n   * @param data the value to be inserted\n   */\n  public void add(int data) {\n    Node parent = null;\n    Node temp = this.root;\n    int rightOrLeft = -1;\n    /* Finds the proper place this node can\n     * be placed in according to rules of BST.\n     */\n    while (temp != null) {\n      if (temp.data > data) {\n        parent = temp;\n        temp = parent.left;\n        rightOrLeft = 0;\n      } else if (temp.data < data) {\n        parent = temp;\n        temp = parent.right;\n        rightOrLeft = 1;\n      } else {\n        System.out.println(data + \" is already present in BST.\");\n        return; // if data already present we ignore insertion\n      }\n    }\n    /* Creates a newNode with the value passed\n     * Since this data doesn't already exists\n     */\n    Node newNode = new Node(data);\n    /* If the parent node is null\n     * then the insertion is to be done in\n     * root itself.\n     */\n    if (parent == null) {\n      this.root = newNode;\n    } else {\n      /* Check if insertion is to be made in\n       * left or right subtree.\n       */\n      if (rightOrLeft == 0) {\n        parent.left = newNode;\n      } else {\n        parent.right = newNode;\n      }\n    }\n  }\n\n  /**\n   * A method to delete the node in BST. If node is present it will be deleted\n   *\n   * @param data the value that needs to be deleted\n   */\n  public void remove(int data) {\n    Node parent = null;\n    Node temp = this.root;\n    int rightOrLeft = -1;\n    /* Find the parent of the node and node itself\n     * That is to be deleted.\n     * parent variable store parent\n     * temp stores node itself.\n     * rightOrLeft use to keep track weather child\n     * is left or right subtree\n     */\n    while (temp != null) {\n      if (temp.data == data) {\n        break;\n      } else if (temp.data > data) {\n        parent = temp;\n        temp = parent.left;\n        rightOrLeft = 0;\n      } else {\n        parent = temp;\n        temp = parent.right;\n        rightOrLeft = 1;\n      }\n    }\n    /* If temp is null than node with given value is not\n     * present in our tree.\n     */\n    if (temp != null) {\n      Node replacement; // used to store the new values for replacing nodes\n      if (temp.right == null && temp.left == null) { // Leaf node Case\n        replacement = null;\n      } else if (temp.right == null) { // Node with only right child\n        replacement = temp.left;\n        temp.left = null;\n      } else if (temp.left == null) { // Node with only left child\n        replacement = temp.right;\n        temp.right = null;\n      } else {\n        /* If both left and right child are present\n         * we replace this nodes data with\n         * leftmost node's data in its right subtree\n         * to maintain the balance of BST.\n         * And then delete that node\n         */\n        if (temp.right.left == null) {\n          temp.data = temp.right.data;\n          replacement = temp;\n          temp.right = temp.right.right;\n        } else {\n          Node parent2 = temp.right;\n          Node child = temp.right.left;\n          while (child.left != null) {\n            parent2 = child;\n            child = parent2.left;\n          }\n          temp.data = child.data;\n          parent2.left = child.right;\n          replacement = temp;\n        }\n      }\n      /* Change references of parent after\n       * deleting the child.\n       */\n      if (parent == null) {\n        this.root = replacement;\n      } else {\n        if (rightOrLeft == 0) {\n          parent.left = replacement;\n        } else {\n          parent.right = replacement;\n        }\n      }\n    }\n  }\n\n  /** A method for inorder traversal of BST. */\n  public void inorder() {\n    if (this.root == null) {\n      System.out.println(\"This BST is empty.\");\n      return;\n    }\n    System.out.println(\"Inorder traversal of this tree is:\");\n    Stack<Node> st = new Stack<Node>();\n    Node cur = this.root;\n    while (cur != null || !st.empty()) {\n      while (cur != null) {\n        st.push(cur);\n        cur = cur.left;\n      }\n      cur = st.pop();\n      System.out.print(cur.data + \" \");\n      cur = cur.right;\n    }\n    System.out.println(); // for next line\n  }\n\n  /** A method used to print postorder traversal of BST. */\n  public void postorder() {\n    if (this.root == null) {\n      System.out.println(\"This BST is empty.\");\n      return;\n    }\n    System.out.println(\"Postorder traversal of this tree is:\");\n    Stack<Node> st = new Stack<Node>();\n    Node cur = this.root, temp2;\n    while (cur != null || !st.empty()) {\n      if (cur != null) {\n        st.push(cur);\n        cur = cur.left;\n      } else {\n        temp2 = st.peek();\n        if (temp2.right != null) {\n          cur = temp2.right;\n        } else {\n          st.pop();\n          while (!st.empty() && st.peek().right == temp2) {\n            System.out.print(temp2.data + \" \");\n            temp2 = st.pop();\n          }\n          System.out.print(temp2.data + \" \");\n        }\n      }\n    }\n    System.out.println(); // for next line\n  }\n\n  /** Method used to display preorder traversal of BST. */\n  public void preorder() {\n    if (this.root == null) {\n      System.out.println(\"This BST is empty.\");\n      return;\n    }\n    System.out.println(\"Preorder traversal of this tree is:\");\n    Stack<Node> st = new Stack<Node>();\n    st.push(this.root);\n    Node temp;\n    while (!st.empty()) {\n      temp = st.pop();\n      System.out.print(temp.data + \" \");\n      if (temp.right != null) {\n        st.push(temp.right);\n      }\n      if (temp.left != null) {\n        st.push(temp.left);\n      }\n    }\n    System.out.println(); // for next line\n  }\n\n  /**\n   * A method to check if given data exists in out Binary Search Tree.\n   *\n   * @param data the value that needs to be searched for\n   * @return boolean representing if the value was find\n   */\n  public boolean find(int data) {\n    Node temp = this.root;\n    /* Check if node exists\n     */\n    while (temp != null) {\n      if (temp.data > data) {\n        temp = temp.left;\n      } else if (temp.data < data) {\n        temp = temp.right;\n      } else {\n        /* If found return true\n         */\n        System.out.println(data + \" is present in the BST.\");\n        return true;\n      }\n    }\n    System.out.println(data + \" not found.\");\n    return false;\n  }\n\n  /** The Node class used for building binary search tree */\n  private static class Node {\n    int data;\n    Node left;\n    Node right;\n\n    /** Constructor with data as parameter */\n    Node(int d) {\n      data = d;\n      left = null;\n      right = null;\n    }\n  }\n}\n","index":73},{"title":"B S T Recursive","category":"Trees","id":"BSTRecursive_Trees","algorithm":"/**\n *\n *\n * <h1>Binary Search Tree (Recursive)</h1>\n *\n * An implementation of BST recursively. In recursive implementation the checks are down the tree\n * First root is checked if not found then its childs are checked Binary Search Tree is a binary\n * tree which satisfies three properties: left child is less than root node, right child is grater\n * than root node, both left and right childs must themselves be a BST.\n *\n * <p>I have made public functions as methods and to actually implement recursive approach I have\n * used private methods\n *\n * @author [Lakhan Nad](https://github.com/Lakhan-Nad)\n */\npublic class BSTRecursive {\n  /** only data member is root of BST */\n  private Node root;\n\n  /** Constructor use to initialize node as null */\n  BSTRecursive() {\n    root = null;\n  }\n\n  /** main function for tests */\n  public static void main(String[] args) {\n    BSTIterative tree = new BSTIterative();\n    tree.add(5);\n    tree.add(10);\n    tree.add(9);\n    assert !tree.find(4) : \"4 is not yet present in BST\";\n    assert tree.find(10) : \"10 should be present in BST\";\n    tree.remove(9);\n    assert !tree.find(9) : \"9 was just deleted from BST\";\n    tree.remove(1);\n    assert !tree.find(1) : \"Since 1 was not present so find deleting would do no change\";\n    tree.add(20);\n    tree.add(70);\n    assert tree.find(70) : \"70 was inserted but not found\";\n    /*\n     Will print in following order\n     5 10 20 70\n    */\n    tree.inorder();\n  }\n\n  /**\n   * Recursive method to delete a data if present in BST.\n   *\n   * @param node the current node to search for data\n   * @param data the value to be deleted\n   * @return Node the updated value of root parameter after delete operation\n   */\n  private Node delete(Node node, int data) {\n    if (node == null) {\n      System.out.println(\"No such data present in BST.\");\n    } else if (node.data > data) {\n      node.left = delete(node.left, data);\n    } else if (node.data < data) {\n      node.right = delete(node.right, data);\n    } else {\n      if (node.right == null && node.left == null) { // If it is leaf node\n        node = null;\n      } else if (node.left == null) { // If only right node is present\n        Node temp = node.right;\n        node.right = null;\n        node = temp;\n      } else if (node.right == null) { // Only left node is present\n        Node temp = node.left;\n        node.left = null;\n        node = temp;\n      } else { // both child are present\n        Node temp = node.right;\n        // Find leftmost child of right subtree\n        while (temp.left != null) {\n          temp = temp.left;\n        }\n        node.data = temp.data;\n        node.right = delete(node.right, temp.data);\n      }\n    }\n    return node;\n  }\n\n  /**\n   * Recursive insertion of value in BST.\n   *\n   * @param node to check if the data can be inserted in current node or its subtree\n   * @param data the value to be inserted\n   * @return the modified value of the root parameter after insertion\n   */\n  private Node insert(Node node, int data) {\n    if (node == null) {\n      node = new Node(data);\n    } else if (node.data > data) {\n      node.left = insert(node.left, data);\n    } else if (node.data < data) {\n      node.right = insert(node.right, data);\n    }\n    return node;\n  }\n\n  /**\n   * Recursively print Preorder traversal of the BST\n   *\n   * @param node the root node\n   */\n  private void preOrder(Node node) {\n    if (node == null) {\n      return;\n    }\n    System.out.print(node.data + \" \");\n    if (node.left != null) {\n      preOrder(node.left);\n    }\n    if (node.right != null) {\n      preOrder(node.right);\n    }\n  }\n\n  /**\n   * Recursively print Postorder travesal of BST.\n   *\n   * @param node the root node\n   */\n  private void postOrder(Node node) {\n    if (node == null) {\n      return;\n    }\n    if (node.left != null) {\n      postOrder(node.left);\n    }\n    if (node.right != null) {\n      postOrder(node.right);\n    }\n    System.out.print(node.data + \" \");\n  }\n\n  /**\n   * Recursively print Inorder traversal of BST.\n   *\n   * @param node the root node\n   */\n  private void inOrder(Node node) {\n    if (node == null) {\n      return;\n    }\n    if (node.left != null) {\n      inOrder(node.left);\n    }\n    System.out.print(node.data + \" \");\n    if (node.right != null) {\n      inOrder(node.right);\n    }\n  }\n\n  /**\n   * Serach recursively if the given value is present in BST or not.\n   *\n   * @param node the current node to check\n   * @param data the value to be checked\n   * @return boolean if data is present or not\n   */\n  private boolean search(Node node, int data) {\n    if (node == null) {\n      return false;\n    } else if (node.data == data) {\n      return true;\n    } else if (node.data > data) {\n      return search(node.left, data);\n    } else {\n      return search(node.right, data);\n    }\n  }\n\n  /**\n   * add in BST. if the value is not already present it is inserted or else no change takes place.\n   *\n   * @param data the value to be inserted\n   */\n  public void add(int data) {\n    this.root = insert(this.root, data);\n  }\n\n  /**\n   * If data is present in BST delete it else do nothing.\n   *\n   * @param data the value to be removed\n   */\n  public void remove(int data) {\n    this.root = delete(this.root, data);\n  }\n\n  /** To call inorder traversal on tree */\n  public void inorder() {\n    System.out.println(\"Inorder traversal of this tree is:\");\n    inOrder(this.root);\n    System.out.println(); // for next line\n  }\n\n  /** To call postorder traversal on tree */\n  public void postorder() {\n    System.out.println(\"Postorder traversal of this tree is:\");\n    postOrder(this.root);\n    System.out.println(); // for next li\n  }\n\n  /** To call preorder traversal on tree. */\n  public void preorder() {\n    System.out.println(\"Preorder traversal of this tree is:\");\n    preOrder(this.root);\n    System.out.println(); // for next li\n  }\n\n  /**\n   * To check if given value is present in tree or not.\n   *\n   * @param data the data to be found for\n   */\n  public boolean find(int data) {\n    if (search(this.root, data)) {\n      System.out.println(data + \" is present in given BST.\");\n      return true;\n    }\n    System.out.println(data + \" not found.\");\n    return false;\n  }\n\n  /** The Node class used for building binary search tree */\n  private static class Node {\n    int data;\n    Node left;\n    Node right;\n\n    /** Constructor with data as parameter */\n    Node(int d) {\n      data = d;\n      left = null;\n      right = null;\n    }\n  }\n}\n","index":74},{"title":"Binary Tree","category":"Trees","id":"BinaryTree_Trees","algorithm":"package DataStructures.Trees;\n\n/**\n * This entire class is used to build a Binary Tree data structure. There is the Node Class and the\n * Tree Class, both explained below.\n */\n\n/**\n * A binary tree is a data structure in which an element has two successors(children). The left\n * child is usually smaller than the parent, and the right child is usually bigger.\n *\n * @author Unknown\n */\npublic class BinaryTree {\n\n  /**\n   * This class implements the nodes that will go on the Binary Tree. They consist of the data in\n   * them, the node to the left, the node to the right, and the parent from which they came from.\n   *\n   * @author Unknown\n   */\n  class Node {\n    /** Data for the node */\n    public int data;\n    /** The Node to the left of this one */\n    public Node left;\n    /** The Node to the right of this one */\n    public Node right;\n    /** The parent of this node */\n    public Node parent;\n\n    /**\n     * Constructor of Node\n     *\n     * @param value Value to put in the node\n     */\n    public Node(int value) {\n      data = value;\n      left = null;\n      right = null;\n      parent = null;\n    }\n  }\n\n  /** The root of the Binary Tree */\n  private Node root;\n\n  /** Constructor */\n  public BinaryTree() {\n    root = null;\n  }\n\n  /**\n   * Method to find a Node with a certain value\n   *\n   * @param key Value being looked for\n   * @return The node if it finds it, otherwise returns the parent\n   */\n  public Node find(int key) {\n    Node current = root;\n    while (current != null) {\n      if (key < current.data) {\n        if (current.left == null) return current; // The key isn't exist, returns the parent\n        current = current.left;\n      } else if (key > current.data) {\n        if (current.right == null) return current;\n        current = current.right;\n      } else { // If you find the value return it\n        return current;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Inserts certain value into the Binary Tree\n   *\n   * @param value Value to be inserted\n   */\n  public void put(int value) {\n    Node newNode = new Node(value);\n    if (root == null) root = newNode;\n    else {\n      // This will return the soon to be parent of the value you're inserting\n      Node parent = find(value);\n\n      // This if/else assigns the new node to be either the left or right child of the parent\n      if (value < parent.data) {\n        parent.left = newNode;\n        parent.left.parent = parent;\n        return;\n      } else {\n        parent.right = newNode;\n        parent.right.parent = parent;\n        return;\n      }\n    }\n  }\n\n  /**\n   * Deletes a given value from the Binary Tree\n   *\n   * @param value Value to be deleted\n   * @return If the value was deleted\n   */\n  public boolean remove(int value) {\n    // temp is the node to be deleted\n    Node temp = find(value);\n\n    // If the value doesn't exist\n    if (temp.data != value) return false;\n\n    // No children\n    if (temp.right == null && temp.left == null) {\n      if (temp == root) root = null;\n\n      // This if/else assigns the new node to be either the left or right child of the parent\n      else if (temp.parent.data < temp.data) temp.parent.right = null;\n      else temp.parent.left = null;\n      return true;\n    }\n\n    // Two children\n    else if (temp.left != null && temp.right != null) {\n      Node successor = findSuccessor(temp);\n\n      // The left tree of temp is made the left tree of the successor\n      successor.left = temp.left;\n      successor.left.parent = successor;\n\n      // If the successor has a right child, the child's grandparent is it's new parent\n      if (successor.parent != temp) {\n        if (successor.right != null) {\n          successor.right.parent = successor.parent;\n          successor.parent.left = successor.right;\n          successor.right = temp.right;\n          successor.right.parent = successor;\n        } else {\n          successor.parent.left = null;\n          successor.right = temp.right;\n          successor.right.parent = successor;\n        }\n      }\n\n      if (temp == root) {\n        successor.parent = null;\n        root = successor;\n        return true;\n      }\n\n      // If you're not deleting the root\n      else {\n        successor.parent = temp.parent;\n\n        // This if/else assigns the new node to be either the left or right child of the parent\n        if (temp.parent.data < temp.data) temp.parent.right = successor;\n        else temp.parent.left = successor;\n        return true;\n      }\n    }\n    // One child\n    else {\n      // If it has a right child\n      if (temp.right != null) {\n        if (temp == root) {\n          root = temp.right;\n          return true;\n        }\n\n        temp.right.parent = temp.parent;\n\n        // Assigns temp to left or right child\n        if (temp.data < temp.parent.data) temp.parent.left = temp.right;\n        else temp.parent.right = temp.right;\n        return true;\n      }\n      // If it has a left child\n      else {\n        if (temp == root) {\n          root = temp.left;\n          return true;\n        }\n\n        temp.left.parent = temp.parent;\n\n        // Assigns temp to left or right side\n        if (temp.data < temp.parent.data) temp.parent.left = temp.left;\n        else temp.parent.right = temp.left;\n        return true;\n      }\n    }\n  }\n\n  /**\n   * This method finds the Successor to the Node given. Move right once and go left down the tree as\n   * far as you can\n   *\n   * @param n Node that you want to find the Successor of\n   * @return The Successor of the node\n   */\n  public Node findSuccessor(Node n) {\n    if (n.right == null) return n;\n    Node current = n.right;\n    Node parent = n.right;\n    while (current != null) {\n      parent = current;\n      current = current.left;\n    }\n    return parent;\n  }\n\n  /**\n   * Returns the root of the Binary Tree\n   *\n   * @return the root of the Binary Tree\n   */\n  public Node getRoot() {\n    return root;\n  }\n\n  /**\n   * Prints leftChild - root - rightChild\n   *\n   * @param localRoot The local root of the binary tree\n   */\n  public void inOrder(Node localRoot) {\n    if (localRoot != null) {\n      inOrder(localRoot.left);\n      System.out.print(localRoot.data + \" \");\n      inOrder(localRoot.right);\n    }\n  }\n\n  /**\n   * Prints root - leftChild - rightChild\n   *\n   * @param localRoot The local root of the binary tree\n   */\n  public void preOrder(Node localRoot) {\n    if (localRoot != null) {\n      System.out.print(localRoot.data + \" \");\n      preOrder(localRoot.left);\n      preOrder(localRoot.right);\n    }\n  }\n\n  /**\n   * Prints rightChild - leftChild - root\n   *\n   * @param localRoot The local root of the binary tree\n   */\n  public void postOrder(Node localRoot) {\n    if (localRoot != null) {\n      postOrder(localRoot.left);\n      postOrder(localRoot.right);\n      System.out.print(localRoot.data + \" \");\n    }\n  }\n}\n","index":75},{"title":"Generic Tree","category":"Trees","id":"GenericTree_Trees","algorithm":"package DataStructures.Trees;\n\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\n/**\n * A generic tree is a tree which can have as many children as it can be It might be possible that\n * every node present is directly connected to root node.\n *\n * <p>In this code Every function has two copies: one function is helper function which can be\n * called from main and from that function a private function is called which will do the actual\n * work. I have done this, while calling from main one have to give minimum parameters.\n */\npublic class GenericTree {\n  private class Node {\n    int data;\n    ArrayList<Node> child = new ArrayList<>();\n  }\n\n  private Node root;\n  private int size;\n\n  public GenericTree() { // Constructor\n    Scanner scn = new Scanner(System.in);\n    root = create_treeG(null, 0, scn);\n  }\n\n  private Node create_treeG(Node node, int childindx, Scanner scn) {\n    // display\n    if (node == null) {\n      System.out.println(\"Enter root's data\");\n    } else {\n      System.out.println(\"Enter data of parent of index \" + node.data + \" \" + childindx);\n    }\n    // input\n    node = new Node();\n    node.data = scn.nextInt();\n    System.out.println(\"number of children\");\n    int number = scn.nextInt();\n    for (int i = 0; i < number; i++) {\n      Node child = create_treeG(node, i, scn);\n      size++;\n      node.child.add(child);\n    }\n    return node;\n  }\n\n  /** Function to display the generic tree */\n  public void display() { // Helper function\n    display_1(root);\n  }\n\n  private void display_1(Node parent) {\n    System.out.print(parent.data + \"=>\");\n    for (int i = 0; i < parent.child.size(); i++) {\n      System.out.print(parent.child.get(i).data + \" \");\n    }\n    System.out.println(\".\");\n    for (int i = 0; i < parent.child.size(); i++) {\n      display_1(parent.child.get(i));\n    }\n  }\n\n  /**\n   * One call store the size directly but if you are asked compute size this function to calculate\n   * size goes as follows\n   *\n   * @return size\n   */\n  public int size2call() {\n    return size2(root);\n  }\n\n  public int size2(Node roott) {\n    int sz = 0;\n    for (int i = 0; i < roott.child.size(); i++) {\n      sz += size2(roott.child.get(i));\n    }\n    return sz + 1;\n  }\n\n  /**\n   * Function to compute maximum value in the generic tree\n   *\n   * @return maximum value\n   */\n  public int maxcall() {\n    int maxi = root.data;\n    return max(root, maxi);\n  }\n\n  private int max(Node roott, int maxi) {\n    if (maxi < roott.data) maxi = roott.data;\n    for (int i = 0; i < roott.child.size(); i++) {\n      maxi = max(roott.child.get(i), maxi);\n    }\n\n    return maxi;\n  }\n\n  /**\n   * Function to compute HEIGHT of the generic tree\n   *\n   * @return height\n   */\n  public int heightcall() {\n    return height(root) - 1;\n  }\n\n  private int height(Node node) {\n    int h = 0;\n    for (int i = 0; i < node.child.size(); i++) {\n      int k = height(node.child.get(i));\n      if (k > h) h = k;\n    }\n    return h + 1;\n  }\n\n  /**\n   * Function to find whether a number is present in the generic tree or not\n   *\n   * @param info number\n   * @return present or not\n   */\n  public boolean findcall(int info) {\n    return find(root, info);\n  }\n\n  private boolean find(Node node, int info) {\n    if (node.data == info) return true;\n    for (int i = 0; i < node.child.size(); i++) {\n      if (find(node.child.get(i), info)) return true;\n    }\n    return false;\n  }\n\n  /**\n   * Function to calculate depth of generic tree\n   *\n   * @param dep depth\n   */\n  public void depthcaller(int dep) {\n    depth(root, dep);\n  }\n\n  public void depth(Node node, int dep) {\n    if (dep == 0) {\n      System.out.println(node.data);\n      return;\n    }\n    for (int i = 0; i < node.child.size(); i++) depth(node.child.get(i), dep - 1);\n    return;\n  }\n\n  /** Function to print generic tree in pre-order */\n  public void preordercall() {\n    preorder(root);\n    System.out.println(\".\");\n  }\n\n  private void preorder(Node node) {\n    System.out.print(node.data + \" \");\n    for (int i = 0; i < node.child.size(); i++) preorder(node.child.get(i));\n  }\n\n  /** Function to print generic tree in post-order */\n  public void postordercall() {\n    postorder(root);\n    System.out.println(\".\");\n  }\n\n  private void postorder(Node node) {\n    for (int i = 0; i < node.child.size(); i++) postorder(node.child.get(i));\n    System.out.print(node.data + \" \");\n  }\n\n  /** Function to print generic tree in level-order */\n  public void levelorder() {\n    LinkedList<Node> q = new LinkedList<>();\n    q.addLast(root);\n    while (!q.isEmpty()) {\n      int k = q.getFirst().data;\n      System.out.print(k + \" \");\n\n      for (int i = 0; i < q.getFirst().child.size(); i++) {\n        q.addLast(q.getFirst().child.get(i));\n      }\n      q.removeFirst();\n    }\n    System.out.println(\".\");\n  }\n\n  /** Function to remove all leaves of generic tree */\n  public void removeleavescall() {\n    removeleaves(root);\n  }\n\n  private void removeleaves(Node node) {\n    ArrayList<Integer> arr = new ArrayList<>();\n    for (int i = 0; i < node.child.size(); i++) {\n      if (node.child.get(i).child.size() == 0) {\n        arr.add(i);\n        // node.child.remove(i);\n        // i--;\n      } else removeleaves(node.child.get(i));\n    }\n    for (int i = arr.size() - 1; i >= 0; i--) {\n      node.child.remove(arr.get(i) + 0);\n    }\n  }\n}\n","index":76},{"title":"Level Order Traversal","category":"Trees","id":"LevelOrderTraversal_Trees","algorithm":"package DataStructures.Trees;\n\npublic class LevelOrderTraversal {\n\n  class Node {\n    int data;\n    Node left, right;\n\n    public Node(int item) {\n      data = item;\n      left = right = null;\n    }\n  }\n\n  // Root of the Binary Tree\n  Node root;\n\n  public LevelOrderTraversal(Node root) {\n    this.root = root;\n  }\n\n  /* function to print level order traversal of tree*/\n  void printLevelOrder() {\n    int h = height(root);\n    int i;\n    for (i = 1; i <= h; i++) printGivenLevel(root, i);\n  }\n\n  /* Compute the \"height\" of a tree -- the number of\n  nodes along the longest path from the root node\n  down to the farthest leaf node.*/\n  int height(Node root) {\n    if (root == null) return 0;\n    else {\n      /** Return the height of larger subtree */\n      return Math.max(height(root.left), height(root.right)) + 1;\n    }\n  }\n\n  /* Print nodes at the given level */\n  void printGivenLevel(Node root, int level) {\n    if (root == null) return;\n    if (level == 1) System.out.print(root.data + \" \");\n    else if (level > 1) {\n      printGivenLevel(root.left, level - 1);\n      printGivenLevel(root.right, level - 1);\n    }\n  }\n}\n","index":77},{"title":"Level Order Traversal Queue","category":"Trees","id":"LevelOrderTraversalQueue_Trees","algorithm":"package DataStructures.Trees;\n\nimport java.util.LinkedList;\nimport java.util.Queue;\n\n/* Class to print Level Order Traversal */\npublic class LevelOrderTraversalQueue {\n\n  /* Class to represent Tree node */\n  class Node {\n    int data;\n    Node left, right;\n\n    public Node(int item) {\n      data = item;\n      left = null;\n      right = null;\n    }\n  }\n\n  /* Given a binary tree. Print its nodes in level order\n  using array for implementing queue  */\n  void printLevelOrder(Node root) {\n    Queue<Node> queue = new LinkedList<Node>();\n    queue.add(root);\n    while (!queue.isEmpty()) {\n\n      /* poll() removes the present head.\n      For more information on poll() visit\n      http://www.tutorialspoint.com/java/util/linkedlist_poll.htm */\n      Node tempNode = queue.poll();\n      System.out.print(tempNode.data + \" \");\n\n      /*Enqueue left child */\n      if (tempNode.left != null) {\n        queue.add(tempNode.left);\n      }\n\n      /*Enqueue right child */\n      if (tempNode.right != null) {\n        queue.add(tempNode.right);\n      }\n    }\n  }\n}\n","index":78},{"title":"Print Top Viewof Tree","category":"Trees","id":"PrintTopViewofTree_Trees","algorithm":"package DataStructures.Trees; // Java program to print top view of Binary tree\n\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Queue;\n\n// Class for a tree node\nclass TreeNode {\n  // Members\n  int key;\n  TreeNode left, right;\n\n  // Constructor\n  public TreeNode(int key) {\n    this.key = key;\n    left = right = null;\n  }\n}\n\n// A class to represent a queue item. The queue is used to do Level\n// order traversal. Every Queue item contains node and horizontal\n// distance of node from root\nclass QItem {\n  TreeNode node;\n  int hd;\n\n  public QItem(TreeNode n, int h) {\n    node = n;\n    hd = h;\n  }\n}\n\n// Class for a Binary Tree\nclass Tree {\n  TreeNode root;\n\n  // Constructors\n  public Tree() {\n    root = null;\n  }\n\n  public Tree(TreeNode n) {\n    root = n;\n  }\n\n  // This method prints nodes in top view of binary tree\n  public void printTopView() {\n    // base case\n    if (root == null) {\n      return;\n    }\n\n    // Creates an empty hashset\n    HashSet<Integer> set = new HashSet<>();\n\n    // Create a queue and add root to it\n    Queue<QItem> Q = new LinkedList<QItem>();\n    Q.add(new QItem(root, 0)); // Horizontal distance of root is 0\n\n    // Standard BFS or level order traversal loop\n    while (!Q.isEmpty()) {\n      // Remove the front item and get its details\n      QItem qi = Q.remove();\n      int hd = qi.hd;\n      TreeNode n = qi.node;\n\n      // If this is the first node at its horizontal distance,\n      // then this node is in top view\n      if (!set.contains(hd)) {\n        set.add(hd);\n        System.out.print(n.key + \" \");\n      }\n\n      // Enqueue left and right children of current node\n      if (n.left != null) Q.add(new QItem(n.left, hd - 1));\n      if (n.right != null) Q.add(new QItem(n.right, hd + 1));\n    }\n  }\n}\n\n// Driver class to test above methods\npublic class PrintTopViewofTree {\n  public static void main(String[] args) {\n    /* Create following Binary Tree\n       1\n     /  \\\n    2    3\n     \\\n      4\n       \\\n        5\n         \\\n          6*/\n    TreeNode root = new TreeNode(1);\n    root.left = new TreeNode(2);\n    root.right = new TreeNode(3);\n    root.left.right = new TreeNode(4);\n    root.left.right.right = new TreeNode(5);\n    root.left.right.right.right = new TreeNode(6);\n    Tree t = new Tree(root);\n    System.out.println(\"Following are nodes in top view of Binary Tree\");\n    t.printTopView();\n  }\n}\n","index":79},{"title":"Red Black B S T","category":"Trees","id":"RedBlackBST_Trees","algorithm":"package DataStructures.Trees;\r\n\r\nimport java.util.Scanner;\r\n\r\n/** @author jack870131 */\r\npublic class RedBlackBST {\r\n\r\n  private final int R = 0;\r\n  private final int B = 1;\r\n\r\n  private class Node {\r\n\r\n    int key = -1, color = B;\r\n    Node left = nil, right = nil, p = nil;\r\n\r\n    Node(int key) {\r\n      this.key = key;\r\n    }\r\n  }\r\n\r\n  private final Node nil = new Node(-1);\r\n  private Node root = nil;\r\n\r\n  public void printTree(Node node) {\r\n    if (node == nil) {\r\n      return;\r\n    }\r\n    printTree(node.left);\r\n    System.out.print(\r\n        ((node.color == R) ? \" R \" : \" B \") + \"Key: \" + node.key + \" Parent: \" + node.p.key + \"\\n\");\r\n    printTree(node.right);\r\n  }\r\n\r\n  public void printTreepre(Node node) {\r\n    if (node == nil) {\r\n      return;\r\n    }\r\n    System.out.print(\r\n        ((node.color == R) ? \" R \" : \" B \") + \"Key: \" + node.key + \" Parent: \" + node.p.key + \"\\n\");\r\n    printTree(node.left);\r\n    printTree(node.right);\r\n  }\r\n\r\n  private Node findNode(Node findNode, Node node) {\r\n    if (root == nil) {\r\n      return null;\r\n    }\r\n    if (findNode.key < node.key) {\r\n      if (node.left != nil) {\r\n        return findNode(findNode, node.left);\r\n      }\r\n    } else if (findNode.key > node.key) {\r\n      if (node.right != nil) {\r\n        return findNode(findNode, node.right);\r\n      }\r\n    } else if (findNode.key == node.key) {\r\n      return node;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  private void insert(Node node) {\r\n    Node temp = root;\r\n    if (root == nil) {\r\n      root = node;\r\n      node.color = B;\r\n      node.p = nil;\r\n    } else {\r\n      node.color = R;\r\n      while (true) {\r\n        if (node.key < temp.key) {\r\n          if (temp.left == nil) {\r\n            temp.left = node;\r\n            node.p = temp;\r\n            break;\r\n          } else {\r\n            temp = temp.left;\r\n          }\r\n        } else if (node.key >= temp.key) {\r\n          if (temp.right == nil) {\r\n            temp.right = node;\r\n            node.p = temp;\r\n            break;\r\n          } else {\r\n            temp = temp.right;\r\n          }\r\n        }\r\n      }\r\n      fixTree(node);\r\n    }\r\n  }\r\n\r\n  private void fixTree(Node node) {\r\n    while (node.p.color == R) {\r\n      Node y = nil;\r\n      if (node.p == node.p.p.left) {\r\n        y = node.p.p.right;\r\n\r\n        if (y != nil && y.color == R) {\r\n          node.p.color = B;\r\n          y.color = B;\r\n          node.p.p.color = R;\r\n          node = node.p.p;\r\n          continue;\r\n        }\r\n        if (node == node.p.right) {\r\n          node = node.p;\r\n          rotateLeft(node);\r\n        }\r\n        node.p.color = B;\r\n        node.p.p.color = R;\r\n        rotateRight(node.p.p);\r\n      } else {\r\n        y = node.p.p.left;\r\n        if (y != nil && y.color == R) {\r\n          node.p.color = B;\r\n          y.color = B;\r\n          node.p.p.color = R;\r\n          node = node.p.p;\r\n          continue;\r\n        }\r\n        if (node == node.p.left) {\r\n          node = node.p;\r\n          rotateRight(node);\r\n        }\r\n        node.p.color = B;\r\n        node.p.p.color = R;\r\n        rotateLeft(node.p.p);\r\n      }\r\n    }\r\n    root.color = B;\r\n  }\r\n\r\n  void rotateLeft(Node node) {\r\n    if (node.p != nil) {\r\n      if (node == node.p.left) {\r\n        node.p.left = node.right;\r\n      } else {\r\n        node.p.right = node.right;\r\n      }\r\n      node.right.p = node.p;\r\n      node.p = node.right;\r\n      if (node.right.left != nil) {\r\n        node.right.left.p = node;\r\n      }\r\n      node.right = node.right.left;\r\n      node.p.left = node;\r\n    } else {\r\n      Node right = root.right;\r\n      root.right = right.left;\r\n      right.left.p = root;\r\n      root.p = right;\r\n      right.left = root;\r\n      right.p = nil;\r\n      root = right;\r\n    }\r\n  }\r\n\r\n  void rotateRight(Node node) {\r\n    if (node.p != nil) {\r\n      if (node == node.p.left) {\r\n        node.p.left = node.left;\r\n      } else {\r\n        node.p.right = node.left;\r\n      }\r\n\r\n      node.left.p = node.p;\r\n      node.p = node.left;\r\n      if (node.left.right != nil) {\r\n        node.left.right.p = node;\r\n      }\r\n      node.left = node.left.right;\r\n      node.p.right = node;\r\n    } else {\r\n      Node left = root.left;\r\n      root.left = root.left.right;\r\n      left.right.p = root;\r\n      root.p = left;\r\n      left.right = root;\r\n      left.p = nil;\r\n      root = left;\r\n    }\r\n  }\r\n\r\n  void transplant(Node target, Node with) {\r\n    if (target.p == nil) {\r\n      root = with;\r\n    } else if (target == target.p.left) {\r\n      target.p.left = with;\r\n    } else target.p.right = with;\r\n    with.p = target.p;\r\n  }\r\n\r\n  Node treeMinimum(Node subTreeRoot) {\r\n    while (subTreeRoot.left != nil) {\r\n      subTreeRoot = subTreeRoot.left;\r\n    }\r\n    return subTreeRoot;\r\n  }\r\n\r\n  boolean delete(Node z) {\r\n    if ((z = findNode(z, root)) == null) return false;\r\n    Node x;\r\n    Node y = z;\r\n    int yorigcolor = y.color;\r\n\r\n    if (z.left == nil) {\r\n      x = z.right;\r\n      transplant(z, z.right);\r\n    } else if (z.right == nil) {\r\n      x = z.left;\r\n      transplant(z, z.left);\r\n    } else {\r\n      y = treeMinimum(z.right);\r\n      yorigcolor = y.color;\r\n      x = y.right;\r\n      if (y.p == z) x.p = y;\r\n      else {\r\n        transplant(y, y.right);\r\n        y.right = z.right;\r\n        y.right.p = y;\r\n      }\r\n      transplant(z, y);\r\n      y.left = z.left;\r\n      y.left.p = y;\r\n      y.color = z.color;\r\n    }\r\n    if (yorigcolor == B) deleteFixup(x);\r\n    return true;\r\n  }\r\n\r\n  void deleteFixup(Node x) {\r\n    while (x != root && x.color == B) {\r\n      if (x == x.p.left) {\r\n        Node w = x.p.right;\r\n        if (w.color == R) {\r\n          w.color = B;\r\n          x.p.color = R;\r\n          rotateLeft(x.p);\r\n          w = x.p.right;\r\n        }\r\n        if (w.left.color == B && w.right.color == B) {\r\n          w.color = R;\r\n          x = x.p;\r\n          continue;\r\n        } else if (w.right.color == B) {\r\n          w.left.color = B;\r\n          w.color = R;\r\n          rotateRight(w);\r\n          w = x.p.right;\r\n        }\r\n        if (w.right.color == R) {\r\n          w.color = x.p.color;\r\n          x.p.color = B;\r\n          w.right.color = B;\r\n          rotateLeft(x.p);\r\n          x = root;\r\n        }\r\n      } else {\r\n        Node w = x.p.left;\r\n        if (w.color == R) {\r\n          w.color = B;\r\n          x.p.color = R;\r\n          rotateRight(x.p);\r\n          w = x.p.left;\r\n        }\r\n        if (w.right.color == B && w.left.color == B) {\r\n          w.color = R;\r\n          x = x.p;\r\n          continue;\r\n        } else if (w.left.color == B) {\r\n          w.right.color = B;\r\n          w.color = R;\r\n          rotateLeft(w);\r\n          w = x.p.left;\r\n        }\r\n        if (w.left.color == R) {\r\n          w.color = x.p.color;\r\n          x.p.color = B;\r\n          w.left.color = B;\r\n          rotateRight(x.p);\r\n          x = root;\r\n        }\r\n      }\r\n    }\r\n    x.color = B;\r\n  }\r\n\r\n  public void insertDemo() {\r\n    Scanner scan = new Scanner(System.in);\r\n    while (true) {\r\n      System.out.println(\"Add items\");\r\n\r\n      int item;\r\n      Node node;\r\n\r\n      item = scan.nextInt();\r\n      while (item != -999) {\r\n        node = new Node(item);\r\n        insert(node);\r\n        item = scan.nextInt();\r\n      }\r\n      printTree(root);\r\n      System.out.println(\"Pre order\");\r\n      printTreepre(root);\r\n      break;\r\n    }\r\n    scan.close();\r\n  }\r\n\r\n  public void deleteDemo() {\r\n    Scanner scan = new Scanner(System.in);\r\n    System.out.println(\"Delete items\");\r\n    int item;\r\n    Node node;\r\n    item = scan.nextInt();\r\n    node = new Node(item);\r\n    System.out.print(\"Deleting item \" + item);\r\n    if (delete(node)) {\r\n      System.out.print(\": deleted!\");\r\n    } else {\r\n      System.out.print(\": does not exist!\");\r\n    }\r\n\r\n    System.out.println();\r\n    printTree(root);\r\n    System.out.println(\"Pre order\");\r\n    printTreepre(root);\r\n    scan.close();\r\n  }\r\n}\r\n","index":80},{"title":"Tree Traversal","category":"Trees","id":"TreeTraversal_Trees","algorithm":"package DataStructures.Trees;\n\nimport java.util.LinkedList;\n\n/** @author Varun Upadhyay (https://github.com/varunu28) */\n\n// Driver Program\npublic class TreeTraversal {\n  public static void main(String[] args) {\n    Node tree = new Node(5);\n    tree.insert(3);\n    tree.insert(2);\n    tree.insert(7);\n    tree.insert(4);\n    tree.insert(6);\n    tree.insert(8);\n\n    // Prints 5 3 2 4 7 6 8\n    System.out.println(\"Pre order traversal:\");\n    tree.printPreOrder();\n    System.out.println();\n    // Prints 2 3 4 5 6 7 8\n    System.out.println(\"In order traversal:\");\n    tree.printInOrder();\n    System.out.println();\n    // Prints 2 4 3 6 8 7 5\n    System.out.println(\"Post order traversal:\");\n    tree.printPostOrder();\n    System.out.println();\n    // Prints 5 3 7 2 4 6 8\n    System.out.println(\"Level order traversal:\");\n    tree.printLevelOrder();\n    System.out.println();\n  }\n}\n\n/**\n * The Node class which initializes a Node of a tree Consists of all 4 traversal methods:\n * printInOrder, printPostOrder， printPreOrder & printLevelOrder printInOrder: LEFT -> ROOT -> RIGHT\n * printPreOrder: ROOT -> LEFT -> RIGHT printPostOrder: LEFT -> RIGHT -> ROOT printLevelOrder:\n * Prints by level (starting at root), from left to right.\n */\nclass Node {\n  Node left, right;\n  int data;\n\n  public Node(int data) {\n    this.data = data;\n  }\n\n  public void insert(int value) {\n    if (value < data) {\n      if (left == null) {\n        left = new Node(value);\n      } else {\n        left.insert(value);\n      }\n    } else {\n      if (right == null) {\n        right = new Node(value);\n      } else {\n        right.insert(value);\n      }\n    }\n  }\n\n  public void printInOrder() {\n    if (left != null) {\n      left.printInOrder();\n    }\n    System.out.print(data + \" \");\n    if (right != null) {\n      right.printInOrder();\n    }\n  }\n\n  public void printPreOrder() {\n    System.out.print(data + \" \");\n    if (left != null) {\n      left.printPreOrder();\n    }\n    if (right != null) {\n      right.printPreOrder();\n    }\n  }\n\n  public void printPostOrder() {\n    if (left != null) {\n      left.printPostOrder();\n    }\n    if (right != null) {\n      right.printPostOrder();\n    }\n    System.out.print(data + \" \");\n  }\n\n  /** O(n) time algorithm. Uses O(n) space to store nodes in a queue to aid in traversal. */\n  public void printLevelOrder() {\n    LinkedList<Node> queue = new LinkedList<>();\n    queue.add(this);\n    while (queue.size() > 0) {\n      Node head = queue.remove();\n      System.out.print(head.data + \" \");\n      // Add children of recently-printed node to queue, if they exist.\n      if (head.left != null) {\n        queue.add(head.left);\n      }\n      if (head.right != null) {\n        queue.add(head.right);\n      }\n    }\n  }\n}\n","index":81},{"title":"Trie Imp","category":"Trees","id":"TrieImp_Trees","algorithm":"package DataStructures.Trees;\n\n/**\n * Trie Data structure implementation without any libraries\n *\n * @author Dheeraj Kumar Barnwal (https://github.com/dheeraj92)\n */\nimport java.util.Scanner;\n\npublic class TrieImp {\n\n  public class TrieNode {\n    TrieNode[] child;\n    boolean end;\n\n    public TrieNode() {\n      child = new TrieNode[26];\n      end = false;\n    }\n  }\n\n  private final TrieNode root;\n\n  public TrieImp() {\n    root = new TrieNode();\n  }\n\n  public void insert(String word) {\n    TrieNode currentNode = root;\n    for (int i = 0; i < word.length(); i++) {\n      TrieNode node = currentNode.child[word.charAt(i) - 'a'];\n      if (node == null) {\n        node = new TrieNode();\n        currentNode.child[word.charAt(i) - 'a'] = node;\n      }\n      currentNode = node;\n    }\n    currentNode.end = true;\n  }\n\n  public boolean search(String word) {\n    TrieNode currentNode = root;\n    for (int i = 0; i < word.length(); i++) {\n      char ch = word.charAt(i);\n      TrieNode node = currentNode.child[ch - 'a'];\n      if (node == null) {\n        return false;\n      }\n      currentNode = node;\n    }\n    return currentNode.end;\n  }\n\n  public boolean delete(String word) {\n    TrieNode currentNode = root;\n    for (int i = 0; i < word.length(); i++) {\n      char ch = word.charAt(i);\n      TrieNode node = currentNode.child[ch - 'a'];\n      if (node == null) {\n        return false;\n      }\n      currentNode = node;\n    }\n    if (currentNode.end == true) {\n      currentNode.end = false;\n      return true;\n    }\n    return false;\n  }\n\n  public static void sop(String print) {\n    System.out.println(print);\n  }\n\n  /** Regex to check if word contains only a-z character */\n  public static boolean isValid(String word) {\n    return word.matches(\"^[a-z]+$\");\n  }\n\n  public static void main(String[] args) {\n    TrieImp obj = new TrieImp();\n    String word;\n    @SuppressWarnings(\"resource\")\n    Scanner scan = new Scanner(System.in);\n    sop(\"string should contain only a-z character for all operation\");\n    while (true) {\n      sop(\"1. Insert\\n2. Search\\n3. Delete\\n4. Quit\");\n      try {\n        int t = scan.nextInt();\n        switch (t) {\n          case 1:\n            word = scan.next();\n            if (isValid(word)) obj.insert(word);\n            else sop(\"Invalid string: allowed only a-z\");\n            break;\n          case 2:\n            word = scan.next();\n            boolean resS = false;\n            if (isValid(word)) resS = obj.search(word);\n            else sop(\"Invalid string: allowed only a-z\");\n            if (resS) sop(\"word found\");\n            else sop(\"word not found\");\n            break;\n          case 3:\n            word = scan.next();\n            boolean resD = false;\n            if (isValid(word)) resD = obj.delete(word);\n            else sop(\"Invalid string: allowed only a-z\");\n            if (resD) {\n              sop(\"word got deleted successfully\");\n            } else {\n              sop(\"word not found\");\n            }\n            break;\n          case 4:\n            sop(\"Quit successfully\");\n            System.exit(1);\n            break;\n          default:\n            sop(\"Input int from 1-4\");\n            break;\n        }\n      } catch (Exception e) {\n        String badInput = scan.next();\n        sop(\"This is bad input: \" + badInput);\n      }\n    }\n  }\n}\n","index":82},{"title":"Valid B S T Or Not","category":"Trees","id":"ValidBSTOrNot_Trees","algorithm":"package DataStructures.Trees;\n\npublic class ValidBSTOrNot {\n\n  class Node {\n    int data;\n    Node left, right;\n\n    public Node(int item) {\n      data = item;\n      left = right = null;\n    }\n  }\n\n  // Root of the Binary Tree\n\n  /* can give min and max value according to your code or\n  can write a function to find min and max value of tree. */\n\n  /* returns true if given search tree is binary\n  search tree (efficient version) */\n  boolean isBST(Node root) {\n    return isBSTUtil(root, Integer.MIN_VALUE, Integer.MAX_VALUE);\n  }\n\n  /* Returns true if the given tree is a BST and its\n  values are >= min and <= max. */\n  boolean isBSTUtil(Node node, int min, int max) {\n    /* an empty tree is BST */\n    if (node == null) return true;\n\n    /* false if this node violates the min/max constraints */\n    if (node.data < min || node.data > max) return false;\n\n    /* otherwise check the subtrees recursively\n    tightening the min/max constraints */\n    // Allow only distinct values\n    return (isBSTUtil(node.left, min, node.data - 1) && isBSTUtil(node.right, node.data + 1, max));\n  }\n}\n","index":83},{"title":"Dynamic Programming","category":null,"id":"DynamicProgramming","index":84},{"title":"Board Path","category":"DynamicProgramming","id":"BoardPath_DynamicProgramming","algorithm":"package DynamicProgramming;\n/*\n* this is an important Algo in which\n* we have starting and ending of board and we have to reach\n* we have to count no. of ways\n* that help to reach end point i.e number by rolling dice\n* which have 1 to 6 digits\n\nTest Case:\nhere target is 10\n\nint n=10;\n\t\tstartAlgo();\n\t\tSystem.out.println(bpR(0,n));\n\t\tSystem.out.println(endAlgo()+\"ms\");\n\t\tint[] strg=new int [n+1];\n\t\tstartAlgo();\n\t\tSystem.out.println(bpRS(0,n,strg));\n\t\tSystem.out.println(endAlgo()+\"ms\");\n\t\tstartAlgo();\n\t\tSystem.out.println(bpIS(0,n,strg));\n\t\tSystem.out.println(endAlgo()+\"ms\");\n\n\n\n*/\npublic class BoardPath {\n  public static long startTime;\n  public static long endTime;\n\n  public static void startAlgo() {\n    startTime = System.currentTimeMillis();\n  }\n\n  public static long endAlgo() {\n    endTime = System.currentTimeMillis();\n    return endTime - startTime;\n  }\n\n  public static int bpR(int start, int end) {\n    if (start == end) {\n      return 1;\n    } else if (start > end) return 0;\n    int count = 0;\n    for (int dice = 1; dice <= 6; dice++) {\n      count += bpR(start + dice, end);\n    }\n    return count;\n  }\n\n  public static int bpRS(int curr, int end, int strg[]) {\n    if (curr == end) {\n      return 1;\n    } else if (curr > end) return 0;\n    if (strg[curr] != 0) return strg[curr];\n    int count = 0;\n    for (int dice = 1; dice <= 6; dice++) {\n      count += bpRS(curr + dice, end, strg);\n    }\n    strg[curr] = count;\n    return count;\n  }\n\n  public static int bpIS(int curr, int end, int[] strg) {\n    strg[end] = 1;\n    for (int i = end - 1; i >= 0; i--) {\n      int count = 0;\n      for (int dice = 1; dice <= 6 && dice + i < strg.length; dice++) {\n        count += strg[i + dice];\n      }\n      strg[i] = count;\n    }\n    return strg[0];\n  }\n}\n","index":85},{"title":"Coin Change","category":"DynamicProgramming","id":"CoinChange_DynamicProgramming","algorithm":"package DynamicProgramming;\n\n/** @author Varun Upadhyay (https://github.com/varunu28) */\npublic class CoinChange {\n\n  // Driver Program\n  public static void main(String[] args) {\n\n    int amount = 12;\n    int[] coins = {2, 4, 5};\n\n    System.out.println(\n        \"Number of combinations of getting change for \" + amount + \" is: \" + change(coins, amount));\n    System.out.println(\n        \"Minimum number of coins required for amount :\"\n            + amount\n            + \" is: \"\n            + minimumCoins(coins, amount));\n  }\n\n  /**\n   * This method finds the number of combinations of getting change for a given amount and change\n   * coins\n   *\n   * @param coins The list of coins\n   * @param amount The amount for which we need to find the change Finds the number of combinations\n   *     of change\n   */\n  public static int change(int[] coins, int amount) {\n\n    int[] combinations = new int[amount + 1];\n    combinations[0] = 1;\n\n    for (int coin : coins) {\n      for (int i = coin; i < amount + 1; i++) {\n        combinations[i] += combinations[i - coin];\n      }\n      // Uncomment the below line to see the state of combinations for each coin\n      // printAmount(combinations);\n    }\n\n    return combinations[amount];\n  }\n\n  /**\n   * This method finds the minimum number of coins needed for a given amount.\n   *\n   * @param coins The list of coins\n   * @param amount The amount for which we need to find the minimum number of coins. Finds the the\n   *     minimum number of coins that make a given value.\n   */\n  public static int minimumCoins(int[] coins, int amount) {\n    // minimumCoins[i] will store the minimum coins needed for amount i\n    int[] minimumCoins = new int[amount + 1];\n\n    minimumCoins[0] = 0;\n\n    for (int i = 1; i <= amount; i++) {\n      minimumCoins[i] = Integer.MAX_VALUE;\n    }\n    for (int i = 1; i <= amount; i++) {\n      for (int coin : coins) {\n        if (coin <= i) {\n          int sub_res = minimumCoins[i - coin];\n          if (sub_res != Integer.MAX_VALUE && sub_res + 1 < minimumCoins[i])\n            minimumCoins[i] = sub_res + 1;\n        }\n      }\n    }\n    // Uncomment the below line to see the state of combinations for each coin\n    // printAmount(minimumCoins);\n    return minimumCoins[amount];\n  }\n\n  // A basic print method which prints all the contents of the array\n  public static void printAmount(int[] arr) {\n    for (int i = 0; i < arr.length; i++) {\n      System.out.print(arr[i] + \" \");\n    }\n    System.out.println();\n  }\n}\n","index":86},{"title":"Edit Distance","category":"DynamicProgramming","id":"EditDistance_DynamicProgramming","algorithm":"package DynamicProgramming;\n\n/**\n * A DynamicProgramming based solution for Edit Distance problem In Java Description of Edit\n * Distance with an Example:\n *\n * <p>Edit distance is a way of quantifying how dissimilar two strings (e.g., words) are to one\n * another, by counting the minimum number of operations required to transform one string into the\n * other. The distance operations are the removal, insertion, or substitution of a character in the\n * string.\n *\n * <p>\n *\n * <p>The Distance between \"kitten\" and \"sitting\" is 3. A minimal edit script that transforms the\n * former into the latter is:\n *\n * <p>kitten → sitten (substitution of \"s\" for \"k\") sitten → sittin (substitution of \"i\" for \"e\")\n * sittin → sitting (insertion of \"g\" at the end).\n *\n * @author SUBHAM SANGHAI\n */\nimport java.util.Scanner;\n\npublic class EditDistance {\n\n  public static int minDistance(String word1, String word2) {\n    int len1 = word1.length();\n    int len2 = word2.length();\n    // len1+1, len2+1, because finally return dp[len1][len2]\n    int[][] dp = new int[len1 + 1][len2 + 1];\n    /* If second string is empty, the only option is to\n    insert all characters of first string into second*/\n    for (int i = 0; i <= len1; i++) {\n      dp[i][0] = i;\n    }\n    /* If first string is empty, the only option is to\n    insert all characters of second string into first*/\n    for (int j = 0; j <= len2; j++) {\n      dp[0][j] = j;\n    }\n    // iterate though, and check last char\n    for (int i = 0; i < len1; i++) {\n      char c1 = word1.charAt(i);\n      for (int j = 0; j < len2; j++) {\n        char c2 = word2.charAt(j);\n        // if last two chars equal\n        if (c1 == c2) {\n          // update dp value for +1 length\n          dp[i + 1][j + 1] = dp[i][j];\n        } else {\n          /* if two characters are different ,\n          then take the minimum of the various operations(i.e insertion,removal,substitution)*/\n          int replace = dp[i][j] + 1;\n          int insert = dp[i][j + 1] + 1;\n          int delete = dp[i + 1][j] + 1;\n\n          int min = replace > insert ? insert : replace;\n          min = delete > min ? min : delete;\n          dp[i + 1][j + 1] = min;\n        }\n      }\n    }\n    /* return the final answer , after traversing through both the strings*/\n    return dp[len1][len2];\n  }\n\n  public static void main(String[] args) {\n    Scanner input = new Scanner(System.in);\n    String s1, s2;\n    System.out.println(\"Enter the First String\");\n    s1 = input.nextLine();\n    System.out.println(\"Enter the Second String\");\n    s2 = input.nextLine();\n    // ans stores the final Edit Distance between the two strings\n    int ans = minDistance(s1, s2);\n    System.out.println(\n        \"The minimum Edit Distance between \\\"\" + s1 + \"\\\" and \\\"\" + s2 + \"\\\" is \" + ans);\n    input.close();\n  }\n}\n","index":87},{"title":"Egg Dropping","category":"DynamicProgramming","id":"EggDropping_DynamicProgramming","algorithm":"package DynamicProgramming;\n\n/** DynamicProgramming solution for the Egg Dropping Puzzle */\npublic class EggDropping {\n\n  // min trials with n eggs and m floors\n\n  private static int minTrials(int n, int m) {\n\n    int[][] eggFloor = new int[n + 1][m + 1];\n    int result, x;\n\n    for (int i = 1; i <= n; i++) {\n      eggFloor[i][0] = 0; // Zero trial for zero floor.\n      eggFloor[i][1] = 1; // One trial for one floor\n    }\n\n    // j trials for only 1 egg\n\n    for (int j = 1; j <= m; j++) eggFloor[1][j] = j;\n\n    // Using bottom-up approach in DP\n\n    for (int i = 2; i <= n; i++) {\n      for (int j = 2; j <= m; j++) {\n        eggFloor[i][j] = Integer.MAX_VALUE;\n        for (x = 1; x <= j; x++) {\n          result = 1 + Math.max(eggFloor[i - 1][x - 1], eggFloor[i][j - x]);\n\n          // choose min of all values for particular x\n          if (result < eggFloor[i][j]) eggFloor[i][j] = result;\n        }\n      }\n    }\n\n    return eggFloor[n][m];\n  }\n\n  public static void main(String args[]) {\n    int n = 2, m = 4;\n    // result outputs min no. of trials in worst case for n eggs and m floors\n    int result = minTrials(n, m);\n    System.out.println(result);\n  }\n}\n","index":88},{"title":"Fibonacci","category":"DynamicProgramming","id":"Fibonacci_DynamicProgramming","algorithm":"package DynamicProgramming;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\n/** @author Varun Upadhyay (https://github.com/varunu28) */\npublic class Fibonacci {\n\n  private static Map<Integer, Integer> map = new HashMap<>();\n\n  public static void main(String[] args) {\n\n    // Methods all returning [0, 1, 1, 2, 3, 5, ...] for n = [0, 1, 2, 3, 4, 5, ...]\n    Scanner sc = new Scanner(System.in);\n    int n = sc.nextInt();\n\n    System.out.println(fibMemo(n));\n    System.out.println(fibBotUp(n));\n    System.out.println(fibOptimized(n));\n    sc.close();\n  }\n\n  /**\n   * This method finds the nth fibonacci number using memoization technique\n   *\n   * @param n The input n for which we have to determine the fibonacci number Outputs the nth\n   *     fibonacci number\n   */\n  public static int fibMemo(int n) {\n    if (map.containsKey(n)) {\n      return map.get(n);\n    }\n\n    int f;\n\n    if (n <= 1) {\n      f = n;\n    } else {\n      f = fibMemo(n - 1) + fibMemo(n - 2);\n      map.put(n, f);\n    }\n    return f;\n  }\n\n  /**\n   * This method finds the nth fibonacci number using bottom up\n   *\n   * @param n The input n for which we have to determine the fibonacci number Outputs the nth\n   *     fibonacci number\n   */\n  public static int fibBotUp(int n) {\n\n    Map<Integer, Integer> fib = new HashMap<>();\n\n    for (int i = 0; i <= n; i++) {\n      int f;\n      if (i <= 1) {\n        f = i;\n      } else {\n        f = fib.get(i - 1) + fib.get(i - 2);\n      }\n      fib.put(i, f);\n    }\n\n    return fib.get(n);\n  }\n\n  /**\n   * This method finds the nth fibonacci number using bottom up\n   *\n   * @param n The input n for which we have to determine the fibonacci number Outputs the nth\n   *     fibonacci number\n   *     <p>This is optimized version of Fibonacci Program. Without using Hashmap and recursion. It\n   *     saves both memory and time. Space Complexity will be O(1) Time Complexity will be O(n)\n   *     <p>Whereas , the above functions will take O(n) Space.\n   * @author Shoaib Rayeen (https://github.com/shoaibrayeen)\n   */\n  public static int fibOptimized(int n) {\n    if (n == 0) {\n      return 0;\n    }\n    int prev = 0, res = 1, next;\n    for (int i = 2; i <= n; i++) {\n      next = prev + res;\n      prev = res;\n      res = next;\n    }\n    return res;\n  }\n}\n","index":89},{"title":"Ford Fulkerson","category":"DynamicProgramming","id":"FordFulkerson_DynamicProgramming","algorithm":"package DynamicProgramming;\n\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Vector;\n\npublic class FordFulkerson {\n  static final int INF = 987654321;\n  // edges\n  static int V;\n  static int[][] capacity, flow;\n\n  public static void main(String[] args) {\n    System.out.println(\"V : 6\");\n    V = 6;\n    capacity = new int[V][V];\n\n    capacity[0][1] = 12;\n    capacity[0][3] = 13;\n    capacity[1][2] = 10;\n    capacity[2][3] = 13;\n    capacity[2][4] = 3;\n    capacity[2][5] = 15;\n    capacity[3][2] = 7;\n    capacity[3][4] = 15;\n    capacity[4][5] = 17;\n\n    System.out.println(\"Max capacity in networkFlow : \" + networkFlow(0, 5));\n  }\n\n  private static int networkFlow(int source, int sink) {\n    flow = new int[V][V];\n    int totalFlow = 0;\n    while (true) {\n      Vector<Integer> parent = new Vector<>(V);\n      for (int i = 0; i < V; i++) parent.add(-1);\n      Queue<Integer> q = new LinkedList<>();\n      parent.set(source, source);\n      q.add(source);\n      while (!q.isEmpty() && parent.get(sink) == -1) {\n        int here = q.peek();\n        q.poll();\n        for (int there = 0; there < V; ++there)\n          if (capacity[here][there] - flow[here][there] > 0 && parent.get(there) == -1) {\n            q.add(there);\n            parent.set(there, here);\n          }\n      }\n      if (parent.get(sink) == -1) break;\n\n      int amount = INF;\n      String printer = \"path : \";\n      StringBuilder sb = new StringBuilder();\n      for (int p = sink; p != source; p = parent.get(p)) {\n        amount = Math.min(capacity[parent.get(p)][p] - flow[parent.get(p)][p], amount);\n        sb.append(p + \"-\");\n      }\n      sb.append(source);\n      for (int p = sink; p != source; p = parent.get(p)) {\n        flow[parent.get(p)][p] += amount;\n        flow[p][parent.get(p)] -= amount;\n      }\n      totalFlow += amount;\n      printer += sb.reverse() + \" / max flow : \" + totalFlow;\n      System.out.println(printer);\n    }\n\n    return totalFlow;\n  }\n}\n","index":90},{"title":"Kadane Algorithm","category":"DynamicProgramming","id":"KadaneAlgorithm_DynamicProgramming","algorithm":"package DynamicProgramming;\n\nimport java.util.Scanner;\n\n/**\n * Program to implement Kadane’s Algorithm to calculate maximum contiguous subarray sum of an array\n * Time Complexity: O(n)\n *\n * @author Nishita Aggarwal\n */\npublic class KadaneAlgorithm {\n\n  /**\n   * This method implements Kadane's Algorithm\n   *\n   * @param arr The input array\n   * @return The maximum contiguous subarray sum of the array\n   */\n  static int largestContiguousSum(int arr[]) {\n    int i, len = arr.length, cursum = 0, maxsum = Integer.MIN_VALUE;\n    if (len == 0) // empty array\n    return 0;\n    for (i = 0; i < len; i++) {\n      cursum += arr[i];\n      if (cursum > maxsum) {\n        maxsum = cursum;\n      }\n      if (cursum <= 0) {\n        cursum = 0;\n      }\n    }\n    return maxsum;\n  }\n\n  /**\n   * Main method\n   *\n   * @param args Command line arguments\n   */\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n, arr[], i;\n    n = sc.nextInt();\n    arr = new int[n];\n    for (i = 0; i < n; i++) {\n      arr[i] = sc.nextInt();\n    }\n    int maxContSum = largestContiguousSum(arr);\n    System.out.println(maxContSum);\n    sc.close();\n  }\n}\n","index":91},{"title":"Knapsack","category":"DynamicProgramming","id":"Knapsack_DynamicProgramming","algorithm":"package DynamicProgramming;\n\n/** A DynamicProgramming based solution for 0-1 Knapsack problem */\npublic class Knapsack {\n\n  private static int knapSack(int W, int wt[], int val[], int n) throws IllegalArgumentException {\n    if (wt == null || val == null) throw new IllegalArgumentException();\n    int i, w;\n    int rv[][] = new int[n + 1][W + 1]; // rv means return value\n\n    // Build table rv[][] in bottom up manner\n    for (i = 0; i <= n; i++) {\n      for (w = 0; w <= W; w++) {\n        if (i == 0 || w == 0) rv[i][w] = 0;\n        else if (wt[i - 1] <= w)\n          rv[i][w] = Math.max(val[i - 1] + rv[i - 1][w - wt[i - 1]], rv[i - 1][w]);\n        else rv[i][w] = rv[i - 1][w];\n      }\n    }\n\n    return rv[n][W];\n  }\n\n  // Driver program to test above function\n  public static void main(String args[]) {\n    int val[] = new int[] {50, 100, 130};\n    int wt[] = new int[] {10, 20, 40};\n    int W = 50;\n    int n = val.length;\n    System.out.println(knapSack(W, wt, val, n));\n  }\n}\n","index":92},{"title":"Levenshtein Distance","category":"DynamicProgramming","id":"LevenshteinDistance_DynamicProgramming","algorithm":"package DynamicProgramming;\n\n/**\n * @author Kshitij VERMA (github.com/kv19971) LEVENSHTEIN DISTANCE dyamic programming implementation\n *     to show the difference between two strings\n *     (https://en.wikipedia.org/wiki/Levenshtein_distance)\n */\npublic class LevenshteinDistance {\n  private static int minimum(int a, int b, int c) {\n    if (a < b && a < c) {\n      return a;\n    } else if (b < a && b < c) {\n      return b;\n    } else {\n      return c;\n    }\n  }\n\n  private static int calculate_distance(String a, String b) {\n    int len_a = a.length() + 1;\n    int len_b = b.length() + 1;\n    int[][] distance_mat = new int[len_a][len_b];\n    for (int i = 0; i < len_a; i++) {\n      distance_mat[i][0] = i;\n    }\n    for (int j = 0; j < len_b; j++) {\n      distance_mat[0][j] = j;\n    }\n    for (int i = 0; i < len_a; i++) {\n      for (int j = 0; j < len_b; j++) {\n        int cost;\n        if (a.charAt(i) == b.charAt(j)) {\n          cost = 0;\n        } else {\n          cost = 1;\n        }\n        distance_mat[i][j] =\n            minimum(distance_mat[i - 1][j], distance_mat[i - 1][j - 1], distance_mat[i][j - 1])\n                + cost;\n      }\n    }\n    return distance_mat[len_a - 1][len_b - 1];\n  }\n\n  public static void main(String[] args) {\n    String a = \"\"; // enter your string here\n    String b = \"\"; // enter your string here\n\n    System.out.print(\"Levenshtein distance between \" + a + \" and \" + b + \" is: \");\n    System.out.println(calculate_distance(a, b));\n  }\n}\n","index":93},{"title":"Longest Common Subsequence","category":"DynamicProgramming","id":"LongestCommonSubsequence_DynamicProgramming","algorithm":"package DynamicProgramming;\n\nclass LongestCommonSubsequence {\n\n  public static String getLCS(String str1, String str2) {\n\n    // At least one string is null\n    if (str1 == null || str2 == null) return null;\n\n    // At least one string is empty\n    if (str1.length() == 0 || str2.length() == 0) return \"\";\n\n    String[] arr1 = str1.split(\"\");\n    String[] arr2 = str2.split(\"\");\n\n    // lcsMatrix[i][j]  = LCS of first i elements of arr1 and first j characters of arr2\n    int[][] lcsMatrix = new int[arr1.length + 1][arr2.length + 1];\n\n    for (int i = 0; i < arr1.length + 1; i++) lcsMatrix[i][0] = 0;\n    for (int j = 1; j < arr2.length + 1; j++) lcsMatrix[0][j] = 0;\n    for (int i = 1; i < arr1.length + 1; i++) {\n      for (int j = 1; j < arr2.length + 1; j++) {\n        if (arr1[i - 1].equals(arr2[j - 1])) {\n          lcsMatrix[i][j] = lcsMatrix[i - 1][j - 1] + 1;\n        } else {\n          lcsMatrix[i][j] =\n              lcsMatrix[i - 1][j] > lcsMatrix[i][j - 1] ? lcsMatrix[i - 1][j] : lcsMatrix[i][j - 1];\n        }\n      }\n    }\n    return lcsString(str1, str2, lcsMatrix);\n  }\n\n  public static String lcsString(String str1, String str2, int[][] lcsMatrix) {\n    StringBuilder lcs = new StringBuilder();\n    int i = str1.length(), j = str2.length();\n    while (i > 0 && j > 0) {\n      if (str1.charAt(i - 1) == str2.charAt(j - 1)) {\n        lcs.append(str1.charAt(i - 1));\n        i--;\n        j--;\n      } else if (lcsMatrix[i - 1][j] > lcsMatrix[i][j - 1]) {\n        i--;\n      } else {\n        j--;\n      }\n    }\n    return lcs.reverse().toString();\n  }\n\n  public static void main(String[] args) {\n    String str1 = \"DSGSHSRGSRHTRD\";\n    String str2 = \"DATRGAGTSHS\";\n    String lcs = getLCS(str1, str2);\n\n    // Print LCS\n    if (lcs != null) {\n      System.out.println(\"String 1: \" + str1);\n      System.out.println(\"String 2: \" + str2);\n      System.out.println(\"LCS: \" + lcs);\n      System.out.println(\"LCS length: \" + lcs.length());\n    }\n  }\n}\n","index":94},{"title":"Longest Increasing Subsequence","category":"DynamicProgramming","id":"LongestIncreasingSubsequence_DynamicProgramming","algorithm":"package DynamicProgramming;\n\nimport java.util.Scanner;\n\n/** @author Afrizal Fikri (https://github.com/icalF) */\npublic class LongestIncreasingSubsequence {\n  public static void main(String[] args) {\n\n    Scanner sc = new Scanner(System.in);\n    int n = sc.nextInt();\n\n    int ar[] = new int[n];\n    for (int i = 0; i < n; i++) {\n      ar[i] = sc.nextInt();\n    }\n\n    System.out.println(LIS(ar));\n    sc.close();\n  }\n\n  private static int upperBound(int[] ar, int l, int r, int key) {\n    while (l < r - 1) {\n      int m = (l + r) >>> 1;\n      if (ar[m] >= key) r = m;\n      else l = m;\n    }\n\n    return r;\n  }\n\n  private static int LIS(int[] array) {\n    int N = array.length;\n    if (N == 0) return 0;\n\n    int[] tail = new int[N];\n\n    // always points empty slot in tail\n    int length = 1;\n\n    tail[0] = array[0];\n    for (int i = 1; i < N; i++) {\n\n      // new smallest value\n      if (array[i] < tail[0]) tail[0] = array[i];\n\n      // array[i] extends largest subsequence\n      else if (array[i] > tail[length - 1]) tail[length++] = array[i];\n\n      // array[i] will become end candidate of an existing subsequence or\n      // Throw away larger elements in all LIS, to make room for upcoming grater elements than\n      // array[i]\n      // (and also, array[i] would have already appeared in one of LIS, identify the location and\n      // replace it)\n      else tail[upperBound(tail, -1, length - 1, array[i])] = array[i];\n    }\n\n    return length;\n  }\n}\n","index":95},{"title":"Longest Palindromic Subsequence","category":"DynamicProgramming","id":"LongestPalindromicSubsequence_DynamicProgramming","algorithm":"package test;\n\nimport java.io.*;\nimport java.util.*;\n\n/**\n * Algorithm explanation https://www.educative.io/edpresso/longest-palindromic-subsequence-algorithm\n */\npublic class LongestPalindromicSubsequence {\n  public static void main(String[] args) {\n    String a = \"BBABCBCAB\";\n    String b = \"BABCBAB\";\n\n    String aLPS = LPS(a);\n    String bLPS = LPS(b);\n\n    System.out.println(a + \" => \" + aLPS);\n    System.out.println(b + \" => \" + bLPS);\n  }\n\n  public static String LPS(String original) throws IllegalArgumentException {\n    StringBuilder reverse = new StringBuilder(original);\n    reverse = reverse.reverse();\n    return recursiveLPS(original, reverse.toString());\n  }\n\n  private static String recursiveLPS(String original, String reverse) {\n    String bestResult = \"\";\n\n    // no more chars, then return empty\n    if (original.length() == 0 || reverse.length() == 0) {\n      bestResult = \"\";\n    } else {\n\n      // if the last chars match, then remove it from both strings and recur\n      if (original.charAt(original.length() - 1) == reverse.charAt(reverse.length() - 1)) {\n        String bestSubResult =\n            recursiveLPS(\n                original.substring(0, original.length() - 1),\n                reverse.substring(0, reverse.length() - 1));\n\n        bestResult = reverse.charAt(reverse.length() - 1) + bestSubResult;\n      } else {\n        // otherwise (1) ignore the last character of reverse, and recur on original and updated\n        // reverse again\n        // (2) ignore the last character of original and recur on the updated original and reverse\n        // again\n        // then select the best result from these two subproblems.\n\n        String bestSubResult1 = recursiveLPS(original, reverse.substring(0, reverse.length() - 1));\n        String bestSubResult2 = recursiveLPS(original.substring(0, original.length() - 1), reverse);\n        if (bestSubResult1.length() > bestSubResult2.length()) {\n          bestResult = bestSubResult1;\n        } else {\n          bestResult = bestSubResult2;\n        }\n      }\n    }\n\n    return bestResult;\n  }\n}\n","index":96},{"title":"Longest Valid Parentheses","category":"DynamicProgramming","id":"LongestValidParentheses_DynamicProgramming","algorithm":"package DynamicProgramming;\n\nimport java.util.Scanner;\n\n/**\n * Given a string containing just the characters '(' and ')', find the length of the longest valid\n * (well-formed) parentheses substring.\n *\n * @author Libin Yang (https://github.com/yanglbme)\n * @since 2018/10/5\n */\npublic class LongestValidParentheses {\n\n  public static int getLongestValidParentheses(String s) {\n    if (s == null || s.length() < 2) {\n      return 0;\n    }\n    char[] chars = s.toCharArray();\n    int n = chars.length;\n    int[] res = new int[n];\n    res[0] = 0;\n    res[1] = chars[1] == ')' && chars[0] == '(' ? 2 : 0;\n\n    int max = res[1];\n\n    for (int i = 2; i < n; ++i) {\n      if (chars[i] == ')') {\n        if (chars[i - 1] == '(') {\n          res[i] = res[i - 2] + 2;\n        } else {\n          int index = i - res[i - 1] - 1;\n          if (index >= 0 && chars[index] == '(') {\n            // ()(())\n            res[i] = res[i - 1] + 2 + (index - 1 >= 0 ? res[index - 1] : 0);\n          }\n        }\n      }\n      max = Math.max(max, res[i]);\n    }\n\n    return max;\n  }\n\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    while (true) {\n      String str = sc.nextLine();\n      if (\"quit\".equals(str)) {\n        break;\n      }\n      int len = getLongestValidParentheses(str);\n      System.out.println(len);\n    }\n\n    sc.close();\n  }\n}\n","index":97},{"title":"Matrix Chain Multiplication","category":"DynamicProgramming","id":"MatrixChainMultiplication_DynamicProgramming","algorithm":"package DynamicProgramming;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class MatrixChainMultiplication {\n  private static Scanner scan = new Scanner(System.in);\n  private static ArrayList<Matrix> mArray = new ArrayList<>();\n  private static int size;\n  private static int[][] m;\n  private static int[][] s;\n  private static int[] p;\n\n  public static void main(String[] args) {\n    int count = 1;\n    while (true) {\n      String[] mSize = input(\"input size of matrix A(\" + count + \") ( ex. 10 20 ) : \");\n      int col = Integer.parseInt(mSize[0]);\n      if (col == 0) break;\n      int row = Integer.parseInt(mSize[1]);\n\n      Matrix matrix = new Matrix(count, col, row);\n      mArray.add(matrix);\n      count++;\n    }\n    for (Matrix m : mArray) {\n      System.out.format(\"A(%d)  =  %2d  x  %2d%n\", m.count(), m.col(), m.row());\n    }\n\n    size = mArray.size();\n    m = new int[size + 1][size + 1];\n    s = new int[size + 1][size + 1];\n    p = new int[size + 1];\n\n    for (int i = 0; i < size + 1; i++) {\n      Arrays.fill(m[i], -1);\n      Arrays.fill(s[i], -1);\n    }\n\n    for (int i = 0; i < p.length; i++) {\n      p[i] = i == 0 ? mArray.get(i).col() : mArray.get(i - 1).row();\n    }\n\n    matrixChainOrder();\n    for (int i = 0; i < size; i++) {\n      System.out.print(\"-------\");\n    }\n    System.out.println();\n    printArray(m);\n    for (int i = 0; i < size; i++) {\n      System.out.print(\"-------\");\n    }\n    System.out.println();\n    printArray(s);\n    for (int i = 0; i < size; i++) {\n      System.out.print(\"-------\");\n    }\n    System.out.println();\n\n    System.out.println(\"Optimal solution : \" + m[1][size]);\n    System.out.print(\"Optimal parens : \");\n    printOptimalParens(1, size);\n  }\n\n  private static void printOptimalParens(int i, int j) {\n    if (i == j) {\n      System.out.print(\"A\" + i);\n    } else {\n      System.out.print(\"(\");\n      printOptimalParens(i, s[i][j]);\n      printOptimalParens(s[i][j] + 1, j);\n      System.out.print(\")\");\n    }\n  }\n\n  private static void printArray(int[][] array) {\n    for (int i = 1; i < size + 1; i++) {\n      for (int j = 1; j < size + 1; j++) {\n        System.out.print(String.format(\"%7d\", array[i][j]));\n      }\n      System.out.println();\n    }\n  }\n\n  private static void matrixChainOrder() {\n    for (int i = 1; i < size + 1; i++) {\n      m[i][i] = 0;\n    }\n\n    for (int l = 2; l < size + 1; l++) {\n      for (int i = 1; i < size - l + 2; i++) {\n        int j = i + l - 1;\n        m[i][j] = Integer.MAX_VALUE;\n\n        for (int k = i; k < j; k++) {\n          int q = m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j];\n          if (q < m[i][j]) {\n            m[i][j] = q;\n            s[i][j] = k;\n          }\n        }\n      }\n    }\n  }\n\n  private static String[] input(String string) {\n    System.out.print(string);\n    return (scan.nextLine().split(\" \"));\n  }\n}\n\nclass Matrix {\n  private int count;\n  private int col;\n  private int row;\n\n  Matrix(int count, int col, int row) {\n    this.count = count;\n    this.col = col;\n    this.row = row;\n  }\n\n  int count() {\n    return count;\n  }\n\n  int col() {\n    return col;\n  }\n\n  int row() {\n    return row;\n  }\n}\n","index":98},{"title":"Minimum Sum Partition","category":"DynamicProgramming","id":"MinimumSumPartition_DynamicProgramming","algorithm":"package DynamicProgramming;\n// Partition a set into two subsets such that the difference of subset sums is minimum\n\n/*\nInput:  arr[] = {1, 6, 11, 5}\nOutput: 1\nExplanation:\nSubset1 = {1, 5, 6}, sum of Subset1 = 12\nSubset2 = {11}, sum of Subset2 = 11\n\nInput:  arr[] = {36, 7, 46, 40}\nOutput: 23\nExplanation:\nSubset1 = {7, 46} ;  sum of Subset1 = 53\nSubset2 = {36, 40} ; sum of Subset2  = 76\n */\n\nimport java.io.*;\nimport java.util.*;\n\npublic class MinimumSumPartition {\n  public static int subSet(int[] arr) {\n    int n = arr.length;\n    int sum = getSum(arr);\n    boolean[][] dp = new boolean[n + 1][sum + 1];\n    for (int i = 0; i <= n; i++) {\n      dp[i][0] = true;\n    }\n    for (int j = 0; j <= sum; j++) {\n      dp[0][j] = false;\n    }\n\n    // fill dp array\n    for (int i = 1; i <= n; i++) {\n      for (int j = 1; j <= sum; j++) {\n        if (arr[i - 1] < j) {\n          dp[i][j] = dp[i - 1][j - arr[i - 1]] || dp[i - 1][j];\n        } else if (arr[i - 1] == j) {\n          dp[i][j] = true;\n        } else {\n          dp[i][j] = dp[i - 1][j];\n        }\n      }\n    }\n\n    // fill the index array\n    int[] index = new int[sum];\n    int p = 0;\n    for (int i = 0; i <= sum / 2; i++) {\n      if (dp[n][i]) {\n        index[p++] = i;\n      }\n    }\n\n    return getMin(index, sum);\n  }\n\n  /**\n   * Calculate sum of array elements\n   *\n   * @param arr the array\n   * @return sum of given array\n   */\n  public static int getSum(int[] arr) {\n    int sum = 0;\n    for (int temp : arr) {\n      sum += temp;\n    }\n    return sum;\n  }\n\n  public static int getMin(int[] arr, int sum) {\n    if (arr.length == 0) {\n      return 0;\n    }\n    int min = Integer.MAX_VALUE;\n    for (int temp : arr) {\n      min = Math.min(min, sum - 2 * temp);\n    }\n    return min;\n  }\n\n  /** Driver Code */\n  public static void main(String[] args) {\n    assert subSet(new int[] {1, 6, 11, 5}) == 1;\n    assert subSet(new int[] {36, 7, 46, 40}) == 23;\n    assert subSet(new int[] {1, 2, 3, 9}) == 3;\n  }\n}\n","index":99},{"title":"Rod Cutting","category":"DynamicProgramming","id":"RodCutting_DynamicProgramming","algorithm":"package DynamicProgramming;\n\n/**\n * A DynamicProgramming solution for Rod cutting problem Returns the best obtainable price for a rod\n * of length n and price[] as prices of different pieces\n */\npublic class RodCutting {\n\n  private static int cutRod(int[] price, int n) {\n    int val[] = new int[n + 1];\n    val[0] = 0;\n\n    for (int i = 1; i <= n; i++) {\n      int max_val = Integer.MIN_VALUE;\n      for (int j = 0; j < i; j++) max_val = Math.max(max_val, price[j] + val[i - j - 1]);\n\n      val[i] = max_val;\n    }\n\n    return val[n];\n  }\n\n  // main function to test\n  public static void main(String args[]) {\n    int[] arr = new int[] {2, 5, 13, 19, 20};\n    int size = arr.length;\n    int result = cutRod(arr, size);\n    System.out.println(\"Maximum Obtainable Value is \" + result);\n  }\n}\n","index":100},{"title":"Subset Sum","category":"DynamicProgramming","id":"SubsetSum_DynamicProgramming","algorithm":"package DynamicProgramming;\n\npublic class SubsetSum {\n\n  /** Driver Code */\n  public static void main(String[] args) {\n    int[] arr = new int[] {50, 4, 10, 15, 34};\n    assert subsetSum(arr, 64); /* 4 + 10 + 15 + 34 = 64 */\n    assert subsetSum(arr, 99); /* 50 + 15 + 34 = 99 */\n    assert !subsetSum(arr, 5);\n    assert !subsetSum(arr, 66);\n  }\n\n  /**\n   * Test if a set of integers contains a subset that sum to a given integer.\n   *\n   * @param arr the array contains integers.\n   * @param sum target sum of subset.\n   * @return {@code true} if subset exists, otherwise {@code false}.\n   */\n  private static boolean subsetSum(int[] arr, int sum) {\n    int n = arr.length;\n    boolean[][] isSum = new boolean[n + 2][sum + 1];\n\n    isSum[n + 1][0] = true;\n    for (int i = 1; i <= sum; i++) {\n      isSum[n + 1][i] = false;\n    }\n\n    for (int i = n; i > 0; i--) {\n      isSum[i][0] = true;\n      for (int j = 1; j <= arr[i - 1] - 1; j++) {\n        if (j <= sum) {\n          isSum[i][j] = isSum[i + 1][j];\n        }\n      }\n      for (int j = arr[i - 1]; j <= sum; j++) {\n        isSum[i][j] = (isSum[i + 1][j] || isSum[i + 1][j - arr[i - 1]]);\n      }\n    }\n\n    return isSum[1][sum];\n  }\n}\n","index":101},{"title":"Maths","category":null,"id":"Maths","index":102},{"title":"Absolute Max","category":"Maths","id":"AbsoluteMax_Maths","algorithm":"package Maths;\n\nimport java.util.Arrays;\n\n/**\n * description:\n *\n * <p>absMax([0, 5, 1, 11]) = 11, absMax([3 , -10, -2]) = -10\n */\npublic class AbsoluteMax {\n  public static void main(String[] args) {\n    int[] testnums = {-2, 0, 16};\n    assert absMax(testnums) == 16;\n\n    int[] numbers = {3, -10, -2};\n    System.out.println(\"absMax(\" + Arrays.toString(numbers) + \") = \" + absMax(numbers));\n  }\n\n  /**\n   * get the value, return the absolute max value\n   *\n   * @param numbers contains elements\n   * @return the absolute max value\n   */\n  public static int absMax(int[] numbers) {\n    int absMaxValue = numbers[0];\n    for (int i = 1, length = numbers.length; i < length; ++i) {\n      if (Math.abs(numbers[i]) > Math.abs(absMaxValue)) {\n        absMaxValue = numbers[i];\n      }\n    }\n    return absMaxValue;\n  }\n}\n","index":103},{"title":"Absolute Min","category":"Maths","id":"AbsoluteMin_Maths","algorithm":"package Maths;\n\nimport java.util.Arrays;\n\n/**\n * description:\n *\n * <p>absMin([0, 5, 1, 11]) = 0, absMin([3 , -10, -2]) = -2\n */\npublic class AbsoluteMin {\n  public static void main(String[] args) {\n    int[] testnums = {4, 0, 16};\n    assert absMin(testnums) == 0;\n\n    int[] numbers = {3, -10, -2};\n    System.out.println(\"absMin(\" + Arrays.toString(numbers) + \") = \" + absMin(numbers));\n  }\n\n  /**\n   * get the value, returns the absolute min value min\n   *\n   * @param numbers contains elements\n   * @return the absolute min value\n   */\n  public static int absMin(int[] numbers) {\n    int absMinValue = numbers[0];\n    for (int i = 1, length = numbers.length; i < length; ++i) {\n      if (Math.abs(numbers[i]) < Math.abs(absMinValue)) {\n        absMinValue = numbers[i];\n      }\n    }\n    return absMinValue;\n  }\n}\n","index":104},{"title":"Absolute Value","category":"Maths","id":"AbsoluteValue_Maths","algorithm":"package Maths;\n\nimport java.util.Random;\n\npublic class AbsoluteValue {\n\n  public static void main(String[] args) {\n    Random random = new Random();\n\n    /* test 1000 random numbers */\n    for (int i = 1; i <= 1000; ++i) {\n      int randomNumber = random.nextInt();\n      assert absVal(randomNumber) == Math.abs(randomNumber);\n    }\n  }\n\n  /**\n   * If value is less than zero, make value positive.\n   *\n   * @param value a number\n   * @return the absolute value of a number\n   */\n  public static int absVal(int value) {\n    return value < 0 ? -value : value;\n  }\n}\n","index":105},{"title":"Aliquot Sum","category":"Maths","id":"AliquotSum_Maths","algorithm":"package Maths;\n\n/**\n * In number theory, the aliquot sum s(n) of a positive integer n is the sum of all proper divisors\n * of n, that is, all divisors of n other than n itself. For example, the proper divisors of 15\n * (that is, the positive divisors of 15 that are not equal to 15) are 1, 3 and 5, so the aliquot\n * sum of 15 is 9 i.e. (1 + 3 + 5). Wikipedia: https://en.wikipedia.org/wiki/Aliquot_sum\n */\npublic class AliquotSum {\n  public static void main(String[] args) {\n    assert aliquotSum(1) == 0;\n    assert aliquotSum(6) == 6;\n    assert aliquotSum(15) == 9;\n    assert aliquotSum(19) == 1;\n  }\n\n  /**\n   * Finds the aliquot sum of an integer number\n   *\n   * @param number a positive integer\n   * @return aliquot sum of given {@code number}\n   */\n  public static int aliquotSum(int number) {\n    int sum = 0;\n    for (int i = 1, limit = number / 2; i <= limit; ++i) {\n      if (number % i == 0) {\n        sum += i;\n      }\n    }\n    return sum;\n  }\n}\n","index":106},{"title":"Amicable Number","category":"Maths","id":"AmicableNumber_Maths","algorithm":"package Maths;\n\n/**\n * Amicable numbers are two different numbers so related that the sum of the proper divisors of each\n * is equal to the other number. (A proper divisor of a number is a positive factor of that number\n * other than the number itself. For example, the proper divisors of 6 are 1, 2, and 3.) A pair of\n * amicable numbers constitutes an aliquot sequence of period 2. It is unknown if there are\n * infinitely many pairs of amicable numbers. *\n *\n * <p>* link: https://en.wikipedia.org/wiki/Amicable_numbers *\n *\n * <p>Simple Example : (220,284) 220 is divisible by {1,2,4,5,10,11,20,22,44,55,110 } <- Sum = 284\n * 284 is divisible by -> 1,2,4,71,142 and the Sum of that is. Yes right you probably expected it\n * 220\n */\npublic class AmicableNumber {\n\n  public static void main(String[] args) {\n\n    AmicableNumber.findAllInRange(1, 3000);\n    /* Res -> Int Range of 1 till 3000there are 3Amicable_numbers These are  1: = ( 220,284)\t2: = ( 1184,1210)\n    3: = ( 2620,2924) So it worked\t*/\n\n  }\n\n  /**\n   * @param startValue\n   * @param stopValue\n   * @return\n   */\n  static void findAllInRange(int startValue, int stopValue) {\n\n    /* the 2 for loops are to avoid to double check tuple. For example (200,100) and (100,200) is the same calculation\n     * also to avoid is to check the number with it self. a number with itself is always a AmicableNumber\n     * */\n    StringBuilder res = new StringBuilder();\n    int countofRes = 0;\n\n    for (int i = startValue; i < stopValue; i++) {\n      for (int j = i + 1; j <= stopValue; j++) {\n        if (isAmicableNumber(i, j)) {\n          countofRes++;\n          res.append(\"\" + countofRes + \": = ( \" + i + \",\" + j + \")\" + \"\\t\");\n        }\n      }\n    }\n    res.insert(\n        0,\n        \"Int Range of \"\n            + startValue\n            + \" till \"\n            + stopValue\n            + \" there are \"\n            + countofRes\n            + \" Amicable_numbers.These are \\n \");\n    System.out.println(res.toString());\n  }\n\n  /**\n   * Check if {@code numberOne and numberTwo } are AmicableNumbers or not\n   *\n   * @param numberOne numberTwo\n   * @return {@code true} if {@code numberOne numberTwo} isAmicableNumbers otherwise false\n   */\n  static boolean isAmicableNumber(int numberOne, int numberTwo) {\n\n    return ((recursiveCalcOfDividerSum(numberOne, numberOne) == numberTwo\n        && numberOne == recursiveCalcOfDividerSum(numberTwo, numberTwo)));\n  }\n\n  /**\n   * calculated in recursive calls the Sum of all the Dividers beside it self\n   *\n   * @param number div = the next to test dividely by using the modulo operator\n   * @return sum of all the dividers\n   */\n  static int recursiveCalcOfDividerSum(int number, int div) {\n\n    if (div == 1) {\n      return 0;\n    } else if (number % --div == 0) {\n      return recursiveCalcOfDividerSum(number, div) + div;\n    } else {\n      return recursiveCalcOfDividerSum(number, div);\n    }\n  }\n}\n","index":107},{"title":"Area","category":"Maths","id":"Area_Maths","algorithm":"package Maths;\n\n/** Find the area of various geometric shapes */\npublic class Area {\n  public static void main(String[] args) {\n\n    /* test cube */\n    assert Double.compare(surfaceAreaCube(1), 6.0) == 0;\n\n    /* test sphere */\n    assert Double.compare(surfaceAreaSphere(5), 314.1592653589793) == 0;\n    assert Double.compare(surfaceAreaSphere(1), 12.566370614359172) == 0;\n\n    /* test rectangle */\n    assert Double.compare(surfaceAreaRectangle(10, 20), 200.0) == 0;\n\n    /* test square */\n    assert Double.compare(surfaceAreaSquare(10), 100.0) == 0;\n\n    /* test triangle */\n    assert Double.compare(surfaceAreaTriangle(10, 10), 50.0) == 0;\n\n    /* test parallelogram */\n    assert Double.compare(surfaceAreaParallelogram(10, 20), 200.0) == 0;\n\n    /* test trapezium */\n    assert Double.compare(surfaceAreaTrapezium(10, 20, 30), 450.0) == 0;\n\n    /* test circle */\n    assert Double.compare(surfaceAreaCircle(20), 1256.6370614359173) == 0;\n  }\n\n  /**\n   * Calculate the surface area of a cube.\n   *\n   * @param sideLength side length of cube\n   * @return surface area of given cube\n   */\n  private static double surfaceAreaCube(double sideLength) {\n    return 6 * sideLength * sideLength;\n  }\n\n  /**\n   * Calculate the surface area of a sphere.\n   *\n   * @param radius radius of sphere\n   * @return surface area of given sphere\n   */\n  private static double surfaceAreaSphere(double radius) {\n    return 4 * Math.PI * radius * radius;\n  }\n\n  /**\n   * Calculate the area of a rectangle\n   *\n   * @param length length of rectangle\n   * @param width width of rectangle\n   * @return area of given rectangle\n   */\n  private static double surfaceAreaRectangle(double length, double width) {\n    return length * width;\n  }\n\n  /**\n   * Calculate the area of a square\n   *\n   * @param sideLength side length of square\n   * @return area of given square\n   */\n  private static double surfaceAreaSquare(double sideLength) {\n    return sideLength * sideLength;\n  }\n\n  /**\n   * Calculate the area of a triangle\n   *\n   * @param base base of triangle\n   * @param height height of triangle\n   * @return area of given triangle\n   */\n  private static double surfaceAreaTriangle(double base, double height) {\n    return base * height / 2;\n  }\n\n  /**\n   * Calculate the area of a parallelogram\n   *\n   * @param base base of parallelogram\n   * @param height height of parallelogram\n   * @return area of given parallelogram\n   */\n  private static double surfaceAreaParallelogram(double base, double height) {\n    return base * height;\n  }\n\n  /**\n   * Calculate the area of a trapezium\n   *\n   * @param base1 upper base of trapezium\n   * @param base2 bottom base of trapezium\n   * @param height height of trapezium\n   * @return area of given trapezium\n   */\n  private static double surfaceAreaTrapezium(double base1, double base2, double height) {\n    return (base1 + base2) * height / 2;\n  }\n\n  /**\n   * Calculate the area of a circle\n   *\n   * @param radius radius of circle\n   * @return area of given circle\n   */\n  private static double surfaceAreaCircle(double radius) {\n    return Math.PI * radius * radius;\n  }\n}\n","index":108},{"title":"Armstrong","category":"Maths","id":"Armstrong_Maths","algorithm":"package Maths;\n\n/**\n * An Armstrong number is equal to the sum of the cubes of its digits. For example, 370 is an\n * Armstrong number because 3*3*3 + 7*7*7 + 0*0*0 = 370. An Armstrong number is often called\n * Narcissistic number.\n */\npublic class Armstrong {\n\n  public static void main(String[] args) {\n    assert (isArmStrong(0));\n    assert (isArmStrong(1));\n    assert (isArmStrong(153));\n    assert (isArmStrong(1634));\n    assert (isArmStrong(371));\n    assert (!isArmStrong(200));\n  }\n\n  /**\n   * Checks whether a given number is an armstrong number or not.\n   *\n   * @param number number to check\n   * @return {@code true} if given number is armstrong number, {@code false} otherwise\n   */\n  private static boolean isArmStrong(int number) {\n    int sum = 0;\n    int temp = number;\n    int numberOfDigits = 0;\n    while (temp != 0) {\n      numberOfDigits++;\n      temp /= 10;\n    }\n    temp = number; /* copy number again */\n    while (number > 0) {\n      int remainder = number % 10;\n      int power = 1;\n      for (int i = 1; i <= numberOfDigits; power *= remainder, ++i)\n        ;\n      sum = sum + power;\n      number /= 10;\n    }\n    return sum == temp;\n  }\n}\n","index":109},{"title":"Average","category":"Maths","id":"Average_Maths","algorithm":"package Maths;\n\n/** Calculate average of a list of numbers */\npublic class Average {\n  private static final double SMALL_VALUE = 0.00001f;\n\n  public static void main(String[] args) {\n    assert Math.abs(average(new double[] {3, 6, 9, 12, 15, 18, 21}) - 12) < SMALL_VALUE;\n    assert Math.abs(average(new double[] {5, 10, 15, 20, 25, 30, 35}) - 20) < SMALL_VALUE;\n    assert Math.abs(average(new double[] {1, 2, 3, 4, 5, 6, 7, 8}) - 4.5) < SMALL_VALUE;\n    int[] array = {2, 4, 10};\n    assert average(array) == 5;\n  }\n\n  /**\n   * Calculate average of a list of numbers\n   *\n   * @param numbers array to store numbers\n   * @return mean of given numbers\n   */\n  public static double average(double[] numbers) {\n    double sum = 0;\n    for (double number : numbers) {\n      sum += number;\n    }\n    return sum / numbers.length;\n  }\n\n  /**\n   * find average value of int array\n   *\n   * @param array the array contains element and the sum does not excess long value limit\n   * @return average value\n   */\n  public static int average(int[] array) {\n    long sum = 0;\n    for (int i = 0; i < array.length; ++i) {\n      sum += array[i];\n    }\n    return (int) (sum / array.length);\n  }\n}\n","index":110},{"title":"Binary Pow","category":"Maths","id":"BinaryPow_Maths","algorithm":"package Maths;\n\npublic class BinaryPow {\n  /**\n   * Calculate a^p using binary exponentiation\n   * [Binary-Exponentiation](https://cp-algorithms.com/algebra/binary-exp.html)\n   *\n   * @param a the base for exponentiation\n   * @param p the exponent - must be greater than 0\n   * @return a^p\n   */\n  public static int binPow(int a, int p) {\n    int res = 1;\n    while (p > 0) {\n      if ((p & 1) == 1) {\n        res = res * a;\n      }\n      a = a * a;\n      p >>>= 1;\n    }\n    return res;\n  }\n\n  /**\n   * Function for testing binary exponentiation\n   *\n   * @param a the base\n   * @param p the exponent\n   */\n  public static void test(int a, int p) {\n    int res = binPow(a, p);\n    assert res == (int) Math.pow(a, p) : \"Incorrect Implementation\";\n    System.out.println(a + \"^\" + p + \": \" + res);\n  }\n\n  /**\n   * Main Function to call tests\n   *\n   * @param args System Line Arguments\n   */\n  public static void main(String[] args) {\n    // prints 2^15: 32768\n    test(2, 15);\n\n    // prints 3^9: 19683\n    test(3, 9);\n  }\n}\n","index":111},{"title":"Ceil","category":"Maths","id":"Ceil_Maths","algorithm":"package Maths;\n\nimport java.util.Random;\n\npublic class Ceil {\n  public static void main(String[] args) {\n    Random random = new Random();\n    for (int i = 1; i <= 1000; ++i) {\n      double randomNumber = random.nextDouble();\n      assert ceil(randomNumber) == Math.ceil(randomNumber);\n    }\n  }\n\n  /**\n   * Returns the smallest (closest to negative infinity)\n   *\n   * @param number the number\n   * @return the smallest (closest to negative infinity) of given {@code number}\n   */\n  public static double ceil(double number) {\n    if (number - (int) number == 0) {\n      return number;\n    } else if (number - (int) number > 0) {\n      return (int) (number + 1);\n    } else {\n      return (int) number;\n    }\n  }\n}\n","index":112},{"title":"Combinations","category":"Maths","id":"Combinations_Maths","algorithm":"package Maths;\n\n/** @see <a href=\"https://en.wikipedia.org/wiki/Combination\">Combination</a> */\npublic class Combinations {\n  public static void main(String[] args) {\n    assert combinations(1, 1) == 1;\n    assert combinations(10, 5) == 252;\n    assert combinations(6, 3) == 20;\n    assert combinations(20, 5) == 15504;\n  }\n\n  /**\n   * Calculate of factorial\n   *\n   * @param n the number\n   * @return factorial of given number\n   */\n  public static long factorial(int n) {\n    if (n < 0) {\n      throw new IllegalArgumentException(\"number is negative\");\n    }\n    return n == 0 || n == 1 ? 1 : n * factorial(n - 1);\n  }\n\n  /**\n   * Calculate combinations\n   *\n   * @param n first number\n   * @param k second number\n   * @return combinations of given {@code n} and {@code k}\n   */\n  public static long combinations(int n, int k) {\n    return factorial(n) / (factorial(k) * factorial(n - k));\n  }\n}\n","index":113},{"title":"Factorial","category":"Maths","id":"Factorial_Maths","algorithm":"package Maths;\n\npublic class Factorial {\n\n  /* Driver Code */\n  public static void main(String[] args) {\n    assert factorial(0) == 1;\n    assert factorial(1) == 1;\n    assert factorial(5) == 120;\n    assert factorial(10) == 3628800;\n  }\n\n  /**\n   * Calculate factorial N using iteration\n   *\n   * @param n the number\n   * @return the factorial of {@code n}\n   */\n  public static long factorial(int n) {\n    if (n < 0) {\n      throw new IllegalArgumentException(\"number is negative\");\n    }\n    long factorial = 1;\n    for (int i = 1; i <= n; factorial *= i, ++i)\n      ;\n    return factorial;\n  }\n}\n","index":114},{"title":"Factorial Recursion","category":"Maths","id":"FactorialRecursion_Maths","algorithm":"package Maths;\n\npublic class FactorialRecursion {\n\n  /* Driver Code */\n  public static void main(String[] args) {\n    assert factorial(0) == 1;\n    assert factorial(1) == 1;\n    assert factorial(2) == 2;\n    assert factorial(3) == 6;\n    assert factorial(5) == 120;\n  }\n\n  /**\n   * Recursive FactorialRecursion Method\n   *\n   * @param n The number to factorial\n   * @return The factorial of the number\n   */\n  public static long factorial(int n) {\n    if (n < 0) {\n      throw new IllegalArgumentException(\"number is negative\");\n    }\n    return n == 0 || n == 1 ? 1 : n * factorial(n - 1);\n  }\n}\n","index":115},{"title":"Fibonacci Number","category":"Maths","id":"FibonacciNumber_Maths","algorithm":"package Maths;\n\n/** Fibonacci: 0 1 1 2 3 5 8 13 21 ... */\npublic class FibonacciNumber {\n  public static void main(String[] args) {\n    assert isFibonacciNumber(1);\n    assert isFibonacciNumber(2);\n    assert isFibonacciNumber(21);\n    assert !isFibonacciNumber(9);\n    assert !isFibonacciNumber(10);\n  }\n\n  /**\n   * Check if a number is perfect square number\n   *\n   * @param number the number to be checked\n   * @return <tt>true</tt> if {@code number} is perfect square, otherwise <tt>false</tt>\n   */\n  public static boolean isPerfectSquare(int number) {\n    int sqrt = (int) Math.sqrt(number);\n    return sqrt * sqrt == number;\n  }\n\n  /**\n   * Check if a number is fibonacci number This is true if and only if at least one of 5x^2+4 or\n   * 5x^2-4 is a perfect square\n   *\n   * @param number the number\n   * @return <tt>true</tt> if {@code number} is fibonacci number, otherwise <tt>false</tt>\n   * @link https://en.wikipedia.org/wiki/Fibonacci_number#Identification\n   */\n  public static boolean isFibonacciNumber(int number) {\n    return isPerfectSquare(5 * number * number + 4) || isPerfectSquare(5 * number * number - 4);\n  }\n}\n","index":116},{"title":"Find Max","category":"Maths","id":"FindMax_Maths","algorithm":"package Maths;\n\nimport java.util.Arrays;\nimport java.util.Random;\n\npublic class FindMax {\n\n  /** Driver Code */\n  public static void main(String[] args) {\n    Random random = new Random();\n\n    /* random size */\n    int size = random.nextInt(100) + 1;\n    int[] array = new int[size];\n\n    /* init array with random numbers */\n    for (int i = 0; i < size; i++) {\n      array[i] = random.nextInt() % 100;\n    }\n\n    assert Arrays.stream(array).max().getAsInt() == findMax(array);\n  }\n\n  /**\n   * find max of array\n   *\n   * @param array the array contains element\n   * @return max value of given array\n   */\n  public static int findMax(int[] array) {\n    int max = array[0];\n    for (int i = 1; i < array.length; ++i) {\n      if (array[i] > max) {\n        max = array[i];\n      }\n    }\n    return max;\n  }\n}\n","index":117},{"title":"Find Max Recursion","category":"Maths","id":"FindMaxRecursion_Maths","algorithm":"package Maths;\n\nimport java.util.Arrays;\nimport java.util.Random;\n\npublic class FindMaxRecursion {\n  public static void main(String[] args) {\n    Random rand = new Random();\n\n    /* rand size */\n    int size = rand.nextInt(100) + 1;\n    int[] array = new int[size];\n\n    /* init array with rand numbers */\n    for (int i = 0; i < size; i++) {\n      array[i] = rand.nextInt() % 100;\n    }\n\n    assert max(array, array.length) == Arrays.stream(array).max().getAsInt();\n    assert max(array, 0, array.length - 1) == Arrays.stream(array).max().getAsInt();\n  }\n\n  /**\n   * Get max of array using divide and conquer algorithm\n   *\n   * @param array contains elements\n   * @param low the index of the first element\n   * @param high the index of the last element\n   * @return max of {@code array}\n   */\n  public static int max(int[] array, int low, int high) {\n    if (low == high) {\n      return array[low]; // or array[high]\n    }\n\n    int mid = (low + high) >>> 1;\n\n    int leftMax = max(array, low, mid); // get max in [low, mid]\n    int rightMax = max(array, mid + 1, high); // get max in [mid+1, high]\n\n    return Math.max(leftMax, rightMax);\n  }\n\n  /**\n   * Get max of array using recursion algorithm\n   *\n   * @param array contains elements\n   * @param len length of given array\n   * @return max value of {@code array}\n   */\n  public static int max(int[] array, int len) {\n    return len == 1 ? array[0] : Math.max(max(array, len - 1), array[len - 1]);\n  }\n}\n","index":118},{"title":"Find Min","category":"Maths","id":"FindMin_Maths","algorithm":"package Maths;\n\nimport java.util.Arrays;\nimport java.util.Random;\n\npublic class FindMin {\n\n  /** Driver Code */\n  public static void main(String[] args) {\n    Random random = new Random();\n\n    /* random size */\n    int size = random.nextInt(100) + 1;\n    int[] array = new int[size];\n\n    /* init array with random numbers */\n    for (int i = 0; i < size; i++) {\n      array[i] = random.nextInt() % 100;\n    }\n\n    assert Arrays.stream(array).min().getAsInt() == findMin(array);\n  }\n\n  /**\n   * Find the minimum number of an array of numbers.\n   *\n   * @param array the array contains element\n   * @return min value\n   */\n  public static int findMin(int[] array) {\n    int min = array[0];\n    for (int i = 1; i < array.length; ++i) {\n      if (array[i] < min) {\n        min = array[i];\n      }\n    }\n    return min;\n  }\n}\n","index":119},{"title":"Find Min Recursion","category":"Maths","id":"FindMinRecursion_Maths","algorithm":"package Maths;\n\nimport java.util.Arrays;\nimport java.util.Random;\n\npublic class FindMinRecursion {\n\n  /** Driver Code */\n  public static void main(String[] args) {\n    Random rand = new Random();\n\n    /* rand size */\n    int size = rand.nextInt(100) + 1;\n    int[] array = new int[size];\n\n    /* init array with rand numbers */\n    for (int i = 0; i < size; i++) {\n      array[i] = rand.nextInt() % 100;\n    }\n\n    assert min(array, 0, array.length - 1) == Arrays.stream(array).min().getAsInt();\n    assert min(array, array.length) == Arrays.stream(array).min().getAsInt();\n  }\n\n  /**\n   * Get min of array using divide and conquer algorithm\n   *\n   * @param array contains elements\n   * @param low the index of the first element\n   * @param high the index of the last element\n   * @return min of {@code array}\n   */\n  public static int min(int[] array, int low, int high) {\n    if (low == high) {\n      return array[low]; // or array[high]\n    }\n\n    int mid = (low + high) >>> 1;\n\n    int leftMin = min(array, low, mid); // get min in [low, mid]\n    int rightMin = min(array, mid + 1, high); // get min in [mid+1, high]\n\n    return Math.min(leftMin, rightMin);\n  }\n\n  /**\n   * Get min of array using recursion algorithm\n   *\n   * @param array contains elements\n   * @param len length of given array\n   * @return min value of {@code array}\n   */\n  public static int min(int[] array, int len) {\n    return len == 1 ? array[0] : Math.min(min(array, len - 1), array[len - 1]);\n  }\n}\n","index":120},{"title":"Floor","category":"Maths","id":"Floor_Maths","algorithm":"package Maths;\n\nimport java.util.Random;\n\npublic class Floor {\n  public static void main(String[] args) {\n    Random random = new Random();\n    for (int i = 1; i <= 1000; ++i) {\n      double randomNumber = random.nextDouble();\n      assert floor(randomNumber) == Math.floor(randomNumber);\n    }\n  }\n\n  /**\n   * Returns the largest (closest to positive infinity)\n   *\n   * @param number the number\n   * @return the largest (closest to positive infinity) of given {@code number}\n   */\n  public static double floor(double number) {\n    if (number - (int) number == 0) {\n      return number;\n    } else if (number - (int) number > 0) {\n      return (int) number;\n    } else {\n      return (int) number - 1;\n    }\n  }\n}\n","index":121},{"title":"G C D","category":"Maths","id":"GCD_Maths","algorithm":"package Maths;\n\n/**\n * This is Euclid's algorithm which is used to find the greatest common denominator Overide function\n * name gcd\n *\n * @author Oskar Enmalm 3/10/17\n */\npublic class GCD {\n\n  /**\n   * get greatest common divisor\n   *\n   * @param num1 the first number\n   * @param num2 the second number\n   * @return gcd\n   */\n  public static int gcd(int num1, int num2) {\n    if (num1 < 0 || num2 < 0) {\n      throw new ArithmeticException();\n    }\n\n    if (num1 == 0 || num2 == 0) {\n      return Math.abs(num1 - num2);\n    }\n\n    while (num1 % num2 != 0) {\n      int remainder = num1 % num2;\n      num1 = num2;\n      num2 = remainder;\n    }\n    return num2;\n  }\n\n  /**\n   * get greatest common divisor in array\n   *\n   * @param number contains number\n   * @return gcd\n   */\n  public static int gcd(int[] number) {\n    int result = number[0];\n    for (int i = 1; i < number.length; i++)\n      // call gcd function (input two value)\n      result = gcd(result, number[i]);\n\n    return result;\n  }\n\n  public static void main(String[] args) {\n    int[] myIntArray = {4, 16, 32};\n\n    // call gcd function (input array)\n    System.out.println(gcd(myIntArray)); // => 4\n    System.out.printf(\"gcd(40,24)=%d gcd(24,40)=%d%n\", gcd(40, 24), gcd(24, 40)); // => 8\n  }\n}\n","index":122},{"title":"G C D Recursion","category":"Maths","id":"GCDRecursion_Maths","algorithm":"package Maths;\n\n/** @author https://github.com/shellhub/ */\npublic class GCDRecursion {\n  public static void main(String[] args) {\n    System.out.println(gcd(20, 15)); /* output: 5 */\n    System.out.println(gcd(10, 8)); /* output: 2 */\n    System.out.println(gcd(gcd(10, 5), gcd(5, 10))); /* output: 5 */\n  }\n\n  /**\n   * get greatest common divisor\n   *\n   * @param a the first number\n   * @param b the second number\n   * @return gcd\n   */\n  public static int gcd(int a, int b) {\n\n    if (a < 0 || b < 0) {\n      throw new ArithmeticException();\n    }\n\n    if (a == 0 || b == 0) {\n      return Math.abs(a - b);\n    }\n\n    if (a % b == 0) {\n      return b;\n    } else {\n      return gcd(b, a % b);\n    }\n  }\n}\n","index":123},{"title":"Lucas Series","category":"Maths","id":"LucasSeries_Maths","algorithm":"package Maths;\n\n/** https://en.wikipedia.org/wiki/Lucas_number */\npublic class LucasSeries {\n  public static void main(String[] args) {\n    assert lucasSeries(1) == 2 && lucasSeriesIteration(1) == 2;\n    assert lucasSeries(2) == 1 && lucasSeriesIteration(2) == 1;\n    assert lucasSeries(3) == 3 && lucasSeriesIteration(3) == 3;\n    assert lucasSeries(4) == 4 && lucasSeriesIteration(4) == 4;\n    assert lucasSeries(5) == 7 && lucasSeriesIteration(5) == 7;\n    assert lucasSeries(6) == 11 && lucasSeriesIteration(6) == 11;\n    assert lucasSeries(11) == 123 && lucasSeriesIteration(11) == 123;\n  }\n\n  /**\n   * Calculate nth number of lucas series(2, 1, 3, 4, 7, 11, 18, 29, 47, 76, 123, ....) using\n   * recursion\n   *\n   * @param n nth\n   * @return nth number of lucas series\n   */\n  public static int lucasSeries(int n) {\n    return n == 1 ? 2 : n == 2 ? 1 : lucasSeries(n - 1) + lucasSeries(n - 2);\n  }\n\n  /**\n   * Calculate nth number of lucas series(2, 1, 3, 4, 7, 11, 18, 29, 47, 76, 123, ....) using\n   * iteration\n   *\n   * @param n nth\n   * @return nth number of lucas series\n   */\n  public static int lucasSeriesIteration(int n) {\n    int previous = 2;\n    int current = 1;\n    for (int i = 1; i < n; i++) {\n      int next = previous + current;\n      previous = current;\n      current = next;\n    }\n    return previous;\n  }\n}\n","index":124},{"title":"Max Value","category":"Maths","id":"MaxValue_Maths","algorithm":"package Maths;\n\nimport java.util.Random;\n\npublic class MaxValue {\n\n  /** Driver Code */\n  public static void main(String[] args) {\n    Random rand = new Random();\n\n    /* test 100 times using rand numbers */\n    for (int i = 1; i <= 100; ++i) {\n      /* generate number from -50 to 49 */\n      int a = rand.nextInt(100) - 50;\n      int b = rand.nextInt(100) - 50;\n      assert max(a, b) == Math.max(a, b);\n    }\n  }\n\n  /**\n   * Returns the greater of two {@code int} values. That is, the result is the argument closer to\n   * the value of {@link Integer#MAX_VALUE}. If the arguments have the same value, the result is\n   * that same value.\n   *\n   * @param a an argument.\n   * @param b another argument.\n   * @return the larger of {@code a} and {@code b}.\n   */\n  public static int max(int a, int b) {\n    return a >= b ? a : b;\n  }\n}\n","index":125},{"title":"Median","category":"Maths","id":"Median_Maths","algorithm":"package Maths;\n\nimport java.util.Arrays;\n\n/** Wikipedia: https://en.wikipedia.org/wiki/Median */\npublic class Median {\n  public static void main(String[] args) {\n    assert median(new int[] {0}) == 0;\n    assert median(new int[] {1, 2}) == 1.5;\n    assert median(new int[] {4, 1, 3, 2}) == 2.5;\n    assert median(new int[] {1, 3, 3, 6, 7, 8, 9}) == 6;\n    assert median(new int[] {1, 2, 3, 4, 5, 6, 8, 9}) == 4.5;\n  }\n\n  /**\n   * Calculate average median\n   *\n   * @param values number series\n   * @return median of given {@code values}\n   */\n  public static double median(int[] values) {\n    Arrays.sort(values);\n    int length = values.length;\n    return length % 2 == 0\n        ? (values[length / 2] + values[length / 2 - 1]) / 2.0\n        : values[length / 2];\n  }\n}\n","index":126},{"title":"Min Value","category":"Maths","id":"MinValue_Maths","algorithm":"package Maths;\n\nimport java.util.Random;\n\npublic class MinValue {\n\n  /** Driver Code */\n  public static void main(String[] args) {\n    Random rand = new Random();\n\n    /* test 100 times using rand numbers */\n    for (int i = 1; i <= 100; ++i) {\n      /* generate number from -50 to 49 */\n      int a = rand.nextInt(100) - 50;\n      int b = rand.nextInt(100) - 50;\n      assert min(a, b) == Math.min(a, b);\n    }\n  }\n\n  /**\n   * Returns the smaller of two {@code int} values. That is, the result the argument closer to the\n   * value of {@link Integer#MIN_VALUE}. If the arguments have the same value, the result is that\n   * same value.\n   *\n   * @param a an argument.\n   * @param b another argument.\n   * @return the smaller of {@code a} and {@code b}.\n   */\n  public static int min(int a, int b) {\n    return a <= b ? a : b;\n  }\n}\n","index":127},{"title":"Mode","category":"Maths","id":"Mode_Maths","algorithm":"package Maths;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\n\n/*\n * Find the mode of an array of numbers\n *\n * The mode of an array of numbers is the most frequently occurring number in the array,\n * or the most frequently occurring numbers if there are multiple numbers with the same frequency\n */\npublic class Mode {\n\n  public static void main(String[] args) {\n\n    /* Test array of integers */\n    assert (mode(new int[] {})) == null;\n    assert Arrays.equals(mode(new int[] {5}), new int[] {5});\n    assert Arrays.equals(mode(new int[] {1, 2, 3, 4, 5}), new int[] {1, 2, 3, 4, 5});\n    assert Arrays.equals(mode(new int[] {7, 9, 9, 4, 5, 6, 7, 7, 8}), new int[] {7});\n    assert Arrays.equals(mode(new int[] {7, 9, 9, 4, 5, 6, 7, 7, 9}), new int[] {7, 9});\n  }\n\n  /*\n   * Find the mode of an array of integers\n   *\n   * @param numbers array of integers\n   * @return mode of the array\n   */\n  public static int[] mode(int[] numbers) {\n\n    if (numbers.length == 0) return null;\n\n    HashMap<Integer, Integer> count = new HashMap<>();\n\n    for (int num : numbers) {\n      if (count.containsKey(num)) {\n\n        count.put(num, count.get(num) + 1);\n\n      } else {\n\n        count.put(num, 1);\n      }\n    }\n\n    int max = Collections.max(count.values());\n    ArrayList<Integer> modes = new ArrayList<>();\n\n    for (int num : count.keySet()) {\n      if (count.get(num) == max) {\n        modes.add(num);\n      }\n    }\n    return modes.stream().mapToInt(n -> n).toArray();\n  }\n}\n","index":128},{"title":"Number Of Digits","category":"Maths","id":"NumberOfDigits_Maths","algorithm":"package Maths;\n\n/** Find the number of digits in a number. */\npublic class NumberOfDigits {\n  public static void main(String[] args) {\n    int[] numbers = {0, 12, 123, 1234, -12345, 123456, 1234567, 12345678, 123456789};\n    for (int i = 0; i < numbers.length; ++i) {\n      assert numberOfDigits(numbers[i]) == i + 1;\n      assert numberOfDigitsFast(numbers[i]) == i + 1;\n      assert numberOfDigitsFaster(numbers[i]) == i + 1;\n      assert numberOfDigitsRecursion(numbers[i]) == i + 1;\n    }\n  }\n\n  /**\n   * Find the number of digits in a number.\n   *\n   * @param number number to find\n   * @return number of digits of given number\n   */\n  private static int numberOfDigits(int number) {\n    int digits = 0;\n    do {\n      digits++;\n      number /= 10;\n    } while (number != 0);\n    return digits;\n  }\n\n  /**\n   * Find the number of digits in a number fast version.\n   *\n   * @param number number to find\n   * @return number of digits of given number\n   */\n  private static int numberOfDigitsFast(int number) {\n    return number == 0 ? 1 : (int) Math.floor(Math.log10(Math.abs(number)) + 1);\n  }\n\n  /**\n   * Find the number of digits in a number faster version.\n   *\n   * @param number number to find\n   * @return number of digits of given number\n   */\n  private static int numberOfDigitsFaster(int number) {\n    return number < 0 ? (-number + \"\").length() : (number + \"\").length();\n  }\n\n  /**\n   * Find the number of digits in a number using recursion.\n   *\n   * @param number number to find\n   * @return number of digits of given number\n   */\n  private static int numberOfDigitsRecursion(int number) {\n    return number / 10 == 0 ? 1 : 1 + numberOfDigitsRecursion(number / 10);\n  }\n}\n","index":129},{"title":"Palindrome Number","category":"Maths","id":"PalindromeNumber_Maths","algorithm":"package Maths;\n\npublic class PalindromeNumber {\n  public static void main(String[] args) {\n\n    assert isPalindrome(12321);\n    assert !isPalindrome(1234);\n    assert isPalindrome(1);\n  }\n\n  /**\n   * Check if {@code n} is palindrome number or not\n   *\n   * @param number the number\n   * @return {@code true} if {@code n} is palindrome number, otherwise {@code false}\n   */\n  public static boolean isPalindrome(int number) {\n    if (number < 0) {\n      throw new IllegalArgumentException(number + \"\");\n    }\n    int numberCopy = number;\n    int reverseNumber = 0;\n    while (numberCopy != 0) {\n      int remainder = numberCopy % 10;\n      reverseNumber = reverseNumber * 10 + remainder;\n      numberCopy /= 10;\n    }\n    return number == reverseNumber;\n  }\n}\n","index":130},{"title":"Parse Integer","category":"Maths","id":"ParseInteger_Maths","algorithm":"package Maths;\n\npublic class ParseInteger {\n  public static void main(String[] args) {\n    assert parseInt(\"123\") == Integer.parseInt(\"123\");\n    assert parseInt(\"-123\") == Integer.parseInt(\"-123\");\n    assert parseInt(\"0123\") == Integer.parseInt(\"0123\");\n    assert parseInt(\"+123\") == Integer.parseInt(\"+123\");\n  }\n\n  /**\n   * Parse a string to integer\n   *\n   * @param s the string\n   * @return the integer value represented by the argument in decimal.\n   * @throws NumberFormatException if the {@code string} does not contain a parsable integer.\n   */\n  public static int parseInt(String s) {\n    if (s == null || s.length() == 0) {\n      throw new NumberFormatException(\"null\");\n    }\n    boolean isNegative = s.charAt(0) == '-';\n    boolean isPositive = s.charAt(0) == '+';\n    int number = 0;\n    for (int i = isNegative ? 1 : isPositive ? 1 : 0, length = s.length(); i < length; ++i) {\n      if (!Character.isDigit(s.charAt(i))) {\n        throw new NumberFormatException(\"s=\" + s);\n      }\n      number = number * 10 + s.charAt(i) - '0';\n    }\n    return isNegative ? -number : number;\n  }\n}\n","index":131},{"title":"Perfect Cube","category":"Maths","id":"PerfectCube_Maths","algorithm":"package Maths;\n\n/** https://en.wikipedia.org/wiki/Cube_(algebra) */\npublic class PerfectCube {\n  public static void main(String[] args) {\n    assert !isPerfectCube(-1);\n    assert isPerfectCube(0);\n    assert isPerfectCube(1);\n    assert !isPerfectCube(4);\n    assert isPerfectCube(8);\n    assert isPerfectCube(27);\n  }\n\n  /**\n   * Check if a number is perfect cube or not\n   *\n   * @param number number to check\n   * @return {@code true} if {@code number} is perfect cube, otherwise {@code false}\n   */\n  public static boolean isPerfectCube(int number) {\n    int a = (int) Math.pow(number, 1.0 / 3);\n    return a * a * a == number;\n  }\n}\n","index":132},{"title":"Perfect Number","category":"Maths","id":"PerfectNumber_Maths","algorithm":"package Maths;\n\n/**\n * In number theory, a perfect number is a positive integer that is equal to the sum of its positive\n * divisors, excluding the number itself. For instance, 6 has divisors 1, 2 and 3 (excluding\n * itself), and 1 + 2 + 3 = 6, so 6 is a perfect number.\n *\n * <p>link:https://en.wikipedia.org/wiki/Perfect_number\n */\npublic class PerfectNumber {\n  public static void main(String[] args) {\n    assert isPerfectNumber(6); /* 1 + 2 + 3 == 6 */\n    assert !isPerfectNumber(8); /* 1 + 2 + 4 != 8 */\n    assert isPerfectNumber(28); /* 1 + 2 + 4 + 7 + 14 == 28 */\n  }\n\n  /**\n   * Check if {@code number} is perfect number or not\n   *\n   * @param number the number\n   * @return {@code true} if {@code number} is perfect number, otherwise false\n   */\n  public static boolean isPerfectNumber(int number) {\n    int sum = 0; /* sum of its positive divisors */\n    for (int i = 1; i < number; ++i) {\n      if (number % i == 0) {\n        sum += i;\n      }\n    }\n    return sum == number;\n  }\n}\n","index":133},{"title":"Perfect Square","category":"Maths","id":"PerfectSquare_Maths","algorithm":"package Maths;\n\n/** https://en.wikipedia.org/wiki/Perfect_square */\npublic class PerfectSquare {\n  public static void main(String[] args) {\n    assert !isPerfectSquare(-1);\n    assert !isPerfectSquare(3);\n    assert !isPerfectSquare(5);\n    assert isPerfectSquare(9);\n    assert isPerfectSquare(100);\n  }\n\n  /**\n   * Check if a number is perfect square number\n   *\n   * @param number the number to be checked\n   * @return <tt>true</tt> if {@code number} is perfect square, otherwise <tt>false</tt>\n   */\n  public static boolean isPerfectSquare(int number) {\n    int sqrt = (int) Math.sqrt(number);\n    return sqrt * sqrt == number;\n  }\n}\n","index":134},{"title":"Pow","category":"Maths","id":"Pow_Maths","algorithm":"package Maths;\n\n// POWER (exponentials) Examples (a^b)\npublic class Pow {\n  public static void main(String[] args) {\n    assert pow(2, 0) == Math.pow(2, 0); // == 1\n    assert pow(0, 2) == Math.pow(0, 2); // == 0\n    assert pow(2, 10) == Math.pow(2, 10); // == 1024\n    assert pow(10, 2) == Math.pow(10, 2); // == 100\n  }\n\n  /**\n   * Returns the value of the first argument raised to the power of the second argument\n   *\n   * @param a the base.\n   * @param b the exponent.\n   * @return the value {@code a}<sup>{@code b}</sup>.\n   */\n  public static long pow(int a, int b) {\n    long result = 1;\n    for (int i = 1; i <= b; i++) {\n      result *= a;\n    }\n    return result;\n  }\n}\n","index":135},{"title":"Pow Recursion","category":"Maths","id":"PowRecursion_Maths","algorithm":"package Maths;\n\npublic class PowRecursion {\n  public static void main(String[] args) {\n    assert Double.compare(pow(2, 0), Math.pow(2, 0)) == 0;\n    assert Double.compare(pow(0, 2), Math.pow(0, 2)) == 0;\n    assert Double.compare(pow(2, 10), Math.pow(2, 10)) == 0;\n    assert Double.compare(pow(10, 2), Math.pow(10, 2)) == 0;\n  }\n\n  /**\n   * Returns the value of the first argument raised to the power of the second argument\n   *\n   * @param a the base.\n   * @param b the exponent.\n   * @return the value {@code a}<sup>{@code b}</sup>.\n   */\n  public static long pow(int a, int b) {\n    return b == 0 ? 1 : a * pow(a, b - 1);\n  }\n}\n","index":136},{"title":"Power Of Two Or Not","category":"Maths","id":"PowerOfTwoOrNot_Maths","algorithm":"package Maths;\n\n/** A utility to check if a given number is power of two or not. For example 8,16 etc. */\npublic class PowerOfTwoOrNot {\n\n  public static void main(String[] args) {\n    assert !checkIfPowerOfTwoOrNot(0);\n    assert checkIfPowerOfTwoOrNot(1);\n    assert checkIfPowerOfTwoOrNot(8);\n    assert checkIfPowerOfTwoOrNot(16);\n    assert checkIfPowerOfTwoOrNot(1024);\n  }\n\n  /**\n   * Checks whether given number is power of two or not.\n   *\n   * @param number the number to check\n   * @return {@code true} if given number is power of two, otherwise {@code false}\n   */\n  public static boolean checkIfPowerOfTwoOrNot(int number) {\n    return number != 0 && ((number & (number - 1)) == 0);\n  }\n}\n","index":137},{"title":"Prime Check","category":"Maths","id":"PrimeCheck_Maths","algorithm":"package Maths;\n\nimport java.util.Scanner;\n\npublic class PrimeCheck {\n  public static void main(String[] args) {\n    Scanner scanner = new Scanner(System.in);\n\n    System.out.print(\"Enter a number: \");\n    int n = scanner.nextInt();\n    if (isPrime(n)) {\n      System.out.println(n + \" is a prime number\");\n    } else {\n      System.out.println(n + \" is not a prime number\");\n    }\n    scanner.close();\n  }\n\n  /***\n   * Checks if a number is prime or not\n   * @param n the number\n   * @return {@code true} if {@code n} is prime\n   */\n  public static boolean isPrime(int n) {\n    if (n == 2) {\n      return true;\n    }\n    if (n < 2 || n % 2 == 0) {\n      return false;\n    }\n    for (int i = 3, limit = (int) Math.sqrt(n); i <= limit; i += 2) {\n      if (n % i == 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n","index":138},{"title":"Prime Factorization","category":"Maths","id":"PrimeFactorization_Maths","algorithm":"package Maths;\n\nimport java.util.Scanner;\n\npublic class PrimeFactorization {\n  public static void main(String[] args) {\n    System.out.println(\"## all prime factors ##\");\n    Scanner scanner = new Scanner(System.in);\n    System.out.print(\"Enter a number: \");\n    int n = scanner.nextInt();\n    System.out.print((\"printing factors of \" + n + \" : \"));\n    pfactors(n);\n    scanner.close();\n  }\n\n  public static void pfactors(int n) {\n\n    while (n % 2 == 0) {\n      System.out.print(2 + \" \");\n      n /= 2;\n    }\n\n    for (int i = 3; i <= Math.sqrt(n); i += 2) {\n      while (n % i == 0) {\n        System.out.print(i + \" \");\n        n /= i;\n      }\n    }\n\n    if (n > 2) System.out.print(n);\n  }\n}\n","index":139},{"title":"Pythagorean Triple","category":"Maths","id":"PythagoreanTriple_Maths","algorithm":"package Maths;\n\n/** https://en.wikipedia.org/wiki/Pythagorean_triple */\npublic class PythagoreanTriple {\n  public static void main(String[] args) {\n    assert isPythagTriple(3, 4, 5);\n    assert isPythagTriple(5, 12, 13);\n    assert isPythagTriple(6, 8, 10);\n    assert !isPythagTriple(10, 20, 30);\n    assert !isPythagTriple(6, 8, 100);\n    assert !isPythagTriple(-1, -1, 1);\n  }\n\n  /**\n   * Check if a,b,c are a Pythagorean Triple\n   *\n   * @param a x/y component length of a right triangle\n   * @param b y/x component length of a right triangle\n   * @param c hypotenuse length of a right triangle\n   * @return boolean <tt>true</tt> if a, b, c satisfy the Pythagorean theorem, otherwise\n   *     <tt>false</tt>\n   */\n  public static boolean isPythagTriple(int a, int b, int c) {\n    if (a <= 0 || b <= 0 || c <= 0) {\n      return false;\n    } else {\n      return (a * a) + (b * b) == (c * c);\n    }\n  }\n}\n","index":140},{"title":"Sum Of Arithmetic Series","category":"Maths","id":"SumOfArithmeticSeries_Maths","algorithm":"package Maths;\n\n/**\n * In mathematics, an arithmetic progression (AP) or arithmetic sequence is a sequence of numbers\n * such that the difference between the consecutive terms is constant. Difference here means the\n * second minus the first. For instance, the sequence 5, 7, 9, 11, 13, 15, . . . is an arithmetic\n * progression with common difference of 2.\n *\n * <p>Wikipedia: https://en.wikipedia.org/wiki/Arithmetic_progression\n */\npublic class SumOfArithmeticSeries {\n  public static void main(String[] args) {\n\n    /* 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10 */\n    assert Double.compare(55.0, sumOfSeries(1, 1, 10)) == 0;\n\n    /* 1 + 3 + 5 + 7 + 9 + 11 + 13 + 15 + 17 + 19 */\n    assert Double.compare(100.0, sumOfSeries(1, 2, 10)) == 0;\n\n    /* 1 + 11 + 21 + 31 + 41 + 51 + 61 + 71 + 81 + 91 */\n    assert Double.compare(460.0, sumOfSeries(1, 10, 10)) == 0;\n\n    /* 0.1 + 0.2 + 0.3 + 0.4 + 0.5 + 0.6 + 0.7 + 0.8 + 0.9 + 1.0 */\n    assert Double.compare(5.5, sumOfSeries(0.1, 0.1, 10)) == 0;\n\n    assert Double.compare(49600.0, sumOfSeries(1, 10, 100)) == 0;\n  }\n\n  /**\n   * Calculate sum of arithmetic series\n   *\n   * @param firstTerm the initial term of an arithmetic series\n   * @param commonDiff the common difference of an arithmetic series\n   * @param numOfTerms the total terms of an arithmetic series\n   * @return sum of given arithmetic series\n   */\n  private static double sumOfSeries(double firstTerm, double commonDiff, int numOfTerms) {\n    return numOfTerms / 2.0 * (2 * firstTerm + (numOfTerms - 1) * commonDiff);\n  }\n}\n","index":141},{"title":"Sum Of Digits","category":"Maths","id":"SumOfDigits_Maths","algorithm":"package Maths;\n\npublic class SumOfDigits {\n  public static void main(String[] args) {\n    assert sumOfDigits(-123) == 6 && sumOfDigitsRecursion(-123) == 6 && sumOfDigitsFast(-123) == 6;\n\n    assert sumOfDigits(0) == 0 && sumOfDigitsRecursion(0) == 0 && sumOfDigitsFast(0) == 0;\n\n    assert sumOfDigits(12345) == 15\n        && sumOfDigitsRecursion(12345) == 15\n        && sumOfDigitsFast(12345) == 15;\n  }\n\n  /**\n   * Calculate the sum of digits of a number\n   *\n   * @param number the number contains digits\n   * @return sum of digits of given {@code number}\n   */\n  public static int sumOfDigits(int number) {\n    number = number < 0 ? -number : number; /* calculate abs value */\n    int sum = 0;\n    while (number != 0) {\n      sum += number % 10;\n      number /= 10;\n    }\n    return sum;\n  }\n\n  /**\n   * Calculate the sum of digits of a number using recursion\n   *\n   * @param number the number contains digits\n   * @return sum of digits of given {@code number}\n   */\n  public static int sumOfDigitsRecursion(int number) {\n    number = number < 0 ? -number : number; /* calculate abs value */\n    return number < 10 ? number : number % 10 + sumOfDigitsRecursion(number / 10);\n  }\n\n  /**\n   * Calculate the sum of digits of a number using char array\n   *\n   * @param number the number contains digits\n   * @return sum of digits of given {@code number}\n   */\n  public static int sumOfDigitsFast(int number) {\n    number = number < 0 ? -number : number; /* calculate abs value */\n    char[] digits = (number + \"\").toCharArray();\n    int sum = 0;\n    for (int i = 0; i < digits.length; ++i) {\n      sum += digits[i] - '0';\n    }\n    return sum;\n  }\n}\n","index":142},{"title":"Vampire Number","category":"Maths","id":"VampireNumber_Maths","algorithm":"package Maths;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\n\n/**\n * n number theory, a vampire number (or true vampire number) is a composite natural number with an\n * even number of digits, that can be factored into two natural numbers each with half as many\n * digits as the original number and not both with trailing zeroes, where the two factors contain\n * precisely all the digits of the original number, in any order, counting multiplicity. The first\n * vampire number is 1260 = 21 × 60. *\n *\n * <p>* link: https://en.wikipedia.org/wiki/Vampire_number *\n *\n * <p>\n */\npublic class VampireNumber {\n\n  public static void main(String[] args) {\n\n    test(10, 1000);\n  }\n\n  static void test(int startValue, int stopValue) {\n    int countofRes = 1;\n    StringBuilder res = new StringBuilder();\n\n    for (int i = startValue; i <= stopValue; i++) {\n      for (int j = i; j <= stopValue; j++) {\n        // System.out.println(i+ \" \"+ j);\n        if (isVampireNumber(i, j, true)) {\n          countofRes++;\n          res.append(\"\" + countofRes + \": = ( \" + i + \",\" + j + \" = \" + i * j + \")\" + \"\\n\");\n        }\n      }\n    }\n    System.out.println(res);\n  }\n\n  static boolean isVampireNumber(int a, int b, boolean noPseudoVamireNumbers) {\n\n    // this is for pseudoVampireNumbers  pseudovampire number need not be of length n/2 digits for\n    // example\n    // 126 = 6 x 21\n    if (noPseudoVamireNumbers) {\n      if (a * 10 <= b || b * 10 <= a) {\n        return false;\n      }\n    }\n\n    String mulDigits = splitIntoDigits(a * b, 0);\n    String faktorDigits = splitIntoDigits(a, b);\n\n    return mulDigits.equals(faktorDigits);\n  }\n\n  // methode to Split the numbers to Digits\n  static String splitIntoDigits(int num, int num2) {\n\n    StringBuilder res = new StringBuilder();\n\n    ArrayList<Integer> digits = new ArrayList<>();\n    while (num > 0) {\n      digits.add(num % 10);\n      num /= 10;\n    }\n    while (num2 > 0) {\n      digits.add(num2 % 10);\n      num2 /= 10;\n    }\n    Collections.sort(digits);\n    for (int i : digits) {\n      res.append(i);\n    }\n\n    return res.toString();\n  }\n}\n","index":143},{"title":"Minimizing Lateness","category":null,"id":"MinimizingLateness","index":144},{"title":"Minimizing Lateness","category":"MinimizingLateness","id":"MinimizingLateness_MinimizingLateness","algorithm":"package MinimizingLateness;\n\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.StringTokenizer;\n\npublic class MinimizingLateness {\n\n  private static class Schedule { // Schedule class\n    int t = 0; // Time required for the operation to be performed\n    int d = 0; // Time the job should be completed\n    int s = 0; // Start time of the task\n    int f = 0; // End time of the operation\n\n    public Schedule(int t, int d) {\n      this.t = t;\n      this.d = d;\n    }\n  }\n\n  public static void main(String[] args) throws IOException {\n    StringTokenizer token;\n\n    BufferedReader in = new BufferedReader(new FileReader(\"MinimizingLateness/lateness_data.txt\"));\n    String ch = in.readLine();\n    if (ch == null || ch.isEmpty()) {\n      in.close();\n      return;\n    }\n    int indexCount = Integer.parseInt(ch);\n    System.out.println(\"Input Data : \");\n    System.out.println(indexCount); // number of operations\n    Schedule[] array = new Schedule[indexCount]; // Create an array to hold the operation\n    int i = 0;\n    while ((ch = in.readLine()) != null) {\n      token = new StringTokenizer(ch, \" \");\n      // Include the time required for the operation to be performed in the array and the time it\n      // should be completed.\n      array[i] =\n          new Schedule(Integer.parseInt(token.nextToken()), Integer.parseInt(token.nextToken()));\n      i++;\n      System.out.println(array[i - 1].t + \" \" + array[i - 1].d);\n    }\n\n    int tryTime = 0; // Total time worked\n    int lateness = 0; // Lateness\n    for (int j = 0; j < indexCount - 1; j++) {\n      array[j].s = tryTime; // Start time of the task\n      array[j].f = tryTime + array[j].t; // Time finished\n      tryTime = tryTime + array[j].t; // Add total work time\n      // Lateness\n      lateness = lateness + Math.max(0, tryTime - array[j].d);\n    }\n    System.out.println();\n    System.out.println(\"Output Data : \");\n    System.out.println(lateness);\n    in.close();\n  }\n}\n","index":145},{"title":"Misc","category":null,"id":"Misc","index":146},{"title":"Median Of Running Array","category":"Misc","id":"MedianOfRunningArray_Misc","algorithm":"package Misc;\n\nimport java.util.Collections;\nimport java.util.PriorityQueue;\n\n/** @author shrutisheoran */\npublic class MedianOfRunningArray {\n  private PriorityQueue<Integer> p1;\n  private PriorityQueue<Integer> p2;\n\n  // Constructor\n  public MedianOfRunningArray() {\n    this.p1 = new PriorityQueue<>(Collections.reverseOrder()); // Max Heap\n    this.p2 = new PriorityQueue<>(); // Min Heap\n  }\n\n  /*\n      Inserting lower half of array to max Heap\n      and upper half to min heap\n  */\n  public void insert(Integer e) {\n    p2.add(e);\n    if (p2.size() - p1.size() > 1) p1.add(p2.remove());\n  }\n\n  /*\n      Returns median at any given point\n  */\n  public Integer median() {\n    if (p1.size() == p2.size()) return (p1.peek() + p2.peek()) / 2;\n    return p1.size() > p2.size() ? p1.peek() : p2.peek();\n  }\n\n  public static void main(String[] args) {\n    /*\n        Testing the median function\n    */\n\n    MedianOfRunningArray p = new MedianOfRunningArray();\n    int arr[] = {10, 7, 4, 9, 2, 3, 11, 17, 14};\n    for (int i = 0; i < 9; i++) {\n      p.insert(arr[i]);\n      System.out.print(p.median() + \" \");\n    }\n  }\n}\n","index":147},{"title":"Palindrome Prime","category":"Misc","id":"PalindromePrime_Misc","algorithm":"package Misc;\n\nimport java.util.Scanner;\n\npublic class PalindromePrime {\n\n  public static void main(String[] args) { // Main funtion\n    Scanner in = new Scanner(System.in);\n    System.out.println(\"Enter the quantity of First Palindromic Primes you want\");\n    int n = in.nextInt(); // Input of how many first pallindromic prime we want\n    functioning(n); // calling function - functioning\n    in.close();\n  }\n\n  public static boolean prime(int num) { // checking if number is prime or not\n    for (int divisor = 3; divisor <= Math.sqrt(num); divisor += 2) {\n      if (num % divisor == 0) {\n        return false; //  false if not prime\n      }\n    }\n    return true; // True if prime\n  }\n\n  public static int reverse(int n) { //  Returns  the reverse of the number\n    int reverse = 0;\n    while (n != 0) {\n      reverse *= 10;\n      reverse += n % 10;\n      n /= 10;\n    }\n    return reverse;\n  }\n\n  public static void functioning(int y) {\n    if (y == 0) return;\n    System.out.print(2 + \"\\n\"); // print the first Palindromic Prime\n    int count = 1;\n    int num = 3;\n    while (count < y) {\n      if (num == reverse(num) && prime(num)) { // number is prime and it's reverse is same\n        count++; // counts check when to terminate while loop\n        System.out.print(num + \"\\n\"); // print the Palindromic Prime\n      }\n      num += 2; // inrease iterator value by two\n    }\n  }\n}\n","index":148},{"title":"Others","category":null,"id":"Others","index":149},{"title":"Best Fit","category":"Others","id":"BestFit_Others","algorithm":"package Others;\n\nimport java.util.ArrayList;\n\n/** @author Dekas Dimitrios */\npublic class BestFit {\n  private static final int NO_ALLOCATION =\n      -255; // if a process has been allocated in position -255,\n  // it means that it has not been actually allocated.\n\n  /**\n   * Method to find the maximum valued element of an array filled with positive integers.\n   *\n   * @param array: an array filled with positive integers.\n   * @return the maximum valued element of the array.\n   */\n  private static int findMaxElement(int[] array) {\n    int max = -1;\n    for (int value : array) {\n      if (value > max) {\n        max = value;\n      }\n    }\n    return max;\n  }\n\n  /**\n   * Method to find the index of the memory block that is going to fit the given process based on\n   * the best fit algorithm.\n   *\n   * @param blocks: the array with the available memory blocks.\n   * @param process: the size of the process.\n   * @return the index of the block that fits, or -255 if no such block exists.\n   */\n  private static int findBestFit(int[] blockSizes, int processSize) {\n    // Initialize minDiff with an unreachable value by a difference between a blockSize and the\n    // processSize.\n    int minDiff = findMaxElement(blockSizes);\n    int index =\n        NO_ALLOCATION; // If there is no block that can fit the process, return NO_ALLOCATION as the\n    // result.\n    for (int i = 0;\n        i < blockSizes.length;\n        i++) { // Find the most fitting memory block for the given process.\n      if (blockSizes[i] - processSize < minDiff && blockSizes[i] - processSize >= 0) {\n        minDiff = blockSizes[i] - processSize;\n        index = i;\n      }\n    }\n    return index;\n  }\n\n  /**\n   * Method to allocate memory to blocks according to the best fit algorithm. It should return an\n   * ArrayList of Integers, where the index is the process ID (zero-indexed) and the value is the\n   * block number (also zero-indexed).\n   *\n   * @param sizeOfBlocks: an int array that contains the sizes of the memory blocks available.\n   * @param sizeOfProcesses: an int array that contains the sizes of the processes we need memory\n   *     blocks for.\n   * @return the ArrayList filled with Integers repressenting the memory allocation that took place.\n   */\n  static ArrayList<Integer> bestFit(int[] sizeOfBlocks, int[] sizeOfProcesses) {\n    // The array list responsible for saving the memory allocations done by the best-fit algorithm\n    ArrayList<Integer> memAlloc = new ArrayList<>();\n    // Do this for every process\n    for (int processSize : sizeOfProcesses) {\n      int chosenBlockIdx =\n          findBestFit(\n              sizeOfBlocks, processSize); // Find the index of the memory block going to be used\n      memAlloc.add(chosenBlockIdx); // Store the chosen block index in the memAlloc array list\n      if (chosenBlockIdx\n          != NO_ALLOCATION) { // Only if a block was chosen to store the process in it,\n        sizeOfBlocks[chosenBlockIdx] -= processSize; // resize the block based on the process size\n      }\n    }\n    return memAlloc;\n  }\n\n  /**\n   * Method to print the memory allocated.\n   *\n   * @param memAllocation: an ArrayList of Integer representing the memory allocation done by the\n   *     bestFit method.\n   */\n  public static void printMemoryAllocation(ArrayList<Integer> memAllocation) {\n    System.out.println(\"Process No.\\tBlock No.\");\n    System.out.println(\"===========\\t=========\");\n    for (int i = 0; i < memAllocation.size(); i++) {\n      System.out.print(\" \" + i + \"\\t\\t\");\n      if (memAllocation.get(i) != NO_ALLOCATION) System.out.print(memAllocation.get(i));\n      else System.out.print(\"Not Allocated\");\n      System.out.println();\n    }\n  }\n}\n","index":150},{"title":"Brian Kernighan Algorithm","category":"Others","id":"BrianKernighanAlgorithm_Others","algorithm":"package Others;\n\nimport java.util.Scanner;\n\n/**\n * @author Nishita Aggarwal\n *     <p>Brian Kernighan’s Algorithm\n *     <p>algorithm to count the number of set bits in a given number\n *     <p>Subtraction of 1 from a number toggles all the bits (from right to left) till the\n *     rightmost set bit(including the rightmost set bit). So if we subtract a number by 1 and do\n *     bitwise & with itself i.e. (n & (n-1)), we unset the rightmost set bit.\n *     <p>If we do n & (n-1) in a loop and count the no of times loop executes we get the set bit\n *     count.\n *     <p>\n *     <p>Time Complexity: O(logn)\n */\npublic class BrianKernighanAlgorithm {\n\n  /**\n   * @param num: number in which we count the set bits\n   * @return int: Number of set bits\n   */\n  static int countSetBits(int num) {\n    int cnt = 0;\n    while (num != 0) {\n      num = num & (num - 1);\n      cnt++;\n    }\n    return cnt;\n  }\n\n  /** @param args : command line arguments */\n  public static void main(String args[]) {\n    Scanner sc = new Scanner(System.in);\n    int num = sc.nextInt();\n    int setBitCount = countSetBits(num);\n    System.out.println(setBitCount);\n    sc.close();\n  }\n}\n","index":151},{"title":"C R C32","category":"Others","id":"CRC32_Others","algorithm":"package Others;\n\nimport java.util.BitSet;\n\n/** Generates a crc32 checksum for a given string or byte array */\npublic class CRC32 {\n\n  public static void main(String[] args) {\n    System.out.println(Integer.toHexString(crc32(\"Hello World\")));\n  }\n\n  public static int crc32(String str) {\n    return crc32(str.getBytes());\n  }\n\n  public static int crc32(byte[] data) {\n    BitSet bitSet = BitSet.valueOf(data);\n    int crc32 = 0xFFFFFFFF; // initial value\n    for (int i = 0; i < data.length * 8; i++) {\n      if (((crc32 >>> 31) & 1) != (bitSet.get(i) ? 1 : 0))\n        crc32 = (crc32 << 1) ^ 0x04C11DB7; // xor with polynomial\n      else crc32 = (crc32 << 1);\n    }\n    crc32 = Integer.reverse(crc32); // result reflect\n    return crc32 ^ 0xFFFFFFFF; // final xor value\n  }\n}\n","index":152},{"title":"C R C Algorithm","category":"Others","id":"CRCAlgorithm_Others","algorithm":"package Others;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Random;\r\nimport java.util.concurrent.ThreadLocalRandom;\r\n\r\n/** @author dimgrichr */\r\npublic class CRCAlgorithm {\r\n\r\n  private int correctMess;\r\n\r\n  private int wrongMess;\r\n\r\n  private int wrongMessCaught;\r\n\r\n  private int wrongMessNotCaught;\r\n\r\n  private int messSize;\r\n\r\n  private double ber;\r\n\r\n  private boolean messageChanged;\r\n\r\n  private ArrayList<Integer> message;\r\n\r\n  private ArrayList<Integer> dividedMessage;\r\n\r\n  private ArrayList<Integer> p;\r\n\r\n  private Random randomGenerator;\r\n\r\n  /**\r\n   * The algorithm's main constructor. The most significant variables, used in the algorithm, are\r\n   * set in their initial values.\r\n   *\r\n   * @param str The binary number P, in a string form, which is used by the CRC algorithm\r\n   * @param size The size of every transmitted message\r\n   * @param ber The Bit Error Rate\r\n   */\r\n  public CRCAlgorithm(String str, int size, double ber) {\r\n    messageChanged = false;\r\n    message = new ArrayList<>();\r\n    messSize = size;\r\n    dividedMessage = new ArrayList<>();\r\n    p = new ArrayList<>();\r\n    for (int i = 0; i < str.length(); i++) {\r\n      p.add(Character.getNumericValue(str.charAt(i)));\r\n    }\r\n    randomGenerator = new Random();\r\n    correctMess = 0;\r\n    wrongMess = 0;\r\n    wrongMessCaught = 0;\r\n    wrongMessNotCaught = 0;\r\n    this.ber = ber;\r\n  }\r\n\r\n  /**\r\n   * Returns the counter wrongMess\r\n   *\r\n   * @return wrongMess, the number of Wrong Messages\r\n   */\r\n  public int getWrongMess() {\r\n    return wrongMess;\r\n  }\r\n\r\n  /**\r\n   * Returns the counter wrongMessCaught\r\n   *\r\n   * @return wrongMessCaught, the number of wrong messages, which are caught by the CRC algoriithm\r\n   */\r\n  public int getWrongMessCaught() {\r\n    return wrongMessCaught;\r\n  }\r\n\r\n  /**\r\n   * Returns the counter wrongMessNotCaught\r\n   *\r\n   * @return wrongMessNotCaught, the number of wrong messages, which are not caught by the CRC\r\n   *     algorithm\r\n   */\r\n  public int getWrongMessNotCaught() {\r\n    return wrongMessNotCaught;\r\n  }\r\n\r\n  /**\r\n   * Returns the counter correctMess\r\n   *\r\n   * @return correctMess, the number of the Correct Messages\r\n   */\r\n  public int getCorrectMess() {\r\n    return correctMess;\r\n  }\r\n\r\n  /**\r\n   * Resets some of the object's values, used on the main function, so that it can be re-used, in\r\n   * order not to waste too much memory and time, by creating new objects.\r\n   */\r\n  public void refactor() {\r\n    messageChanged = false;\r\n    message = new ArrayList<>();\r\n    dividedMessage = new ArrayList<>();\r\n  }\r\n\r\n  /**\r\n   * Random messages, consisted of 0's and 1's, are generated, so that they can later be transmitted\r\n   */\r\n  public void generateRandomMess() {\r\n    for (int i = 0; i < messSize; i++) {\r\n      int x = ThreadLocalRandom.current().nextInt(0, 2);\r\n      message.add(x);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The most significant part of the CRC algorithm. The message is divided by P, so the\r\n   * dividedMessage ArrayList<Integer> is created. If check == true, the dividedMessaage is\r\n   * examined, in order to see if it contains any 1's. If it does, the message is considered to be\r\n   * wrong by the receiver,so the variable wrongMessCaught changes. If it does not, it is accepted,\r\n   * so one of the variables correctMess, wrongMessNotCaught, changes. If check == false, the\r\n   * diviided Message is added at the end of the ArrayList<integer> message.\r\n   *\r\n   * @param check the variable used to determine, if the message is going to be checked from the\r\n   *     receiver if true, it is checked otherwise, it is not\r\n   */\r\n  public void divideMessageWithP(boolean check) {\r\n    ArrayList<Integer> x = new ArrayList<>();\r\n    ArrayList<Integer> k = (ArrayList<Integer>) message.clone();\r\n    if (!check) {\r\n      for (int i = 0; i < p.size() - 1; i++) {\r\n        k.add(0);\r\n      }\r\n    }\r\n    while (!k.isEmpty()) {\r\n      while (x.size() < p.size() && !k.isEmpty()) {\r\n        x.add(k.get(0));\r\n        k.remove(0);\r\n      }\r\n      if (x.size() == p.size()) {\r\n        for (int i = 0; i < p.size(); i++) {\r\n          if (x.get(i) == p.get(i)) {\r\n            x.set(i, 0);\r\n          } else {\r\n            x.set(i, 1);\r\n          }\r\n        }\r\n        for (int i = 0; i < x.size() && x.get(i) != 1; i++) {\r\n          x.remove(0);\r\n        }\r\n      }\r\n    }\r\n    dividedMessage = (ArrayList<Integer>) x.clone();\r\n    if (!check) {\r\n      for (int z : dividedMessage) {\r\n        message.add(z);\r\n      }\r\n    } else {\r\n      if (dividedMessage.contains(1) && messageChanged) {\r\n        wrongMessCaught++;\r\n      } else if (!dividedMessage.contains(1) && messageChanged) {\r\n        wrongMessNotCaught++;\r\n      } else if (!messageChanged) {\r\n        correctMess++;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Once the message is transmitted, some of it's elements, is possible to change from 1 to 0, or\r\n   * from 0 to 1, because of the Bit Error Rate (ber). For every element of the message, a random\r\n   * double number is created. If that number is smaller than ber, then the spesific element\r\n   * changes. On the other hand, if it's bigger than ber, it does not. Based on these changes. the\r\n   * boolean variable messageChanged, gets the value: true, or false.\r\n   */\r\n  public void changeMess() {\r\n    for (int y : message) {\r\n      double x = randomGenerator.nextDouble();\r\n      while (x < 0.0000 || x > 1.00000) {\r\n        x = randomGenerator.nextDouble();\r\n      }\r\n      if (x < ber) {\r\n        messageChanged = true;\r\n        if (y == 1) {\r\n          message.set(message.indexOf(y), 0);\r\n        } else {\r\n          message.set(message.indexOf(y), 1);\r\n        }\r\n      }\r\n    }\r\n    if (messageChanged) {\r\n      wrongMess++;\r\n    }\r\n  }\r\n}\r\n","index":153},{"title":"Count Char","category":"Others","id":"CountChar_Others","algorithm":"package Others;\n\nimport java.util.Scanner;\n\npublic class CountChar {\n\n  public static void main(String[] args) {\n    Scanner input = new Scanner(System.in);\n    System.out.print(\"Enter your text: \");\n    String str = input.nextLine();\n    input.close();\n    System.out.println(\"There are \" + CountCharacters(str) + \" characters.\");\n  }\n\n  /**\n   * Count non space character in string\n   *\n   * @param str String to count the characters\n   * @return number of character in the specified string\n   */\n  private static int CountCharacters(String str) {\n    return str.replaceAll(\"\\\\s\", \"\").length();\n  }\n}\n","index":154},{"title":"Count Words","category":"Others","id":"CountWords_Others","algorithm":"package Others;\n\nimport java.util.Scanner;\n\n/**\n * You enter a string into this program, and it will return how many words were in that particular\n * string\n *\n * @author Marcus\n */\npublic class CountWords {\n\n  public static void main(String[] args) {\n    Scanner input = new Scanner(System.in);\n    System.out.println(\"Enter your text: \");\n    String str = input.nextLine();\n\n    System.out.println(\"Your text has \" + wordCount(str) + \" word(s)\");\n    System.out.println(\"Your text has \" + secondaryWordCount(str) + \" word(s)\");\n    input.close();\n  }\n\n  private static int wordCount(String s) {\n    if (s == null || s.isEmpty()) return 0;\n    return s.trim().split(\"[\\\\s]+\").length;\n  }\n\n  /**\n   * counts the number of words in a sentence but ignores all potential non-alphanumeric characters\n   * that do not represent a word. runs in O(n) where n is the length of s\n   *\n   * @param s String: sentence with word(s)\n   * @return int: number of words\n   */\n  private static int secondaryWordCount(String s) {\n    if (s == null || s.isEmpty()) return 0;\n    StringBuilder sb = new StringBuilder();\n    for (char c : s.toCharArray()) {\n      if (Character.isLetter(c) || Character.isDigit(c)) sb.append(c);\n    }\n    s = sb.toString();\n    return s.trim().split(\"[\\\\s]+\").length;\n  }\n}\n","index":155},{"title":"Dijkstra","category":"Others","id":"Dijkstra_Others","algorithm":"package Others;\n\n/**\n * Dijkstra's algorithm,is a graph search algorithm that solves the single-source shortest path\n * problem for a graph with nonnegative edge path costs, producing a shortest path tree.\n *\n * <p>NOTE: The inputs to Dijkstra's algorithm are a directed and weighted graph consisting of 2 or\n * more nodes, generally represented by an adjacency matrix or list, and a start node.\n *\n * <p>Original source of code: https://rosettacode.org/wiki/Dijkstra%27s_algorithm#Java Also most of\n * the comments are from RosettaCode.\n */\nimport java.util.*;\n\npublic class Dijkstra {\n  private static final Graph.Edge[] GRAPH = {\n    // Distance from node \"a\" to node \"b\" is 7.\n    // In the current Graph there is no way to move the other way (e,g, from \"b\" to \"a\"),\n    // a new edge would be needed for that\n    new Graph.Edge(\"a\", \"b\", 7),\n    new Graph.Edge(\"a\", \"c\", 9),\n    new Graph.Edge(\"a\", \"f\", 14),\n    new Graph.Edge(\"b\", \"c\", 10),\n    new Graph.Edge(\"b\", \"d\", 15),\n    new Graph.Edge(\"c\", \"d\", 11),\n    new Graph.Edge(\"c\", \"f\", 2),\n    new Graph.Edge(\"d\", \"e\", 6),\n    new Graph.Edge(\"e\", \"f\", 9),\n  };\n  private static final String START = \"a\";\n  private static final String END = \"e\";\n\n  /** main function Will run the code with \"GRAPH\" that was defined above. */\n  public static void main(String[] args) {\n    Graph g = new Graph(GRAPH);\n    g.dijkstra(START);\n    g.printPath(END);\n    // g.printAllPaths();\n  }\n}\n\nclass Graph {\n  // mapping of vertex names to Vertex objects, built from a set of Edges\n  private final Map<String, Vertex> graph;\n\n  /** One edge of the graph (only used by Graph constructor) */\n  public static class Edge {\n    public final String v1, v2;\n    public final int dist;\n\n    public Edge(String v1, String v2, int dist) {\n      this.v1 = v1;\n      this.v2 = v2;\n      this.dist = dist;\n    }\n  }\n\n  /** One vertex of the graph, complete with mappings to neighbouring vertices */\n  public static class Vertex implements Comparable<Vertex> {\n    public final String name;\n    // MAX_VALUE assumed to be infinity\n    public int dist = Integer.MAX_VALUE;\n    public Vertex previous = null;\n    public final Map<Vertex, Integer> neighbours = new HashMap<>();\n\n    public Vertex(String name) {\n      this.name = name;\n    }\n\n    private void printPath() {\n      if (this == this.previous) {\n        System.out.printf(\"%s\", this.name);\n      } else if (this.previous == null) {\n        System.out.printf(\"%s(unreached)\", this.name);\n      } else {\n        this.previous.printPath();\n        System.out.printf(\" -> %s(%d)\", this.name, this.dist);\n      }\n    }\n\n    public int compareTo(Vertex other) {\n      if (dist == other.dist) return name.compareTo(other.name);\n\n      return Integer.compare(dist, other.dist);\n    }\n\n    @Override\n    public boolean equals(Object object) {\n      if (this == object) return true;\n      if (object == null || getClass() != object.getClass()) return false;\n      if (!super.equals(object)) return false;\n\n      Vertex vertex = (Vertex) object;\n\n      if (dist != vertex.dist) return false;\n      if (name != null ? !name.equals(vertex.name) : vertex.name != null) return false;\n      if (previous != null ? !previous.equals(vertex.previous) : vertex.previous != null)\n        return false;\n      if (neighbours != null ? !neighbours.equals(vertex.neighbours) : vertex.neighbours != null)\n        return false;\n\n      return true;\n    }\n\n    @Override\n    public int hashCode() {\n      int result = super.hashCode();\n      result = 31 * result + (name != null ? name.hashCode() : 0);\n      result = 31 * result + dist;\n      result = 31 * result + (previous != null ? previous.hashCode() : 0);\n      result = 31 * result + (neighbours != null ? neighbours.hashCode() : 0);\n      return result;\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + name + \", \" + dist + \")\";\n    }\n  }\n\n  /** Builds a graph from a set of edges */\n  public Graph(Edge[] edges) {\n    graph = new HashMap<>(edges.length);\n\n    // one pass to find all vertices\n    for (Edge e : edges) {\n      if (!graph.containsKey(e.v1)) graph.put(e.v1, new Vertex(e.v1));\n      if (!graph.containsKey(e.v2)) graph.put(e.v2, new Vertex(e.v2));\n    }\n\n    // another pass to set neighbouring vertices\n    for (Edge e : edges) {\n      graph.get(e.v1).neighbours.put(graph.get(e.v2), e.dist);\n      // graph.get(e.v2).neighbours.put(graph.get(e.v1), e.dist); // also do this for an undirected\n      // graph\n    }\n  }\n\n  /** Runs dijkstra using a specified source vertex */\n  public void dijkstra(String startName) {\n    if (!graph.containsKey(startName)) {\n      System.err.printf(\"Graph doesn't contain start vertex \\\"%s\\\"%n\", startName);\n      return;\n    }\n    final Vertex source = graph.get(startName);\n    NavigableSet<Vertex> q = new TreeSet<>();\n\n    // set-up vertices\n    for (Vertex v : graph.values()) {\n      v.previous = v == source ? source : null;\n      v.dist = v == source ? 0 : Integer.MAX_VALUE;\n      q.add(v);\n    }\n\n    dijkstra(q);\n  }\n\n  /** Implementation of dijkstra's algorithm using a binary heap. */\n  private void dijkstra(final NavigableSet<Vertex> q) {\n    Vertex u, v;\n    while (!q.isEmpty()) {\n      // vertex with shortest distance (first iteration will return source)\n      u = q.pollFirst();\n      if (u.dist == Integer.MAX_VALUE)\n        break; // we can ignore u (and any other remaining vertices) since they are unreachable\n\n      // look at distances to each neighbour\n      for (Map.Entry<Vertex, Integer> a : u.neighbours.entrySet()) {\n        v = a.getKey(); // the neighbour in this iteration\n\n        final int alternateDist = u.dist + a.getValue();\n        if (alternateDist < v.dist) { // shorter path to neighbour found\n          q.remove(v);\n          v.dist = alternateDist;\n          v.previous = u;\n          q.add(v);\n        }\n      }\n    }\n  }\n\n  /** Prints a path from the source to the specified vertex */\n  public void printPath(String endName) {\n    if (!graph.containsKey(endName)) {\n      System.err.printf(\"Graph doesn't contain end vertex \\\"%s\\\"%n\", endName);\n      return;\n    }\n\n    graph.get(endName).printPath();\n    System.out.println();\n  }\n\n  /** Prints the path from the source to every vertex (output order is not guaranteed) */\n  public void printAllPaths() {\n    for (Vertex v : graph.values()) {\n      v.printPath();\n      System.out.println();\n    }\n  }\n}\n","index":156},{"title":"Eulers Function","category":"Others","id":"EulersFunction_Others","algorithm":"package Others;\n\n/**\n * You can read more about Euler's totient function\n *\n * <p>See https://en.wikipedia.org/wiki/Euler%27s_totient_function\n */\npublic class EulersFunction {\n  // This method returns us number of x that (x < n) and gcd(x, n) == 1 in O(sqrt(n)) time\n  // complexity;\n  public static int getEuler(int n) {\n    int result = n;\n    for (int i = 2; i * i <= n; i++) {\n      if (n % i == 0) {\n        while (n % i == 0) n /= i;\n        result -= result / i;\n      }\n    }\n    if (n > 1) result -= result / n;\n    return result;\n  }\n\n  public static void main(String[] args) {\n    for (int i = 1; i < 100; i++) {\n      System.out.println(getEuler(i));\n    }\n  }\n}\n","index":157},{"title":"Fib To N","category":"Others","id":"FibToN_Others","algorithm":"package Others;\n\nimport java.util.Scanner;\n\n/**\n * Fibonacci sequence, and characterized by the fact that every number after the first two is the\n * sum of the two preceding ones.\n *\n * <p>Fibonacci sequence: 0, 1, 1, 2, 3, 5, 8, 13, 21,...\n *\n * <p>Source for the explanation: https://en.wikipedia.org/wiki/Fibonacci_number\n */\npublic class FibToN {\n  public static void main(String[] args) {\n    // take input\n    Scanner scn = new Scanner(System.in);\n    int N = scn.nextInt();\n    // print all Fibonacci numbers that are smaller than your given input N\n    int first = 0, second = 1;\n    scn.close();\n    while (first <= N) {\n      // print first fibo 0 then add second fibo into it while updating second as well\n\n      System.out.println(first);\n\n      int next = first + second;\n      first = second;\n      second = next;\n    }\n  }\n}\n","index":158},{"title":"First Fit","category":"Others","id":"FirstFit_Others","algorithm":"package Others;\n\nimport java.util.ArrayList;\n\n/** @author Dekas Dimitrios */\npublic class FirstFit {\n  private static final int NO_ALLOCATION =\n      -255; // if a process has been allocated in position -255,\n  // it means that it has not been actually allocated.\n\n  /**\n   * Method to find the index of the memory block that is going to fit the given process based on\n   * the first fit algorithm.\n   *\n   * @param blocks: the array with the available memory blocks.\n   * @param process: the size of the process.\n   * @return the index of the block that fits, or -255 if no such block exists.\n   */\n  private static int findFirstFit(int[] blockSizes, int processSize) {\n    for (int i = 0; i < blockSizes.length; i++) {\n      if (blockSizes[i] >= processSize) {\n        return i;\n      }\n    }\n    // If there is not a block that can fit the process, return -255 as the result\n    return NO_ALLOCATION;\n  }\n\n  /**\n   * Method to allocate memory to blocks according to the first fit algorithm. It should return an\n   * ArrayList of Integers, where the index is the process ID (zero-indexed) and the value is the\n   * block number (also zero-indexed).\n   *\n   * @param sizeOfBlocks: an int array that contains the sizes of the memory blocks available.\n   * @param sizeOfProcesses: an int array that contains the sizes of the processes we need memory\n   *     blocks for.\n   * @return the ArrayList filled with Integers repressenting the memory allocation that took place.\n   */\n  static ArrayList<Integer> firstFit(int[] sizeOfBlocks, int[] sizeOfProcesses) {\n    // The array list responsible for saving the memory allocations done by the first-fit algorithm\n    ArrayList<Integer> memAlloc = new ArrayList<>();\n    // Do this for every process\n    for (int processSize : sizeOfProcesses) {\n      int chosenBlockIdx =\n          findFirstFit(\n              sizeOfBlocks, processSize); // Find the index of the memory block going to be used\n      memAlloc.add(chosenBlockIdx); // Store the chosen block index in the memAlloc array list\n      if (chosenBlockIdx\n          != NO_ALLOCATION) { // Only if a block was chosen to store the process in it,\n        sizeOfBlocks[chosenBlockIdx] -= processSize; // resize the block based on the process size\n      }\n    }\n    return memAlloc;\n  }\n\n  /**\n   * Method to print the memory allocated.\n   *\n   * @param memAllocation: an ArrayList of Integer representing the memory allocation done by the\n   *     firstFit method.\n   */\n  public static void printMemoryAllocation(ArrayList<Integer> memAllocation) {\n    System.out.println(\"Process No.\\tBlock No.\");\n    System.out.println(\"===========\\t=========\");\n    for (int i = 0; i < memAllocation.size(); i++) {\n      System.out.print(\" \" + i + \"\\t\\t\");\n      if (memAllocation.get(i) != NO_ALLOCATION) System.out.print(memAllocation.get(i));\n      else System.out.print(\"Not Allocated\");\n      System.out.println();\n    }\n  }\n}\n","index":159},{"title":"Floyd Triangle","category":"Others","id":"FloydTriangle_Others","algorithm":"package Others;\n\nimport java.util.Scanner;\n\nclass FloydTriangle {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    System.out.println(\"Enter the number of rows which you want in your Floyd Triangle: \");\n    int r = sc.nextInt(), n = 0;\n    sc.close();\n    for (int i = 0; i < r; i++) {\n      for (int j = 0; j <= i; j++) {\n        System.out.print(++n + \" \");\n      }\n      System.out.println();\n    }\n  }\n}\n","index":160},{"title":"Guass Legendre","category":"Others","id":"GuassLegendre_Others","algorithm":"package Others;\n\n/**\n * Guass Legendre Algorithm ref https://en.wikipedia.org/wiki/Gauss–Legendre_algorithm\n *\n * @author AKS1996\n */\npublic class GuassLegendre {\n\n  public static void main(String[] args) {\n    for (int i = 1; i <= 3; ++i) System.out.println(pi(i));\n  }\n\n  static double pi(int l) {\n    /*\n     * l: No of loops to run\n     */\n\n    double a = 1, b = Math.pow(2, -0.5), t = 0.25, p = 1;\n    for (int i = 0; i < l; ++i) {\n      double temp[] = update(a, b, t, p);\n      a = temp[0];\n      b = temp[1];\n      t = temp[2];\n      p = temp[3];\n    }\n\n    return Math.pow(a + b, 2) / (4 * t);\n  }\n\n  static double[] update(double a, double b, double t, double p) {\n    double values[] = new double[4];\n    values[0] = (a + b) / 2;\n    values[1] = Math.sqrt(a * b);\n    values[2] = t - p * Math.pow(a - values[0], 2);\n    values[3] = 2 * p;\n\n    return values;\n  }\n}\n","index":161},{"title":"Insert Delete In Array","category":"Others","id":"InsertDeleteInArray_Others","algorithm":"package Others;\n\nimport java.util.*;\n\npublic class InsertDeleteInArray {\n\n  public static void main(String[] args) {\n    Scanner s = new Scanner(System.in); // Input statement\n    System.out.println(\"Enter the size of the array\");\n    int size = s.nextInt();\n    int a[] = new int[size];\n    int i;\n\n    // To enter the initial elements\n    for (i = 0; i < size; i++) {\n      System.out.println(\"Enter the element\");\n      a[i] = s.nextInt();\n    }\n\n    // To insert a new element(we are creating a new array)\n    System.out.println(\"Enter the index at which the element should be inserted\");\n    int insert_pos = s.nextInt();\n    System.out.println(\"Enter the element to be inserted\");\n    int ins = s.nextInt();\n    int size2 = size + 1;\n    int b[] = new int[size2];\n    for (i = 0; i < size2; i++) {\n      if (i <= insert_pos) {\n        b[i] = a[i];\n      } else {\n        b[i] = a[i - 1];\n      }\n    }\n    b[insert_pos] = ins;\n    for (i = 0; i < size2; i++) {\n      System.out.println(b[i]);\n    }\n\n    // To delete an element given the index\n    System.out.println(\"Enter the index at which element is to be deleted\");\n    int del_pos = s.nextInt();\n    for (i = del_pos; i < size2 - 1; i++) {\n      b[i] = b[i + 1];\n    }\n    for (i = 0; i < size2 - 1; i++) System.out.println(b[i]);\n    s.close();\n  }\n}\n","index":162},{"title":"K M P","category":"Others","id":"KMP_Others","algorithm":"package Others;\n\n/** Implementation of Knuth–Morris–Pratt algorithm Usage: see the main function for an example */\npublic class KMP {\n  // a working example\n  public static void main(String[] args) {\n    final String haystack = \"AAAAABAAABA\"; // This is the full string\n    final String needle = \"AAAA\"; // This is the substring that we want to find\n    KMPmatcher(haystack, needle);\n  }\n\n  // find the starting index in string haystack[] that matches the search word P[]\n  public static void KMPmatcher(final String haystack, final String needle) {\n    final int m = haystack.length();\n    final int n = needle.length();\n    final int[] pi = computePrefixFunction(needle);\n    int q = 0;\n    for (int i = 0; i < m; i++) {\n      while (q > 0 && haystack.charAt(i) != needle.charAt(q)) {\n        q = pi[q - 1];\n      }\n\n      if (haystack.charAt(i) == needle.charAt(q)) {\n        q++;\n      }\n\n      if (q == n) {\n        System.out.println(\"Pattern starts: \" + (i + 1 - n));\n        q = pi[q - 1];\n      }\n    }\n  }\n\n  // return the prefix function\n  private static int[] computePrefixFunction(final String P) {\n    final int n = P.length();\n    final int[] pi = new int[n];\n    pi[0] = 0;\n    int q = 0;\n    for (int i = 1; i < n; i++) {\n      while (q > 0 && P.charAt(q) != P.charAt(i)) {\n        q = pi[q - 1];\n      }\n\n      if (P.charAt(q) == P.charAt(i)) {\n        q++;\n      }\n\n      pi[i] = q;\n    }\n    return pi;\n  }\n}\n","index":163},{"title":"Krishnamurthy","category":"Others","id":"Krishnamurthy_Others","algorithm":"package Others;\n\nimport java.util.Scanner;\n\nclass Krishnamurthy {\n  static int fact(int n) {\n    int i, p = 1;\n    for (i = n; i >= 1; i--) p = p * i;\n    return p;\n  }\n\n  public static void main(String args[]) {\n    Scanner sc = new Scanner(System.in);\n    int a, b, s = 0;\n    System.out.print(\"Enter the number : \");\n    a = sc.nextInt();\n    int n = a;\n    while (a > 0) {\n      b = a % 10;\n      s = s + fact(b);\n      a = a / 10;\n    }\n    if (s == n) System.out.print(n + \" is a krishnamurthy number\");\n    else System.out.print(n + \" is not a krishnamurthy number\");\n    sc.close();\n  }\n}\n","index":164},{"title":"Linear Congruential Generator","category":"Others","id":"LinearCongruentialGenerator_Others","algorithm":"package Others;\n\n/***\n * A pseudorandom number generator.\n *\n * @author Tobias Carryer\n * @date October 10, 2017\n */\npublic class LinearCongruentialGenerator {\n\n  private double a, c, m, previousValue;\n\n  /***\n   * These parameters are saved and used when nextNumber() is called.\n   * The current timestamp in milliseconds is used as the seed.\n   *\n   * @param multiplier\n   * @param increment\n   * @param modulo The maximum number that can be generated (exclusive). A common value is 2^32.\n   */\n  public LinearCongruentialGenerator(double multiplier, double increment, double modulo) {\n    this(System.currentTimeMillis(), multiplier, increment, modulo);\n  }\n\n  /***\n   * These parameters are saved and used when nextNumber() is called.\n   *\n   * @param seed\n   * @param multiplier\n   * @param increment\n   * @param modulo The maximum number that can be generated (exclusive). A common value is 2^32.\n   */\n  public LinearCongruentialGenerator(\n      double seed, double multiplier, double increment, double modulo) {\n    this.previousValue = seed;\n    this.a = multiplier;\n    this.c = increment;\n    this.m = modulo;\n  }\n\n  /**\n   * The smallest number that can be generated is zero. The largest number that can be generated is\n   * modulo-1. modulo is set in the constructor.\n   *\n   * @return a pseudorandom number.\n   */\n  public double nextNumber() {\n    previousValue = (a * previousValue + c) % m;\n    return previousValue;\n  }\n\n  public static void main(String[] args) {\n    // Show the LCG in action.\n    // Decisive proof that the LCG works could be made by adding each number\n    // generated to a Set while checking for duplicates.\n    LinearCongruentialGenerator lcg =\n        new LinearCongruentialGenerator(1664525, 1013904223, Math.pow(2.0, 32.0));\n    for (int i = 0; i < 512; i++) {\n      System.out.println(lcg.nextNumber());\n    }\n  }\n}\n","index":165},{"title":"Lowest Base Palindrome","category":"Others","id":"LowestBasePalindrome_Others","algorithm":"package Others;\n\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\n/**\n * Class for finding the lowest base in which a given integer is a palindrome. Includes auxiliary\n * methods for converting between bases and reversing strings.\n *\n * <p>NOTE: There is potential for error, see note at line 63.\n *\n * @author RollandMichael\n * @version 2017.09.28\n */\npublic class LowestBasePalindrome {\n\n  public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    int n = 0;\n    while (true) {\n      try {\n        System.out.print(\"Enter number: \");\n        n = in.nextInt();\n        break;\n      } catch (InputMismatchException e) {\n        System.out.println(\"Invalid input!\");\n        in.next();\n      }\n    }\n    System.out.println(n + \" is a palindrome in base \" + lowestBasePalindrome(n));\n    System.out.println(base2base(Integer.toString(n), 10, lowestBasePalindrome(n)));\n    in.close();\n  }\n\n  /**\n   * Given a number in base 10, returns the lowest base in which the number is represented by a\n   * palindrome (read the same left-to-right and right-to-left).\n   *\n   * @param num A number in base 10.\n   * @return The lowest base in which num is a palindrome.\n   */\n  public static int lowestBasePalindrome(int num) {\n    int base, num2 = num;\n    int digit;\n    char digitC;\n    boolean foundBase = false;\n    String newNum = \"\";\n    String digits = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\n    while (!foundBase) {\n      // Try from bases 2 to num-1\n      for (base = 2; base < num2; base++) {\n        newNum = \"\";\n        while (num > 0) {\n          // Obtain the first digit of n in the current base,\n          // which is equivalent to the integer remainder of (n/base).\n          // The next digit is obtained by dividing n by the base and\n          // continuing the process of getting the remainder. This is done\n          // until n is <=0 and the number in the new base is obtained.\n          digit = (num % base);\n          num /= base;\n          // If the digit isn't in the set of [0-9][A-Z] (beyond base 36), its character\n          // form is just its value in ASCII.\n\n          // NOTE: This may cause problems, as the capital letters are ASCII values\n          // 65-90. It may cause false positives when one digit is, for instance 10 and assigned\n          // 'A' from the character array and the other is 65 and also assigned 'A'.\n\n          // Regardless, the character is added to the representation of n\n          // in the current base.\n          if (digit >= digits.length()) {\n            digitC = (char) (digit);\n            newNum += digitC;\n            continue;\n          }\n          newNum += digits.charAt(digit);\n        }\n        // Num is assigned back its original value for the next iteration.\n        num = num2;\n        // Auxiliary method reverses the number.\n        String reverse = reverse(newNum);\n        // If the number is read the same as its reverse, then it is a palindrome.\n        // The current base is returned.\n        if (reverse.equals(newNum)) {\n          foundBase = true;\n          return base;\n        }\n      }\n    }\n    // If all else fails, n is always a palindrome in base n-1. (\"11\")\n    return num - 1;\n  }\n\n  private static String reverse(String str) {\n    String reverse = \"\";\n    for (int i = str.length() - 1; i >= 0; i--) {\n      reverse += str.charAt(i);\n    }\n    return reverse;\n  }\n\n  private static String base2base(String n, int b1, int b2) {\n    // Declare variables: decimal value of n,\n    // character of base b1, character of base b2,\n    // and the string that will be returned.\n    int decimalValue = 0, charB2;\n    char charB1;\n    String output = \"\";\n    // Go through every character of n\n    for (int i = 0; i < n.length(); i++) {\n      // store the character in charB1\n      charB1 = n.charAt(i);\n      // if it is a non-number, convert it to a decimal value >9 and store it in charB2\n      if (charB1 >= 'A' && charB1 <= 'Z') charB2 = 10 + (charB1 - 'A');\n      // Else, store the integer value in charB2\n      else charB2 = charB1 - '0';\n      // Convert the digit to decimal and add it to the\n      // decimalValue of n\n      decimalValue = decimalValue * b1 + charB2;\n    }\n\n    // Converting the decimal value to base b2:\n    // A number is converted from decimal to another base\n    // by continuously dividing by the base and recording\n    // the remainder until the quotient is zero. The number in the\n    // new base is the remainders, with the last remainder\n    // being the left-most digit.\n\n    // While the quotient is NOT zero:\n    while (decimalValue != 0) {\n      // If the remainder is a digit < 10, simply add it to\n      // the left side of the new number.\n      if (decimalValue % b2 < 10) output = Integer.toString(decimalValue % b2) + output;\n      // If the remainder is >= 10, add a character with the\n      // corresponding value to the new number. (A = 10, B = 11, C = 12, ...)\n      else output = (char) ((decimalValue % b2) + 55) + output;\n      // Divide by the new base again\n      decimalValue /= b2;\n    }\n    return output;\n  }\n}\n","index":166},{"title":"Password Gen","category":"Others","id":"PasswordGen_Others","algorithm":"package Others;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Random;\n\n/**\n * Creates a random password from ASCII letters Given password length bounds\n *\n * @author AKS1996\n * @date 2017.10.25\n */\nclass PasswordGen {\n  public static void main(String args[]) {\n    String password = generatePassword(8, 16);\n    System.out.print(\"Password: \" + password);\n  }\n\n  static String generatePassword(int min_length, int max_length) {\n    Random random = new Random();\n\n    String upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    String lower = \"abcdefghijklmnopqrstuvwxyz\";\n    String numbers = \"0123456789\";\n    String specialChars = \"!@#$%^&*(){}?\";\n\n    String allChars = upper + lower + numbers + specialChars;\n\n    List<Character> letters = new ArrayList<Character>();\n    for (char c : allChars.toCharArray()) letters.add(c);\n\n    // Inbuilt method to randomly shuffle a elements of a list\n    Collections.shuffle(letters);\n    StringBuilder password = new StringBuilder();\n\n    // Note that size of the password is also random\n    for (int i = random.nextInt(max_length - min_length) + min_length; i > 0; --i) {\n      password.append(letters.get(random.nextInt(letters.size())));\n    }\n\n    return password.toString();\n  }\n}\n","index":167},{"title":"Perlin Noise","category":"Others","id":"PerlinNoise_Others","algorithm":"package Others;\n\nimport java.util.Random;\nimport java.util.Scanner;\n\n/**\n * For detailed info and implementation see: <a\n * href=\"http://devmag.org.za/2009/04/25/perlin-noise/\">Perlin-Noise</a>\n */\npublic class PerlinNoise {\n  /**\n   * @param width width of noise array\n   * @param height height of noise array\n   * @param octaveCount numbers of layers used for blending noise\n   * @param persistence value of impact each layer get while blending\n   * @param seed used for randomizer\n   * @return float array containing calculated \"Perlin-Noise\" values\n   */\n  static float[][] generatePerlinNoise(\n      int width, int height, int octaveCount, float persistence, long seed) {\n    final float[][] base = new float[width][height];\n    final float[][] perlinNoise = new float[width][height];\n    final float[][][] noiseLayers = new float[octaveCount][][];\n\n    Random random = new Random(seed);\n    // fill base array with random values as base for noise\n    for (int x = 0; x < width; x++) {\n      for (int y = 0; y < height; y++) {\n        base[x][y] = random.nextFloat();\n      }\n    }\n\n    // calculate octaves with different roughness\n    for (int octave = 0; octave < octaveCount; octave++) {\n      noiseLayers[octave] = generatePerlinNoiseLayer(base, width, height, octave);\n    }\n\n    float amplitude = 1f;\n    float totalAmplitude = 0f;\n\n    // calculate perlin noise by blending each layer together with specific persistence\n    for (int octave = octaveCount - 1; octave >= 0; octave--) {\n      amplitude *= persistence;\n      totalAmplitude += amplitude;\n\n      for (int x = 0; x < width; x++) {\n        for (int y = 0; y < height; y++) {\n          // adding each value of the noise layer to the noise\n          // by increasing amplitude the rougher noises will have more impact\n          perlinNoise[x][y] += noiseLayers[octave][x][y] * amplitude;\n        }\n      }\n    }\n\n    // normalize values so that they stay between 0..1\n    for (int x = 0; x < width; x++) {\n      for (int y = 0; y < height; y++) {\n        perlinNoise[x][y] /= totalAmplitude;\n      }\n    }\n\n    return perlinNoise;\n  }\n\n  /**\n   * @param base base random float array\n   * @param width width of noise array\n   * @param height height of noise array\n   * @param octave current layer\n   * @return float array containing calculated \"Perlin-Noise-Layer\" values\n   */\n  static float[][] generatePerlinNoiseLayer(float[][] base, int width, int height, int octave) {\n    float[][] perlinNoiseLayer = new float[width][height];\n\n    // calculate period (wavelength) for different shapes\n    int period = 1 << octave; // 2^k\n    float frequency = 1f / period; // 1/2^k\n\n    for (int x = 0; x < width; x++) {\n      // calculates the horizontal sampling indices\n      int x0 = (x / period) * period;\n      int x1 = (x0 + period) % width;\n      float horizintalBlend = (x - x0) * frequency;\n\n      for (int y = 0; y < height; y++) {\n        // calculates the vertical sampling indices\n        int y0 = (y / period) * period;\n        int y1 = (y0 + period) % height;\n        float verticalBlend = (y - y0) * frequency;\n\n        // blend top corners\n        float top = interpolate(base[x0][y0], base[x1][y0], horizintalBlend);\n\n        // blend bottom corners\n        float bottom = interpolate(base[x0][y1], base[x1][y1], horizintalBlend);\n\n        // blend top and bottom interpolation to get the final blend value for this cell\n        perlinNoiseLayer[x][y] = interpolate(top, bottom, verticalBlend);\n      }\n    }\n\n    return perlinNoiseLayer;\n  }\n\n  /**\n   * @param a value of point a\n   * @param b value of point b\n   * @param alpha determine which value has more impact (closer to 0 -> a, closer to 1 -> b)\n   * @return interpolated value\n   */\n  static float interpolate(float a, float b, float alpha) {\n    return a * (1 - alpha) + alpha * b;\n  }\n\n  public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n\n    final int width;\n    final int height;\n    final int octaveCount;\n    final float persistence;\n    final long seed;\n    final String charset;\n    final float[][] perlinNoise;\n\n    System.out.println(\"Width (int): \");\n    width = in.nextInt();\n\n    System.out.println(\"Height (int): \");\n    height = in.nextInt();\n\n    System.out.println(\"Octave count (int): \");\n    octaveCount = in.nextInt();\n\n    System.out.println(\"Persistence (float): \");\n    persistence = in.nextFloat();\n\n    System.out.println(\"Seed (long): \");\n    seed = in.nextLong();\n\n    System.out.println(\"Charset (String): \");\n    charset = in.next();\n\n    perlinNoise = generatePerlinNoise(width, height, octaveCount, persistence, seed);\n    final char[] chars = charset.toCharArray();\n    final int length = chars.length;\n    final float step = 1f / length;\n    // output based on charset\n    for (int x = 0; x < width; x++) {\n      for (int y = 0; y < height; y++) {\n        float value = step;\n        float noiseValue = perlinNoise[x][y];\n\n        for (char c : chars) {\n          if (noiseValue <= value) {\n            System.out.print(c);\n            break;\n          }\n\n          value += step;\n        }\n      }\n\n      System.out.println();\n    }\n    in.close();\n  }\n}\n","index":168},{"title":"Queue Using Two Stacks","category":"Others","id":"QueueUsingTwoStacks_Others","algorithm":"package Others;\n\nimport java.util.Stack;\n\n/**\n * This implements Queue using two Stacks.\n *\n * <p>Big O Runtime: insert(): O(1) remove(): O(1) amortized isEmpty(): O(1)\n *\n * <p>A queue data structure functions the same as a real world queue. The elements that are added\n * first are the first to be removed. New elements are added to the back/rear of the queue.\n *\n * @author sahilb2 (https://www.github.com/sahilb2)\n */\nclass QueueWithStack {\n\n  // Stack to keep track of elements inserted into the queue\n  private Stack inStack;\n  // Stack to keep track of elements to be removed next in queue\n  private Stack outStack;\n\n  /** Constructor */\n  public QueueWithStack() {\n    this.inStack = new Stack();\n    this.outStack = new Stack();\n  }\n\n  /**\n   * Inserts an element at the rear of the queue\n   *\n   * @param x element to be added\n   */\n  public void insert(Object x) {\n    // Insert element into inStack\n    this.inStack.push(x);\n  }\n\n  /**\n   * Remove an element from the front of the queue\n   *\n   * @return the new front of the queue\n   */\n  public Object remove() {\n    if (this.outStack.isEmpty()) {\n      // Move all elements from inStack to outStack (preserving the order)\n      while (!this.inStack.isEmpty()) {\n        this.outStack.push(this.inStack.pop());\n      }\n    }\n    return this.outStack.pop();\n  }\n\n  /**\n   * Peek at the element from the front of the queue\n   *\n   * @return the front element of the queue\n   */\n  public Object peekFront() {\n    if (this.outStack.isEmpty()) {\n      // Move all elements from inStack to outStack (preserving the order)\n      while (!this.inStack.isEmpty()) {\n        this.outStack.push(this.inStack.pop());\n      }\n    }\n    return this.outStack.peek();\n  }\n\n  /**\n   * Peek at the element from the back of the queue\n   *\n   * @return the back element of the queue\n   */\n  public Object peekBack() {\n    return this.inStack.peek();\n  }\n\n  /**\n   * Returns true if the queue is empty\n   *\n   * @return true if the queue is empty\n   */\n  public boolean isEmpty() {\n    return (this.inStack.isEmpty() && this.outStack.isEmpty());\n  }\n}\n\n/**\n * This class is the example for the Queue class\n *\n * @author sahilb2 (https://www.github.com/sahilb2)\n */\npublic class QueueUsingTwoStacks {\n\n  /**\n   * Main method\n   *\n   * @param args Command line arguments\n   */\n  public static void main(String args[]) {\n    QueueWithStack myQueue = new QueueWithStack();\n    myQueue.insert(1);\n    System.out.println(myQueue.peekBack()); // Will print 1\n    // instack: [(top) 1]\n    // outStack: []\n    myQueue.insert(2);\n    System.out.println(myQueue.peekBack()); // Will print 2\n    // instack: [(top) 2, 1]\n    // outStack: []\n    myQueue.insert(3);\n    System.out.println(myQueue.peekBack()); // Will print 3\n    // instack: [(top) 3, 2, 1]\n    // outStack: []\n    myQueue.insert(4);\n    System.out.println(myQueue.peekBack()); // Will print 4\n    // instack: [(top) 4, 3, 2, 1]\n    // outStack: []\n\n    System.out.println(myQueue.isEmpty()); // Will print false\n\n    System.out.println(myQueue.remove()); // Will print 1\n    System.out.println(myQueue.peekBack()); // Will print NULL\n    // instack: []\n    // outStack: [(top) 2, 3, 4]\n\n    myQueue.insert(5);\n    System.out.println(myQueue.peekFront()); // Will print 2\n    // instack: [(top) 5]\n    // outStack: [(top) 2, 3, 4]\n\n    myQueue.remove();\n    System.out.println(myQueue.peekFront()); // Will print 3\n    // instack: [(top) 5]\n    // outStack: [(top) 3, 4]\n    myQueue.remove();\n    System.out.println(myQueue.peekFront()); // Will print 4\n    // instack: [(top) 5]\n    // outStack: [(top) 4]\n    myQueue.remove();\n    // instack: [(top) 5]\n    // outStack: []\n    System.out.println(myQueue.peekFront()); // Will print 5\n    // instack: []\n    // outStack: [(top) 5]\n    myQueue.remove();\n    // instack: []\n    // outStack: []\n\n    System.out.println(myQueue.isEmpty()); // Will print true\n  }\n}\n","index":169},{"title":"Rabin Karp","category":"Others","id":"RabinKarp_Others","algorithm":"/** @author Prateek Kumar Oraon (https://github.com/prateekKrOraon) */\nimport java.util.Scanner;\n\n// An implementation of Rabin-Karp string matching algorithm\n// Program will simply end if there is no match\npublic class RabinKarp {\n\n  public static Scanner scanner = null;\n  public static final int d = 256;\n\n  public static void main(String[] args) {\n\n    scanner = new Scanner(System.in);\n    System.out.println(\"Enter String\");\n    String text = scanner.nextLine();\n    System.out.println(\"Enter pattern\");\n    String pattern = scanner.nextLine();\n\n    int q = 101;\n    searchPat(text, pattern, q);\n  }\n\n  private static void searchPat(String text, String pattern, int q) {\n\n    int m = pattern.length();\n    int n = text.length();\n    int t = 0;\n    int p = 0;\n    int h = 1;\n    int j = 0;\n    int i = 0;\n\n    h = (int) Math.pow(d, m - 1) % q;\n\n    for (i = 0; i < m; i++) {\n      // hash value is calculated for each character and then added with the hash value of the next\n      // character for pattern\n      // as well as the text for length equal to the length of pattern\n      p = (d * p + pattern.charAt(i)) % q;\n      t = (d * t + text.charAt(i)) % q;\n    }\n\n    for (i = 0; i <= n - m; i++) {\n\n      // if the calculated hash value of the pattern and text matches then\n      // all the characters of the pattern is matched with the text of length equal to length of the\n      // pattern\n      // if all matches then pattern exist in string\n      // if not then the hash value of the first character of the text is subtracted and hash value\n      // of the next character after the end\n      // of the evaluated characters is added\n      if (p == t) {\n\n        // if hash value matches then the individual characters are matched\n        for (j = 0; j < m; j++) {\n\n          // if not matched then break out of the loop\n          if (text.charAt(i + j) != pattern.charAt(j)) break;\n        }\n\n        // if all characters are matched then pattern exist in the string\n        if (j == m) {\n          System.out.println(\"Pattern found at index \" + i);\n        }\n      }\n\n      // if i<n-m then hash value of the first character of the text is subtracted and hash value of\n      // the next character after the end\n      // of the evaluated characters is added to get the hash value of the next window of characters\n      // in the text\n      if (i < n - m) {\n        t = (d * (t - text.charAt(i) * h) + text.charAt(i + m)) % q;\n\n        // if hash value becomes less than zero than q is added to make it positive\n        if (t < 0) t = (t + q);\n      }\n    }\n  }\n}\n","index":170},{"title":"Remove Duplicate From String","category":"Others","id":"RemoveDuplicateFromString_Others","algorithm":"package Others;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\n/** @author Varun Upadhyay (https://github.com/varunu28) */\npublic class RemoveDuplicateFromString {\n  public static void main(String[] args) throws Exception {\n    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    String inpStr = br.readLine();\n\n    System.out.println(\"Actual string is: \" + inpStr);\n    System.out.println(\"String after removing duplicates: \" + removeDuplicate(inpStr));\n\n    br.close();\n  }\n\n  /**\n   * This method produces a string after removing all the duplicate characters from input string and\n   * returns it Example: Input String - \"aabbbccccddddd\" Output String - \"abcd\"\n   *\n   * @param s String from which duplicate characters have to be removed\n   * @return string with only unique characters\n   */\n  public static String removeDuplicate(String s) {\n    if (s == null || s.isEmpty()) {\n      return s;\n    }\n\n    StringBuilder sb = new StringBuilder();\n    int n = s.length();\n\n    for (int i = 0; i < n; i++) {\n      if (sb.toString().indexOf(s.charAt(i)) == -1) {\n        sb.append(String.valueOf(s.charAt(i)));\n      }\n    }\n\n    return sb.toString();\n  }\n}\n","index":171},{"title":"Restricted Tower Of Hanoi","category":"Others","id":"RestrictedTowerOfHanoi","index":172},{"title":"Main","category":"RestrictedTowerOfHanoi","id":"Main","index":173},{"title":"Hanoi","category":"Main","id":"Hanoi_Main","algorithm":"import java.awt.*;\nimport java.awt.event.*;\nimport java.util.*;\nimport javax.swing.*;\nimport javax.swing.Timer;\n\npublic class Hanoi extends JFrame {\n\n  public static int ONE_SECOND = 1000;\n\n  int number_of_disks = 0;\n  int game_counter = 0;\n  int i = 0;\n\n  /*  GUI COMPONENTS */\n  public JButton move_button = new JButton();\n  public JButton exit_button = new JButton();\n  public JButton replay_button = new JButton();\n  public JButton auto_button = new JButton();\n\n  /* BACKEND COMPONENTS */\n  public ArrayList<String> movements = new ArrayList<String>();\n  public StringBuilder stringBuilder = new StringBuilder();\n\n  public ArrayList<Integer> Stack1 = new ArrayList<Integer>();\n  public ArrayList<Integer> Stack2 = new ArrayList<Integer>();\n  public ArrayList<Integer> Stack3 = new ArrayList<Integer>();\n\n  public void updateStacks() {\n    if (game_counter != movements.size()) {\n      String temp = movements.get(game_counter);\n      System.out.println(temp);\n      if (temp.charAt(1) == 'A') {\n        if (temp.charAt(2) == 'B') {\n          int x = Stack1.get(Stack1.size() - 1);\n          Stack1.remove(Stack1.size() - 1);\n          Stack2.add(x);\n        }\n      }\n      if (temp.charAt(1) == 'C') {\n        if (temp.charAt(2) == 'B') {\n          int x = Stack3.get(Stack3.size() - 1);\n          Stack3.remove(Stack3.size() - 1);\n          Stack2.add(x);\n        }\n      }\n\n      if (temp.charAt(1) == 'B') {\n        if (temp.charAt(2) == 'C') {\n          int x = Stack2.get(Stack2.size() - 1);\n          Stack2.remove(Stack2.size() - 1);\n          Stack3.add(x);\n        } else if (temp.charAt(2) == 'A') {\n          int x = Stack2.get(Stack2.size() - 1);\n          Stack2.remove(Stack2.size() - 1);\n          Stack1.add(x);\n        }\n      }\n      revalidate();\n      repaint();\n      game_counter++;\n    }\n  }\n\n  public void paint(Graphics canvas) {\n    super.paint(canvas);\n\n    // Drawing pedestels\n    for (int i = 0; i < 3; i++) {\n      canvas.drawRect(30 + i * 230, 670, 200, 20);\n      canvas.setColor(new Color(76, 174, 227)); // Blue Accent\n      canvas.fillRect(30 + i * 230, 670, 200, 20);\n\n      canvas.fillRect(130 + i * 230 - 2, 670 - 170, 4, 170);\n      canvas.setColor(new Color(150, 0, 0)); // Arseny\n      canvas.fillRect(130 + i * 230 - 2, 670 - 170, 4, 170);\n    }\n\n    // Disks in stack1\n    for (int i = 1; i <= Stack1.size(); i++) {\n      canvas.drawRect(130 - Stack1.get(i - 1) * 10, 670 - i * 12, Stack1.get(i - 1) * 20, 10);\n      canvas.setColor(new Color(64, 26, 0)); // Brown Wolfers\n      canvas.fillRect(130 - Stack1.get(i - 1) * 10, 670 - i * 12, Stack1.get(i - 1) * 20, 10);\n    }\n\n    // Disks in stack2\n    for (int i = 1; i <= Stack2.size(); i++) {\n      canvas.drawRect(360 - Stack2.get(i - 1) * 10, 670 - i * 12, Stack2.get(i - 1) * 20, 10);\n      canvas.setColor(new Color(64, 26, 0)); // Brown Wolfers\n      canvas.fillRect(360 - Stack2.get(i - 1) * 10, 670 - i * 12, Stack2.get(i - 1) * 20, 10);\n    }\n\n    // Disks in stack3\n    for (int i = 1; i <= Stack3.size(); i++) {\n      canvas.drawRect(590 - Stack3.get(i - 1) * 10, 670 - i * 12, Stack3.get(i - 1) * 20, 10);\n      canvas.setColor(new Color(64, 26, 0)); // Brown Wolfers\n      canvas.fillRect(590 - Stack3.get(i - 1) * 10, 670 - i * 12, Stack3.get(i - 1) * 20, 10);\n    }\n  }\n\n  // Function to initialize the widget properties and the frame.\n  public void initialize() {\n\n    move_button.setIcon(new ImageIcon(\"../Resources/rsz_move.png\"));\n    move_button.setBounds(130, 0, 50, 50);\n\n    auto_button.setIcon(new ImageIcon(\"../Resources/rsz_loop.png\"));\n    auto_button.setBounds(260, 0, 50, 50);\n\n    replay_button.setIcon(new ImageIcon(\"../Resources/rsz_replay.jpg\"));\n    replay_button.setBounds(390, 0, 50, 50);\n\n    exit_button.setIcon(new ImageIcon(\"../Resources/rsz_exit.png\"));\n    exit_button.setBounds(520, 0, 50, 50);\n\n    add(move_button);\n    add(exit_button);\n    add(replay_button);\n    add(auto_button);\n\n    setLayout(null);\n    setSize(720, 720);\n    setVisible(true);\n    setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n  }\n  // Main cnstructor.\n  Hanoi() {\n    super(\"restricted tower of hanoi\");\n    initialize();\n\n    // MOVE BUTTON ACTION LISTENER\n    move_button.addActionListener(\n        new ActionListener() {\n          @Override\n          public void actionPerformed(ActionEvent e) {\n            updateStacks();\n          }\n        });\n\n    // EXIT BUTTON ACTION LISTENER\n    exit_button.addActionListener(\n        new ActionListener() {\n          @Override\n          public void actionPerformed(ActionEvent e) {\n            System.exit(0);\n          }\n        });\n\n    // REPLAY BUTTON ACTION LISTENER\n    replay_button.addActionListener(\n        new ActionListener() {\n          @Override\n          public void actionPerformed(ActionEvent e) {\n            startGame();\n            repaint();\n          }\n        });\n\n    // AUTOMATIC PLAY BUTTON ACTION LISTENER\n    auto_button.addActionListener(\n        new ActionListener() {\n          @Override\n          public void actionPerformed(ActionEvent e) {\n            timer.start();\n            if (game_counter == movements.size()) {\n              timer.stop();\n            }\n          }\n        });\n  }\n\n  Timer timer =\n      new Timer(\n          ONE_SECOND,\n          new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n              updateStacks();\n            }\n          });\n\n  public void startGame() {\n\n    System.out.println(\"New Game Started\");\n    timer.stop();\n\n    Stack1 = new ArrayList<Integer>();\n    Stack2 = new ArrayList<Integer>();\n    Stack3 = new ArrayList<Integer>();\n\n    movements = new ArrayList<String>();\n    game_counter = 0;\n\n    for (int i = 0; i < number_of_disks; i++) {\n      Stack1.add(number_of_disks - i);\n    }\n\n    towerOfHanoi(number_of_disks, 'A', 'C', 'B');\n  }\n\n  public static void main(String args[]) {\n    Hanoi tower = new Hanoi();\n    int number = Integer.parseInt(args[0]);\n    tower.number_of_disks = number;\n    tower.startGame();\n    /*for(int i=0;i<tower.movements.size();i++) {\n        System.out.println(tower.movements.get(i));\n        //System.out.println(tower.Stack1.get(i));\n    }*/\n  }\n\n  // Recursive function to formulate restricted tower of hanoi.\n  public void towerOfHanoi(int n, char from_rod, char to_rod, char aux_rod) {\n    if (n == 1) {\n      stringBuilder.setLength(0);\n      stringBuilder.append(Integer.toString(n));\n      stringBuilder.append(from_rod);\n      stringBuilder.append(aux_rod);\n      movements.add(stringBuilder.toString());\n      // System.out.println(\"Move disk 1 from rod \" +  from_rod + \" to rod \" + aux_rod);\n      stringBuilder.setLength(0);\n      stringBuilder.append(Integer.toString(n));\n      stringBuilder.append(aux_rod);\n      stringBuilder.append(to_rod);\n      movements.add(stringBuilder.toString());\n      // System.out.println(\"Move disk 1 from rod \" +  aux_rod + \" to rod \" + to_rod);\n      return;\n    }\n    towerOfHanoi(n - 1, from_rod, to_rod, aux_rod);\n    stringBuilder.setLength(0);\n    stringBuilder.append(Integer.toString(n));\n    stringBuilder.append(from_rod);\n    stringBuilder.append(aux_rod);\n    movements.add(stringBuilder.toString());\n    // System.out.println(\"Move disk \" + n + \" from rod \" +  from_rod + \" to rod \" + aux_rod);\n    towerOfHanoi(n - 1, to_rod, from_rod, aux_rod);\n    stringBuilder.setLength(0);\n    stringBuilder.append(Integer.toString(n));\n    stringBuilder.append(aux_rod);\n    stringBuilder.append(to_rod);\n    movements.add(stringBuilder.toString());\n    // System.out.println(\"Move disk \" + n + \" from rod \" +  aux_rod + \" to rod \" + to_rod);\n    towerOfHanoi(n - 1, from_rod, to_rod, aux_rod);\n  }\n}\n","index":174},{"title":"Resources","category":"RestrictedTowerOfHanoi","id":"Resources","index":175},{"title":"Screenshots","category":"RestrictedTowerOfHanoi","id":"Screenshots","index":176},{"title":"Return Subsequence","category":"Others","id":"ReturnSubsequence_Others","algorithm":"package Others;\n\nimport java.util.Scanner;\n\npublic class ReturnSubsequence {\n  public static void main(String[] args) {\n    System.out.println(\"Enter String: \");\n    Scanner s = new Scanner(System.in);\n    String givenString = s.next(); // given string\n    String[] subsequence = returnSubsequence(givenString); // calling returnSubsequence() function\n    System.out.println(\"Subsequences : \");\n    // print the given array of subsequences\n    for (int i = 0; i < subsequence.length; i++) {\n      System.out.println(subsequence[i]);\n    }\n    s.close();\n  }\n\n  /**\n   * @param givenString\n   * @return subsequence\n   */\n  private static String[] returnSubsequence(String givenString) {\n    if (givenString.length()\n        == 0) // If string is empty we will create an array of size=1 and insert \"\" (Empty string)\n    // in it\n    {\n      String[] ans = new String[1];\n      ans[0] = \"\";\n      return ans;\n    }\n    String[] SmallAns =\n        returnSubsequence(\n            givenString.substring(\n                1)); // recursive call to get subsequences of substring starting from index\n    // position=1\n\n    String[] ans =\n        new String\n            [2 * SmallAns.length]; // Our answer will be an array off string of size=2*SmallAns\n    int i = 0;\n    for (; i < SmallAns.length; i++) {\n      ans[i] = SmallAns[i]; // Copying all the strings present in SmallAns to ans string array\n    }\n    for (int k = 0; k < SmallAns.length; k++) {\n      ans[k + SmallAns.length] =\n          givenString.charAt(0)\n              + SmallAns[\n                  k]; // Insert character at index=0 of the given substring in front of every string\n      // in SmallAns\n    }\n    return ans;\n  }\n}\n","index":177},{"title":"Reverse Stack Using Recursion","category":"Others","id":"ReverseStackUsingRecursion_Others","algorithm":"package Others;\n\n/* Program to reverse a Stack using Recursion*/\n\nimport java.util.Stack;\n\npublic class ReverseStackUsingRecursion {\n\n  // Stack\n  private static Stack<Integer> stack = new Stack<>();\n\n  // Main function\n  public static void main(String[] args) {\n    // To Create a Dummy Stack containing integers from 0-9\n    for (int i = 0; i < 10; i++) {\n      stack.push(i);\n    }\n    System.out.println(\"STACK\");\n\n    // To print that dummy Stack\n    for (int k = 9; k >= 0; k--) {\n      System.out.println(k);\n    }\n\n    // Reverse Function called\n    reverseUsingRecursion(stack);\n\n    System.out.println(\"REVERSED STACK : \");\n    // To print reversed  stack\n    while (!stack.isEmpty()) {\n      System.out.println(stack.pop());\n    }\n  }\n\n  // Function Used to reverse Stack Using Recursion\n  private static void reverseUsingRecursion(Stack<Integer> stack) {\n    if (stack.isEmpty()) // If stack is empty then return\n    {\n      return;\n    }\n    /* All items are stored in call stack until we reach the end*/\n\n    int temptop = stack.peek();\n    stack.pop();\n    reverseUsingRecursion(stack); // Recursion call\n    insertAtEnd(temptop); // Insert items held in call stack one by one into stack\n  }\n\n  // Function used to insert element at the end of stack\n  private static void insertAtEnd(int temptop) {\n    if (stack.isEmpty()) {\n      stack.push(temptop); // If stack is empty push the element\n    } else {\n      int temp = stack.peek(); /* All the items are stored in call stack until we reach end*/\n      stack.pop();\n\n      insertAtEnd(temptop); // Recursive call\n\n      stack.push(temp);\n    }\n  }\n}\n","index":178},{"title":"Root Precision","category":"Others","id":"RootPrecision_Others","algorithm":"package Others;\n\nimport java.util.Scanner;\n\npublic class RootPrecision {\n\n  public static void main(String[] args) {\n    // take input\n    Scanner scn = new Scanner(System.in);\n\n    // N is the input number\n    int N = scn.nextInt();\n\n    // P is precision value for eg - P is 3 in 2.564 and 5 in 3.80870.\n    int P = scn.nextInt();\n    System.out.println(squareRoot(N, P));\n\n    scn.close();\n  }\n\n  public static double squareRoot(int N, int P) {\n    // rv means return value\n    double rv;\n\n    double root = Math.pow(N, 0.5);\n\n    // calculate precision to power of 10 and then multiply it with root value.\n    int precision = (int) Math.pow(10, P);\n    root = root * precision;\n    /*typecast it into integer then divide by precision and again typecast into double\n    so as to have decimal points upto P precision */\n\n    rv = (int) root;\n    return rv / precision;\n  }\n}\n","index":179},{"title":"S J F","category":"Others","id":"SJF_Others","algorithm":"package Others;\n/**\n *\n *\n * <h2>Shortest job first.</h2>\n *\n * <p>Shortest job first (SJF) or shortest job next, is a scheduling policy that selects the waiting\n * process with the smallest execution time to execute next Shortest Job first has the advantage of\n * having minimum average waiting time among all scheduling algorithms. It is a Greedy Algorithm. It\n * may cause starvation if shorter processes keep coming. This problem has been solved using the\n * concept of aging.\n *\n * @author shivg7706\n * @since 2018/10/27\n */\nimport java.util.*;\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\nclass Process {\n\n  public int pid;\n  public int arrivalTime;\n  public int burstTime;\n  public int priority;\n  public int turnAroundTime;\n  public int waitTime;\n  public int remainingTime;\n}\n\nclass Schedule {\n\n  private int noOfProcess;\n  private int timer = 0;\n  private ArrayList<Process> processes;\n  private ArrayList<Process> remainingProcess;\n  private ArrayList<Integer> gantChart;\n  private float burstAll;\n  private Map<Integer, ArrayList<Process>> arrivals;\n\n  Schedule() {\n    Scanner in = new Scanner(System.in);\n\n    processes = new ArrayList<Process>();\n    remainingProcess = new ArrayList<Process>();\n\n    gantChart = new ArrayList<>();\n    arrivals = new HashMap<>();\n\n    System.out.print(\"Enter the no. of processes: \");\n    noOfProcess = in.nextInt();\n    System.out.println(\"Enter the arrival, burst and priority of processes\");\n    for (int i = 0; i < noOfProcess; i++) {\n      Process p = new Process();\n      p.pid = i;\n      p.arrivalTime = in.nextInt();\n      p.burstTime = in.nextInt();\n      p.priority = in.nextInt();\n      p.turnAroundTime = 0;\n      p.waitTime = 0;\n      p.remainingTime = p.burstTime;\n\n      if (arrivals.get(p.arrivalTime) == null) {\n        arrivals.put(p.arrivalTime, new ArrayList<Process>());\n      }\n      arrivals.get(p.arrivalTime).add(p);\n      processes.add(p);\n      burstAll += p.burstTime;\n    }\n    in.close();\n  }\n\n  void startScheduling() {\n\n    processes.sort(\n        new Comparator<Process>() {\n          @Override\n          public int compare(Process a, Process b) {\n            return a.arrivalTime - b.arrivalTime;\n          }\n        });\n\n    while (!(arrivals.size() == 0 && remainingProcess.size() == 0)) {\n      removeFinishedProcess();\n      if (arrivals.get(timer) != null) {\n        remainingProcess.addAll(arrivals.get(timer));\n        arrivals.remove(timer);\n      }\n\n      remainingProcess.sort(\n          new Comparator<Process>() {\n            private int alpha = 6;\n            private int beta = 1;\n\n            @Override\n            public int compare(Process a, Process b) {\n              int aRem = a.remainingTime;\n              int bRem = b.remainingTime;\n              int aprior = a.priority;\n              int bprior = b.priority;\n              return (alpha * aRem + beta * aprior) - (alpha * bRem + beta * bprior);\n            }\n          });\n\n      int k = timeElapsed(timer);\n      ageing(k);\n      timer++;\n    }\n\n    System.out.println(\"Total time required: \" + (timer - 1));\n  }\n\n  void removeFinishedProcess() {\n    ArrayList<Integer> completed = new ArrayList<Integer>();\n    for (int i = 0; i < remainingProcess.size(); i++) {\n      if (remainingProcess.get(i).remainingTime == 0) {\n        completed.add(i);\n      }\n    }\n\n    for (int i = 0; i < completed.size(); i++) {\n      int pid = remainingProcess.get(completed.get(i)).pid;\n      processes.get(pid).waitTime = remainingProcess.get(completed.get(i)).waitTime;\n      remainingProcess.remove(remainingProcess.get(completed.get(i)));\n    }\n  }\n\n  public int timeElapsed(int i) {\n    if (!remainingProcess.isEmpty()) {\n      gantChart.add(i, remainingProcess.get(0).pid);\n      remainingProcess.get(0).remainingTime--;\n      return 1;\n    }\n    return 0;\n  }\n\n  public void ageing(int k) {\n    for (int i = k; i < remainingProcess.size(); i++) {\n      remainingProcess.get(i).waitTime++;\n      if (remainingProcess.get(i).waitTime % 7 == 0) {\n        remainingProcess.get(i).priority--;\n      }\n    }\n  }\n\n  public void solve() {\n    System.out.println(\"Gant chart \");\n    for (int i = 0; i < gantChart.size(); i++) {\n      System.out.print(gantChart.get(i) + \" \");\n    }\n    System.out.println();\n\n    float waitTimeTot = 0;\n    float tatTime = 0;\n\n    for (int i = 0; i < noOfProcess; i++) {\n      processes.get(i).turnAroundTime = processes.get(i).waitTime + processes.get(i).burstTime;\n\n      waitTimeTot += processes.get(i).waitTime;\n      tatTime += processes.get(i).turnAroundTime;\n\n      System.out.println(\n          \"Process no.: \"\n              + i\n              + \" Wait time: \"\n              + processes.get(i).waitTime\n              + \" Turn Around Time: \"\n              + processes.get(i).turnAroundTime);\n    }\n\n    System.out.println(\"Average Waiting Time: \" + waitTimeTot / noOfProcess);\n    System.out.println(\"Average TAT Time: \" + tatTime / noOfProcess);\n    System.out.println(\"Throughput: \" + (float) noOfProcess / (timer - 1));\n  }\n}\n\npublic class SJF {\n  public static void main(String[] args) {\n    Schedule s = new Schedule();\n    s.startScheduling();\n    s.solve();\n  }\n}\n","index":180},{"title":"Sieve Of Eratosthenes","category":"Others","id":"SieveOfEratosthenes_Others","algorithm":"package Others;\n\n/** @author Varun Upadhyay (https://github.com/varunu28) */\npublic class SieveOfEratosthenes {\n\n  /**\n   * This method implements the Sieve of Eratosthenes Algorithm\n   *\n   * @param n The number till which we have to check for prime Prints all the prime numbers till n\n   */\n  public static void findPrimesTillN(int n) {\n    int[] arr = new int[n + 1];\n\n    for (int i = 0; i <= n; i++) {\n      arr[i] = 1;\n    }\n\n    arr[0] = arr[1] = 0;\n\n    for (int i = 2; i <= Math.sqrt(n); i++) {\n      if (arr[i] == 1) {\n        for (int j = 2; i * j <= n; j++) {\n          arr[i * j] = 0;\n        }\n      }\n    }\n\n    for (int i = 0; i < n + 1; i++) {\n      if (arr[i] == 1) {\n        System.out.print(i + \" \");\n      }\n    }\n\n    System.out.println();\n  }\n\n  // Driver Program\n  public static void main(String[] args) {\n    int n = 100;\n\n    // Prints 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97\n    findPrimesTillN(n);\n  }\n}\n","index":181},{"title":"Skyline Problem","category":"Others","id":"SkylineProblem_Others","algorithm":"package Others;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.Scanner;\n\npublic class SkylineProblem {\n  Building[] building;\n  int count;\n\n  public void run() {\n    Scanner sc = new Scanner(System.in);\n\n    int num = sc.nextInt();\n    this.building = new Building[num];\n\n    for (int i = 0; i < num; i++) {\n      String input = sc.next();\n      String[] data = input.split(\",\");\n      this.add(Integer.parseInt(data[0]), Integer.parseInt(data[1]), Integer.parseInt(data[2]));\n    }\n    this.print(this.findSkyline(0, num - 1));\n\n    sc.close();\n  }\n\n  public void add(int left, int height, int right) {\n    building[count++] = new Building(left, height, right);\n  }\n\n  public void print(ArrayList<Skyline> skyline) {\n    Iterator<Skyline> it = skyline.iterator();\n\n    while (it.hasNext()) {\n      Skyline temp = it.next();\n      System.out.print(temp.coordinates + \",\" + temp.height);\n      if (it.hasNext()) {\n        System.out.print(\",\");\n      }\n    }\n  }\n\n  public ArrayList<Skyline> findSkyline(int start, int end) {\n    if (start == end) {\n      ArrayList<Skyline> list = new ArrayList<>();\n      list.add(new Skyline(building[start].left, building[start].height));\n      list.add(new Skyline(building[end].right, 0));\n\n      return list;\n    }\n\n    int mid = (start + end) / 2;\n\n    ArrayList<Skyline> sky1 = this.findSkyline(start, mid);\n    ArrayList<Skyline> sky2 = this.findSkyline(mid + 1, end);\n\n    return this.mergeSkyline(sky1, sky2);\n  }\n\n  public ArrayList<Skyline> mergeSkyline(ArrayList<Skyline> sky1, ArrayList<Skyline> sky2) {\n    int currentH1 = 0, currentH2 = 0;\n    ArrayList<Skyline> skyline = new ArrayList<>();\n    int maxH = 0;\n\n    while (!sky1.isEmpty() && !sky2.isEmpty()) {\n      if (sky1.get(0).coordinates < sky2.get(0).coordinates) {\n        int currentX = sky1.get(0).coordinates;\n        currentH1 = sky1.get(0).height;\n\n        if (currentH1 < currentH2) {\n          sky1.remove(0);\n          if (maxH != currentH2) skyline.add(new Skyline(currentX, currentH2));\n        } else {\n          maxH = currentH1;\n          sky1.remove(0);\n          skyline.add(new Skyline(currentX, currentH1));\n        }\n      } else {\n        int currentX = sky2.get(0).coordinates;\n        currentH2 = sky2.get(0).height;\n\n        if (currentH2 < currentH1) {\n          sky2.remove(0);\n          if (maxH != currentH1) skyline.add(new Skyline(currentX, currentH1));\n        } else {\n          maxH = currentH2;\n          sky2.remove(0);\n          skyline.add(new Skyline(currentX, currentH2));\n        }\n      }\n    }\n\n    while (!sky1.isEmpty()) {\n      skyline.add(sky1.get(0));\n      sky1.remove(0);\n    }\n\n    while (!sky2.isEmpty()) {\n      skyline.add(sky2.get(0));\n      sky2.remove(0);\n    }\n\n    return skyline;\n  }\n\n  public class Skyline {\n    public int coordinates;\n    public int height;\n\n    public Skyline(int coordinates, int height) {\n      this.coordinates = coordinates;\n      this.height = height;\n    }\n  }\n\n  public class Building {\n    public int left;\n    public int height;\n    public int right;\n\n    public Building(int left, int height, int right) {\n      this.left = left;\n      this.height = height;\n      this.right = right;\n    }\n  }\n\n  public static void main(String[] args) {\n    SkylineProblem skylineProblem = new SkylineProblem();\n    skylineProblem.run();\n  }\n}\n","index":182},{"title":"Stack Postfix Notation","category":"Others","id":"StackPostfixNotation_Others","algorithm":"package Others;\n\nimport java.util.*;\n\npublic class StackPostfixNotation {\n  public static void main(String[] args) {\n    Scanner scanner = new Scanner(System.in);\n    String post = scanner.nextLine(); // Takes input with spaces in between eg. \"1 21 +\"\n    System.out.println(postfixEvaluate(post));\n    scanner.close();\n  }\n\n  // Evaluates the given postfix expression string and returns the result.\n  public static int postfixEvaluate(String exp) {\n    Stack<Integer> s = new Stack<Integer>();\n    Scanner tokens = new Scanner(exp);\n\n    while (tokens.hasNext()) {\n      if (tokens.hasNextInt()) {\n        s.push(tokens.nextInt()); // If int then push to stack\n      } else { // else pop top two values and perform the operation\n        int num2 = s.pop();\n        int num1 = s.pop();\n        String op = tokens.next();\n\n        if (op.equals(\"+\")) {\n          s.push(num1 + num2);\n        } else if (op.equals(\"-\")) {\n          s.push(num1 - num2);\n        } else if (op.equals(\"*\")) {\n          s.push(num1 * num2);\n        } else {\n          s.push(num1 / num2);\n        }\n\n        //  \"+\", \"-\", \"*\", \"/\"\n      }\n    }\n    tokens.close();\n    return s.pop();\n  }\n}\n","index":183},{"title":"String Match Finite Automata","category":"Others","id":"StringMatchFiniteAutomata_Others","algorithm":"/** @author Prateek Kumar Oraon (https://github.com/prateekKrOraon) */\nimport java.util.Scanner;\n\n// An implementaion of string matching using finite automata\npublic class StringMatchFiniteAutomata {\n\n  public static final int CHARS = 256;\n  public static int[][] FA;\n  public static Scanner scanner = null;\n\n  public static void main(String[] args) {\n\n    scanner = new Scanner(System.in);\n    System.out.println(\"Enter String\");\n    String text = scanner.nextLine();\n    System.out.println(\"Enter pattern\");\n    String pat = scanner.nextLine();\n\n    searchPat(text, pat);\n\n    scanner.close();\n  }\n\n  public static void searchPat(String text, String pat) {\n\n    int m = pat.length();\n    int n = text.length();\n\n    FA = new int[m + 1][CHARS];\n\n    computeFA(pat, m, FA);\n\n    int state = 0;\n    for (int i = 0; i < n; i++) {\n      state = FA[state][text.charAt(i)];\n\n      if (state == m) {\n        System.out.println(\"Pattern found at index \" + (i - m + 1));\n      }\n    }\n  }\n\n  // Computes finite automata for the partern\n  public static void computeFA(String pat, int m, int[][] FA) {\n\n    for (int state = 0; state <= m; ++state) {\n      for (int x = 0; x < CHARS; ++x) {\n        FA[state][x] = getNextState(pat, m, state, x);\n      }\n    }\n  }\n\n  public static int getNextState(String pat, int m, int state, int x) {\n\n    // if current state is less than length of pattern\n    // and input character of pattern matches the character in the alphabet\n    // then automata goes to next state\n    if (state < m && x == pat.charAt(state)) {\n      return state + 1;\n    }\n\n    for (int ns = state; ns > 0; ns--) {\n\n      if (pat.charAt(ns - 1) == x) {\n\n        for (int i = 0; i < ns - 1; i++) {\n\n          if (pat.charAt(i) != pat.charAt(state - ns + i + 1)) {\n            break;\n          }\n\n          if (i == ns - 1) {\n            return ns;\n          }\n        }\n      }\n    }\n\n    return 0;\n  }\n}\n","index":184},{"title":"Three Sum","category":"Others","id":"ThreeSum_Others","algorithm":"package Others;\n\nimport java.util.Arrays;\nimport java.util.Scanner;\n\n/**\n * To find triplet equals to given sum in complexity O(n*log(n))\n *\n * <p>Array must be sorted\n *\n * @author Ujjawal Joshi\n * @date 2020.05.18\n *     <p>Test Cases: Input: 6 //Length of array 12 3 4 1 6 9 target=24 Output:3 9 12 Explanation:\n *     There is a triplet (12, 3 and 9) present in the array whose sum is 24.\n */\nclass ThreeSum {\n  public static void main(String args[]) {\n    Scanner sc = new Scanner(System.in);\n    int n = sc.nextInt(); // Length of an array\n\n    int a[] = new int[n];\n\n    for (int i = 0; i < n; i++) {\n      a[i] = sc.nextInt();\n    }\n    System.out.println(\"Target\");\n    int n_find = sc.nextInt();\n\n    Arrays.sort(a); // Sort the array if array is not sorted\n\n    for (int i = 0; i < n; i++) {\n\n      int l = i + 1, r = n - 1;\n\n      while (l < r) {\n        if (a[i] + a[l] + a[r] == n_find) {\n          System.out.println(a[i] + \" \" + a[l] + \" \" + a[r]);\n          break;\n        } // if you want all the triplets write l++;r--; insted of break;\n        else if (a[i] + a[l] + a[r] < n_find) l++;\n        else r--;\n      }\n    }\n\n    sc.close();\n  }\n}\n","index":185},{"title":"Top K Words","category":"Others","id":"TopKWords_Others","algorithm":"package Others;\n\nimport java.io.*;\nimport java.util.*;\n\n/* display the most frequent K words in the file and the times it appear\nin the file – shown in order (ignore case and periods) */\n\npublic class TopKWords {\n  static class CountWords {\n    private String fileName;\n\n    public CountWords(String fileName) {\n      this.fileName = fileName;\n    }\n\n    public Map<String, Integer> getDictionary() {\n      Map<String, Integer> dictionary = new HashMap<>();\n      FileInputStream fis = null;\n\n      try {\n\n        fis = new FileInputStream(fileName); // open the file\n        int in = 0;\n        String s = \"\"; // init a empty word\n        in = fis.read(); // read one character\n\n        while (-1 != in) {\n          if (Character.isLetter((char) in)) {\n            s += (char) in; // if get a letter, append to s\n          } else {\n            // this branch means an entire word has just been read\n            if (s.length() > 0) {\n              // see whether word exists or not\n              if (dictionary.containsKey(s)) {\n                // if exist, count++\n                dictionary.put(s, dictionary.get(s) + 1);\n              } else {\n                // if not exist, initiate count of this word with 1\n                dictionary.put(s, 1);\n              }\n            }\n            s = \"\"; // reInit a empty word\n          }\n          in = fis.read();\n        }\n        return dictionary;\n      } catch (IOException e) {\n        e.printStackTrace();\n      } finally {\n        try {\n          // you always have to close the I/O streams\n          if (fis != null) fis.close();\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n      }\n      return null;\n    }\n  }\n\n  public static void main(String[] args) {\n    // you can replace the filePath with yours\n    CountWords cw = new CountWords(\"/Users/lisanaaa/Desktop/words.txt\");\n    Map<String, Integer> dictionary =\n        cw.getDictionary(); // get the words dictionary: {word: frequency}\n\n    // we change the map to list for convenient sort\n    List<Map.Entry<String, Integer>> list = new ArrayList<>(dictionary.entrySet());\n\n    // sort by lambda valueComparator\n    list.sort(Comparator.comparing(m -> m.getValue()));\n\n    Scanner input = new Scanner(System.in);\n    int k = input.nextInt();\n    while (k > list.size()) {\n      System.out.println(\"Retype a number, your number is too large\");\n      input = new Scanner(System.in);\n      k = input.nextInt();\n    }\n    for (int i = 0; i < k; i++) {\n      System.out.println(list.get(list.size() - i - 1));\n    }\n    input.close();\n  }\n}\n","index":186},{"title":"Tower Of Hanoi","category":"Others","id":"TowerOfHanoi_Others","algorithm":"package Others;\n\nimport java.util.Scanner;\n\nclass TowerOfHanoi {\n  public static void shift(int n, String startPole, String intermediatePole, String endPole) {\n    // if n becomes zero the program returns thus ending the loop.\n    if (n != 0) {\n      // Shift function is called in recursion for swapping the n-1 disc from the startPole to the\n      // intermediatePole\n      shift(n - 1, startPole, endPole, intermediatePole);\n      System.out.format(\"Move %d from %s to %s\\n\", n, startPole, endPole); // Result Printing\n      // Shift function is called in recursion for swapping the n-1 disc from the intermediatePole\n      // to the endPole\n      shift(n - 1, intermediatePole, startPole, endPole);\n    }\n  }\n\n  public static void main(String[] args) {\n    System.out.print(\"Enter number of discs on Pole 1: \");\n    Scanner scanner = new Scanner(System.in);\n    int numberOfDiscs = scanner.nextInt(); // input of number of discs on pole 1\n    shift(numberOfDiscs, \"Pole1\", \"Pole2\", \"Pole3\"); // Shift function called\n    scanner.close();\n  }\n}\n","index":187},{"title":"Two Pointers","category":"Others","id":"TwoPointers_Others","algorithm":"package Others;\n\nimport java.util.Arrays;\n\n/**\n * The two pointer technique is a useful tool to utilize when searching for pairs in a sorted array.\n *\n * <p>link: https://www.geeksforgeeks.org/two-pointers-technique/\n */\nclass TwoPointers {\n\n  public static void main(String[] args) {\n    int[] arr = {10, 20, 35, 50, 75, 80};\n    int key = 70;\n    assert isPairedSum(arr, key); /* 20 + 60 == 70 */\n\n    arr = new int[] {1, 2, 3, 4, 5, 6, 7};\n    key = 13;\n    assert isPairedSum(arr, key); /* 6 + 7 == 13 */\n\n    key = 14;\n    assert !isPairedSum(arr, key);\n  }\n\n  /**\n   * Given a sorted array arr (sorted in ascending order). Find if there exists any pair of elements\n   * such that their sum is equal to key.\n   *\n   * @param arr the array contains elements\n   * @param key the number to search\n   * @return {@code true} if there exists a pair of elements, {@code false} otherwise.\n   */\n  private static boolean isPairedSum(int[] arr, int key) {\n    /* array sorting is necessary for this algorithm to function correctly */\n    Arrays.sort(arr);\n    int i = 0; /* index of first element */\n    int j = arr.length - 1; /* index of last element */\n\n    while (i < j) {\n      if (arr[i] + arr[j] == key) {\n        return true;\n      } else if (arr[i] + arr[j] < key) {\n        i++;\n      } else {\n        j--;\n      }\n    }\n    return false;\n  }\n}\n","index":188},{"title":"Worst Fit","category":"Others","id":"WorstFit_Others","algorithm":"package Others;\n\nimport java.util.ArrayList;\n\n/** @author Dekas Dimitrios */\npublic class WorstFit {\n  private static final int NO_ALLOCATION =\n      -255; // if a process has been allocated in position -255,\n  // it means that it has not been actually allocated.\n\n  /**\n   * Method to find the index of the memory block that is going to fit the given process based on\n   * the worst fit algorithm.\n   *\n   * @param blocks: the array with the available memory blocks.\n   * @param process: the size of the process.\n   * @return the index of the block that fits, or -255 if no such block exists.\n   */\n  private static int findWorstFit(int[] blockSizes, int processSize) {\n    int max = -1;\n    int index = -1;\n    for (int i = 0;\n        i < blockSizes.length;\n        i++) { // Find the index of the biggest memory block available.\n      if (blockSizes[i] > max) {\n        max = blockSizes[i];\n        index = i;\n      }\n    }\n    // If the biggest memory block cannot fit the process, return -255 as the result\n    if (processSize > blockSizes[index]) {\n      return NO_ALLOCATION;\n    }\n    return index;\n  }\n\n  /**\n   * Method to allocate memory to blocks according to the worst fit algorithm. It should return an\n   * ArrayList of Integers, where the index is the process ID (zero-indexed) and the value is the\n   * block number (also zero-indexed).\n   *\n   * @param sizeOfBlocks: an int array that contains the sizes of the memory blocks available.\n   * @param sizeOfProcesses: an int array that contains the sizes of the processes we need memory\n   *     blocks for.\n   * @return the ArrayList filled with Integers repressenting the memory allocation that took place.\n   */\n  static ArrayList<Integer> worstFit(int[] sizeOfBlocks, int[] sizeOfProcesses) {\n    // The array list responsible for saving the memory allocations done by the worst-fit algorithm\n    ArrayList<Integer> memAlloc = new ArrayList<>();\n    // Do this for every process\n    for (int processSize : sizeOfProcesses) {\n      int chosenBlockIdx =\n          findWorstFit(\n              sizeOfBlocks, processSize); // Find the index of the memory block going to be used\n      memAlloc.add(chosenBlockIdx); // Store the chosen block index in the memAlloc array list\n      if (chosenBlockIdx\n          != NO_ALLOCATION) { // Only if a block was chosen to store the process in it,\n        sizeOfBlocks[chosenBlockIdx] -= processSize; // resize the block based on the process size\n      }\n    }\n    return memAlloc;\n  }\n\n  /**\n   * Method to print the memory allocated.\n   *\n   * @param memAllocation: an ArrayList of Integer representing the memory allocation done by the\n   *     worstFit method.\n   */\n  public static void printMemoryAllocation(ArrayList<Integer> memAllocation) {\n    System.out.println(\"Process No.\\tBlock No.\");\n    System.out.println(\"===========\\t=========\");\n    for (int i = 0; i < memAllocation.size(); i++) {\n      System.out.print(\" \" + i + \"\\t\\t\");\n      if (memAllocation.get(i) != NO_ALLOCATION) System.out.print(memAllocation.get(i));\n      else System.out.print(\"Not Allocated\");\n      System.out.println();\n    }\n  }\n}\n","index":189},{"title":"Project Euler","category":null,"id":"ProjectEuler","index":190},{"title":"Problem01","category":"ProjectEuler","id":"Problem01_ProjectEuler","algorithm":"package ProjectEuler;\n\n/**\n * If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9.\n * The sum of these multiples is 23.\n *\n * <p>Find the sum of all the multiples of 3 or 5 below 1000.\n *\n * <p>Link: https://projecteuler.net/problem=1\n */\npublic class Problem01 {\n  public static void main(String[] args) {\n    int[][] testNumber = {\n      {3, 0},\n      {4, 3},\n      {10, 23},\n      {1000, 233168},\n      {-1, 0}\n    };\n\n    for (int[] ints : testNumber) {\n      assert solution1(ints[0]) == ints[1];\n      assert solution2(ints[0]) == ints[1];\n    }\n  }\n\n  private static int solution1(int n) {\n    int sum = 0;\n    for (int i = 3; i < n; ++i) {\n      if (i % 3 == 0 || i % 5 == 0) {\n        sum += i;\n      }\n    }\n    return sum;\n  }\n\n  private static int solution2(int n) {\n    int sum = 0;\n\n    int terms = (n - 1) / 3;\n    sum += terms * (6 + (terms - 1) * 3) / 2;\n\n    terms = (n - 1) / 5;\n    sum += terms * (10 + (terms - 1) * 5) / 2;\n\n    terms = (n - 1) / 15;\n    sum -= terms * (30 + (terms - 1) * 15) / 2;\n\n    return sum;\n  }\n}\n","index":191},{"title":"Problem02","category":"ProjectEuler","id":"Problem02_ProjectEuler","algorithm":"package ProjectEuler;\n\n/**\n * Each new term in the Fibonacci sequence is generated by adding the previous two terms. By\n * starting with 1 and 2, the first 10 terms will be:\n *\n * <p>1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...\n *\n * <p>By considering the terms in the Fibonacci sequence whose values do not exceed four million,\n * find the sum of the even-valued terms.\n *\n * <p>Link: https://projecteuler.net/problem=2\n */\npublic class Problem02 {\n  public static void main(String[] args) {\n    int[][] testNumbers = {\n      {10, 10}, /* 2 + 8 == 10 */\n      {15, 10}, /* 2 + 8 == 10 */\n      {2, 2},\n      {1, 0},\n      {89, 44} /* 2 + 8 + 34 == 44 */\n    };\n\n    for (int[] ints : testNumbers) {\n      assert solution1(ints[0]) == ints[1];\n    }\n  }\n\n  private static int solution1(int n) {\n    int sum = 0;\n    int first = 1;\n    int second = 2;\n    while (second <= n) {\n      if (second % 2 == 0) {\n        sum += second;\n      }\n      int temp = first + second;\n      first = second;\n      second = temp;\n    }\n    return sum;\n  }\n}\n","index":192},{"title":"Problem04","category":"ProjectEuler","id":"Problem04_ProjectEuler","algorithm":"package ProjectEuler;\n\n/**\n * A palindromic number reads the same both ways. The largest palindrome made from the product of\n * two 2-digit numbers is 9009 = 91 × 99.\n *\n * <p>Find the largest palindrome made from the product of two 3-digit numbers.\n *\n * <p>link: https://projecteuler.net/problem=4\n */\npublic class Problem04 {\n  public static void main(String[] args) {\n\n    assert solution1(10000) == -1;\n    assert solution1(20000) == 19591; /* 19591 == 143*137 */\n    assert solution1(30000) == 29992; /* 29992 == 184*163 */\n    assert solution1(40000) == 39893; /* 39893 == 287*139 */\n    assert solution1(50000) == 49894; /* 49894 == 494*101 */\n    assert solution1(60000) == 59995; /* 59995 == 355*169 */\n    assert solution1(70000) == 69996; /* 69996 == 614*114 */\n    assert solution1(80000) == 79897; /* 79897 == 733*109 */\n    assert solution1(90000) == 89798; /* 89798 == 761*118 */\n    assert solution1(100000) == 99999; /* 100000 == 813*123 */\n  }\n\n  private static int solution1(int n) {\n    for (int i = n - 1; i >= 10000; --i) {\n      String strNumber = String.valueOf(i);\n\n      /* Test if strNumber is palindrome */\n      if (new StringBuilder(strNumber).reverse().toString().equals(strNumber)) {\n        for (int divisor = 999; divisor >= 100; --divisor) {\n          if (i % divisor == 0 && String.valueOf(i / divisor).length() == 3) {\n            return i;\n          }\n        }\n      }\n    }\n    return -1; /* not found */\n  }\n}\n","index":193},{"title":"Problem06","category":"ProjectEuler","id":"Problem06_ProjectEuler","algorithm":"package ProjectEuler;\n\n/**\n * The sum of the squares of the first ten natural numbers is, 1^2 + 2^2 + ... + 10^2 = 385 The\n * square of the sum of the first ten natural numbers is, (1 + 2 + ... + 10)^2 = 552 = 3025 Hence\n * the difference between the sum of the squares of the first ten natural numbers and the square of\n * the sum is 3025 − 385 = 2640. Find the difference between the sum of the squares of the first N\n * natural numbers and the square of the sum.\n *\n * <p>link: https://projecteuler.net/problem=6\n */\npublic class Problem06 {\n  public static void main(String[] args) {\n    int[][] testNumbers = {\n      {10, 2640},\n      {15, 13160},\n      {20, 41230},\n      {50, 1582700}\n    };\n\n    for (int[] testNumber : testNumbers) {\n      assert solution1(testNumber[0]) == testNumber[1]\n          && solutions2(testNumber[0]) == testNumber[1];\n    }\n  }\n\n  private static int solution1(int n) {\n    int sum1 = 0;\n    int sum2 = 0;\n    for (int i = 1; i <= n; ++i) {\n      sum1 += i * i;\n      sum2 += i;\n    }\n    return sum2 * sum2 - sum1;\n  }\n\n  private static int solutions2(int n) {\n    int sumOfSquares = n * (n + 1) * (2 * n + 1) / 6;\n    int squareOfSum = (int) Math.pow((n * (n + 1) / 2.0), 2);\n    return squareOfSum - sumOfSquares;\n  }\n}\n","index":194},{"title":"Problem07","category":"ProjectEuler","id":"Problem07_ProjectEuler","algorithm":"package ProjectEuler;\n\n/**\n * By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is\n * 13.\n *\n * <p>What is the 10 001st prime number?\n *\n * <p>link: https://projecteuler.net/problem=7\n */\npublic class Problem07 {\n  public static void main(String[] args) {\n    int[][] testNumbers = {\n      {1, 2},\n      {2, 3},\n      {3, 5},\n      {4, 7},\n      {5, 11},\n      {6, 13},\n      {20, 71},\n      {50, 229},\n      {100, 541}\n    };\n    for (int[] number : testNumbers) {\n      assert solution1(number[0]) == number[1];\n    }\n  }\n\n  /***\n   * Checks if a number is prime or not\n   * @param number the number\n   * @return {@code true} if {@code number} is prime\n   */\n  private static boolean isPrime(int number) {\n    if (number == 2) {\n      return true;\n    }\n    if (number < 2 || number % 2 == 0) {\n      return false;\n    }\n    for (int i = 3, limit = (int) Math.sqrt(number); i <= limit; i += 2) {\n      if (number % i == 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private static int solution1(int n) {\n    int count = 0;\n    int number = 1;\n\n    while (count != n) {\n      if (isPrime(++number)) {\n        count++;\n      }\n    }\n    return number;\n  }\n}\n","index":195},{"title":"Problem09","category":"ProjectEuler","id":"Problem09_ProjectEuler","algorithm":"package ProjectEuler;\n\n/**\n * A Pythagorean triplet is a set of three natural numbers, a < b < c, for which,\n *\n * <p>a^2 + b^2 = c^2 For example, 3^2 + 4^2 = 9 + 16 = 25 = 5^2.\n *\n * <p>There exists exactly one Pythagorean triplet for which a + b + c = 1000. Find the product abc.\n *\n * <p>link: https://projecteuler.net/problem=9\n */\npublic class Problem09 {\n  public static void main(String[] args) {\n    assert solution1() == 31875000;\n  }\n\n  private static int solution1() {\n    for (int i = 0; i <= 300; ++i) {\n      for (int j = 0; j <= 400; ++j) {\n        int k = 1000 - i - j;\n        if (i * i + j * j == k * k) {\n          return i * j * k;\n        }\n      }\n    }\n    return -1; /* should not happen */\n  }\n}\n","index":196},{"title":"Problem10","category":"ProjectEuler","id":"Problem10_ProjectEuler","algorithm":"package ProjectEuler;\n\n/**\n * The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.\n *\n * <p>Find the sum of all the primes below two million.\n *\n * <p>link: https://projecteuler.net/problem=10\n */\npublic class Problem10 {\n  public static void main(String[] args) {\n    long[][] testNumbers = {\n      {2000000, 142913828922L},\n      {10000, 5736396},\n      {5000, 1548136},\n      {1000, 76127},\n      {10, 17},\n      {7, 10}\n    };\n\n    for (long[] testNumber : testNumbers) {\n      assert solution1(testNumber[0]) == testNumber[1];\n    }\n  }\n\n  /***\n   * Checks if a number is prime or not\n   * @param n the number\n   * @return {@code true} if {@code n} is prime\n   */\n  private static boolean isPrime(int n) {\n    if (n == 2) {\n      return true;\n    }\n    if (n < 2 || n % 2 == 0) {\n      return false;\n    }\n    for (int i = 3, limit = (int) Math.sqrt(n); i <= limit; i += 2) {\n      if (n % i == 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private static long solution1(long n) {\n    long sum = 0;\n    for (int i = 2; i < n; ++i) {\n      if (isPrime(i)) {\n        sum += i;\n      }\n    }\n    return sum;\n  }\n}\n","index":197},{"title":"Problem12","category":"ProjectEuler","id":"Problem12_ProjectEuler","algorithm":"package ProjectEuler;\n/**\n * The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle\n * number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:\n *\n * <p>1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...\n *\n * <p>Let us list the factors of the first seven triangle numbers:\n *\n * <p>1: 1 3: 1,3 6: 1,2,3,6 10: 1,2,5,10 15: 1,3,5,15 21: 1,3,7,21 28: 1,2,4,7,14,28 We can see\n * that 28 is the first triangle number to have over five divisors.\n *\n * <p>What is the value of the first triangle number to have over five hundred divisors?\n *\n * <p>link: https://projecteuler.net/problem=12\n */\npublic class Problem12 {\n\n  /** Driver Code */\n  public static void main(String[] args) {\n    assert solution1(500) == 76576500;\n  }\n\n  /* returns the nth triangle number; that is, the sum of all the natural numbers less than, or equal to, n */\n  public static int triangleNumber(int n) {\n    int sum = 0;\n    for (int i = 0; i <= n; i++) sum += i;\n    return sum;\n  }\n\n  public static int solution1(int number) {\n    int j = 0; // j represents the jth triangle number\n    int n = 0; // n represents the triangle number corresponding to j\n    int numberOfDivisors = 0; // number of divisors for triangle number n\n\n    while (numberOfDivisors <= number) {\n\n      // resets numberOfDivisors because it's now checking a new triangle number\n      // and also sets n to be the next triangle number\n      numberOfDivisors = 0;\n      j++;\n      n = triangleNumber(j);\n\n      // for every number from 1 to the square root of this triangle number,\n      // count the number of divisors\n      for (int i = 1; i <= Math.sqrt(n); i++) if (n % i == 0) numberOfDivisors++;\n\n      // 1 to the square root of the number holds exactly half of the divisors\n      // so multiply it by 2 to include the other corresponding half\n      numberOfDivisors *= 2;\n    }\n    return n;\n  }\n}\n","index":198},{"title":"Searches","category":null,"id":"Searches","index":199},{"title":"Binary Search","category":"Searches","id":"BinarySearch_Searches","algorithm":"package Searches;\n\nimport static java.lang.String.format;\n\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.stream.IntStream;\n\n/**\n * Binary search is one of the most popular algorithms The algorithm finds the position of a target\n * value within a sorted array\n *\n * <p>Worst-case performance O(log n) Best-case performance O(1) Average performance O(log n)\n * Worst-case space complexity O(1)\n *\n * @author Varun Upadhyay (https://github.com/varunu28)\n * @author Podshivalov Nikita (https://github.com/nikitap492)\n * @see SearchAlgorithm\n * @see IterativeBinarySearch\n */\nclass BinarySearch implements SearchAlgorithm {\n\n  /**\n   * @param array is an array where the element should be found\n   * @param key is an element which should be found\n   * @param <T> is any comparable type\n   * @return index of the element\n   */\n  @Override\n  public <T extends Comparable<T>> int find(T[] array, T key) {\n    return search(array, key, 0, array.length);\n  }\n\n  /**\n   * This method implements the Generic Binary Search\n   *\n   * @param array The array to make the binary search\n   * @param key The number you are looking for\n   * @param left The lower bound\n   * @param right The upper bound\n   * @return the location of the key\n   */\n  private <T extends Comparable<T>> int search(T array[], T key, int left, int right) {\n    if (right < left) return -1; // this means that the key not found\n\n    // find median\n    int median = (left + right) >>> 1;\n    int comp = key.compareTo(array[median]);\n\n    if (comp == 0) {\n      return median;\n    } else if (comp < 0) {\n      return search(array, key, left, median - 1);\n    } else {\n      return search(array, key, median + 1, right);\n    }\n  }\n\n  // Driver Program\n  public static void main(String[] args) {\n    // Just generate data\n    Random r = ThreadLocalRandom.current();\n\n    int size = 100;\n    int maxElement = 100000;\n\n    Integer[] integers =\n        IntStream.generate(() -> r.nextInt(maxElement))\n            .limit(size)\n            .sorted()\n            .boxed()\n            .toArray(Integer[]::new);\n\n    // The element that should be found\n    int shouldBeFound = integers[r.nextInt(size - 1)];\n\n    BinarySearch search = new BinarySearch();\n    int atIndex = search.find(integers, shouldBeFound);\n\n    System.out.println(\n        format(\n            \"Should be found: %d. Found %d at index %d. An array length %d\",\n            shouldBeFound, integers[atIndex], atIndex, size));\n\n    int toCheck = Arrays.binarySearch(integers, shouldBeFound);\n    System.out.println(\n        format(\n            \"Found by system method at an index: %d. Is equal: %b\", toCheck, toCheck == atIndex));\n  }\n}\n","index":200},{"title":"Interpolation Search","category":"Searches","id":"InterpolationSearch_Searches","algorithm":"package Searches;\n\nimport static java.lang.String.format;\n\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.stream.IntStream;\n\n/**\n * Interpolation search algorithm implementation\n *\n * <p>Worst-case performance O(n) Best-case performance O(1) Average performance O(log(log(n))) if\n * the elements are uniformly distributed if not O(n) Worst-case space complexity O(1)\n *\n * @author Podshivalov Nikita (https://github.com/nikitap492)\n */\nclass InterpolationSearch {\n\n  /**\n   * @param array is a sorted array\n   * @param key is a value what shoulb be found in the array\n   * @return an index if the array contains the key unless -1\n   */\n  public int find(int array[], int key) {\n    // Find indexes of two corners\n    int start = 0, end = (array.length - 1);\n\n    // Since array is sorted, an element present\n    // in array must be in range defined by corner\n    while (start <= end && key >= array[start] && key <= array[end]) {\n      // Probing the position with keeping\n      // uniform distribution in mind.\n      int pos = start + (((end - start) / (array[end] - array[start])) * (key - array[start]));\n\n      // Condition of target found\n      if (array[pos] == key) return pos;\n\n      // If key is larger, key is in upper part\n      if (array[pos] < key) start = pos + 1;\n\n      // If key is smaller, x is in lower part\n      else end = pos - 1;\n    }\n    return -1;\n  }\n\n  // Driver method\n  public static void main(String[] args) {\n    Random r = new Random();\n    int size = 100;\n    int maxElement = 100000;\n    int[] integers = IntStream.generate(() -> r.nextInt(maxElement)).limit(size).sorted().toArray();\n\n    // the element that should be found\n    Integer shouldBeFound = integers[r.nextInt(size - 1)];\n\n    InterpolationSearch search = new InterpolationSearch();\n    int atIndex = search.find(integers, shouldBeFound);\n\n    System.out.println(\n        String.format(\n            \"Should be found: %d. Found %d at index %d. An array length %d\",\n            shouldBeFound, integers[atIndex], atIndex, size));\n\n    int toCheck = Arrays.binarySearch(integers, shouldBeFound);\n    System.out.println(\n        format(\n            \"Found by system method at an index: %d. Is equal: %b\", toCheck, toCheck == atIndex));\n  }\n}\n","index":201},{"title":"Iterative Binary Search","category":"Searches","id":"IterativeBinarySearch_Searches","algorithm":"package Searches;\n\nimport static java.lang.String.format;\n\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.stream.Stream;\n\n/**\n * Binary search is one of the most popular algorithms This class represents iterative version\n * {@link BinarySearch} Iterative binary search is likely to have lower constant factors because it\n * doesn't involve the overhead of manipulating the call stack. But in java the recursive version\n * can be optimized by the compiler to this version.\n *\n * <p>Worst-case performance O(log n) Best-case performance O(1) Average performance O(log n)\n * Worst-case space complexity O(1)\n *\n * @author Gabriele La Greca : https://github.com/thegabriele97\n * @author Podshivalov Nikita (https://github.com/nikitap492)\n * @see SearchAlgorithm\n * @see BinarySearch\n */\npublic final class IterativeBinarySearch implements SearchAlgorithm {\n\n  /**\n   * This method implements an iterative version of binary search algorithm\n   *\n   * @param array a sorted array\n   * @param key the key to search in array\n   * @return the index of key in the array or -1 if not found\n   */\n  @Override\n  public <T extends Comparable<T>> int find(T[] array, T key) {\n    int l, r, k, cmp;\n\n    l = 0;\n    r = array.length - 1;\n\n    while (l <= r) {\n      k = (l + r) >>> 1;\n      cmp = key.compareTo(array[k]);\n\n      if (cmp == 0) {\n        return k;\n      } else if (cmp < 0) {\n        r = --k;\n      } else {\n        l = ++k;\n      }\n    }\n\n    return -1;\n  }\n\n  // Only a main method for test purpose\n  public static void main(String[] args) {\n    Random r = new Random();\n    int size = 100;\n    int maxElement = 100000;\n    Integer[] integers =\n        Stream.generate(() -> r.nextInt(maxElement)).limit(size).sorted().toArray(Integer[]::new);\n\n    // the element that should be found\n    Integer shouldBeFound = integers[r.nextInt(size - 1)];\n\n    IterativeBinarySearch search = new IterativeBinarySearch();\n    int atIndex = search.find(integers, shouldBeFound);\n\n    System.out.println(\n        String.format(\n            \"Should be found: %d. Found %d at index %d. An array length %d\",\n            shouldBeFound, integers[atIndex], atIndex, size));\n\n    int toCheck = Arrays.binarySearch(integers, shouldBeFound);\n    System.out.println(\n        format(\n            \"Found by system method at an index: %d. Is equal: %b\", toCheck, toCheck == atIndex));\n  }\n}\n","index":202},{"title":"Iterative Ternary Search","category":"Searches","id":"IterativeTernarySearch_Searches","algorithm":"package Searches;\n\nimport static java.lang.String.format;\n\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.stream.Stream;\n\n/**\n * A iterative version of a ternary search algorithm This is better way to implement the ternary\n * search, because a recursive version adds some overhead to a stack. But in java the compile can\n * transform the recursive version to iterative implicitly, so there are no much differences between\n * these two algorithms\n *\n * <p>Worst-case performance Θ(log3(N)) Best-case performance O(1) Average performance Θ(log3(N))\n * Worst-case space complexity O(1)\n *\n * @author Podshivalov Nikita (https://github.com/nikitap492)\n * @see SearchAlgorithm\n * @see TernarySearch\n * @since 2018-04-13\n */\npublic class IterativeTernarySearch implements SearchAlgorithm {\n\n  @Override\n  public <T extends Comparable<T>> int find(T[] array, T key) {\n    int left = 0;\n    int right = array.length - 1;\n\n    while (right > left) {\n\n      int leftCmp = array[left].compareTo(key);\n      int rightCmp = array[right].compareTo(key);\n      if (leftCmp == 0) return left;\n      if (rightCmp == 0) return right;\n\n      int leftThird = left + (right - left) / 3 + 1;\n      int rightThird = right - (right - left) / 3 - 1;\n\n      if (array[leftThird].compareTo(key) <= 0) {\n        left = leftThird;\n      } else {\n        right = rightThird;\n      }\n    }\n\n    return -1;\n  }\n\n  public static void main(String[] args) {\n    // just generate data\n    Random r = new Random();\n    int size = 100;\n    int maxElement = 100000;\n    Integer[] integers =\n        Stream.generate(() -> r.nextInt(maxElement)).limit(size).sorted().toArray(Integer[]::new);\n\n    // the element that should be found\n    Integer shouldBeFound = integers[r.nextInt(size - 1)];\n\n    IterativeTernarySearch search = new IterativeTernarySearch();\n    int atIndex = search.find(integers, shouldBeFound);\n\n    System.out.println(\n        format(\n            \"Should be found: %d. Found %d at index %d. An array length %d\",\n            shouldBeFound, integers[atIndex], atIndex, size));\n\n    int toCheck = Arrays.binarySearch(integers, shouldBeFound);\n    System.out.println(\n        format(\n            \"Found by system method at an index: %d. Is equal: %b\", toCheck, toCheck == atIndex));\n  }\n}\n","index":203},{"title":"Jump Search","category":"Searches","id":"JumpSearch_Searches","algorithm":"package Searches;\n\npublic class JumpSearch implements SearchAlgorithm {\n\n  public static void main(String[] args) {\n    JumpSearch jumpSearch = new JumpSearch();\n    Integer[] array = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n    for (int i = 0; i < array.length; i++) {\n      assert jumpSearch.find(array, i) == i;\n    }\n    assert jumpSearch.find(array, -1) == -1;\n    assert jumpSearch.find(array, 11) == -1;\n  }\n\n  /**\n   * Jump Search algorithm implements\n   *\n   * @param array the array contains elements\n   * @param key to be searched\n   * @return index of {@code key} if found, otherwise <tt>-1</tt>\n   */\n  @Override\n  public <T extends Comparable<T>> int find(T[] array, T key) {\n    int length = array.length; /* length of array */\n    int blockSize = (int) Math.sqrt(length); /* block size to be jumped */\n\n    int limit = blockSize;\n    while (key.compareTo(array[limit]) > 0 && limit < array.length - 1) {\n      limit = Math.min(limit + blockSize, array.length - 1);\n    }\n\n    for (int i = limit - blockSize; i <= limit; i++) {\n      if (array[i] == key) {\n        /* execute linear search */\n        return i;\n      }\n    }\n    return -1; /* not found */\n  }\n}\n","index":204},{"title":"Linear Search","category":"Searches","id":"LinearSearch_Searches","algorithm":"package Searches;\n\nimport java.util.Random;\nimport java.util.stream.Stream;\n\n/**\n * Linear search is the easiest search algorithm It works with sorted and unsorted arrays (an binary\n * search works only with sorted array) This algorithm just compares all elements of an array to\n * find a value\n *\n * <p>Worst-case performance O(n) Best-case performance O(1) Average performance O(n) Worst-case\n * space complexity\n *\n * @author Varun Upadhyay (https://github.com/varunu28)\n * @author Podshivalov Nikita (https://github.com/nikitap492)\n * @see BinarySearch\n * @see SearchAlgorithm\n */\npublic class LinearSearch implements SearchAlgorithm {\n\n  /**\n   * Generic Linear search method\n   *\n   * @param array List to be searched\n   * @param value Key being searched for\n   * @return Location of the key\n   */\n  @Override\n  public <T extends Comparable<T>> int find(T[] array, T value) {\n    for (int i = 0; i < array.length; i++) {\n      if (array[i].compareTo(value) == 0) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  public static void main(String[] args) {\n    // just generate data\n    Random r = new Random();\n    int size = 200;\n    int maxElement = 100;\n    Integer[] integers =\n        Stream.generate(() -> r.nextInt(maxElement)).limit(size).toArray(Integer[]::new);\n\n    // the element that should be found\n    Integer shouldBeFound = integers[r.nextInt(size - 1)];\n\n    LinearSearch search = new LinearSearch();\n    int atIndex = search.find(integers, shouldBeFound);\n\n    System.out.println(\n        String.format(\n            \"Should be found: %d. Found %d at index %d. An array length %d\",\n            shouldBeFound, integers[atIndex], atIndex, size));\n  }\n}\n","index":205},{"title":"Perfect Binary Search","category":"Searches","id":"PerfectBinarySearch_Searches","algorithm":"package Searches;\n\nimport java.util.*;\n\nclass PerfectBinarySearch {\n\n  static int binarySearch(int[] arr, int target) {\n    int low = 0;\n    int high = arr.length - 1;\n\n    while (low <= high) {\n      int mid = (low + high) / 2;\n\n      if (arr[mid] == target) {\n        return mid;\n      } else if (arr[mid] > target) {\n        high = mid - 1;\n      } else {\n        low = mid + 1;\n      }\n    }\n    return -1;\n  }\n\n  public static void main(String[] args) {\n    PerfectBinarySearch BinarySearch = new PerfectBinarySearch();\n    int[] array = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n    assert BinarySearch.binarySearch(array, -1) == -1;\n    assert BinarySearch.binarySearch(array, 11) == -1;\n  }\n}\n","index":206},{"title":"Saddleback Search","category":"Searches","id":"SaddlebackSearch_Searches","algorithm":"package Searches;\n\nimport java.util.Scanner;\n\n/**\n * Program to perform Saddleback Search Given a sorted 2D array(elements are sorted across every row\n * and column, assuming ascending order) of size n*m we can search a given element in O(n+m)\n *\n * <p>we start from bottom left corner if the current element is greater than the given element then\n * we move up else we move right Sample Input: 5 5 ->Dimensions -10 -5 -3 4 9 -6 -2 0 5 10 -4 -1 1 6\n * 12 2 3 7 8 13 100 120 130 140 150 140 ->element to be searched output: 4 3 // first value is row,\n * second one is column\n *\n * @author Nishita Aggarwal\n */\npublic class SaddlebackSearch {\n\n  /**\n   * This method performs Saddleback Search\n   *\n   * @param arr The **Sorted** array in which we will search the element.\n   * @param row the current row.\n   * @param col the current column.\n   * @param key the element that we want to search for.\n   * @return The index(row and column) of the element if found. Else returns -1 -1.\n   */\n  private static int[] find(int arr[][], int row, int col, int key) {\n\n    // array to store the answer row and column\n    int ans[] = {-1, -1};\n    if (row < 0 || col >= arr[row].length) {\n      return ans;\n    }\n    if (arr[row][col] == key) {\n      ans[0] = row;\n      ans[1] = col;\n      return ans;\n    }\n    // if the current element is greater than the given element then we move up\n    else if (arr[row][col] > key) {\n      return find(arr, row - 1, col, key);\n    }\n    // else we move right\n    return find(arr, row, col + 1, key);\n  }\n\n  /**\n   * Main method\n   *\n   * @param args Command line arguments\n   */\n  public static void main(String[] args) {\n    // TODO Auto-generated method stub\n    Scanner sc = new Scanner(System.in);\n    int arr[][];\n    int i, j, rows = sc.nextInt(), col = sc.nextInt();\n    arr = new int[rows][col];\n    for (i = 0; i < rows; i++) {\n      for (j = 0; j < col; j++) {\n        arr[i][j] = sc.nextInt();\n      }\n    }\n    int ele = sc.nextInt();\n    // we start from bottom left corner\n    int ans[] = find(arr, rows - 1, 0, ele);\n    System.out.println(ans[0] + \" \" + ans[1]);\n    sc.close();\n  }\n}\n","index":207},{"title":"Search Algorithm","category":"Searches","id":"SearchAlgorithm_Searches","algorithm":"package Searches;\n\n/**\n * The common interface of most searching algorithms\n *\n * @author Podshivalov Nikita (https://github.com/nikitap492)\n */\npublic interface SearchAlgorithm {\n\n  /**\n   * @param key is an element which should be found\n   * @param array is an array where the element should be found\n   * @param <T> Comparable type\n   * @return first found index of the element\n   */\n  <T extends Comparable<T>> int find(T array[], T key);\n}\n","index":208},{"title":"Ternary Search","category":"Searches","id":"TernarySearch_Searches","algorithm":"package Searches;\n\nimport static java.lang.String.format;\n\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.stream.Stream;\n\n/**\n * A ternary search algorithm is a technique in computer science for finding the minimum or maximum\n * of a unimodal function The algorithm determines either that the minimum or maximum cannot be in\n * the first third of the domain or that it cannot be in the last third of the domain, then repeats\n * on the remaining third.\n *\n * <p>Worst-case performance Θ(log3(N)) Best-case performance O(1) Average performance Θ(log3(N))\n * Worst-case space complexity O(1)\n *\n * @author Podshivalov Nikita (https://github.com/nikitap492)\n * @see SearchAlgorithm\n * @see IterativeBinarySearch\n */\npublic class TernarySearch implements SearchAlgorithm {\n\n  /**\n   * @param arr The **Sorted** array in which we will search the element.\n   * @param value The value that we want to search for.\n   * @return The index of the element if found. Else returns -1.\n   */\n  @Override\n  public <T extends Comparable<T>> int find(T[] arr, T value) {\n    return ternarySearch(arr, value, 0, arr.length - 1);\n  }\n\n  /**\n   * @param arr The **Sorted** array in which we will search the element.\n   * @param key The value that we want to search for.\n   * @param start The starting index from which we will start Searching.\n   * @param end The ending index till which we will Search.\n   * @return Returns the index of the Element if found. Else returns -1.\n   */\n  private <T extends Comparable<T>> int ternarySearch(T[] arr, T key, int start, int end) {\n    if (start > end) {\n      return -1;\n    }\n    /* First boundary: add 1/3 of length to start */\n    int mid1 = start + (end - start) / 3;\n    /* Second boundary: add 2/3 of length to start */\n    int mid2 = start + 2 * (end - start) / 3;\n\n    if (key.compareTo(arr[mid1]) == 0) {\n      return mid1;\n    } else if (key.compareTo(arr[mid2]) == 0) {\n      return mid2;\n    }\n\n    /* Search the first (1/3) rd part of the array.*/\n\n    else if (key.compareTo(arr[mid1]) < 0) {\n      return ternarySearch(arr, key, start, --mid1);\n    }\n    /* Search 3rd (1/3)rd part of the array */\n\n    else if (key.compareTo(arr[mid2]) > 0) {\n      return ternarySearch(arr, key, ++mid2, end);\n    }\n    /* Search middle (1/3)rd part of the array */\n\n    else {\n      return ternarySearch(arr, key, mid1, mid2);\n    }\n  }\n\n  public static void main(String[] args) {\n    // just generate data\n    Random r = new Random();\n    int size = 100;\n    int maxElement = 100000;\n    Integer[] integers =\n        Stream.generate(() -> r.nextInt(maxElement)).limit(size).sorted().toArray(Integer[]::new);\n\n    // the element that should be found\n    Integer shouldBeFound = integers[r.nextInt(size - 1)];\n\n    TernarySearch search = new TernarySearch();\n    int atIndex = search.find(integers, shouldBeFound);\n\n    System.out.println(\n        format(\n            \"Should be found: %d. Found %d at index %d. An array length %d\",\n            shouldBeFound, integers[atIndex], atIndex, size));\n\n    int toCheck = Arrays.binarySearch(integers, shouldBeFound);\n    System.out.println(\n        format(\n            \"Found by system method at an index: %d. Is equal: %b\", toCheck, toCheck == atIndex));\n  }\n}\n","index":209},{"title":"Sorts","category":null,"id":"Sorts","index":210},{"title":"Bitonic Sort","category":"Sorts","id":"BitonicSort_Sorts","algorithm":"package Sorts;\n\n/* Java program for Bitonic Sort. Note that this program\nworks only when size of input is a power of 2. */\npublic class BitonicSort {\n  /* The parameter dir indicates the sorting direction,\n  ASCENDING or DESCENDING; if (a[i] > a[j]) agrees\n  with the direction, then a[i] and a[j] are\n  interchanged. */\n  void compAndSwap(int a[], int i, int j, int dir) {\n    if ((a[i] > a[j] && dir == 1) || (a[i] < a[j] && dir == 0)) {\n      // Swapping elements\n      int temp = a[i];\n      a[i] = a[j];\n      a[j] = temp;\n    }\n  }\n\n  /* It recursively sorts a bitonic sequence in ascending\n  order, if dir = 1, and in descending order otherwise\n  (means dir=0). The sequence to be sorted starts at\n  index position low, the parameter cnt is the number\n  of elements to be sorted.*/\n  void bitonicMerge(int a[], int low, int cnt, int dir) {\n    if (cnt > 1) {\n      int k = cnt / 2;\n      for (int i = low; i < low + k; i++) compAndSwap(a, i, i + k, dir);\n      bitonicMerge(a, low, k, dir);\n      bitonicMerge(a, low + k, k, dir);\n    }\n  }\n\n  /* This funcion first produces a bitonic sequence by\n  recursively sorting its two halves in opposite sorting\n  orders, and then calls bitonicMerge to make them in\n  the same order */\n  void bitonicSort(int a[], int low, int cnt, int dir) {\n    if (cnt > 1) {\n      int k = cnt / 2;\n\n      // sort in ascending order since dir here is 1\n      bitonicSort(a, low, k, 1);\n\n      // sort in descending order since dir here is 0\n      bitonicSort(a, low + k, k, 0);\n\n      // Will merge wole sequence in ascending order\n      // since dir=1.\n      bitonicMerge(a, low, cnt, dir);\n    }\n  }\n\n  /*Caller of bitonicSort for sorting the entire array\n  of length N in ASCENDING order */\n  void sort(int a[], int N, int up) {\n    bitonicSort(a, 0, N, up);\n  }\n\n  /* A utility function to print array of size n */\n  static void printArray(int arr[]) {\n    int n = arr.length;\n    for (int i = 0; i < n; ++i) System.out.print(arr[i] + \" \");\n    System.out.println();\n  }\n\n  public static void main(String args[]) {\n    int a[] = {3, 7, 4, 8, 6, 2, 1, 5};\n    int up = 1;\n    BitonicSort ob = new BitonicSort();\n    ob.sort(a, a.length, up);\n    System.out.println(\"\\nSorted array\");\n    printArray(a);\n  }\n}\n","index":211},{"title":"Bogo Sort","category":"Sorts","id":"BogoSort_Sorts","algorithm":"package Sorts;\n\nimport java.util.Random;\n\n/**\n * @author Podshivalov Nikita (https://github.com/nikitap492)\n * @see SortAlgorithm\n */\npublic class BogoSort implements SortAlgorithm {\n\n  private static final Random random = new Random();\n\n  private static <T extends Comparable<T>> boolean isSorted(T[] array) {\n    for (int i = 0; i < array.length - 1; i++) {\n      if (SortUtils.less(array[i + 1], array[i])) return false;\n    }\n    return true;\n  }\n\n  // Randomly shuffles the array\n  private static <T> void nextPermutation(T[] array) {\n    int length = array.length;\n\n    for (int i = 0; i < array.length; i++) {\n      int randomIndex = i + random.nextInt(length - i);\n      SortUtils.swap(array, randomIndex, i);\n    }\n  }\n\n  public <T extends Comparable<T>> T[] sort(T[] array) {\n    while (!isSorted(array)) {\n      nextPermutation(array);\n    }\n    return array;\n  }\n\n  // Driver Program\n  public static void main(String[] args) {\n    // Integer Input\n    Integer[] integers = {4, 23, 6, 78, 1, 54, 231, 9, 12};\n\n    BogoSort bogoSort = new BogoSort();\n\n    // print a sorted array\n    SortUtils.print(bogoSort.sort(integers));\n\n    // String Input\n    String[] strings = {\"c\", \"a\", \"e\", \"b\", \"d\"};\n\n    SortUtils.print(bogoSort.sort(strings));\n  }\n}\n","index":212},{"title":"Bubble Sort","category":"Sorts","id":"BubbleSort_Sorts","algorithm":"package Sorts;\n\nimport static Sorts.SortUtils.*;\n\n/**\n * @author Varun Upadhyay (https://github.com/varunu28)\n * @author Podshivalov Nikita (https://github.com/nikitap492)\n * @see SortAlgorithm\n */\nclass BubbleSort implements SortAlgorithm {\n\n  /**\n   * Implements generic bubble sort algorithm.\n   *\n   * @param array the array to be sorted.\n   * @param <T> the type of elements in the array.\n   * @return the sorted array.\n   */\n  @Override\n  public <T extends Comparable<T>> T[] sort(T[] array) {\n    for (int i = 0, size = array.length; i < size - 1; ++i) {\n      boolean swapped = false;\n      for (int j = 0; j < size - 1 - i; ++j) {\n        if (greater(array[j], array[j + 1])) {\n          swap(array, j, j + 1);\n          swapped = true;\n        }\n      }\n      if (!swapped) {\n        break;\n      }\n    }\n    return array;\n  }\n\n  /** Driver Code */\n  public static void main(String[] args) {\n\n    Integer[] integers = {4, 23, 6, 78, 1, 54, 231, 9, 12};\n    BubbleSort bubbleSort = new BubbleSort();\n    bubbleSort.sort(integers);\n\n    for (int i = 0; i < integers.length - 1; ++i) {\n      assert integers[i] <= integers[i + 1];\n    }\n    print(integers); /* output: [1, 4, 6, 9, 12, 23, 54, 78, 231] */\n\n    String[] strings = {\"c\", \"a\", \"e\", \"b\", \"d\"};\n    bubbleSort.sort(strings);\n    for (int i = 0; i < strings.length - 1; i++) {\n      assert strings[i].compareTo(strings[i + 1]) <= 0;\n    }\n    print(bubbleSort.sort(strings)); /* output: [a, b, c, d, e] */\n  }\n}\n","index":213},{"title":"Bubble Sort Recursion","category":"Sorts","id":"BubbleSortRecursion_Sorts","algorithm":"package Sorts;\n\nimport java.util.Random;\n\n/** BubbleSort algorithm implements using recursion */\npublic class BubbleSortRecursion implements SortAlgorithm {\n  public static void main(String[] args) {\n    Integer[] array = new Integer[10];\n\n    Random random = new Random();\n    /* generate 10 random numbers from -50 to 49 */\n    for (int i = 0; i < array.length; ++i) {\n      array[i] = random.nextInt(100) - 50;\n    }\n\n    BubbleSortRecursion bubbleSortRecursion = new BubbleSortRecursion();\n    bubbleSortRecursion.sort(array);\n\n    /* check array is sorted or not */\n    for (int i = 0; i < array.length - 1; ++i) {\n      assert (array[i].compareTo(array[i + 1]) <= 0);\n    }\n  }\n\n  /**\n   * @param unsorted - an array should be sorted\n   * @return sorted array\n   */\n  @Override\n  public <T extends Comparable<T>> T[] sort(T[] unsorted) {\n    bubbleSort(unsorted, unsorted.length);\n    return unsorted;\n  }\n\n  /**\n   * BubbleSort algorithm implements using recursion\n   *\n   * @param unsorted array contains elements\n   * @param len length of given array\n   */\n  private static <T extends Comparable<T>> void bubbleSort(T[] unsorted, int len) {\n    boolean swapped = false; /* flag to check if array is sorted or not */\n    for (int i = 0; i < len - 1; ++i) {\n      if (SortUtils.greater(unsorted[i], unsorted[i + 1])) {\n        SortUtils.swap(unsorted, i, i + 1);\n        swapped = true;\n      }\n    }\n    if (swapped) {\n      bubbleSort(unsorted, len - 1);\n    }\n  }\n}\n","index":214},{"title":"Bucket Sort","category":"Sorts","id":"BucketSort_Sorts","algorithm":"package Sorts;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Random;\n\n/** Wikipedia: https://en.wikipedia.org/wiki/Bucket_sort */\npublic class BucketSort {\n  public static void main(String[] args) {\n    int[] arr = new int[10];\n\n    /* generate 10 random numbers from -50 to 49 */\n    Random random = new Random();\n    for (int i = 0; i < arr.length; ++i) {\n      arr[i] = random.nextInt(100) - 50;\n    }\n\n    bucketSort(arr);\n\n    /* check array is sorted or not */\n    for (int i = 0, limit = arr.length - 1; i < limit; ++i) {\n      assert arr[i] <= arr[i + 1];\n    }\n  }\n\n  /**\n   * BucketSort algorithms implements\n   *\n   * @param arr the array contains elements\n   */\n  private static void bucketSort(int[] arr) {\n    /* get max value of arr */\n    int max = max(arr);\n\n    /* get min value of arr */\n    int min = min(arr);\n\n    /* number of buckets */\n    int numberOfBuckets = max - min + 1;\n\n    List<List<Integer>> buckets = new ArrayList<>(numberOfBuckets);\n\n    /* init buckets */\n    for (int i = 0; i < numberOfBuckets; ++i) {\n      buckets.add(new ArrayList<>());\n    }\n\n    /* store elements to buckets */\n    for (int value : arr) {\n      int hash = hash(value, min, numberOfBuckets);\n      buckets.get(hash).add(value);\n    }\n\n    /* sort individual bucket */\n    for (List<Integer> bucket : buckets) {\n      Collections.sort(bucket);\n    }\n\n    /* concatenate buckets to origin array */\n    int index = 0;\n    for (List<Integer> bucket : buckets) {\n      for (int value : bucket) {\n        arr[index++] = value;\n      }\n    }\n  }\n\n  /**\n   * Get index of bucket which of our elements gets placed into it.\n   *\n   * @param elem the element of array to be sorted\n   * @param min min value of array\n   * @param numberOfBucket the number of bucket\n   * @return index of bucket\n   */\n  private static int hash(int elem, int min, int numberOfBucket) {\n    return (elem - min) / numberOfBucket;\n  }\n\n  /**\n   * Calculate max value of array\n   *\n   * @param arr the array contains elements\n   * @return max value of given array\n   */\n  public static int max(int[] arr) {\n    int max = arr[0];\n    for (int value : arr) {\n      if (value > max) {\n        max = value;\n      }\n    }\n    return max;\n  }\n\n  /**\n   * Calculate min value of array\n   *\n   * @param arr the array contains elements\n   * @return min value of given array\n   */\n  public static int min(int[] arr) {\n    int min = arr[0];\n    for (int value : arr) {\n      if (value < min) {\n        min = value;\n      }\n    }\n    return min;\n  }\n}\n","index":215},{"title":"Cocktail Shaker Sort","category":"Sorts","id":"CocktailShakerSort_Sorts","algorithm":"package Sorts;\n\n/**\n * @author Mateus Bizzo (https://github.com/MattBizzo)\n * @author Podshivalov Nikita (https://github.com/nikitap492)\n */\nclass CocktailShakerSort implements SortAlgorithm {\n\n  /**\n   * This method implements the Generic Cocktail Shaker Sort\n   *\n   * @param array The array to be sorted Sorts the array in increasing order\n   */\n  @Override\n  public <T extends Comparable<T>> T[] sort(T[] array) {\n\n    int length = array.length;\n    int left = 0;\n    int right = length - 1;\n    int swappedLeft, swappedRight;\n    while (left < right) {\n      // front\n      swappedRight = 0;\n      for (int i = left; i < right; i++) {\n        if (SortUtils.less(array[i + 1], array[i])) {\n          SortUtils.swap(array, i, i + 1);\n          swappedRight = i;\n        }\n      }\n      // back\n      right = swappedRight;\n      swappedLeft = length - 1;\n      for (int j = right; j > left; j--) {\n        if (SortUtils.less(array[j], array[j - 1])) {\n          SortUtils.swap(array, j - 1, j);\n          swappedLeft = j;\n        }\n      }\n      left = swappedLeft;\n    }\n    return array;\n  }\n\n  // Driver Program\n  public static void main(String[] args) {\n    // Integer Input\n    Integer[] integers = {4, 23, 6, 78, 1, 54, 231, 9, 12};\n    CocktailShakerSort shakerSort = new CocktailShakerSort();\n\n    // Output => 1 4 6 9 12 23 54 78 231\n    SortUtils.print(shakerSort.sort(integers));\n\n    // String Input\n    String[] strings = {\"c\", \"a\", \"e\", \"b\", \"d\"};\n    SortUtils.print(shakerSort.sort(strings));\n  }\n}\n","index":216},{"title":"Comb Sort","category":"Sorts","id":"CombSort_Sorts","algorithm":"package Sorts;\n\nimport static Sorts.SortUtils.*;\n\n/**\n * Comb Sort algorithm implementation\n *\n * <p>Best-case performance O(n * log(n)) Worst-case performance O(n ^ 2) Worst-case space\n * complexity O(1)\n *\n * <p>Comb sort improves on bubble sort.\n *\n * @author Sandeep Roy (https://github.com/sandeeproy99)\n * @author Podshivalov Nikita (https://github.com/nikitap492)\n * @see BubbleSort\n * @see SortAlgorithm\n */\nclass CombSort implements SortAlgorithm {\n\n  // To find gap between elements\n  private int nextGap(int gap) {\n    // Shrink gap by Shrink factor\n    gap = (gap * 10) / 13;\n    return (gap < 1) ? 1 : gap;\n  }\n\n  /**\n   * Function to sort arr[] using Comb\n   *\n   * @param arr - an array should be sorted\n   * @return sorted array\n   */\n  @Override\n  public <T extends Comparable<T>> T[] sort(T[] arr) {\n    int size = arr.length;\n\n    // initialize gap\n    int gap = size;\n\n    // Initialize swapped as true to make sure that loop runs\n    boolean swapped = true;\n\n    // Keep running while gap is more than 1 and last iteration caused a swap\n    while (gap != 1 || swapped) {\n      // Find next gap\n      gap = nextGap(gap);\n\n      // Initialize swapped as false so that we can check if swap happened or not\n      swapped = false;\n\n      // Compare all elements with current gap\n      for (int i = 0; i < size - gap; i++) {\n        if (less(arr[i + gap], arr[i])) {\n          // Swap arr[i] and arr[i+gap]\n          swapped = swap(arr, i, i + gap);\n        }\n      }\n    }\n    return arr;\n  }\n\n  // Driver method\n  public static void main(String[] args) {\n    CombSort ob = new CombSort();\n    Integer[] arr = {8, 4, 1, 56, 3, -44, -1, 0, 36, 34, 8, 12, -66, -78, 23, -6, 28, 0};\n    ob.sort(arr);\n\n    System.out.println(\"sorted array\");\n    print(arr);\n  }\n}\n","index":217},{"title":"Counting Sort","category":"Sorts","id":"CountingSort_Sorts","algorithm":"package Sorts;\n\nimport static Sorts.SortUtils.print;\nimport static java.util.stream.Collectors.toList;\nimport static java.util.stream.Collectors.toMap;\n\nimport java.util.*;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\n\n/**\n * @author Youssef Ali (https://github.com/youssefAli11997)\n * @author Podshivalov Nikita (https://github.com/nikitap492)\n */\nclass CountingSort implements SortAlgorithm {\n\n  @Override\n  public <T extends Comparable<T>> T[] sort(T[] unsorted) {\n    return sort(Arrays.asList(unsorted)).toArray(unsorted);\n  }\n\n  /**\n   * This method implements the Generic Counting Sort\n   *\n   * @param list The list to be sorted\n   *     <p>Sorts the list in increasing order The method uses list elements as keys in the\n   *     frequency map\n   */\n  @Override\n  public <T extends Comparable<T>> List<T> sort(List<T> list) {\n\n    Map<T, Integer> frequency = new TreeMap<>();\n    // The final output array\n    List<T> sortedArray = new ArrayList<>(list.size());\n\n    // Counting the frequency of @param array elements\n    list.forEach(v -> frequency.put(v, frequency.getOrDefault(v, 0) + 1));\n\n    // Filling the sortedArray\n    for (Map.Entry<T, Integer> element : frequency.entrySet()) {\n      for (int j = 0; j < element.getValue(); j++) {\n        sortedArray.add(element.getKey());\n      }\n    }\n\n    return sortedArray;\n  }\n\n  /**\n   * Stream Counting Sort The same as method {@link CountingSort#sort(List)} } but this method uses\n   * stream API\n   *\n   * @param list The list to be sorted\n   */\n  private static <T extends Comparable<T>> List<T> streamSort(List<T> list) {\n    return list.stream()\n        .collect(toMap(k -> k, v -> 1, (v1, v2) -> v1 + v2, TreeMap::new))\n        .entrySet()\n        .stream()\n        .flatMap(entry -> IntStream.rangeClosed(1, entry.getValue()).mapToObj(t -> entry.getKey()))\n        .collect(toList());\n  }\n\n  // Driver Program\n  public static void main(String[] args) {\n    // Integer Input\n    List<Integer> unsortedInts =\n        Stream.of(4, 23, 6, 78, 1, 54, 23, 1, 9, 231, 9, 12).collect(toList());\n    CountingSort countingSort = new CountingSort();\n\n    System.out.println(\"Before Sorting:\");\n    print(unsortedInts);\n\n    // Output => 1 1 4 6 9 9 12 23 23 54 78 231\n    System.out.println(\"After Sorting:\");\n    print(countingSort.sort(unsortedInts));\n    System.out.println(\"After Sorting By Streams:\");\n    print(streamSort(unsortedInts));\n\n    System.out.println(\"\\n------------------------------\\n\");\n\n    // String Input\n    List<String> unsortedStrings =\n        Stream.of(\"c\", \"a\", \"e\", \"b\", \"d\", \"a\", \"f\", \"g\", \"c\").collect(toList());\n\n    System.out.println(\"Before Sorting:\");\n    print(unsortedStrings);\n\n    // Output => a a b c c d e f g\n    System.out.println(\"After Sorting:\");\n    print(countingSort.sort(unsortedStrings));\n\n    System.out.println(\"After Sorting By Streams:\");\n    print(streamSort(unsortedStrings));\n  }\n}\n","index":218},{"title":"Cycle Sort","category":"Sorts","id":"CycleSort_Sorts","algorithm":"package Sorts;\n\nimport static Sorts.SortUtils.less;\nimport static Sorts.SortUtils.print;\n\n/** @author Podshivalov Nikita (https://github.com/nikitap492) */\nclass CycleSort implements SortAlgorithm {\n\n  @Override\n  public <T extends Comparable<T>> T[] sort(T[] arr) {\n    int n = arr.length;\n\n    // traverse array elements\n    for (int j = 0; j <= n - 2; j++) {\n      // initialize item as starting point\n      T item = arr[j];\n\n      // Find position where we put the item.\n      int pos = j;\n      for (int i = j + 1; i < n; i++) if (less(arr[i], item)) pos++;\n\n      // If item is already in correct position\n      if (pos == j) continue;\n\n      // ignore all duplicate elements\n      while (item.compareTo(arr[pos]) == 0) pos += 1;\n\n      // put the item to it's right position\n      if (pos != j) {\n        item = replace(arr, pos, item);\n      }\n\n      // Rotate rest of the cycle\n      while (pos != j) {\n        pos = j;\n\n        // Find position where we put the element\n        for (int i = j + 1; i < n; i++)\n          if (less(arr[i], item)) {\n            pos += 1;\n          }\n\n        // ignore all duplicate elements\n        while (item.compareTo(arr[pos]) == 0) pos += 1;\n\n        // put the item to it's right position\n        if (item != arr[pos]) {\n          item = replace(arr, pos, item);\n        }\n      }\n    }\n\n    return arr;\n  }\n\n  private <T extends Comparable<T>> T replace(T[] arr, int pos, T item) {\n    T temp = item;\n    item = arr[pos];\n    arr[pos] = temp;\n    return item;\n  }\n\n  public static void main(String[] args) {\n    Integer arr[] = {4, 23, 6, 78, 1, 26, 11, 23, 0, -6, 3, 54, 231, 9, 12};\n    CycleSort cycleSort = new CycleSort();\n    cycleSort.sort(arr);\n\n    System.out.println(\"After sort : \");\n    print(arr);\n  }\n}\n","index":219},{"title":"Gnome Sort","category":"Sorts","id":"GnomeSort_Sorts","algorithm":"package Sorts;\n\nimport static Sorts.SortUtils.*;\n\n/**\n * Implementation of gnome sort\n *\n * @author Podshivalov Nikita (https://github.com/nikitap492)\n * @since 2018-04-10\n */\npublic class GnomeSort implements SortAlgorithm {\n\n  @Override\n  public <T extends Comparable<T>> T[] sort(T[] arr) {\n    int i = 1;\n    int j = 2;\n    while (i < arr.length) {\n      if (less(arr[i - 1], arr[i])) i = j++;\n      else {\n        swap(arr, i - 1, i);\n        if (--i == 0) {\n          i = j++;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  public static void main(String[] args) {\n    Integer[] integers = {4, 23, 6, 78, 1, 26, 11, 23, 0, -6, 3, 54, 231, 9, 12};\n    String[] strings = {\"c\", \"a\", \"e\", \"b\", \"d\", \"dd\", \"da\", \"zz\", \"AA\", \"aa\", \"aB\", \"Hb\", \"Z\"};\n    GnomeSort gnomeSort = new GnomeSort();\n\n    gnomeSort.sort(integers);\n    gnomeSort.sort(strings);\n\n    System.out.println(\"After sort : \");\n    print(integers);\n    print(strings);\n  }\n}\n","index":220},{"title":"Heap Sort","category":"Sorts","id":"HeapSort_Sorts","algorithm":"package Sorts;\n\nimport static Sorts.SortUtils.*;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * Heap Sort Algorithm Implements MinHeap\n *\n * @author Podshivalov Nikita (https://github.com/nikitap492)\n */\npublic class HeapSort implements SortAlgorithm {\n\n  private static class Heap<T extends Comparable<T>> {\n    /** Array to store heap */\n    private T[] heap;\n\n    /**\n     * Constructor\n     *\n     * @param heap array of unordered integers\n     */\n    public Heap(T[] heap) {\n      this.heap = heap;\n    }\n\n    /**\n     * Heapifies subtree from top as root to last as last child\n     *\n     * @param rootIndex index of root\n     * @param lastChild index of last child\n     */\n    private void heapSubtree(int rootIndex, int lastChild) {\n      int leftIndex = rootIndex * 2 + 1;\n      int rightIndex = rootIndex * 2 + 2;\n      T root = heap[rootIndex];\n      if (rightIndex <= lastChild) { // if has right and left children\n        T left = heap[leftIndex];\n        T right = heap[rightIndex];\n        if (less(left, right) && less(left, root)) {\n          swap(heap, leftIndex, rootIndex);\n          heapSubtree(leftIndex, lastChild);\n        } else if (less(right, root)) {\n          swap(heap, rightIndex, rootIndex);\n          heapSubtree(rightIndex, lastChild);\n        }\n      } else if (leftIndex <= lastChild) { // if no right child, but has left child\n        T left = heap[leftIndex];\n        if (less(left, root)) {\n          swap(heap, leftIndex, rootIndex);\n          heapSubtree(leftIndex, lastChild);\n        }\n      }\n    }\n\n    /**\n     * Makes heap with root as root\n     *\n     * @param root index of root of heap\n     */\n    private void makeMinHeap(int root) {\n      int leftIndex = root * 2 + 1;\n      int rightIndex = root * 2 + 2;\n      boolean hasLeftChild = leftIndex < heap.length;\n      boolean hasRightChild = rightIndex < heap.length;\n      if (hasRightChild) { // if has left and right\n        makeMinHeap(leftIndex);\n        makeMinHeap(rightIndex);\n        heapSubtree(root, heap.length - 1);\n      } else if (hasLeftChild) {\n        heapSubtree(root, heap.length - 1);\n      }\n    }\n\n    /**\n     * Gets the root of heap\n     *\n     * @return root of heap\n     */\n    private T getRoot(int size) {\n      swap(heap, 0, size);\n      heapSubtree(0, size - 1);\n      return heap[size]; // return old root\n    }\n  }\n\n  @Override\n  public <T extends Comparable<T>> T[] sort(T[] unsorted) {\n    return sort(Arrays.asList(unsorted)).toArray(unsorted);\n  }\n\n  @Override\n  public <T extends Comparable<T>> List<T> sort(List<T> unsorted) {\n    int size = unsorted.size();\n\n    @SuppressWarnings(\"unchecked\")\n    Heap<T> heap = new Heap<>(unsorted.toArray((T[]) new Comparable[unsorted.size()]));\n\n    heap.makeMinHeap(0); // make min heap using index 0 as root.\n    List<T> sorted = new ArrayList<>(size);\n    while (size > 0) {\n      T min = heap.getRoot(--size);\n      sorted.add(min);\n    }\n\n    return sorted;\n  }\n\n  /**\n   * Main method\n   *\n   * @param args the command line arguments\n   */\n  public static void main(String[] args) {\n    Integer[] heap = {4, 23, 6, 78, 1, 54, 231, 9, 12};\n    HeapSort heapSort = new HeapSort();\n    print(heapSort.sort(heap));\n  }\n}\n","index":221},{"title":"Insertion Sort","category":"Sorts","id":"InsertionSort_Sorts","algorithm":"package Sorts;\n\nimport static Sorts.SortUtils.less;\nimport static Sorts.SortUtils.print;\n\n/**\n * @author Varun Upadhyay (https://github.com/varunu28)\n * @author Podshivalov Nikita (https://github.com/nikitap492)\n */\nclass InsertionSort implements SortAlgorithm {\n\n  /**\n   * This method implements the Generic Insertion Sort Sorts the array in increasing order\n   *\n   * @param array The array to be sorted\n   */\n  @Override\n  public <T extends Comparable<T>> T[] sort(T[] array) {\n    for (int j = 1; j < array.length; j++) {\n\n      // Picking up the key(Card)\n      T key = array[j];\n      int i = j - 1;\n\n      while (i >= 0 && less(key, array[i])) {\n        array[i + 1] = array[i];\n        i--;\n      }\n      // Placing the key (Card) at its correct position in the sorted subarray\n      array[i + 1] = key;\n    }\n    return array;\n  }\n\n  // Driver Program\n  public static void main(String[] args) {\n    // Integer Input\n    Integer[] integers = {4, 23, 6, 78, 1, 54, 231, 9, 12};\n\n    InsertionSort sort = new InsertionSort();\n\n    sort.sort(integers);\n\n    // Output => 1 4 6 9 12 23 54 78 231\n    print(integers);\n\n    // String Input\n    String[] strings = {\"c\", \"a\", \"e\", \"b\", \"d\"};\n\n    sort.sort(strings);\n\n    // Output => a\tb\tc\td\te\n    print(strings);\n  }\n}\n","index":222},{"title":"Merge Sort","category":"Sorts","id":"MergeSort_Sorts","algorithm":"package Sorts;\n\nimport static Sorts.SortUtils.print;\n\n/**\n * This method implements the Generic Merge Sort\n *\n * @author Varun Upadhyay (https://github.com/varunu28)\n * @author Podshivalov Nikita (https://github.com/nikitap492)\n * @see SortAlgorithm\n */\nclass MergeSort implements SortAlgorithm {\n\n  /**\n   * This method implements the Generic Merge Sort\n   *\n   * @param unsorted the array which should be sorted\n   * @param <T> Comparable class\n   * @return sorted array\n   */\n  @Override\n  public <T extends Comparable<T>> T[] sort(T[] unsorted) {\n    doSort(unsorted, 0, unsorted.length - 1);\n    return unsorted;\n  }\n\n  /**\n   * @param arr The array to be sorted\n   * @param left The first index of the array\n   * @param right The last index of the array Recursively sorts the array in increasing order\n   */\n  private static <T extends Comparable<T>> void doSort(T[] arr, int left, int right) {\n    if (left < right) {\n      int mid = left + (right - left) / 2;\n      doSort(arr, left, mid);\n      doSort(arr, mid + 1, right);\n      merge(arr, left, mid, right);\n    }\n  }\n\n  /**\n   * This method implements the merge step of the merge sort\n   *\n   * @param arr The array to be sorted\n   * @param left The first index of the array\n   * @param mid The middle index of the array\n   * @param right The last index of the array merges two parts of an array in increasing order\n   */\n  private static <T extends Comparable<T>> void merge(T[] arr, int left, int mid, int right) {\n    int length = right - left + 1;\n    T[] temp = (T[]) new Comparable[length];\n    int i = left;\n    int j = mid + 1;\n    int k = 0;\n\n    while (i <= mid && j <= right) {\n      if (arr[i].compareTo(arr[j]) <= 0) {\n        temp[k++] = arr[i++];\n      } else {\n        temp[k++] = arr[j++];\n      }\n    }\n\n    while (i <= mid) {\n      temp[k++] = arr[i++];\n    }\n\n    while (j <= right) {\n      temp[k++] = arr[j++];\n    }\n\n    System.arraycopy(temp, 0, arr, left, length);\n  }\n\n  // Driver program\n  public static void main(String[] args) {\n\n    // Integer Input\n    Integer[] arr = {4, 23, 6, 78, 1, 54, 231, 9, 12};\n    MergeSort mergeSort = new MergeSort();\n    mergeSort.sort(arr);\n\n    // Output => 1\t   4  \t 6\t9\t12\t23\t54\t78\t231\n    print(arr);\n\n    // String Inpu\n    String[] stringArray = {\"c\", \"a\", \"e\", \"b\", \"d\"};\n    mergeSort.sort(stringArray);\n    // Output => a\tb\tc\td\te\n    print(stringArray);\n  }\n}\n","index":223},{"title":"Pancake Sort","category":"Sorts","id":"PancakeSort_Sorts","algorithm":"package Sorts;\n\nimport static Sorts.SortUtils.*;\n\n/**\n * Implementation of gnome sort\n *\n * @author Podshivalov Nikita (https://github.com/nikitap492)\n * @since 2018-04-10\n */\npublic class PancakeSort implements SortAlgorithm {\n\n  @Override\n  public <T extends Comparable<T>> T[] sort(T[] array) {\n    int size = array.length;\n\n    for (int i = 0; i < size; i++) {\n      T max = array[0];\n      int index = 0;\n      for (int j = 0; j < size - i; j++) {\n        if (less(max, array[j])) {\n          max = array[j];\n          index = j;\n        }\n      }\n      flip(array, index, array.length - 1 - i);\n    }\n    return array;\n  }\n\n  public static void main(String[] args) {\n\n    Integer[] arr = {\n      10, 9, 8, 7, 6, 15, 14, 7, 4, 3, 8, 6, 3, 1, 2, -2, -5, -8, -3, -1, 13, 12, 11, 5, 4, 3, 2, 1\n    };\n    PancakeSort pancakeSort = new PancakeSort();\n    System.out.println(\"After sorting:\");\n    pancakeSort.sort(arr);\n    print(arr);\n  }\n}\n","index":224},{"title":"Quick Sort","category":"Sorts","id":"QuickSort_Sorts","algorithm":"package Sorts;\n\nimport static Sorts.SortUtils.*;\n\n/**\n * @author Varun Upadhyay (https://github.com/varunu28)\n * @author Podshivalov Nikita (https://github.com/nikitap492)\n * @see SortAlgorithm\n */\nclass QuickSort implements SortAlgorithm {\n\n  /**\n   * This method implements the Generic Quick Sort\n   *\n   * @param array The array to be sorted Sorts the array in increasing order\n   */\n  @Override\n  public <T extends Comparable<T>> T[] sort(T[] array) {\n    doSort(array, 0, array.length - 1);\n    return array;\n  }\n\n  /**\n   * The sorting process\n   *\n   * @param left The first index of an array\n   * @param right The last index of an array\n   * @param array The array to be sorted\n   */\n  private static <T extends Comparable<T>> void doSort(T[] array, int left, int right) {\n    if (left < right) {\n      int pivot = randomPartition(array, left, right);\n      doSort(array, left, pivot - 1);\n      doSort(array, pivot, right);\n    }\n  }\n\n  /**\n   * Ramdomize the array to avoid the basically ordered sequences\n   *\n   * @param array The array to be sorted\n   * @param left The first index of an array\n   * @param right The last index of an array\n   * @return the partition index of the array\n   */\n  private static <T extends Comparable<T>> int randomPartition(T[] array, int left, int right) {\n    int randomIndex = left + (int) (Math.random() * (right - left + 1));\n    swap(array, randomIndex, right);\n    return partition(array, left, right);\n  }\n\n  /**\n   * This method finds the partition index for an array\n   *\n   * @param array The array to be sorted\n   * @param left The first index of an array\n   * @param right The last index of an array Finds the partition index of an array\n   */\n  private static <T extends Comparable<T>> int partition(T[] array, int left, int right) {\n    int mid = (left + right) >>> 1;\n    T pivot = array[mid];\n\n    while (left <= right) {\n      while (less(array[left], pivot)) {\n        ++left;\n      }\n      while (less(pivot, array[right])) {\n        --right;\n      }\n      if (left <= right) {\n        swap(array, left, right);\n        ++left;\n        --right;\n      }\n    }\n    return left;\n  }\n\n  // Driver Program\n  public static void main(String[] args) {\n\n    // For integer input\n    Integer[] array = {3, 4, 1, 32, 0, 1, 5, 12, 2, 5, 7, 8, 9, 2, 44, 111, 5};\n\n    QuickSort quickSort = new QuickSort();\n    quickSort.sort(array);\n\n    // Output => 0 1 1 2 2 3 4 5 5 5 7 8 9 12 32 44 111\n    print(array);\n\n    String[] stringArray = {\"c\", \"a\", \"e\", \"b\", \"d\"};\n    quickSort.sort(stringArray);\n\n    // Output => a\tb\tc\td\te\n    print(stringArray);\n  }\n}\n","index":225},{"title":"Radix Sort","category":"Sorts","id":"RadixSort_Sorts","algorithm":"package Sorts;\n\nimport java.util.Arrays;\n\nclass RadixSort {\n\n  private static int getMax(int[] arr, int n) {\n    int mx = arr[0];\n    for (int i = 1; i < n; i++) if (arr[i] > mx) mx = arr[i];\n    return mx;\n  }\n\n  private static void countSort(int[] arr, int n, int exp) {\n    int[] output = new int[n];\n    int i;\n    int[] count = new int[10];\n    Arrays.fill(count, 0);\n\n    for (i = 0; i < n; i++) count[(arr[i] / exp) % 10]++;\n\n    for (i = 1; i < 10; i++) count[i] += count[i - 1];\n\n    for (i = n - 1; i >= 0; i--) {\n      output[count[(arr[i] / exp) % 10] - 1] = arr[i];\n      count[(arr[i] / exp) % 10]--;\n    }\n\n    for (i = 0; i < n; i++) arr[i] = output[i];\n  }\n\n  private static void radixsort(int[] arr, int n) {\n\n    int m = getMax(arr, n);\n\n    for (int exp = 1; m / exp > 0; exp *= 10) countSort(arr, n, exp);\n  }\n\n  static void print(int[] arr, int n) {\n    for (int i = 0; i < n; i++) System.out.print(arr[i] + \" \");\n  }\n\n  public static void main(String[] args) {\n    int[] arr = {170, 45, 75, 90, 802, 24, 2, 66};\n    int n = arr.length;\n    radixsort(arr, n);\n    print(arr, n);\n  }\n}\n// Written by James Mc Dermott(theycallmemac)\n","index":226},{"title":"Selection Sort","category":"Sorts","id":"SelectionSort_Sorts","algorithm":"package Sorts;\n\n/**\n * @author Varun Upadhyay (https://github.com/varunu28)\n * @author Podshivalov Nikita (https://github.com/nikitap492)\n * @see SortAlgorithm\n */\npublic class SelectionSort implements SortAlgorithm {\n\n  /**\n   * This method swaps the two elements in the array\n   *\n   * @param <T>\n   * @param arr, i, j The array for the swap and the indexes of the to-swap elements\n   */\n  public <T> void swap(T[] arr, int i, int j) {\n    T temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n\n  /**\n   * This method implements the Generic Selection Sort\n   *\n   * @param arr The array to be sorted Sorts the array in increasing order\n   */\n  @Override\n  public <T extends Comparable<T>> T[] sort(T[] arr) {\n    int n = arr.length;\n    for (int i = 0; i < n - 1; i++) {\n      // Initial index of min\n      int min = i;\n\n      for (int j = i + 1; j < n; j++) {\n        if (arr[min].compareTo(arr[j]) < 0) {\n          min = j;\n        }\n      }\n\n      // Swapping if index of min is changed\n      if (min != i) {\n        swap(arr, i, min);\n      }\n    }\n\n    return arr;\n  }\n\n  // Driver Program\n  public static void main(String[] args) {\n\n    Integer[] arr = {4, 23, 6, 78, 1, 54, 231, 9, 12};\n\n    SelectionSort selectionSort = new SelectionSort();\n\n    Integer[] sorted = selectionSort.sort(arr);\n\n    // Output => 1\t  4\t 6\t9\t12\t23\t54\t78\t231\n    SortUtils.print(sorted);\n\n    // String Input\n    String[] strings = {\"c\", \"a\", \"e\", \"b\", \"d\"};\n    String[] sortedStrings = selectionSort.sort(strings);\n\n    // Output => a\tb\t c  d\te\n    SortUtils.print(sortedStrings);\n  }\n}\n","index":227},{"title":"Shell Sort","category":"Sorts","id":"ShellSort_Sorts","algorithm":"package Sorts;\n\nimport static Sorts.SortUtils.*;\n\npublic class ShellSort implements SortAlgorithm {\n\n  /**\n   * Implements generic shell sort.\n   *\n   * @param array the array to be sorted.\n   * @param <T> the type of elements in the array.\n   * @return the sorted array.\n   */\n  @Override\n  public <T extends Comparable<T>> T[] sort(T[] array) {\n    int length = array.length;\n    int gap = 1;\n\n    /* Calculate gap for optimization purpose */\n    while (gap < length / 3) {\n      gap = 3 * gap + 1;\n    }\n\n    for (; gap > 0; gap /= 3) {\n      for (int i = gap; i < length; i++) {\n        int j;\n        T temp = array[i];\n        for (j = i; j >= gap && less(temp, array[j - gap]); j -= gap) {\n          array[j] = array[j - gap];\n        }\n        array[j] = temp;\n      }\n    }\n    return array;\n  }\n\n  /* Driver Code */\n  public static void main(String[] args) {\n    Integer[] toSort = {4, 23, 6, 78, 1, 54, 231, 9, 12};\n\n    ShellSort sort = new ShellSort();\n    sort.sort(toSort);\n    for (int i = 0; i < toSort.length - 1; ++i) {\n      assert toSort[i] <= toSort[i + 1];\n    }\n    print(toSort);\n  }\n}\n","index":228},{"title":"Sort Algorithm","category":"Sorts","id":"SortAlgorithm_Sorts","algorithm":"package Sorts;\n\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * The common interface of most sorting algorithms\n *\n * @author Podshivalov Nikita (https://github.com/nikitap492)\n */\npublic interface SortAlgorithm {\n\n  /**\n   * Main method arrays sorting algorithms\n   *\n   * @param unsorted - an array should be sorted\n   * @return a sorted array\n   */\n  <T extends Comparable<T>> T[] sort(T[] unsorted);\n\n  /**\n   * Auxiliary method for algorithms what wanted to work with lists from JCF\n   *\n   * @param unsorted - a list should be sorted\n   * @return a sorted list\n   */\n  @SuppressWarnings(\"unchecked\")\n  default <T extends Comparable<T>> List<T> sort(List<T> unsorted) {\n    return Arrays.asList(sort(unsorted.toArray((T[]) new Comparable[unsorted.size()])));\n  }\n}\n","index":229},{"title":"Sort Utils","category":"Sorts","id":"SortUtils_Sorts","algorithm":"package Sorts;\n\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * The class contains util methods\n *\n * @author Podshivalov Nikita (https://github.com/nikitap492)\n */\nfinal class SortUtils {\n\n  /**\n   * Helper method for swapping places in array\n   *\n   * @param array The array which elements we want to swap\n   * @param idx index of the first element\n   * @param idy index of the second element\n   */\n  static <T> boolean swap(T[] array, int idx, int idy) {\n    T swap = array[idx];\n    array[idx] = array[idy];\n    array[idy] = swap;\n    return true;\n  }\n\n  /**\n   * This method checks if first element is less than the other element\n   *\n   * @param v first element\n   * @param w second element\n   * @return true if the first element is less than the second element\n   */\n  static <T extends Comparable<T>> boolean less(T v, T w) {\n    return v.compareTo(w) < 0;\n  }\n\n  /**\n   * This method checks if first element is greater than the other element\n   *\n   * @param v first element\n   * @param w second element\n   * @return true if the first element is greater than the second element\n   */\n  static <T extends Comparable<T>> boolean greater(T v, T w) {\n    return v.compareTo(w) > 0;\n  }\n\n  /**\n   * Prints a list\n   *\n   * @param toPrint - a list which should be printed\n   */\n  static void print(List<?> toPrint) {\n    toPrint.stream().map(Object::toString).map(str -> str + \" \").forEach(System.out::print);\n\n    System.out.println();\n  }\n\n  /**\n   * Prints an array\n   *\n   * @param toPrint - an array which should be printed\n   */\n  static void print(Object[] toPrint) {\n    System.out.println(Arrays.toString(toPrint));\n  }\n\n  /**\n   * Swaps all position from {@param left} to @{@param right} for {@param array}\n   *\n   * @param array is an array\n   * @param left is a left flip border of the array\n   * @param right is a right flip border of the array\n   */\n  static <T extends Comparable<T>> void flip(T[] array, int left, int right) {\n    while (left <= right) {\n      swap(array, left++, right--);\n    }\n  }\n}\n","index":230},{"title":"Ciphers","category":null,"id":"ciphers","index":231},{"title":"A E S","category":"ciphers","id":"AES_ciphers","algorithm":"package ciphers;\n\nimport java.math.BigInteger;\nimport java.util.Scanner;\n\n/**\n * This class is build to demonstrate the application of the AES-algorithm on a single 128-Bit block\n * of data.\n */\npublic class AES {\n\n  /**\n   * Precalculated values for x to the power of 2 in Rijndaels galois field. Used as 'RCON' during\n   * the key expansion.\n   */\n  private static final int[] RCON = {\n    0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a,\n    0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39,\n    0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a,\n    0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8,\n    0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef,\n    0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc,\n    0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b,\n    0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3,\n    0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94,\n    0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20,\n    0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35,\n    0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f,\n    0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04,\n    0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63,\n    0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd,\n    0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d\n  };\n\n  /**\n   * Rijndael S-box Substitution table used for encryption in the subBytes step, as well as the key\n   * expansion.\n   */\n  private static final int[] SBOX = {\n    0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,\n    0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,\n    0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,\n    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,\n    0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,\n    0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,\n    0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,\n    0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,\n    0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,\n    0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,\n    0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,\n    0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,\n    0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,\n    0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,\n    0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,\n    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16\n  };\n\n  /** Inverse Rijndael S-box Substitution table used for decryption in the subBytesDec step. */\n  private static final int[] INVERSE_SBOX = {\n    0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,\n    0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,\n    0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,\n    0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,\n    0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,\n    0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,\n    0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,\n    0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,\n    0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,\n    0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,\n    0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,\n    0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,\n    0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,\n    0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,\n    0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,\n    0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D\n  };\n\n  /**\n   * Precalculated lookup table for galois field multiplication by 2 used in the MixColums step\n   * during encryption.\n   */\n  private static final int[] MULT2 = {\n    0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e, 0x10, 0x12, 0x14, 0x16, 0x18, 0x1a, 0x1c, 0x1e,\n    0x20, 0x22, 0x24, 0x26, 0x28, 0x2a, 0x2c, 0x2e, 0x30, 0x32, 0x34, 0x36, 0x38, 0x3a, 0x3c, 0x3e,\n    0x40, 0x42, 0x44, 0x46, 0x48, 0x4a, 0x4c, 0x4e, 0x50, 0x52, 0x54, 0x56, 0x58, 0x5a, 0x5c, 0x5e,\n    0x60, 0x62, 0x64, 0x66, 0x68, 0x6a, 0x6c, 0x6e, 0x70, 0x72, 0x74, 0x76, 0x78, 0x7a, 0x7c, 0x7e,\n    0x80, 0x82, 0x84, 0x86, 0x88, 0x8a, 0x8c, 0x8e, 0x90, 0x92, 0x94, 0x96, 0x98, 0x9a, 0x9c, 0x9e,\n    0xa0, 0xa2, 0xa4, 0xa6, 0xa8, 0xaa, 0xac, 0xae, 0xb0, 0xb2, 0xb4, 0xb6, 0xb8, 0xba, 0xbc, 0xbe,\n    0xc0, 0xc2, 0xc4, 0xc6, 0xc8, 0xca, 0xcc, 0xce, 0xd0, 0xd2, 0xd4, 0xd6, 0xd8, 0xda, 0xdc, 0xde,\n    0xe0, 0xe2, 0xe4, 0xe6, 0xe8, 0xea, 0xec, 0xee, 0xf0, 0xf2, 0xf4, 0xf6, 0xf8, 0xfa, 0xfc, 0xfe,\n    0x1b, 0x19, 0x1f, 0x1d, 0x13, 0x11, 0x17, 0x15, 0x0b, 0x09, 0x0f, 0x0d, 0x03, 0x01, 0x07, 0x05,\n    0x3b, 0x39, 0x3f, 0x3d, 0x33, 0x31, 0x37, 0x35, 0x2b, 0x29, 0x2f, 0x2d, 0x23, 0x21, 0x27, 0x25,\n    0x5b, 0x59, 0x5f, 0x5d, 0x53, 0x51, 0x57, 0x55, 0x4b, 0x49, 0x4f, 0x4d, 0x43, 0x41, 0x47, 0x45,\n    0x7b, 0x79, 0x7f, 0x7d, 0x73, 0x71, 0x77, 0x75, 0x6b, 0x69, 0x6f, 0x6d, 0x63, 0x61, 0x67, 0x65,\n    0x9b, 0x99, 0x9f, 0x9d, 0x93, 0x91, 0x97, 0x95, 0x8b, 0x89, 0x8f, 0x8d, 0x83, 0x81, 0x87, 0x85,\n    0xbb, 0xb9, 0xbf, 0xbd, 0xb3, 0xb1, 0xb7, 0xb5, 0xab, 0xa9, 0xaf, 0xad, 0xa3, 0xa1, 0xa7, 0xa5,\n    0xdb, 0xd9, 0xdf, 0xdd, 0xd3, 0xd1, 0xd7, 0xd5, 0xcb, 0xc9, 0xcf, 0xcd, 0xc3, 0xc1, 0xc7, 0xc5,\n    0xfb, 0xf9, 0xff, 0xfd, 0xf3, 0xf1, 0xf7, 0xf5, 0xeb, 0xe9, 0xef, 0xed, 0xe3, 0xe1, 0xe7, 0xe5\n  };\n\n  /**\n   * Precalculated lookup table for galois field multiplication by 3 used in the MixColums step\n   * during encryption.\n   */\n  private static final int[] MULT3 = {\n    0x00, 0x03, 0x06, 0x05, 0x0c, 0x0f, 0x0a, 0x09, 0x18, 0x1b, 0x1e, 0x1d, 0x14, 0x17, 0x12, 0x11,\n    0x30, 0x33, 0x36, 0x35, 0x3c, 0x3f, 0x3a, 0x39, 0x28, 0x2b, 0x2e, 0x2d, 0x24, 0x27, 0x22, 0x21,\n    0x60, 0x63, 0x66, 0x65, 0x6c, 0x6f, 0x6a, 0x69, 0x78, 0x7b, 0x7e, 0x7d, 0x74, 0x77, 0x72, 0x71,\n    0x50, 0x53, 0x56, 0x55, 0x5c, 0x5f, 0x5a, 0x59, 0x48, 0x4b, 0x4e, 0x4d, 0x44, 0x47, 0x42, 0x41,\n    0xc0, 0xc3, 0xc6, 0xc5, 0xcc, 0xcf, 0xca, 0xc9, 0xd8, 0xdb, 0xde, 0xdd, 0xd4, 0xd7, 0xd2, 0xd1,\n    0xf0, 0xf3, 0xf6, 0xf5, 0xfc, 0xff, 0xfa, 0xf9, 0xe8, 0xeb, 0xee, 0xed, 0xe4, 0xe7, 0xe2, 0xe1,\n    0xa0, 0xa3, 0xa6, 0xa5, 0xac, 0xaf, 0xaa, 0xa9, 0xb8, 0xbb, 0xbe, 0xbd, 0xb4, 0xb7, 0xb2, 0xb1,\n    0x90, 0x93, 0x96, 0x95, 0x9c, 0x9f, 0x9a, 0x99, 0x88, 0x8b, 0x8e, 0x8d, 0x84, 0x87, 0x82, 0x81,\n    0x9b, 0x98, 0x9d, 0x9e, 0x97, 0x94, 0x91, 0x92, 0x83, 0x80, 0x85, 0x86, 0x8f, 0x8c, 0x89, 0x8a,\n    0xab, 0xa8, 0xad, 0xae, 0xa7, 0xa4, 0xa1, 0xa2, 0xb3, 0xb0, 0xb5, 0xb6, 0xbf, 0xbc, 0xb9, 0xba,\n    0xfb, 0xf8, 0xfd, 0xfe, 0xf7, 0xf4, 0xf1, 0xf2, 0xe3, 0xe0, 0xe5, 0xe6, 0xef, 0xec, 0xe9, 0xea,\n    0xcb, 0xc8, 0xcd, 0xce, 0xc7, 0xc4, 0xc1, 0xc2, 0xd3, 0xd0, 0xd5, 0xd6, 0xdf, 0xdc, 0xd9, 0xda,\n    0x5b, 0x58, 0x5d, 0x5e, 0x57, 0x54, 0x51, 0x52, 0x43, 0x40, 0x45, 0x46, 0x4f, 0x4c, 0x49, 0x4a,\n    0x6b, 0x68, 0x6d, 0x6e, 0x67, 0x64, 0x61, 0x62, 0x73, 0x70, 0x75, 0x76, 0x7f, 0x7c, 0x79, 0x7a,\n    0x3b, 0x38, 0x3d, 0x3e, 0x37, 0x34, 0x31, 0x32, 0x23, 0x20, 0x25, 0x26, 0x2f, 0x2c, 0x29, 0x2a,\n    0x0b, 0x08, 0x0d, 0x0e, 0x07, 0x04, 0x01, 0x02, 0x13, 0x10, 0x15, 0x16, 0x1f, 0x1c, 0x19, 0x1a\n  };\n\n  /**\n   * Precalculated lookup table for galois field multiplication by 9 used in the MixColums step\n   * during decryption.\n   */\n  private static final int[] MULT9 = {\n    0x00, 0x09, 0x12, 0x1b, 0x24, 0x2d, 0x36, 0x3f, 0x48, 0x41, 0x5a, 0x53, 0x6c, 0x65, 0x7e, 0x77,\n    0x90, 0x99, 0x82, 0x8b, 0xb4, 0xbd, 0xa6, 0xaf, 0xd8, 0xd1, 0xca, 0xc3, 0xfc, 0xf5, 0xee, 0xe7,\n    0x3b, 0x32, 0x29, 0x20, 0x1f, 0x16, 0x0d, 0x04, 0x73, 0x7a, 0x61, 0x68, 0x57, 0x5e, 0x45, 0x4c,\n    0xab, 0xa2, 0xb9, 0xb0, 0x8f, 0x86, 0x9d, 0x94, 0xe3, 0xea, 0xf1, 0xf8, 0xc7, 0xce, 0xd5, 0xdc,\n    0x76, 0x7f, 0x64, 0x6d, 0x52, 0x5b, 0x40, 0x49, 0x3e, 0x37, 0x2c, 0x25, 0x1a, 0x13, 0x08, 0x01,\n    0xe6, 0xef, 0xf4, 0xfd, 0xc2, 0xcb, 0xd0, 0xd9, 0xae, 0xa7, 0xbc, 0xb5, 0x8a, 0x83, 0x98, 0x91,\n    0x4d, 0x44, 0x5f, 0x56, 0x69, 0x60, 0x7b, 0x72, 0x05, 0x0c, 0x17, 0x1e, 0x21, 0x28, 0x33, 0x3a,\n    0xdd, 0xd4, 0xcf, 0xc6, 0xf9, 0xf0, 0xeb, 0xe2, 0x95, 0x9c, 0x87, 0x8e, 0xb1, 0xb8, 0xa3, 0xaa,\n    0xec, 0xe5, 0xfe, 0xf7, 0xc8, 0xc1, 0xda, 0xd3, 0xa4, 0xad, 0xb6, 0xbf, 0x80, 0x89, 0x92, 0x9b,\n    0x7c, 0x75, 0x6e, 0x67, 0x58, 0x51, 0x4a, 0x43, 0x34, 0x3d, 0x26, 0x2f, 0x10, 0x19, 0x02, 0x0b,\n    0xd7, 0xde, 0xc5, 0xcc, 0xf3, 0xfa, 0xe1, 0xe8, 0x9f, 0x96, 0x8d, 0x84, 0xbb, 0xb2, 0xa9, 0xa0,\n    0x47, 0x4e, 0x55, 0x5c, 0x63, 0x6a, 0x71, 0x78, 0x0f, 0x06, 0x1d, 0x14, 0x2b, 0x22, 0x39, 0x30,\n    0x9a, 0x93, 0x88, 0x81, 0xbe, 0xb7, 0xac, 0xa5, 0xd2, 0xdb, 0xc0, 0xc9, 0xf6, 0xff, 0xe4, 0xed,\n    0x0a, 0x03, 0x18, 0x11, 0x2e, 0x27, 0x3c, 0x35, 0x42, 0x4b, 0x50, 0x59, 0x66, 0x6f, 0x74, 0x7d,\n    0xa1, 0xa8, 0xb3, 0xba, 0x85, 0x8c, 0x97, 0x9e, 0xe9, 0xe0, 0xfb, 0xf2, 0xcd, 0xc4, 0xdf, 0xd6,\n    0x31, 0x38, 0x23, 0x2a, 0x15, 0x1c, 0x07, 0x0e, 0x79, 0x70, 0x6b, 0x62, 0x5d, 0x54, 0x4f, 0x46\n  };\n\n  /**\n   * Precalculated lookup table for galois field multiplication by 11 used in the MixColums step\n   * during decryption.\n   */\n  private static final int[] MULT11 = {\n    0x00, 0x0b, 0x16, 0x1d, 0x2c, 0x27, 0x3a, 0x31, 0x58, 0x53, 0x4e, 0x45, 0x74, 0x7f, 0x62, 0x69,\n    0xb0, 0xbb, 0xa6, 0xad, 0x9c, 0x97, 0x8a, 0x81, 0xe8, 0xe3, 0xfe, 0xf5, 0xc4, 0xcf, 0xd2, 0xd9,\n    0x7b, 0x70, 0x6d, 0x66, 0x57, 0x5c, 0x41, 0x4a, 0x23, 0x28, 0x35, 0x3e, 0x0f, 0x04, 0x19, 0x12,\n    0xcb, 0xc0, 0xdd, 0xd6, 0xe7, 0xec, 0xf1, 0xfa, 0x93, 0x98, 0x85, 0x8e, 0xbf, 0xb4, 0xa9, 0xa2,\n    0xf6, 0xfd, 0xe0, 0xeb, 0xda, 0xd1, 0xcc, 0xc7, 0xae, 0xa5, 0xb8, 0xb3, 0x82, 0x89, 0x94, 0x9f,\n    0x46, 0x4d, 0x50, 0x5b, 0x6a, 0x61, 0x7c, 0x77, 0x1e, 0x15, 0x08, 0x03, 0x32, 0x39, 0x24, 0x2f,\n    0x8d, 0x86, 0x9b, 0x90, 0xa1, 0xaa, 0xb7, 0xbc, 0xd5, 0xde, 0xc3, 0xc8, 0xf9, 0xf2, 0xef, 0xe4,\n    0x3d, 0x36, 0x2b, 0x20, 0x11, 0x1a, 0x07, 0x0c, 0x65, 0x6e, 0x73, 0x78, 0x49, 0x42, 0x5f, 0x54,\n    0xf7, 0xfc, 0xe1, 0xea, 0xdb, 0xd0, 0xcd, 0xc6, 0xaf, 0xa4, 0xb9, 0xb2, 0x83, 0x88, 0x95, 0x9e,\n    0x47, 0x4c, 0x51, 0x5a, 0x6b, 0x60, 0x7d, 0x76, 0x1f, 0x14, 0x09, 0x02, 0x33, 0x38, 0x25, 0x2e,\n    0x8c, 0x87, 0x9a, 0x91, 0xa0, 0xab, 0xb6, 0xbd, 0xd4, 0xdf, 0xc2, 0xc9, 0xf8, 0xf3, 0xee, 0xe5,\n    0x3c, 0x37, 0x2a, 0x21, 0x10, 0x1b, 0x06, 0x0d, 0x64, 0x6f, 0x72, 0x79, 0x48, 0x43, 0x5e, 0x55,\n    0x01, 0x0a, 0x17, 0x1c, 0x2d, 0x26, 0x3b, 0x30, 0x59, 0x52, 0x4f, 0x44, 0x75, 0x7e, 0x63, 0x68,\n    0xb1, 0xba, 0xa7, 0xac, 0x9d, 0x96, 0x8b, 0x80, 0xe9, 0xe2, 0xff, 0xf4, 0xc5, 0xce, 0xd3, 0xd8,\n    0x7a, 0x71, 0x6c, 0x67, 0x56, 0x5d, 0x40, 0x4b, 0x22, 0x29, 0x34, 0x3f, 0x0e, 0x05, 0x18, 0x13,\n    0xca, 0xc1, 0xdc, 0xd7, 0xe6, 0xed, 0xf0, 0xfb, 0x92, 0x99, 0x84, 0x8f, 0xbe, 0xb5, 0xa8, 0xa3\n  };\n\n  /**\n   * Precalculated lookup table for galois field multiplication by 13 used in the MixColums step\n   * during decryption.\n   */\n  private static final int[] MULT13 = {\n    0x00, 0x0d, 0x1a, 0x17, 0x34, 0x39, 0x2e, 0x23, 0x68, 0x65, 0x72, 0x7f, 0x5c, 0x51, 0x46, 0x4b,\n    0xd0, 0xdd, 0xca, 0xc7, 0xe4, 0xe9, 0xfe, 0xf3, 0xb8, 0xb5, 0xa2, 0xaf, 0x8c, 0x81, 0x96, 0x9b,\n    0xbb, 0xb6, 0xa1, 0xac, 0x8f, 0x82, 0x95, 0x98, 0xd3, 0xde, 0xc9, 0xc4, 0xe7, 0xea, 0xfd, 0xf0,\n    0x6b, 0x66, 0x71, 0x7c, 0x5f, 0x52, 0x45, 0x48, 0x03, 0x0e, 0x19, 0x14, 0x37, 0x3a, 0x2d, 0x20,\n    0x6d, 0x60, 0x77, 0x7a, 0x59, 0x54, 0x43, 0x4e, 0x05, 0x08, 0x1f, 0x12, 0x31, 0x3c, 0x2b, 0x26,\n    0xbd, 0xb0, 0xa7, 0xaa, 0x89, 0x84, 0x93, 0x9e, 0xd5, 0xd8, 0xcf, 0xc2, 0xe1, 0xec, 0xfb, 0xf6,\n    0xd6, 0xdb, 0xcc, 0xc1, 0xe2, 0xef, 0xf8, 0xf5, 0xbe, 0xb3, 0xa4, 0xa9, 0x8a, 0x87, 0x90, 0x9d,\n    0x06, 0x0b, 0x1c, 0x11, 0x32, 0x3f, 0x28, 0x25, 0x6e, 0x63, 0x74, 0x79, 0x5a, 0x57, 0x40, 0x4d,\n    0xda, 0xd7, 0xc0, 0xcd, 0xee, 0xe3, 0xf4, 0xf9, 0xb2, 0xbf, 0xa8, 0xa5, 0x86, 0x8b, 0x9c, 0x91,\n    0x0a, 0x07, 0x10, 0x1d, 0x3e, 0x33, 0x24, 0x29, 0x62, 0x6f, 0x78, 0x75, 0x56, 0x5b, 0x4c, 0x41,\n    0x61, 0x6c, 0x7b, 0x76, 0x55, 0x58, 0x4f, 0x42, 0x09, 0x04, 0x13, 0x1e, 0x3d, 0x30, 0x27, 0x2a,\n    0xb1, 0xbc, 0xab, 0xa6, 0x85, 0x88, 0x9f, 0x92, 0xd9, 0xd4, 0xc3, 0xce, 0xed, 0xe0, 0xf7, 0xfa,\n    0xb7, 0xba, 0xad, 0xa0, 0x83, 0x8e, 0x99, 0x94, 0xdf, 0xd2, 0xc5, 0xc8, 0xeb, 0xe6, 0xf1, 0xfc,\n    0x67, 0x6a, 0x7d, 0x70, 0x53, 0x5e, 0x49, 0x44, 0x0f, 0x02, 0x15, 0x18, 0x3b, 0x36, 0x21, 0x2c,\n    0x0c, 0x01, 0x16, 0x1b, 0x38, 0x35, 0x22, 0x2f, 0x64, 0x69, 0x7e, 0x73, 0x50, 0x5d, 0x4a, 0x47,\n    0xdc, 0xd1, 0xc6, 0xcb, 0xe8, 0xe5, 0xf2, 0xff, 0xb4, 0xb9, 0xae, 0xa3, 0x80, 0x8d, 0x9a, 0x97\n  };\n\n  /**\n   * Precalculated lookup table for galois field multiplication by 14 used in the MixColums step\n   * during decryption.\n   */\n  private static final int[] MULT14 = {\n    0x00, 0x0e, 0x1c, 0x12, 0x38, 0x36, 0x24, 0x2a, 0x70, 0x7e, 0x6c, 0x62, 0x48, 0x46, 0x54, 0x5a,\n    0xe0, 0xee, 0xfc, 0xf2, 0xd8, 0xd6, 0xc4, 0xca, 0x90, 0x9e, 0x8c, 0x82, 0xa8, 0xa6, 0xb4, 0xba,\n    0xdb, 0xd5, 0xc7, 0xc9, 0xe3, 0xed, 0xff, 0xf1, 0xab, 0xa5, 0xb7, 0xb9, 0x93, 0x9d, 0x8f, 0x81,\n    0x3b, 0x35, 0x27, 0x29, 0x03, 0x0d, 0x1f, 0x11, 0x4b, 0x45, 0x57, 0x59, 0x73, 0x7d, 0x6f, 0x61,\n    0xad, 0xa3, 0xb1, 0xbf, 0x95, 0x9b, 0x89, 0x87, 0xdd, 0xd3, 0xc1, 0xcf, 0xe5, 0xeb, 0xf9, 0xf7,\n    0x4d, 0x43, 0x51, 0x5f, 0x75, 0x7b, 0x69, 0x67, 0x3d, 0x33, 0x21, 0x2f, 0x05, 0x0b, 0x19, 0x17,\n    0x76, 0x78, 0x6a, 0x64, 0x4e, 0x40, 0x52, 0x5c, 0x06, 0x08, 0x1a, 0x14, 0x3e, 0x30, 0x22, 0x2c,\n    0x96, 0x98, 0x8a, 0x84, 0xae, 0xa0, 0xb2, 0xbc, 0xe6, 0xe8, 0xfa, 0xf4, 0xde, 0xd0, 0xc2, 0xcc,\n    0x41, 0x4f, 0x5d, 0x53, 0x79, 0x77, 0x65, 0x6b, 0x31, 0x3f, 0x2d, 0x23, 0x09, 0x07, 0x15, 0x1b,\n    0xa1, 0xaf, 0xbd, 0xb3, 0x99, 0x97, 0x85, 0x8b, 0xd1, 0xdf, 0xcd, 0xc3, 0xe9, 0xe7, 0xf5, 0xfb,\n    0x9a, 0x94, 0x86, 0x88, 0xa2, 0xac, 0xbe, 0xb0, 0xea, 0xe4, 0xf6, 0xf8, 0xd2, 0xdc, 0xce, 0xc0,\n    0x7a, 0x74, 0x66, 0x68, 0x42, 0x4c, 0x5e, 0x50, 0x0a, 0x04, 0x16, 0x18, 0x32, 0x3c, 0x2e, 0x20,\n    0xec, 0xe2, 0xf0, 0xfe, 0xd4, 0xda, 0xc8, 0xc6, 0x9c, 0x92, 0x80, 0x8e, 0xa4, 0xaa, 0xb8, 0xb6,\n    0x0c, 0x02, 0x10, 0x1e, 0x34, 0x3a, 0x28, 0x26, 0x7c, 0x72, 0x60, 0x6e, 0x44, 0x4a, 0x58, 0x56,\n    0x37, 0x39, 0x2b, 0x25, 0x0f, 0x01, 0x13, 0x1d, 0x47, 0x49, 0x5b, 0x55, 0x7f, 0x71, 0x63, 0x6d,\n    0xd7, 0xd9, 0xcb, 0xc5, 0xef, 0xe1, 0xf3, 0xfd, 0xa7, 0xa9, 0xbb, 0xb5, 0x9f, 0x91, 0x83, 0x8d\n  };\n\n  /**\n   * Subroutine of the Rijndael key expansion.\n   *\n   * @param t\n   * @param rconCounter\n   * @return\n   */\n  public static BigInteger scheduleCore(BigInteger t, int rconCounter) {\n    String rBytes = t.toString(16);\n\n    // Add zero padding\n    while (rBytes.length() < 8) {\n      rBytes = \"0\" + rBytes;\n    }\n\n    // rotate the first 16 bits to the back\n    String rotatingBytes = rBytes.substring(0, 2);\n    String fixedBytes = rBytes.substring(2);\n\n    rBytes = fixedBytes + rotatingBytes;\n\n    // apply S-Box to all 8-Bit Substrings\n    for (int i = 0; i < 4; i++) {\n      String currentByteBits = rBytes.substring(i * 2, (i + 1) * 2);\n\n      int currentByte = Integer.parseInt(currentByteBits, 16);\n      currentByte = SBOX[currentByte];\n\n      // add the current RCON value to the first byte\n      if (i == 0) {\n        currentByte = currentByte ^ RCON[rconCounter];\n      }\n\n      currentByteBits = Integer.toHexString(currentByte);\n\n      // Add zero padding\n\n      while (currentByteBits.length() < 2) {\n        currentByteBits = '0' + currentByteBits;\n      }\n\n      // replace bytes in original string\n      rBytes = rBytes.substring(0, i * 2) + currentByteBits + rBytes.substring((i + 1) * 2);\n    }\n\n    // t = new BigInteger(rBytes, 16);\n    // return t;\n    return new BigInteger(rBytes, 16);\n  }\n\n  /**\n   * Returns an array of 10 + 1 round keys that are calculated by using Rijndael key schedule\n   *\n   * @param initialKey\n   * @return array of 10 + 1 round keys\n   */\n  public static BigInteger[] keyExpansion(BigInteger initialKey) {\n    BigInteger[] roundKeys = {\n      initialKey,\n      new BigInteger(\"0\"),\n      new BigInteger(\"0\"),\n      new BigInteger(\"0\"),\n      new BigInteger(\"0\"),\n      new BigInteger(\"0\"),\n      new BigInteger(\"0\"),\n      new BigInteger(\"0\"),\n      new BigInteger(\"0\"),\n      new BigInteger(\"0\"),\n      new BigInteger(\"0\"),\n    };\n\n    // initialize rcon iteration\n    int rconCounter = 1;\n\n    for (int i = 1; i < 11; i++) {\n\n      // get the previous 32 bits the key\n      BigInteger t = roundKeys[i - 1].remainder(new BigInteger(\"100000000\", 16));\n\n      // split previous key into 8-bit segments\n      BigInteger[] prevKey = {\n        roundKeys[i - 1].remainder(new BigInteger(\"100000000\", 16)),\n        roundKeys[i - 1]\n            .remainder(new BigInteger(\"10000000000000000\", 16))\n            .divide(new BigInteger(\"100000000\", 16)),\n        roundKeys[i - 1]\n            .remainder(new BigInteger(\"1000000000000000000000000\", 16))\n            .divide(new BigInteger(\"10000000000000000\", 16)),\n        roundKeys[i - 1].divide(new BigInteger(\"1000000000000000000000000\", 16)),\n      };\n\n      // run schedule core\n      t = scheduleCore(t, rconCounter);\n      rconCounter += 1;\n\n      // Calculate partial round key\n      BigInteger t0 = t.xor(prevKey[3]);\n      BigInteger t1 = t0.xor(prevKey[2]);\n      BigInteger t2 = t1.xor(prevKey[1]);\n      BigInteger t3 = t2.xor(prevKey[0]);\n\n      // Join round key segments\n      t2 = t2.multiply(new BigInteger(\"100000000\", 16));\n      t1 = t1.multiply(new BigInteger(\"10000000000000000\", 16));\n      t0 = t0.multiply(new BigInteger(\"1000000000000000000000000\", 16));\n      roundKeys[i] = t0.add(t1).add(t2).add(t3);\n    }\n    return roundKeys;\n  }\n\n  /**\n   * representation of the input 128-bit block as an array of 8-bit integers.\n   *\n   * @param block of 128-bit integers\n   * @return array of 8-bit integers\n   */\n  public static int[] splitBlockIntoCells(BigInteger block) {\n\n    int[] cells = new int[16];\n    String blockBits = block.toString(2);\n\n    // Append leading 0 for full \"128-bit\" string\n    while (blockBits.length() < 128) {\n      blockBits = '0' + blockBits;\n    }\n\n    // split 128 to 8 bit cells\n    for (int i = 0; i < cells.length; i++) {\n      String cellBits = blockBits.substring(8 * i, 8 * (i + 1));\n      cells[i] = Integer.parseInt(cellBits, 2);\n    }\n\n    return cells;\n  }\n\n  /**\n   * Returns the 128-bit BigInteger representation of the input of an array of 8-bit integers.\n   *\n   * @param cells that we need to merge\n   * @return block of merged cells\n   */\n  public static BigInteger mergeCellsIntoBlock(int[] cells) {\n\n    String blockBits = \"\";\n    for (int i = 0; i < 16; i++) {\n      String cellBits = Integer.toBinaryString(cells[i]);\n\n      // Append leading 0 for full \"8-bit\" strings\n      while (cellBits.length() < 8) {\n        cellBits = '0' + cellBits;\n      }\n\n      blockBits += cellBits;\n    }\n\n    return new BigInteger(blockBits, 2);\n  }\n\n  /**\n   * @param ciphertext\n   * @param key\n   * @return ciphertext XOR key\n   */\n  public static BigInteger addRoundKey(BigInteger ciphertext, BigInteger key) {\n    return ciphertext.xor(key);\n  }\n\n  /**\n   * substitutes 8-Bit long substrings of the input using the S-Box and returns the result.\n   *\n   * @param ciphertext\n   * @return subtraction Output\n   */\n  public static BigInteger subBytes(BigInteger ciphertext) {\n\n    int[] cells = splitBlockIntoCells(ciphertext);\n\n    for (int i = 0; i < 16; i++) {\n      cells[i] = SBOX[cells[i]];\n    }\n\n    return mergeCellsIntoBlock(cells);\n  }\n\n  /**\n   * substitutes 8-Bit long substrings of the input using the inverse S-Box for decryption and\n   * returns the result.\n   *\n   * @param ciphertext\n   * @return subtraction Output\n   */\n  public static BigInteger subBytesDec(BigInteger ciphertext) {\n\n    int[] cells = splitBlockIntoCells(ciphertext);\n\n    for (int i = 0; i < 16; i++) {\n      cells[i] = INVERSE_SBOX[cells[i]];\n    }\n\n    return mergeCellsIntoBlock(cells);\n  }\n\n  /**\n   * Cell permutation step. Shifts cells within the rows of the input and returns the result.\n   *\n   * @param ciphertext\n   */\n  public static BigInteger shiftRows(BigInteger ciphertext) {\n    int[] cells = splitBlockIntoCells(ciphertext);\n    int[] output = new int[16];\n\n    // do nothing in the first row\n    output[0] = cells[0];\n    output[4] = cells[4];\n    output[8] = cells[8];\n    output[12] = cells[12];\n\n    // shift the second row backwards by one cell\n    output[1] = cells[5];\n    output[5] = cells[9];\n    output[9] = cells[13];\n    output[13] = cells[1];\n\n    // shift the third row backwards by two cell\n    output[2] = cells[10];\n    output[6] = cells[14];\n    output[10] = cells[2];\n    output[14] = cells[6];\n\n    // shift the forth row backwards by tree cell\n    output[3] = cells[15];\n    output[7] = cells[3];\n    output[11] = cells[7];\n    output[15] = cells[11];\n\n    return mergeCellsIntoBlock(output);\n  }\n\n  /**\n   * Cell permutation step for decryption . Shifts cells within the rows of the input and returns\n   * the result.\n   *\n   * @param ciphertext\n   */\n  public static BigInteger shiftRowsDec(BigInteger ciphertext) {\n    int[] cells = splitBlockIntoCells(ciphertext);\n    int[] output = new int[16];\n\n    // do nothing in the first row\n    output[0] = cells[0];\n    output[4] = cells[4];\n    output[8] = cells[8];\n    output[12] = cells[12];\n\n    // shift the second row forwards by one cell\n    output[1] = cells[13];\n    output[5] = cells[1];\n    output[9] = cells[5];\n    output[13] = cells[9];\n\n    // shift the third row forwards by two cell\n    output[2] = cells[10];\n    output[6] = cells[14];\n    output[10] = cells[2];\n    output[14] = cells[6];\n\n    // shift the forth row forwards by tree cell\n    output[3] = cells[7];\n    output[7] = cells[11];\n    output[11] = cells[15];\n    output[15] = cells[3];\n\n    return mergeCellsIntoBlock(output);\n  }\n\n  /**\n   * Applies the Rijndael MixColumns to the input and returns the result.\n   *\n   * @param ciphertext\n   */\n  public static BigInteger mixColumns(BigInteger ciphertext) {\n\n    int[] cells = splitBlockIntoCells(ciphertext);\n    int[] outputCells = new int[16];\n\n    for (int i = 0; i < 4; i++) {\n      int[] row = {cells[i * 4], cells[i * 4 + 1], cells[i * 4 + 2], cells[i * 4 + 3]};\n\n      outputCells[i * 4] = MULT2[row[0]] ^ MULT3[row[1]] ^ row[2] ^ row[3];\n      outputCells[i * 4 + 1] = row[0] ^ MULT2[row[1]] ^ MULT3[row[2]] ^ row[3];\n      outputCells[i * 4 + 2] = row[0] ^ row[1] ^ MULT2[row[2]] ^ MULT3[row[3]];\n      outputCells[i * 4 + 3] = MULT3[row[0]] ^ row[1] ^ row[2] ^ MULT2[row[3]];\n    }\n    return mergeCellsIntoBlock(outputCells);\n  }\n\n  /**\n   * Applies the inverse Rijndael MixColumns for decryption to the input and returns the result.\n   *\n   * @param ciphertext\n   */\n  public static BigInteger mixColumnsDec(BigInteger ciphertext) {\n\n    int[] cells = splitBlockIntoCells(ciphertext);\n    int[] outputCells = new int[16];\n\n    for (int i = 0; i < 4; i++) {\n      int[] row = {cells[i * 4], cells[i * 4 + 1], cells[i * 4 + 2], cells[i * 4 + 3]};\n\n      outputCells[i * 4] = MULT14[row[0]] ^ MULT11[row[1]] ^ MULT13[row[2]] ^ MULT9[row[3]];\n      outputCells[i * 4 + 1] = MULT9[row[0]] ^ MULT14[row[1]] ^ MULT11[row[2]] ^ MULT13[row[3]];\n      outputCells[i * 4 + 2] = MULT13[row[0]] ^ MULT9[row[1]] ^ MULT14[row[2]] ^ MULT11[row[3]];\n      outputCells[i * 4 + 3] = MULT11[row[0]] ^ MULT13[row[1]] ^ MULT9[row[2]] ^ MULT14[row[3]];\n    }\n    return mergeCellsIntoBlock(outputCells);\n  }\n\n  /**\n   * Encrypts the plaintext with the key and returns the result\n   *\n   * @param plainText which we want to encrypt\n   * @param key the key for encrypt\n   * @return EncryptedText\n   */\n  public static BigInteger encrypt(BigInteger plainText, BigInteger key) {\n    BigInteger[] roundKeys = keyExpansion(key);\n\n    // Initial round\n    plainText = addRoundKey(plainText, roundKeys[0]);\n\n    // Main rounds\n    for (int i = 1; i < 10; i++) {\n      plainText = subBytes(plainText);\n      plainText = shiftRows(plainText);\n      plainText = mixColumns(plainText);\n      plainText = addRoundKey(plainText, roundKeys[i]);\n    }\n\n    // Final round\n    plainText = subBytes(plainText);\n    plainText = shiftRows(plainText);\n    plainText = addRoundKey(plainText, roundKeys[10]);\n\n    return plainText;\n  }\n\n  /**\n   * Decrypts the ciphertext with the key and returns the result\n   *\n   * @param cipherText The Encrypted text which we want to decrypt\n   * @param key\n   * @return decryptedText\n   */\n  public static BigInteger decrypt(BigInteger cipherText, BigInteger key) {\n\n    BigInteger[] roundKeys = keyExpansion(key);\n\n    // Invert final round\n    cipherText = addRoundKey(cipherText, roundKeys[10]);\n    cipherText = shiftRowsDec(cipherText);\n    cipherText = subBytesDec(cipherText);\n\n    // Invert main rounds\n    for (int i = 9; i > 0; i--) {\n      cipherText = addRoundKey(cipherText, roundKeys[i]);\n      cipherText = mixColumnsDec(cipherText);\n      cipherText = shiftRowsDec(cipherText);\n      cipherText = subBytesDec(cipherText);\n    }\n\n    // Invert initial round\n    cipherText = addRoundKey(cipherText, roundKeys[0]);\n\n    return cipherText;\n  }\n\n  public static void main(String[] args) {\n\n    try (Scanner input = new Scanner(System.in)) {\n      System.out.println(\"Enter (e) letter for encrpyt or (d) letter for decrypt :\");\n      char choice = input.nextLine().charAt(0);\n      String in;\n      switch (choice) {\n        case 'E':\n        case 'e':\n          System.out.println(\"Choose a plaintext block (128-Bit Integer in base 16):\");\n          in = input.nextLine();\n          BigInteger plaintext = new BigInteger(in, 16);\n          System.out.println(\"Choose a Key (128-Bit Integer in base 16):\");\n          in = input.nextLine();\n          BigInteger encryptionKey = new BigInteger(in, 16);\n          System.out.println(\n              \"The encrypted message is: \\n\" + encrypt(plaintext, encryptionKey).toString(16));\n          break;\n        case 'D':\n        case 'd':\n          System.out.println(\"Enter your ciphertext block (128-Bit Integer in base 16):\");\n          in = input.nextLine();\n          BigInteger ciphertext = new BigInteger(in, 16);\n          System.out.println(\"Choose a Key (128-Bit Integer in base 16):\");\n          in = input.nextLine();\n          BigInteger decryptionKey = new BigInteger(in, 16);\n          System.out.println(\n              \"The deciphered message is:\\n\" + decrypt(ciphertext, decryptionKey).toString(16));\n          break;\n        default:\n          System.out.println(\"** End **\");\n      }\n    }\n  }\n}\n","index":232},{"title":"A E S Encryption","category":"ciphers","id":"AESEncryption_ciphers","algorithm":"package ciphers;\n\nimport java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.SecretKey;\n\n/**\n * This example program shows how AES encryption and decryption can be done in Java. Please note\n * that secret key and encrypted text is unreadable binary and hence in the following program we\n * display it in hexadecimal format of the underlying bytes.\n */\npublic class AESEncryption {\n\n  private static final char[] HEX_ARRAY = \"0123456789ABCDEF\".toCharArray();\n  /**\n   * 1. Generate a plain text for encryption 2. Get a secret key (printed in hexadecimal form). In\n   * actual use this must by encrypted and kept safe. The same key is required for decryption.\n   */\n  public static void main(String[] args) throws Exception {\n    String plainText = \"Hello World\";\n    SecretKey secKey = getSecretEncryptionKey();\n    byte[] cipherText = encryptText(plainText, secKey);\n    String decryptedText = decryptText(cipherText, secKey);\n\n    System.out.println(\"Original Text:\" + plainText);\n    System.out.println(\"AES Key (Hex Form):\" + bytesToHex(secKey.getEncoded()));\n    System.out.println(\"Encrypted Text (Hex Form):\" + bytesToHex(cipherText));\n    System.out.println(\"Descrypted Text:\" + decryptedText);\n  }\n\n  /**\n   * gets the AES encryption key. In your actual programs, this should be safely stored.\n   *\n   * @return secKey (Secret key that we encrypt using it)\n   * @throws NoSuchAlgorithmException (from KeyGenrator)\n   */\n  public static SecretKey getSecretEncryptionKey() throws NoSuchAlgorithmException {\n    KeyGenerator aesKeyGenerator = KeyGenerator.getInstance(\"AES\");\n    aesKeyGenerator.init(128); // The AES key size in number of bits\n    SecretKey secKey = aesKeyGenerator.generateKey();\n    return secKey;\n  }\n\n  /**\n   * Encrypts plainText in AES using the secret key\n   *\n   * @param plainText\n   * @param secKey\n   * @return byteCipherText (The encrypted text)\n   * @throws NoSuchPaddingException (from Cipher)\n   * @throws NoSuchAlgorithmException (from Cipher)\n   * @throws InvalidKeyException (from Cipher)\n   * @throws BadPaddingException (from Cipher)\n   * @throws IllegalBlockSizeException (from Cipher)\n   */\n  public static byte[] encryptText(String plainText, SecretKey secKey)\n      throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException,\n          IllegalBlockSizeException, BadPaddingException {\n    // AES defaults to AES/ECB/PKCS5Padding in Java 7\n    Cipher aesCipher = Cipher.getInstance(\"AES\");\n    aesCipher.init(Cipher.ENCRYPT_MODE, secKey);\n    byte[] byteCipherText = aesCipher.doFinal(plainText.getBytes());\n    return byteCipherText;\n  }\n\n  /**\n   * Decrypts encrypted byte array using the key used for encryption.\n   *\n   * @param byteCipherText\n   * @param secKey\n   * @return plainText\n   * @throws NoSuchPaddingException\n   * @throws NoSuchAlgorithmException\n   * @throws InvalidKeyException\n   * @throws BadPaddingException\n   * @throws IllegalBlockSizeException\n   */\n  public static String decryptText(byte[] byteCipherText, SecretKey secKey)\n      throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException,\n          IllegalBlockSizeException, BadPaddingException {\n    // AES defaults to AES/ECB/PKCS5Padding in Java 7\n    Cipher aesCipher = Cipher.getInstance(\"AES\");\n    aesCipher.init(Cipher.DECRYPT_MODE, secKey);\n    byte[] bytePlainText = aesCipher.doFinal(byteCipherText);\n    return new String(bytePlainText);\n  }\n\n  /**\n   * Convert a binary byte array into readable hex form Old library is deprecated on OpenJdk 11 and\n   * this is faster regarding other solution is using StringBuilder Credit {@link\n   * https://stackoverflow.com/questions/9655181/how-to-convert-a-byte-array-to-a-hex-string-in-java/9855338#9855338}\n   *\n   * @param hash (in binary)\n   * @return hexHash\n   */\n  public static String bytesToHex(byte[] bytes) {\n    char[] hexChars = new char[bytes.length * 2];\n    for (int j = 0; j < bytes.length; j++) {\n      int v = bytes[j] & 0xFF;\n      hexChars[j * 2] = HEX_ARRAY[v >>> 4];\n      hexChars[j * 2 + 1] = HEX_ARRAY[v & 0x0F];\n    }\n    return new String(hexChars);\n  }\n}\n","index":233},{"title":"Caesar","category":"ciphers","id":"Caesar_ciphers","algorithm":"package ciphers;\n\nimport java.util.Scanner;\n\n/**\n * A Java implementation of Caesar Cipher. /It is a type of substitution cipher in which each letter\n * in the plaintext is replaced by a letter some fixed number of positions down the alphabet. /\n *\n * @author FAHRI YARDIMCI\n * @author khalil2535\n */\npublic class Caesar {\n\n  /**\n   * Encrypt text by shifting every Latin char by add number shift for ASCII Example : A + 1 -> B\n   *\n   * @param message\n   * @param shift\n   * @return Encrypted message\n   */\n  public static String encode(String message, int shift) {\n    String encoded = \"\";\n\n    shift %= 26;\n\n    final int length = message.length();\n    for (int i = 0; i < length; i++) {\n\n      //            int current = message.charAt(i); //using char to shift characters because ascii\n      // is in-order latin alphabet\n      char current = message.charAt(i); // Java law : char + int = char\n\n      if (IsCapitalLatinLetter(current)) {\n\n        current += shift;\n        encoded += (char) (current > 'Z' ? current - 26 : current); // 26 = number of latin letters\n\n      } else if (IsSmallLatinLetter(current)) {\n\n        current += shift;\n        encoded += (char) (current > 'z' ? current - 26 : current); // 26 = number of latin letters\n\n      } else {\n        encoded += current;\n      }\n    }\n    return encoded;\n  }\n\n  /**\n   * Decrypt message by shifting back every Latin char to previous the ASCII Example : B - 1 -> A\n   *\n   * @param encryptedMessage\n   * @param shift\n   * @return message\n   */\n  public static String decode(String encryptedMessage, int shift) {\n    String decoded = \"\";\n\n    shift %= 26;\n\n    final int length = encryptedMessage.length();\n    for (int i = 0; i < length; i++) {\n      char current = encryptedMessage.charAt(i);\n      if (IsCapitalLatinLetter(current)) {\n\n        current -= shift;\n        decoded += (char) (current < 'A' ? current + 26 : current); // 26 = number of latin letters\n\n      } else if (IsSmallLatinLetter(current)) {\n\n        current -= shift;\n        decoded += (char) (current < 'a' ? current + 26 : current); // 26 = number of latin letters\n\n      } else {\n        decoded += current;\n      }\n    }\n    return decoded;\n  }\n\n  /**\n   * @param c\n   * @return true if character is capital Latin letter or false for others\n   */\n  private static boolean IsCapitalLatinLetter(char c) {\n    return c >= 'A' && c <= 'Z';\n  }\n\n  /**\n   * @param c\n   * @return true if character is small Latin letter or false for others\n   */\n  private static boolean IsSmallLatinLetter(char c) {\n    return c >= 'a' && c <= 'z';\n  }\n\n  public static void main(String[] args) {\n    Scanner input = new Scanner(System.in);\n    System.out.println(\"Please enter the message (Latin Alphabet)\");\n    String message = input.nextLine();\n    System.out.println(message);\n    System.out.println(\"Please enter the shift number\");\n    int shift = input.nextInt() % 26;\n    System.out.println(\"(E)ncode or (D)ecode ?\");\n    char choice = input.next().charAt(0);\n    switch (choice) {\n      case 'E':\n      case 'e':\n        System.out.println(\n            \"ENCODED MESSAGE IS \\n\" + encode(message, shift)); // send our function to handle\n        break;\n      case 'D':\n      case 'd':\n        System.out.println(\"DECODED MESSAGE IS \\n\" + decode(message, shift));\n      default:\n        System.out.println(\"default case\");\n    }\n    input.close();\n  }\n}\n","index":234},{"title":"Columnar Transposition Cipher","category":"ciphers","id":"ColumnarTranspositionCipher_ciphers","algorithm":"package ciphers;\n\n/**\n * Columnar Transposition Cipher Encryption and Decryption.\n *\n * @author <a href=\"https://github.com/freitzzz\">freitzzz</a>\n */\npublic class ColumnarTranspositionCipher {\n\n  private static String keyword;\n  private static Object[][] table;\n  private static String abecedarium;\n  public static final String ABECEDARIUM =\n      \"abcdefghijklmnopqrstuvwxyzABCDEFG\" + \"HIJKLMNOPQRSTUVWXYZ0123456789,.;:-@\";\n  private static final String ENCRYPTION_FIELD = \"≈\";\n  private static final char ENCRYPTION_FIELD_CHAR = '≈';\n\n  /**\n   * Encrypts a certain String with the Columnar Transposition Cipher Rule\n   *\n   * @param word Word being encrypted\n   * @param keyword String with keyword being used\n   * @return a String with the word encrypted by the Columnar Transposition Cipher Rule\n   */\n  public static String encrpyter(String word, String keyword) {\n    ColumnarTranspositionCipher.keyword = keyword;\n    abecedariumBuilder(500);\n    table = tableBuilder(word);\n    Object[][] sortedTable = sortTable(table);\n    String wordEncrypted = \"\";\n    for (int i = 0; i < sortedTable[i].length; i++) {\n      for (int j = 1; j < sortedTable.length; j++) {\n        wordEncrypted += sortedTable[j][i];\n      }\n    }\n    return wordEncrypted;\n  }\n\n  /**\n   * Encrypts a certain String with the Columnar Transposition Cipher Rule\n   *\n   * @param word Word being encrypted\n   * @param keyword String with keyword being used\n   * @param abecedarium String with the abecedarium being used. null for default one\n   * @return a String with the word encrypted by the Columnar Transposition Cipher Rule\n   */\n  public static String encrpyter(String word, String keyword, String abecedarium) {\n    ColumnarTranspositionCipher.keyword = keyword;\n    if (abecedarium != null) {\n      ColumnarTranspositionCipher.abecedarium = abecedarium;\n    } else {\n      ColumnarTranspositionCipher.abecedarium = ABECEDARIUM;\n    }\n    table = tableBuilder(word);\n    Object[][] sortedTable = sortTable(table);\n    String wordEncrypted = \"\";\n    for (int i = 0; i < sortedTable[0].length; i++) {\n      for (int j = 1; j < sortedTable.length; j++) {\n        wordEncrypted += sortedTable[j][i];\n      }\n    }\n    return wordEncrypted;\n  }\n\n  /**\n   * Decrypts a certain encrypted String with the Columnar Transposition Cipher Rule\n   *\n   * @return a String decrypted with the word encrypted by the Columnar Transposition Cipher Rule\n   */\n  public static String decrypter() {\n    String wordDecrypted = \"\";\n    for (int i = 1; i < table.length; i++) {\n      for (Object item : table[i]) {\n        wordDecrypted += item;\n      }\n    }\n    return wordDecrypted.replaceAll(ENCRYPTION_FIELD, \"\");\n  }\n\n  /**\n   * Builds a table with the word to be encrypted in rows by the Columnar Transposition Cipher Rule\n   *\n   * @return An Object[][] with the word to be encrypted filled in rows and columns\n   */\n  private static Object[][] tableBuilder(String word) {\n    Object[][] table = new Object[numberOfRows(word) + 1][keyword.length()];\n    char[] wordInChards = word.toCharArray();\n    // Fils in the respective numbers\n    table[0] = findElements();\n    int charElement = 0;\n    for (int i = 1; i < table.length; i++) {\n      for (int j = 0; j < table[i].length; j++) {\n        if (charElement < wordInChards.length) {\n          table[i][j] = wordInChards[charElement];\n          charElement++;\n        } else {\n          table[i][j] = ENCRYPTION_FIELD_CHAR;\n        }\n      }\n    }\n    return table;\n  }\n\n  /**\n   * Determines the number of rows the table should have regarding the Columnar Transposition Cipher\n   * Rule\n   *\n   * @return an int with the number of rows that the table should have in order to respect the\n   *     Columnar Transposition Cipher Rule.\n   */\n  private static int numberOfRows(String word) {\n    if (word.length() / keyword.length() > word.length() / keyword.length()) {\n      return (word.length() / keyword.length()) + 1;\n    } else {\n      return word.length() / keyword.length();\n    }\n  }\n\n  /** @return charValues */\n  private static Object[] findElements() {\n    Object[] charValues = new Object[keyword.length()];\n    for (int i = 0; i < charValues.length; i++) {\n      int charValueIndex = abecedarium.indexOf(keyword.charAt(i));\n      charValues[i] = charValueIndex > -1 ? charValueIndex : null;\n    }\n    return charValues;\n  }\n\n  /**\n   * @param table\n   * @return tableSorted\n   */\n  private static Object[][] sortTable(Object[][] table) {\n    Object[][] tableSorted = new Object[table.length][table[0].length];\n    for (int i = 0; i < tableSorted.length; i++) {\n      System.arraycopy(table[i], 0, tableSorted[i], 0, tableSorted[i].length);\n    }\n    for (int i = 0; i < tableSorted[0].length; i++) {\n      for (int j = i + 1; j < tableSorted[0].length; j++) {\n        if ((int) tableSorted[0][i] > (int) table[0][j]) {\n          Object[] column = getColumn(tableSorted, tableSorted.length, i);\n          switchColumns(tableSorted, j, i, column);\n        }\n      }\n    }\n    return tableSorted;\n  }\n\n  /**\n   * @param table\n   * @param rows\n   * @param column\n   * @return columnArray\n   */\n  private static Object[] getColumn(Object[][] table, int rows, int column) {\n    Object[] columnArray = new Object[rows];\n    for (int i = 0; i < rows; i++) {\n      columnArray[i] = table[i][column];\n    }\n    return columnArray;\n  }\n\n  /**\n   * @param table\n   * @param firstColumnIndex\n   * @param secondColumnIndex\n   * @param columnToSwitch\n   */\n  private static void switchColumns(\n      Object[][] table, int firstColumnIndex, int secondColumnIndex, Object[] columnToSwitch) {\n    for (int i = 0; i < table.length; i++) {\n      table[i][secondColumnIndex] = table[i][firstColumnIndex];\n      table[i][firstColumnIndex] = columnToSwitch[i];\n    }\n  }\n\n  /**\n   * Creates an abecedarium with a specified ascii inded\n   *\n   * @param value Number of characters being used based on the ASCII Table\n   */\n  private static void abecedariumBuilder(int value) {\n    abecedarium = \"\";\n    for (int i = 0; i < value; i++) {\n      abecedarium += (char) i;\n    }\n  }\n\n  private static void showTable() {\n    for (Object[] table1 : table) {\n      for (Object item : table1) {\n        System.out.print(item + \" \");\n      }\n      System.out.println();\n    }\n  }\n\n  public static void main(String[] args) {\n    String keywordForExample = \"asd215\";\n    String wordBeingEncrypted = \"This is a test of the Columnar Transposition Cipher\";\n    System.out.println(\"### Example of Columnar Transposition Cipher ###\\n\");\n    System.out.println(\"Word being encryped ->>> \" + wordBeingEncrypted);\n    System.out.println(\n        \"Word encrypted ->>> \"\n            + ColumnarTranspositionCipher.encrpyter(wordBeingEncrypted, keywordForExample));\n    System.out.println(\"Word decryped ->>> \" + ColumnarTranspositionCipher.decrypter());\n    System.out.println(\"\\n### Encrypted Table ###\");\n    showTable();\n  }\n}\n","index":235},{"title":"R S A","category":"ciphers","id":"RSA_ciphers","algorithm":"package ciphers;\n\nimport java.math.BigInteger;\nimport java.security.SecureRandom;\nimport javax.swing.JOptionPane;\n\n/** @author Nguyen Duy Tiep on 23-Oct-17. */\npublic final class RSA {\n\n  public static void main(String[] args) {\n\n    RSA rsa = new RSA(1024);\n    String text1 = JOptionPane.showInputDialog(\"Enter a message to encrypt :\");\n\n    String ciphertext = rsa.encrypt(text1);\n    JOptionPane.showMessageDialog(null, \"Your encrypted message : \" + ciphertext);\n\n    JOptionPane.showMessageDialog(null, \"Your message after decrypt : \" + rsa.decrypt(ciphertext));\n  }\n\n  private BigInteger modulus, privateKey, publicKey;\n\n  /** @param bits */\n  public RSA(int bits) {\n    generateKeys(bits);\n  }\n\n  /**\n   * @param message\n   * @return encrypted message\n   */\n  public synchronized String encrypt(String message) {\n    return (new BigInteger(message.getBytes())).modPow(publicKey, modulus).toString();\n  }\n\n  /**\n   * @param message\n   * @return encrypted message as big integer\n   */\n  public synchronized BigInteger encrypt(BigInteger message) {\n    return message.modPow(publicKey, modulus);\n  }\n\n  /**\n   * @param encryptedMessage\n   * @return plain message\n   */\n  public synchronized String decrypt(String encryptedMessage) {\n    return new String((new BigInteger(encryptedMessage)).modPow(privateKey, modulus).toByteArray());\n  }\n\n  /**\n   * @param encryptedMessage\n   * @return plain message as big integer\n   */\n  public synchronized BigInteger decrypt(BigInteger encryptedMessage) {\n    return encryptedMessage.modPow(privateKey, modulus);\n  }\n\n  /**\n   * Generate a new public and private key set.\n   *\n   * @param bits\n   */\n  public synchronized void generateKeys(int bits) {\n    SecureRandom r = new SecureRandom();\n    BigInteger p = new BigInteger(bits / 2, 100, r);\n    BigInteger q = new BigInteger(bits / 2, 100, r);\n    modulus = p.multiply(q);\n\n    BigInteger m = (p.subtract(BigInteger.ONE)).multiply(q.subtract(BigInteger.ONE));\n\n    publicKey = new BigInteger(\"3\");\n\n    while (m.gcd(publicKey).intValue() > 1) {\n      publicKey = publicKey.add(new BigInteger(\"2\"));\n    }\n\n    privateKey = publicKey.modInverse(m);\n  }\n}\n","index":236},{"title":"Simple Substitution Cipher","category":"ciphers","id":"SimpleSubstitutionCipher_ciphers","algorithm":"package ciphers;\n\nimport java.util.*;\n\n/**\n * The simple substitution cipher is a cipher that has been in use for many hundreds of years (an\n * excellent history is given in Simon Singhs 'the Code Book'). It basically consists of\n * substituting every plaintext character for a different ciphertext character. It differs from the\n * Caesar cipher in that the cipher alphabet is not simply the alphabet shifted, it is completely\n * jumbled.\n *\n * @author Hassan Elseoudy\n */\npublic class SimpleSubstitutionCipher {\n\n  /**\n   * Encrypt text by replacing each element with its opposite character.\n   *\n   * @param message\n   * @param cipherSmall\n   * @return Encrypted message\n   */\n  public static String encode(String message, String cipherSmall) {\n    String encoded = \"\";\n\n    // This map is used to encode\n    Map<Character, Character> cipherMap = new HashMap<Character, Character>();\n\n    char beginSmallLetter = 'a';\n    char beginCapitalLetter = 'A';\n\n    cipherSmall = cipherSmall.toLowerCase();\n    String cipherCapital = cipherSmall.toUpperCase();\n\n    // To handle Small and Capital letters\n    for (int i = 0; i < cipherSmall.length(); i++) {\n      cipherMap.put(beginSmallLetter++, cipherSmall.charAt(i));\n      cipherMap.put(beginCapitalLetter++, cipherCapital.charAt(i));\n    }\n\n    for (int i = 0; i < message.length(); i++) {\n      if (Character.isAlphabetic(message.charAt(i))) encoded += cipherMap.get(message.charAt(i));\n      else encoded += message.charAt(i);\n    }\n\n    return encoded;\n  }\n\n  /**\n   * Decrypt message by replacing each element with its opposite character in cipher.\n   *\n   * @param encryptedMessage\n   * @param cipherSmall\n   * @return message\n   */\n  public static String decode(String encryptedMessage, String cipherSmall) {\n    String decoded = \"\";\n\n    Map<Character, Character> cipherMap = new HashMap<Character, Character>();\n\n    char beginSmallLetter = 'a';\n    char beginCapitalLetter = 'A';\n\n    cipherSmall = cipherSmall.toLowerCase();\n    String cipherCapital = cipherSmall.toUpperCase();\n\n    for (int i = 0; i < cipherSmall.length(); i++) {\n      cipherMap.put(cipherSmall.charAt(i), beginSmallLetter++);\n      cipherMap.put(cipherCapital.charAt(i), beginCapitalLetter++);\n    }\n\n    for (int i = 0; i < encryptedMessage.length(); i++) {\n      if (Character.isAlphabetic(encryptedMessage.charAt(i)))\n        decoded += cipherMap.get(encryptedMessage.charAt(i));\n      else decoded += encryptedMessage.charAt(i);\n    }\n\n    return decoded;\n  }\n\n  /** TODO remove main and make JUnit Testing */\n  public static void main(String[] args) {\n    String a = encode(\"defend the east wall of the castle\", \"phqgiumeaylnofdxjkrcvstzwb\");\n    String b = decode(a, \"phqgiumeaylnofdxjkrcvstzwb\");\n    System.out.println(b);\n  }\n}\n","index":237},{"title":"Vigenere","category":"ciphers","id":"Vigenere_ciphers","algorithm":"package ciphers;\r\n\r\n/**\r\n * A Java implementation of Vigenere Cipher.\r\n *\r\n * @author straiffix\r\n */\r\npublic class Vigenere {\r\n\r\n  public static String encrypt(final String message, final String key) {\r\n\r\n    String result = \"\";\r\n\r\n    for (int i = 0, j = 0; i < message.length(); i++) {\r\n      char c = message.charAt(i);\r\n      if (Character.isLetter(c)) {\r\n        if (Character.isUpperCase(c)) {\r\n          result += (char) ((c + key.toUpperCase().charAt(j) - 2 * 'A') % 26 + 'A');\r\n\r\n        } else {\r\n          result += (char) ((c + key.toLowerCase().charAt(j) - 2 * 'a') % 26 + 'a');\r\n        }\r\n      } else {\r\n        result += c;\r\n      }\r\n      j = ++j % key.length();\r\n    }\r\n    return result;\r\n  }\r\n\r\n  public static String decrypt(final String message, final String key) {\r\n    String result = \"\";\r\n\r\n    for (int i = 0, j = 0; i < message.length(); i++) {\r\n\r\n      char c = message.charAt(i);\r\n      if (Character.isLetter(c)) {\r\n        if (Character.isUpperCase(c)) {\r\n          result += ((char) ('Z' - (25 - (c - key.toUpperCase().charAt(j))) % 26));\r\n\r\n        } else {\r\n          result += ((char) ('z' - (25 - (c - key.toLowerCase().charAt(j))) % 26));\r\n        }\r\n      } else {\r\n        result += c;\r\n      }\r\n\r\n      j = ++j % key.length();\r\n    }\r\n    return result;\r\n  }\r\n\r\n  public static void main(String[] args) {\r\n    String text = \"Hello World!\";\r\n    String key = \"itsakey\";\r\n    System.out.println(text);\r\n    String ciphertext = encrypt(text, key);\r\n    System.out.println(ciphertext);\r\n    System.out.println(decrypt(ciphertext, key));\r\n  }\r\n}\r\n","index":238},{"title":"Divideconquer","category":null,"id":"divideconquer","index":239},{"title":"Closest Pair","category":"divideconquer","id":"ClosestPair_divideconquer","algorithm":"package divideconquer;\n\n/**\n * For a set of points in a coordinates system (10000 maximum), ClosestPair class calculates the two\n * closest points.\n *\n * @author: anonymous\n * @author: Marisa Afuera\n */\npublic final class ClosestPair {\n\n  /** Number of points */\n  int numberPoints = 0;\n  /** Input data, maximum 10000. */\n  private Location[] array;\n  /** Minimum point coordinate. */\n  Location point1 = null;\n  /** Minimum point coordinate. */\n  Location point2 = null;\n  /** Minimum point length. */\n  private static double minNum = Double.MAX_VALUE;\n\n  public static void setMinNum(double minNum) {\n    ClosestPair.minNum = minNum;\n  }\n\n  public static void setSecondCount(int secondCount) {\n    ClosestPair.secondCount = secondCount;\n  }\n\n  /** secondCount */\n  private static int secondCount = 0;\n\n  /** Constructor. */\n  ClosestPair(int points) {\n    numberPoints = points;\n    array = new Location[numberPoints];\n  }\n\n  /** Location class is an auxiliary type to keep points coordinates. */\n  public static class Location {\n\n    double x = 0;\n    double y = 0;\n\n    /**\n     * @param xpar (IN Parameter) x coordinate <br>\n     * @param ypar (IN Parameter) y coordinate <br>\n     */\n    Location(final double xpar, final double ypar) { // Save x, y coordinates\n      this.x = xpar;\n      this.y = ypar;\n    }\n  }\n\n  public Location[] createLocation(int numberValues) {\n    return new Location[numberValues];\n  }\n\n  public Location buildLocation(double x, double y) {\n    return new Location(x, y);\n  }\n\n  /**\n   * xPartition function: arrange x-axis.\n   *\n   * @param a (IN Parameter) array of points <br>\n   * @param first (IN Parameter) first point <br>\n   * @param last (IN Parameter) last point <br>\n   * @return pivot index\n   */\n  public int xPartition(final Location[] a, final int first, final int last) {\n\n    Location pivot = a[last]; // pivot\n    int i = first - 1;\n    Location temp; // Temporarily store value for position transformation\n    for (int j = first; j <= last - 1; j++) {\n      if (a[j].x <= pivot.x) { // Less than or less than pivot\n        i++;\n        temp = a[i]; // array[i] <-> array[j]\n        a[i] = a[j];\n        a[j] = temp;\n      }\n    }\n    i++;\n    temp = a[i]; // array[pivot] <-> array[i]\n    a[i] = a[last];\n    a[last] = temp;\n    return i; // pivot index\n  }\n\n  /**\n   * yPartition function: arrange y-axis.\n   *\n   * @param a (IN Parameter) array of points <br>\n   * @param first (IN Parameter) first point <br>\n   * @param last (IN Parameter) last point <br>\n   * @return pivot index\n   */\n  public int yPartition(final Location[] a, final int first, final int last) {\n\n    Location pivot = a[last]; // pivot\n    int i = first - 1;\n    Location temp; // Temporarily store value for position transformation\n    for (int j = first; j <= last - 1; j++) {\n      if (a[j].y <= pivot.y) { // Less than or less than pivot\n        i++;\n        temp = a[i]; // array[i] <-> array[j]\n        a[i] = a[j];\n        a[j] = temp;\n      }\n    }\n    i++;\n    temp = a[i]; // array[pivot] <-> array[i]\n    a[i] = a[last];\n    a[last] = temp;\n    return i; // pivot index\n  }\n\n  /**\n   * xQuickSort function: //x-axis Quick Sorting.\n   *\n   * @param a (IN Parameter) array of points <br>\n   * @param first (IN Parameter) first point <br>\n   * @param last (IN Parameter) last point <br>\n   */\n  public void xQuickSort(final Location[] a, final int first, final int last) {\n\n    if (first < last) {\n      int q = xPartition(a, first, last); // pivot\n      xQuickSort(a, first, q - 1); // Left\n      xQuickSort(a, q + 1, last); // Right\n    }\n  }\n\n  /**\n   * yQuickSort function: //y-axis Quick Sorting.\n   *\n   * @param a (IN Parameter) array of points <br>\n   * @param first (IN Parameter) first point <br>\n   * @param last (IN Parameter) last point <br>\n   */\n  public void yQuickSort(final Location[] a, final int first, final int last) {\n\n    if (first < last) {\n      int q = yPartition(a, first, last); // pivot\n      yQuickSort(a, first, q - 1); // Left\n      yQuickSort(a, q + 1, last); // Right\n    }\n  }\n\n  /**\n   * closestPair function: find closest pair.\n   *\n   * @param a (IN Parameter) array stored before divide <br>\n   * @param indexNum (IN Parameter) number coordinates divideArray <br>\n   * @return minimum distance <br>\n   */\n  public double closestPair(final Location[] a, final int indexNum) {\n\n    Location[] divideArray = new Location[indexNum];\n    System.arraycopy(a, 0, divideArray, 0, indexNum); // Copy previous array\n    int divideX = indexNum / 2; // Intermediate value for divide\n    Location[] leftArray = new Location[divideX]; // divide - left array\n    // divide-right array\n    Location[] rightArray = new Location[indexNum - divideX];\n    if (indexNum <= 3) { // If the number of coordinates is 3 or less\n      return bruteForce(divideArray);\n    }\n    // divide-left array\n    System.arraycopy(divideArray, 0, leftArray, 0, divideX);\n    // divide-right array\n    System.arraycopy(divideArray, divideX, rightArray, 0, indexNum - divideX);\n\n    double minLeftArea = 0; // Minimum length of left array\n    double minRightArea = 0; // Minimum length of right array\n    double minValue = 0; // Minimum lengt\n\n    minLeftArea = closestPair(leftArray, divideX); // recursive closestPair\n    minRightArea = closestPair(rightArray, indexNum - divideX);\n    // window size (= minimum length)\n    minValue = Math.min(minLeftArea, minRightArea);\n\n    // Create window.  Set the size for creating a window\n    // and creating a new array for the coordinates in the window\n    for (int i = 0; i < indexNum; i++) {\n      double xGap = Math.abs(divideArray[divideX].x - divideArray[i].x);\n      if (xGap < minValue) {\n        ClosestPair.setSecondCount(secondCount + 1); // size of the array\n      } else {\n        if (divideArray[i].x > divideArray[divideX].x) {\n          break;\n        }\n      }\n    }\n    // new array for coordinates in window\n    Location[] firstWindow = new Location[secondCount];\n    int k = 0;\n    for (int i = 0; i < indexNum; i++) {\n      double xGap = Math.abs(divideArray[divideX].x - divideArray[i].x);\n      if (xGap < minValue) { // if it's inside a window\n        firstWindow[k] = divideArray[i]; // put in an array\n        k++;\n      } else {\n        if (divideArray[i].x > divideArray[divideX].x) {\n          break;\n        }\n      }\n    }\n    yQuickSort(firstWindow, 0, secondCount - 1); // Sort by y coordinates\n    /* Coordinates in Window */\n    double length = 0;\n    // size comparison within window\n    for (int i = 0; i < secondCount - 1; i++) {\n      for (int j = (i + 1); j < secondCount; j++) {\n        double xGap = Math.abs(firstWindow[i].x - firstWindow[j].x);\n        double yGap = Math.abs(firstWindow[i].y - firstWindow[j].y);\n        if (yGap < minValue) {\n          length = Math.sqrt(Math.pow(xGap, 2) + Math.pow(yGap, 2));\n          // If measured distance is less than current min distance\n          if (length < minValue) {\n            // Change minimum distance to current distance\n            minValue = length;\n            // Conditional for registering final coordinate\n            if (length < minNum) {\n              ClosestPair.setMinNum(length);\n              point1 = firstWindow[i];\n              point2 = firstWindow[j];\n            }\n          }\n        } else {\n          break;\n        }\n      }\n    }\n    ClosestPair.setSecondCount(0);\n    return minValue;\n  }\n\n  /**\n   * bruteForce function: When the number of coordinates is less than 3.\n   *\n   * @param arrayParam (IN Parameter) array stored before divide <br>\n   * @return <br>\n   */\n  public double bruteForce(final Location[] arrayParam) {\n\n    double minValue = Double.MAX_VALUE; // minimum distance\n    double length = 0;\n    double xGap = 0; // Difference between x coordinates\n    double yGap = 0; // Difference between y coordinates\n    double result = 0;\n\n    if (arrayParam.length == 2) {\n      // Difference between x coordinates\n      xGap = (arrayParam[0].x - arrayParam[1].x);\n      // Difference between y coordinates\n      yGap = (arrayParam[0].y - arrayParam[1].y);\n      // distance between coordinates\n      length = Math.sqrt(Math.pow(xGap, 2) + Math.pow(yGap, 2));\n      // Conditional statement for registering final coordinate\n      if (length < minNum) {\n        ClosestPair.setMinNum(length);\n      }\n      point1 = arrayParam[0];\n      point2 = arrayParam[1];\n      result = length;\n    }\n    if (arrayParam.length == 3) {\n      for (int i = 0; i < arrayParam.length - 1; i++) {\n        for (int j = (i + 1); j < arrayParam.length; j++) {\n          // Difference between x coordinates\n          xGap = (arrayParam[i].x - arrayParam[j].x);\n          // Difference between y coordinates\n          yGap = (arrayParam[i].y - arrayParam[j].y);\n          // distance between coordinates\n          length = Math.sqrt(Math.pow(xGap, 2) + Math.pow(yGap, 2));\n          // If measured distance is less than current min distance\n          if (length < minValue) {\n            // Change minimum distance to current distance\n            minValue = length;\n            if (length < minNum) {\n              // Registering final coordinate\n              ClosestPair.setMinNum(length);\n              point1 = arrayParam[i];\n              point2 = arrayParam[j];\n            }\n          }\n        }\n      }\n      result = minValue;\n    }\n    return result; // If only one point returns 0.\n  }\n\n  /**\n   * main function: execute class.\n   *\n   * @param args (IN Parameter) <br>\n   * @throws IOException If an input or output exception occurred\n   */\n  public static void main(final String[] args) {\n\n    // Input data consists of one x-coordinate and one y-coordinate\n\n    ClosestPair cp = new ClosestPair(12);\n    cp.array[0] = cp.buildLocation(2, 3);\n    cp.array[1] = cp.buildLocation(2, 16);\n    cp.array[2] = cp.buildLocation(3, 9);\n    cp.array[3] = cp.buildLocation(6, 3);\n    cp.array[4] = cp.buildLocation(7, 7);\n    cp.array[5] = cp.buildLocation(19, 4);\n    cp.array[6] = cp.buildLocation(10, 11);\n    cp.array[7] = cp.buildLocation(15, 2);\n    cp.array[8] = cp.buildLocation(15, 19);\n    cp.array[9] = cp.buildLocation(16, 11);\n    cp.array[10] = cp.buildLocation(17, 13);\n    cp.array[11] = cp.buildLocation(9, 12);\n\n    System.out.println(\"Input data\");\n    System.out.println(\"Number of points: \" + cp.array.length);\n    for (int i = 0; i < cp.array.length; i++) {\n      System.out.println(\"x: \" + cp.array[i].x + \", y: \" + cp.array[i].y);\n    }\n\n    cp.xQuickSort(cp.array, 0, cp.array.length - 1); // Sorting by x value\n\n    double result; // minimum distance\n\n    result = cp.closestPair(cp.array, cp.array.length);\n    // ClosestPair start\n    // minimum distance coordinates and distance output\n    System.out.println(\"Output Data\");\n    System.out.println(\"(\" + cp.point1.x + \", \" + cp.point1.y + \")\");\n    System.out.println(\"(\" + cp.point2.x + \", \" + cp.point2.y + \")\");\n    System.out.println(\"Minimum Distance : \" + result);\n  }\n}\n","index":240},{"title":"Skyline Algorithm","category":"divideconquer","id":"SkylineAlgorithm_divideconquer","algorithm":"package divideconquer;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Comparator;\r\n\r\n/**\r\n * @author dimgrichr\r\n *     <p>Space complexity: O(n) Time complexity: O(nlogn), because it is a divide and conquer\r\n *     algorithm\r\n */\r\npublic class SkylineAlgorithm {\r\n  private ArrayList<Point> points;\r\n\r\n  /**\r\n   * Main constructor of the application. ArrayList points gets created, which represents the sum of\r\n   * all edges.\r\n   */\r\n  public SkylineAlgorithm() {\r\n    points = new ArrayList<>();\r\n  }\r\n\r\n  /** @return points, the ArrayList that includes all points. */\r\n  public ArrayList<Point> getPoints() {\r\n    return points;\r\n  }\r\n\r\n  /**\r\n   * The main divide and conquer, and also recursive algorithm. It gets an ArrayList full of points\r\n   * as an argument. If the size of that ArrayList is 1 or 2, the ArrayList is returned as it is, or\r\n   * with one less point (if the initial size is 2 and one of it's points, is dominated by the other\r\n   * one). On the other hand, if the ArrayList's size is bigger than 2, the function is called\r\n   * again, twice, with arguments the corresponding half of the initial ArrayList each time. Once\r\n   * the flashback has ended, the function produceFinalSkyLine gets called, in order to produce the\r\n   * final skyline, and return it.\r\n   *\r\n   * @param list, the initial list of points\r\n   * @return leftSkyLine, the combination of first half's and second half's skyline\r\n   * @see Point\r\n   */\r\n  public ArrayList<Point> produceSubSkyLines(ArrayList<Point> list) {\r\n\r\n    // part where function exits flashback\r\n    int size = list.size();\r\n    if (size == 1) {\r\n      return list;\r\n    } else if (size == 2) {\r\n      if (list.get(0).dominates(list.get(1))) {\r\n        list.remove(1);\r\n      } else {\r\n        if (list.get(1).dominates(list.get(0))) {\r\n          list.remove(0);\r\n        }\r\n      }\r\n      return list;\r\n    }\r\n\r\n    // recursive part of the function\r\n    ArrayList<Point> leftHalf = new ArrayList<>();\r\n    ArrayList<Point> rightHalf = new ArrayList<>();\r\n    for (int i = 0; i < list.size(); i++) {\r\n      if (i < list.size() / 2) {\r\n        leftHalf.add(list.get(i));\r\n      } else {\r\n        rightHalf.add(list.get(i));\r\n      }\r\n    }\r\n    ArrayList<Point> leftSubSkyLine = produceSubSkyLines(leftHalf);\r\n    ArrayList<Point> rightSubSkyLine = produceSubSkyLines(rightHalf);\r\n\r\n    // skyline is produced\r\n    return produceFinalSkyLine(leftSubSkyLine, rightSubSkyLine);\r\n  }\r\n\r\n  /**\r\n   * The first half's skyline gets cleared from some points that are not part of the final skyline\r\n   * (Points with same x-value and different y=values. The point with the smallest y-value is kept).\r\n   * Then, the minimum y-value of the points of first half's skyline is found. That helps us to\r\n   * clear the second half's skyline, because, the points of second half's skyline that have greater\r\n   * y-value of the minimum y-value that we found before, are dominated, so they are not part of the\r\n   * final skyline. Finally, the \"cleaned\" first half's and second half's skylines, are combined,\r\n   * producing the final skyline, which is returned.\r\n   *\r\n   * @param left the skyline of the left part of points\r\n   * @param right the skyline of the right part of points\r\n   * @return left the final skyline\r\n   */\r\n  public ArrayList<Point> produceFinalSkyLine(ArrayList<Point> left, ArrayList<Point> right) {\r\n\r\n    // dominated points of ArrayList left are removed\r\n    for (int i = 0; i < left.size() - 1; i++) {\r\n      if (left.get(i).x == left.get(i + 1).x && left.get(i).y > left.get(i + 1).y) {\r\n        left.remove(i);\r\n        i--;\r\n      }\r\n    }\r\n\r\n    // minimum y-value is found\r\n    int min = left.get(0).y;\r\n    for (int i = 1; i < left.size(); i++) {\r\n      if (min > left.get(i).y) {\r\n        min = left.get(i).y;\r\n        if (min == 1) {\r\n          i = left.size();\r\n        }\r\n      }\r\n    }\r\n\r\n    // dominated points of ArrayList right are removed\r\n    for (int i = 0; i < right.size(); i++) {\r\n      if (right.get(i).y >= min) {\r\n        right.remove(i);\r\n        i--;\r\n      }\r\n    }\r\n\r\n    // final skyline found and returned\r\n    left.addAll(right);\r\n    return left;\r\n  }\r\n\r\n  public static class Point {\r\n    private int x;\r\n    private int y;\r\n\r\n    /**\r\n     * The main constructor of Point Class, used to represent the 2 Dimension points.\r\n     *\r\n     * @param x the point's x-value.\r\n     * @param y the point's y-value.\r\n     */\r\n    public Point(int x, int y) {\r\n      this.x = x;\r\n      this.y = y;\r\n    }\r\n\r\n    /** @return x, the x-value */\r\n    public int getX() {\r\n      return x;\r\n    }\r\n\r\n    /** @return y, the y-value */\r\n    public int getY() {\r\n      return y;\r\n    }\r\n\r\n    /**\r\n     * Based on the skyline theory, it checks if the point that calls the function dominates the\r\n     * argument point.\r\n     *\r\n     * @param p1 the point that is compared\r\n     * @return true if the point wich calls the function dominates p1 false otherwise.\r\n     */\r\n    public boolean dominates(Point p1) {\r\n      // checks if p1 is dominated\r\n      return (this.x < p1.x && this.y <= p1.y) || (this.x <= p1.x && this.y < p1.y);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * It is used to compare the 2 Dimension points, based on their x-values, in order get sorted\r\n   * later.\r\n   */\r\n  class XComparator implements Comparator<Point> {\r\n    @Override\r\n    public int compare(Point a, Point b) {\r\n      return Integer.compare(a.x, b.x);\r\n    }\r\n  }\r\n}\r\n","index":241},{"title":"Strings","category":null,"id":"strings","index":242},{"title":"Alphabetical","category":"strings","id":"Alphabetical_strings","algorithm":"package strings;\n\n/**\n * Alphabetical order is a system whereby character strings are placed in order based on the\n * position of the characters in the conventional ordering of an alphabet. Wikipedia:\n * https://en.wikipedia.org/wiki/Alphabetical_order\n */\nclass Alphabetical {\n\n  public static void main(String[] args) {\n    assert !isAlphabetical(\"123abc\");\n    assert isAlphabetical(\"aBC\");\n    assert isAlphabetical(\"abc\");\n    assert !isAlphabetical(\"xyzabc\");\n    assert isAlphabetical(\"abcxyz\");\n  }\n\n  /**\n   * Check if a string is alphabetical order or not\n   *\n   * @param s a string\n   * @return {@code true} if given string is alphabetical order, otherwise {@code false}\n   */\n  public static boolean isAlphabetical(String s) {\n    s = s.toLowerCase();\n    for (int i = 0; i < s.length() - 1; ++i) {\n      if (!Character.isLetter(s.charAt(i)) || !(s.charAt(i) <= s.charAt(i + 1))) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n","index":243},{"title":"Characters Same","category":"strings","id":"CharactersSame_strings","algorithm":"package strings;\n\npublic class CharactersSame {\n\n  /** Driver Code */\n  public static void main(String[] args) {\n    assert isAllCharactersSame(\"\");\n    assert !isAllCharactersSame(\"aab\");\n    assert isAllCharactersSame(\"aaa\");\n    assert isAllCharactersSame(\"11111\");\n  }\n\n  /**\n   * check if all the characters of a string are same\n   *\n   * @param s the string to check\n   * @return {@code true} if all characters of a string are same, otherwise {@code false}\n   */\n  public static boolean isAllCharactersSame(String s) {\n    for (int i = 1, length = s.length(); i < length; ++i) {\n      if (s.charAt(i) != s.charAt(0)) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n","index":244},{"title":"Check Anagrams","category":"strings","id":"CheckAnagrams_strings","algorithm":"package strings;\n\nimport java.util.Arrays;\n\n/**\n * Two strings are anagrams if they are made of the same letters arranged differently (ignoring the\n * case).\n */\npublic class CheckAnagrams {\n  public static void main(String[] args) {\n    assert isAnagrams(\"Silent\", \"Listen\");\n    assert isAnagrams(\"This is a string\", \"Is this a string\");\n    assert !isAnagrams(\"There\", \"Their\");\n  }\n\n  /**\n   * Check if two strings are anagrams or not\n   *\n   * @param s1 the first string\n   * @param s2 the second string\n   * @return {@code true} if two string are anagrams, otherwise {@code false}\n   */\n  public static boolean isAnagrams(String s1, String s2) {\n    s1 = s1.toLowerCase();\n    s2 = s2.toLowerCase();\n    char[] values1 = s1.toCharArray();\n    char[] values2 = s2.toCharArray();\n    Arrays.sort(values1);\n    Arrays.sort(values2);\n    return new String(values1).equals(new String(values2));\n  }\n}\n","index":245},{"title":"Lower","category":"strings","id":"Lower_strings","algorithm":"package strings;\n\npublic class Lower {\n\n  /** Driver Code */\n  public static void main(String[] args) {\n    String[] strings = {\"ABC\", \"ABC123\", \"abcABC\", \"abc123ABC\"};\n    for (String s : strings) {\n      assert toLowerCase(s).equals(s.toLowerCase());\n    }\n  }\n\n  /**\n   * Converts all of the characters in this {@code String} to lower case\n   *\n   * @param s the string to convert\n   * @return the {@code String}, converted to lowercase.\n   */\n  public static String toLowerCase(String s) {\n    char[] values = s.toCharArray();\n    for (int i = 0; i < values.length; ++i) {\n      if (Character.isLetter(values[i]) && Character.isUpperCase(values[i])) {\n        values[i] = Character.toLowerCase(values[i]);\n      }\n    }\n    return new String(values);\n  }\n}\n","index":246},{"title":"Palindrome","category":"strings","id":"Palindrome_strings","algorithm":"package strings;\n\n/** Wikipedia: https://en.wikipedia.org/wiki/Palindrome */\nclass Palindrome {\n\n  /** Driver Code */\n  public static void main(String[] args) {\n    String[] palindromes = {null, \"\", \"aba\", \"123321\"};\n    for (String s : palindromes) {\n      assert isPalindrome(s) && isPalindromeRecursion(s) && isPalindrome1(s);\n    }\n\n    String[] notPalindromes = {\"abb\", \"abc\", \"abc123\"};\n    for (String s : notPalindromes) {\n      assert !isPalindrome(s) && !isPalindromeRecursion(s) && !isPalindrome1(s);\n    }\n  }\n\n  /**\n   * Check if a string is palindrome string or not\n   *\n   * @param s a string to check\n   * @return {@code true} if given string is palindrome, otherwise {@code false}\n   */\n  public static boolean isPalindrome(String s) {\n    return (s == null || s.length() <= 1) || s.equals(new StringBuilder(s).reverse().toString());\n  }\n\n  /**\n   * Check if a string is palindrome string or not using recursion\n   *\n   * @param s a string to check\n   * @return {@code true} if given string is palindrome, otherwise {@code false}\n   */\n  public static boolean isPalindromeRecursion(String s) {\n    if (s == null || s.length() <= 1) {\n      return true;\n    }\n\n    if (s.charAt(0) != s.charAt(s.length() - 1)) {\n      return false;\n    }\n\n    return isPalindrome(s.substring(1, s.length() - 1));\n  }\n\n  /**\n   * Check if a string is palindrome string or not another way\n   *\n   * @param s a string to check\n   * @return {@code true} if given string is palindrome, otherwise {@code false}\n   */\n  public static boolean isPalindrome1(String s) {\n    if (s == null || s.length() <= 1) {\n      return true;\n    }\n    for (int i = 0, j = s.length() - 1; i < j; ++i, --j) {\n      if (s.charAt(i) != s.charAt(j)) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n","index":247},{"title":"Pangram","category":"strings","id":"Pangram_strings","algorithm":"package strings;\n\n/** Wikipedia: https://en.wikipedia.org/wiki/Pangram */\npublic class Pangram {\n\n  /** Driver Code */\n  public static void main(String[] args) {\n    assert isPangram(\"The quick brown fox jumps over the lazy dog\");\n    assert !isPangram(\"The quick brown fox jumps over the azy dog\"); /* not exists l character */\n  }\n\n  /**\n   * Check if a string is a pangram string or not\n   *\n   * @param s string to check\n   * @return {@code true} if given string is pangram, otherwise {@code false}\n   */\n  public static boolean isPangram(String s) {\n    boolean[] marked = new boolean[26]; /* by default all letters don't exists */\n    char[] values = s.toCharArray();\n    for (char value : values) {\n      if (Character.isLetter(value)) {\n        int index = Character.isUpperCase(value) ? value - 'A' : value - 'a';\n        marked[index] = true; /* mark current character exists */\n      }\n    }\n\n    for (boolean b : marked) {\n      if (!b) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n","index":248},{"title":"Reverse String","category":"strings","id":"ReverseString_strings","algorithm":"package strings;\n\n/** Reverse String using different version */\npublic class ReverseString {\n\n  public static void main(String[] args) {\n    assert reverse(\"abc123\").equals(\"321cba\");\n    assert reverse2(\"abc123\").equals(\"321cba\");\n  }\n\n  /**\n   * easiest way to reverses the string str and returns it\n   *\n   * @param str string to be reversed\n   * @return reversed string\n   */\n  public static String reverse(String str) {\n    return new StringBuilder(str).reverse().toString();\n  }\n\n  /**\n   * second way to reverses the string str and returns it\n   *\n   * @param str string to be reversed\n   * @return reversed string\n   */\n  public static String reverse2(String str) {\n\n    if (str == null || str.isEmpty()) {\n      return str;\n    }\n\n    char[] value = str.toCharArray();\n    for (int i = 0, j = str.length() - 1; i < j; i++, j--) {\n      char temp = value[i];\n      value[i] = value[j];\n      value[j] = temp;\n    }\n    return new String(value);\n  }\n}\n","index":249},{"title":"Rotation","category":"strings","id":"Rotation_strings","algorithm":"package strings;\n\n/**\n * Given a string, moving several characters in front of the string to the end of the string. For\n * example, move the two characters'a' and 'b' in front of the string \"abcdef\" to the end of the\n * string, so that the original string becomes the string \"cdefab\"\n */\npublic class Rotation {\n  public static void main(String[] args) {\n    assert rotation(\"abcdef\", 2).equals(\"cdefab\");\n\n    char[] values = \"abcdef\".toCharArray();\n    rotation(values, 2);\n    assert new String(values).equals(\"cdefab\");\n  }\n\n  /**\n   * Move {@code n} characters in front of given string to the end of string time complexity: O(n)\n   * space complexity: O(n)\n   *\n   * @param s given string\n   * @param n the total characters to be moved\n   * @return string after rotation\n   */\n  public static String rotation(String s, int n) {\n    return s.substring(n) + s.substring(0, n);\n  }\n\n  /**\n   * Move {@code n} characters in front of given character array to the end of array time\n   * complexity: O(n) space complexity: O(1)\n   *\n   * @param values given character array\n   * @param n the total characters to be moved\n   */\n  public static void rotation(char[] values, int n) {\n    reverse(values, 0, n - 1);\n    reverse(values, n, values.length - 1);\n    reverse(values, 0, values.length - 1);\n  }\n\n  /**\n   * Reverse character array\n   *\n   * @param values character array\n   * @param from begin index of given array\n   * @param to end index of given array\n   */\n  public static void reverse(char[] values, int from, int to) {\n    while (from < to) {\n      char temp = values[from];\n      values[from] = values[to];\n      values[to] = temp;\n      from++;\n      to--;\n    }\n  }\n}\n","index":250},{"title":"Upper","category":"strings","id":"Upper_strings","algorithm":"package strings;\n\npublic class Upper {\n\n  /** Driver Code */\n  public static void main(String[] args) {\n    String[] strings = {\"ABC\", \"ABC123\", \"abcABC\", \"abc123ABC\"};\n    for (String s : strings) {\n      assert toUpperCase(s).equals(s.toUpperCase());\n    }\n  }\n\n  /**\n   * Converts all of the characters in this {@code String} to upper case\n   *\n   * @param s the string to convert\n   * @return the {@code String}, converted to uppercase.\n   */\n  public static String toUpperCase(String s) {\n    char[] values = s.toCharArray();\n    for (int i = 0; i < values.length; ++i) {\n      if (Character.isLetter(values[i]) && Character.isLowerCase(values[i])) {\n        values[i] = Character.toUpperCase(values[i]);\n      }\n    }\n    return new String(values);\n  }\n}\n","index":251}]