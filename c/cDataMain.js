[{"title":"C-master","id":"C-master"},{"title":"Client Server","category":null,"id":"client_server","index":0},{"title":"Client","category":"client_server","id":"client_client_server","algorithm":"/**\n * @file\n * @author [Nairit11](https://github.com/Nairit11)\n * @author [Krishna Vedala](https://github.com/kvedala)\n * @brief Client side implementation of Server-Client system.\n * @see client_server/server.c\n */\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#ifdef _WIN32                            // if compiling for Windows\n#define _WINSOCK_DEPRECATED_NO_WARNINGS  // will make the code invalid for next\n                                         // MSVC compiler versions\n#include <winsock2.h>\n#define bzero(b, len) \\\n    (memset((b), '\\0', (len)), (void)0) /**< BSD name not in windows */\n#define read(a, b, c) recv(a, b, c, 0)  /**< map BSD name to Winsock */\n#define write(a, b, c) send(a, b, c, 0) /**< map BSD name to Winsock */\n#define close closesocket               /**< map BSD name to Winsock */\n#else                                   // if not windows platform\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#endif\n\n#define MAX 80             /**< max. characters per message */\n#define PORT 8080          /**< port number to connect to */\n#define SA struct sockaddr /**< shortname for sockaddr */\n\n/**\n * Continuous loop to send and receive over the socket.\n * Exits when \"exit\" is sent from commandline.\n * @param sockfd socket handle number\n */\nvoid func(int sockfd)\n{\n    char buff[MAX];\n    int n;\n    for (;;)\n    {\n        bzero(buff, sizeof(buff));\n        printf(\"Enter the string : \");\n        n = 0;\n        while ((buff[n++] = getchar()) != '\\n')\n        {\n            ;\n        }\n        write(sockfd, buff, sizeof(buff));\n        bzero(buff, sizeof(buff));\n        read(sockfd, buff, sizeof(buff));\n        printf(\"From Server : %s\", buff);\n        if ((strncmp(buff, \"exit\", 4)) == 0)\n        {\n            printf(\"Client Exit...\\n\");\n            break;\n        }\n    }\n}\n\n#ifdef _WIN32\n/** Cleanup function will be automatically called on program exit */\nvoid cleanup() { WSACleanup(); }\n#endif\n\n/**\n * @brief Driver code\n */\nint main()\n{\n#ifdef _WIN32\n    // when using winsock2.h, startup required\n    WSADATA wsData;\n    if (WSAStartup(MAKEWORD(2, 2), &wsData) != 0)\n    {\n        perror(\"WSA Startup error: \\n\");\n        return 0;\n    }\n\n    atexit(cleanup);  // register at-exit function\n#endif\n\n    int sockfd, connfd;\n    struct sockaddr_in servaddr, cli;\n\n    // socket create and verification\n    sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd == -1)\n    {\n        printf(\"socket creation failed...\\n\");\n        exit(0);\n    }\n    else\n    {\n        printf(\"Socket successfully created..\\n\");\n    }\n    bzero(&servaddr, sizeof(servaddr));\n\n    // assign IP, PORT\n    servaddr.sin_family = AF_INET;\n    servaddr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n    servaddr.sin_port = htons(PORT);\n\n    // connect the client socket to server socket\n    if (connect(sockfd, (SA *)&servaddr, sizeof(servaddr)) != 0)\n    {\n        printf(\"connection with the server failed...\\n\");\n        exit(0);\n    }\n    else\n    {\n        printf(\"connected to the server..\\n\");\n    }\n\n    // function for chat\n    func(sockfd);\n\n    // close the socket\n    close(sockfd);\n    return 0;\n}\n","index":1},{"title":"Server","category":"client_server","id":"server_client_server","algorithm":"/**\n * @file\n * @author [Nairit11](https://github.com/Nairit11)\n * @author [Krishna Vedala](https://github.com/kvedala)\n * @brief Server side implementation of Server-Client system.\n * @see client_server/client.c\n */\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// #ifdef HAS_UNISTD\n// #include <unistd.h>\n// #endif\n\n#ifdef _WIN32\n#define _WINSOCK_DEPRECATED_NO_WARNINGS  // will make the code invalid for next\n                                         // MSVC compiler versions\n#include <winsock2.h>\n#define bzero(b, len) \\\n    (memset((b), '\\0', (len)), (void)0) /**< BSD name not in windows */\n#define read(a, b, c) recv(a, b, c, 0)  /**< map BSD name to Winsock */\n#define write(a, b, c) send(a, b, c, 0) /**< map BSD name to Winsock */\n#define close closesocket               /**< map BSD name to Winsock */\n#else\n// if not windows platform\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <sys/socket.h>\n#include <unistd.h>\n#endif\n\n#define MAX 80             /**< max. characters per message */\n#define PORT 8080          /**< port number to connect to */\n#define SA struct sockaddr /**< shortname for sockaddr */\n\n#ifdef _WIN32\n/** Cleanup function will be automatically called on program exit */\nvoid cleanup() { WSACleanup(); }\n#endif\n\n/**\n * Continuous loop to send and receive over the socket.\n * Exits when \"exit\" is sent from commandline.\n * @param sockfd socket handle number\n */\nvoid func(int sockfd)\n{\n    char buff[MAX];\n    int n;\n    // infinite loop for chat\n    for (;;)\n    {\n        bzero(buff, MAX);\n\n        // read the message from client and copy it in buffer\n        read(sockfd, buff, sizeof(buff));\n        // print buffer which contains the client contents\n        printf(\"From client: %s\\t To client : \", buff);\n        bzero(buff, MAX);\n        n = 0;\n        // copy server message in the buffer\n        while ((buff[n++] = getchar()) != '\\n')\n        {\n            ;\n        }\n\n        // and send that buffer to client\n        write(sockfd, buff, sizeof(buff));\n\n        // if msg contains \"Exit\" then server exit and chat ended.\n        if (strncmp(\"exit\", buff, 4) == 0)\n        {\n            printf(\"Server Exit...\\n\");\n            break;\n        }\n    }\n}\n\n/** Driver code */\nint main()\n{\n#ifdef _WIN32\n    // when using winsock2.h, startup required\n    WSADATA wsData;\n    if (WSAStartup(MAKEWORD(2, 2), &wsData) != 0)\n    {\n        perror(\"WSA Startup error: \\n\");\n        return 0;\n    }\n\n    atexit(cleanup);  // register at-exit function\n#endif\n\n    int sockfd, connfd;\n    unsigned int len;\n    struct sockaddr_in servaddr, cli;\n\n    // socket create and verification\n    sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd == -1)\n    {\n        perror(\"socket creation failed...\\n\");\n        exit(0);\n    }\n    else\n    {\n        printf(\"Socket successfully created..\\n\");\n    }\n    bzero(&servaddr, sizeof(servaddr));\n\n    // assign IP, PORT\n    servaddr.sin_family = AF_INET;\n    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);\n    servaddr.sin_port = htons(PORT);\n\n    // Binding newly created socket to given IP and verification\n    if ((bind(sockfd, (SA *)&servaddr, sizeof(servaddr))) != 0)\n    {\n        perror(\"socket bind failed...\\n\");\n        exit(0);\n    }\n    else\n    {\n        printf(\"Socket successfully binded..\\n\");\n    }\n\n    // Now server is ready to listen and verification\n    if ((listen(sockfd, 5)) != 0)\n    {\n        perror(\"Listen failed...\\n\");\n        exit(0);\n    }\n    else\n    {\n        printf(\"Server listening..\\n\");\n    }\n    len = sizeof(cli);\n\n    // Accept the data packet from client and verification\n    connfd = accept(sockfd, (SA *)&cli, &len);\n    if (connfd < 0)\n    {\n        perror(\"server acccept failed...\\n\");\n        exit(0);\n    }\n    else\n    {\n        printf(\"server acccept the client...\\n\");\n    }\n\n    // Function for chatting between client and server\n    func(connfd);\n\n    // After chatting close the socket\n    close(sockfd);\n    return 0;\n}\n","index":2},{"title":"Udp Client","category":"client_server","id":"udp_client_client_server","algorithm":"/**\n * @file\n * @author [TheShubham99](https://github.com/TheShubham99)\n * @author [Krishna Vedala](https://github.com/kvedala)\n * @brief Client side implementation of UDP client-server model\n * @see client_server/udp_server.c\n */\n#ifdef _WIN32                            // if compiling for Windows\n#define _WINSOCK_DEPRECATED_NO_WARNINGS  // will make the code invalid for next\n                                         // MSVC compiler versions\n#include <winsock2.h>\n#define close closesocket /**< map BSD name to Winsock */\n#else                     // if not windows platform\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <unistd.h>\n#endif\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define PORT 8080    /**< port number to connect to */\n#define MAXLINE 1024 /**< maximum characters per line */\n\n#ifdef _WIN32\n/** Cleanup function will be automatically called on program exit */\nvoid cleanup() { WSACleanup(); }\n#endif\n\n/** Driver code */\nint main()\n{\n#ifdef _WIN32\n    // when using winsock2.h, startup required\n    WSADATA wsData;\n    if (WSAStartup(MAKEWORD(2, 2), &wsData) != 0)\n    {\n        perror(\"WSA Startup error: \\n\");\n        return 0;\n    }\n\n    atexit(cleanup);  // register at-exit function\n#endif\n\n    int sockfd;\n    char buffer[MAXLINE];\n    char *hello = \"Hello from client\";\n    struct sockaddr_in servaddr;\n\n    // Creating socket file descriptor\n    if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0)\n    {\n        perror(\"socket creation failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    memset(&servaddr, 0, sizeof(servaddr));\n\n    // Filling server information\n    servaddr.sin_family = AF_INET;\n    servaddr.sin_port = htons(PORT);\n    servaddr.sin_addr.s_addr = INADDR_ANY;\n\n    int n;\n    unsigned int len;\n\n    sendto(sockfd, (const char *)hello, strlen(hello), 0,\n           (const struct sockaddr *)&servaddr, sizeof(servaddr));\n    printf(\"Hello message sent.\\n\");\n\n    n = recvfrom(sockfd, (char *)buffer, MAXLINE, MSG_WAITALL,\n                 (struct sockaddr *)&servaddr, &len);\n    buffer[n] = '\\0';\n    printf(\"Server : %s\\n\", buffer);\n\n    close(sockfd);\n    return 0;\n}\n","index":3},{"title":"Udp Server","category":"client_server","id":"udp_server_client_server","algorithm":"/**\n * @file\n * @author [TheShubham99](https://github.com/TheShubham99)\n * @author [Krishna Vedala](https://github.com/kvedala)\n * @brief Server side implementation of UDP client-server model\n * @see client_server/udp_client.c\n */\n#ifdef _WIN32                            // if compiling for Windows\n#define _WINSOCK_DEPRECATED_NO_WARNINGS  // will make the code invalid for next\n                                         // MSVC compiler versions\n#define close closesocket                /**< map BSD name to Winsock */\n#include <winsock2.h>\n#else  // if not windows platform\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <unistd.h>\n#endif\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define PORT 8080    /**< port number to connect to */\n#define MAXLINE 1024 /**< maximum characters per line */\n\n#ifdef _WIN32\n/** Cleanup function will be automatically called on program exit */\nvoid cleanup() { WSACleanup(); }\n#endif\n\n/** Driver code */\nint main()\n{\n#ifdef _WIN32\n    // when using winsock2.h, startup required\n    WSADATA wsData;\n    if (WSAStartup(MAKEWORD(2, 2), &wsData) != 0)\n    {\n        perror(\"WSA Startup error: \\n\");\n        return 0;\n    }\n\n    atexit(cleanup);  // register at-exit function\n#endif\n\n    int sockfd;\n    char buffer[MAXLINE];\n    char *hello = \"Hello from server\";\n    struct sockaddr_in servaddr, cliaddr;\n\n    // Creating socket file descriptor\n    if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0)\n    {\n        perror(\"socket creation failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    memset(&servaddr, 0, sizeof(servaddr));\n    memset(&cliaddr, 0, sizeof(cliaddr));\n\n    // Filling server information\n    servaddr.sin_family = AF_INET;  // IPv4\n    servaddr.sin_addr.s_addr = INADDR_ANY;\n    servaddr.sin_port = htons(PORT);\n\n    // Bind the socket with the server address\n    if (bind(sockfd, (const struct sockaddr *)&servaddr, sizeof(servaddr)) < 0)\n    {\n        perror(\"bind failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    unsigned int len;\n    int n;\n    n = recvfrom(sockfd, (char *)buffer, MAXLINE, MSG_WAITALL,\n                 (struct sockaddr *)&cliaddr, &len);\n    buffer[n] = '\\0';\n    printf(\"Client : %s\\n\", buffer);\n    sendto(sockfd, (const char *)hello, strlen(hello), 0,\n           (const struct sockaddr *)&cliaddr, len);\n    printf(\"Hello message sent.\\n\");\n\n    close(sockfd);\n\n    return 0;\n}\n","index":4},{"title":"Conversions","category":null,"id":"conversions","index":5},{"title":"Binary To Decimal","category":"conversions","id":"binary_to_decimal_conversions","algorithm":"/**\n * Modified 07/12/2017, Kyler Smith\n *\n */\n\n#include <stdio.h>\n\nint main()\n{\n    int remainder, number = 0, decimal_number = 0, temp = 1;\n    printf(\"/n Enter any binary number= \");\n    scanf(\"%d\", &number);\n\n    // Iterate over the number until the end.\n    while (number > 0)\n    {\n        remainder = number % 10;\n        number = number / 10;\n        decimal_number += remainder * temp;\n        temp = temp * 2;  // used as power of 2\n    }\n\n    printf(\"%d\\n\", decimal_number);\n}\n","index":6},{"title":"Binary To Hexadecimal","category":"conversions","id":"binary_to_hexadecimal_conversions","algorithm":"/*\r\n * C Program to Convert Binary to Hexadecimal\r\n */\r\n#include <stdio.h>\r\n\r\nint main()\r\n{\r\n    long int binary, hexa = 0, i = 1, remainder;\r\n\r\n    printf(\"Enter the binary number: \");\r\n    scanf(\"%ld\", &binary);\r\n    while (binary != 0)\r\n    {\r\n        remainder = binary % 10;\r\n        hexa = hexa + remainder * i;\r\n        i = i * 2;\r\n        binary = binary / 10;\r\n    }\r\n    printf(\"THe Equivalent hexadecimal value: %lX\", hexa);\r\n    return 0;\r\n}\r\n","index":7},{"title":"Binary To Octal","category":"conversions","id":"binary_to_octal_conversions","algorithm":"// Binary number to octal number conversion\n#include <stdio.h>\n\n// Function that returns the last three digits\nint three_digits(int n)\n{\n    int r, d = 0, p = 1;\n\n    for (int i = 0; i < 3; i++)\n    {\n        r = n % 10;\n        d += r * p;\n        p *= 10;\n        n /= 10;\n    }\n    return d;\n}\n\nint main(void)\n{\n    int binary_num, d = 0, base = 1, remainder, td, res = 0, ord = 1;\n\n    printf(\"Enter the binary no: \");\n    scanf(\"%d\", &binary_num);\n\n    while (binary_num > 0)\n    {\n        if (binary_num >\n            111)  // Checking if binary number is greater than three digits\n            td = three_digits(binary_num);\n\n        else\n            td = binary_num;\n\n        binary_num /= 1000;\n\n        d = 0, base = 1;\n\n        // Converting the last three digits to decimal\n        while (td > 0)\n        {\n            remainder = td % 10;\n            td /= 10;\n            d += (base * remainder);\n            base *= 2;\n        }\n\n        res += d * ord;  // Calculating the octal value\n        ord *= 10;\n    }\n\n    printf(\"\\nOctal equivalent is: %d\", res);\n    return 0;\n}\n","index":8},{"title":"C Atoi Str To Integer","category":"conversions","id":"c_atoi_str_to_integer_conversions","algorithm":"/**\n * \\file\n * \\brief Recoding the original atoi function in stdlib.h\n * \\author [Mohammed YMIK](https://github.com/medymik)W\n * The function convert a string passed to an integer\n */\n#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n/**\n * the function take a string and return an integer\n * \\param[out] str pointer to a char address\n */\nint c_atoi(const char *str)\n{\n    int i;\n    int sign;\n    long value;\n    long prev;\n\n    i = 0;\n    sign = 1;\n    value = 0;\n\n    /* skipping the spaces */\n    while (((str[i] <= 13 && str[i] >= 9) || str[i] == 32) && str[i] != '\\0')\n        i++;\n\n    /* store the sign if it is negative sign */\n    if (str[i] == '-')\n        sign = -1;\n    else if (str[i] == '+')\n        sign = 1;\n\n    /* converting char by char to a numeric value */\n    while (str[i] >= 48 && str[i] <= 57 && str[i] != '\\0')\n    {\n        prev = value;\n        value = value * 10 + sign * (str[i] - '0');\n\n        /* managing the overflow */\n        if (sign == 1 && prev > value)\n            return (-1);\n        else if (sign == -1 && prev < value)\n            return (0);\n        i++;\n    }\n    return (value);\n}\n\n/**\n * test the function implementation\n */\nvoid test_c_atoi()\n{\n    printf(\"<<<< TEST FUNCTION >>>>\\n\");\n    assert(c_atoi(\"123\") == atoi(\"123\"));\n    assert(c_atoi(\"-123\") == atoi(\"-123\"));\n    assert(c_atoi(\"\") == atoi(\"\"));\n    assert(c_atoi(\"-h23\") == atoi(\"-h23\"));\n    assert(c_atoi(\"         23\") == atoi(\"         23\"));\n    assert(c_atoi(\"999999999\") == atoi(\"999999999\"));\n    printf(\"<<<< TEST DONE >>>>\\n\");\n}\n\n/**\n * the main function take one argument of type char*\n * example : ./program 123\n */\nint main(int argc, char **argv)\n{\n    test_c_atoi();\n\n    if (argc == 2)\n    {\n        printf(\"Your number + 5 is %d\\n\", c_atoi(argv[1]) + 5);\n        return (0);\n    }\n    printf(\"wrong number of parmeters\\n\");\n    return (1);\n}\n","index":9},{"title":"Decimal To Binary","category":"conversions","id":"decimal_to_binary_conversions","algorithm":"#include <stdio.h>\n#include <stdlib.h>\n\n#define MAXBITS 100\n\nint main()\n{\n    // input of the user\n    int inputNumber;\n\n    // for the remainder\n    int re;\n\n    // contains the bits 0/1\n    int bits[MAXBITS];\n\n    // for the loops\n    int j;\n    int i = 0;\n\n    printf(\"\\t\\tConverter decimal --> binary\\n\\n\");\n\n    // reads a decimal number from the user.\n    printf(\"\\nenter a positive integer number: \");\n    scanf(\"%d\", &inputNumber);\n\n    // make sure the input number is a positive integer.\n    if (inputNumber < 0)\n    {\n        printf(\"only positive integers >= 0\\n\");\n        return 1;\n    }\n\n    // actual processing\n    while (inputNumber > 0)\n    {\n        // computes the remainder by modulo 2\n        re = inputNumber % 2;\n\n        // computes the quotient of division by 2\n        inputNumber = inputNumber / 2;\n\n        bits[i] = re;\n        i++;\n    }\n\n    printf(\"\\n the number in binary is: \");\n\n    // iterates backwards over all bits\n    for (j = i - 1; j >= 0; j--)\n    {\n        printf(\"%d\", bits[j]);\n    }\n\n    // for the case the input number is 0\n    if (i == 0)\n    {\n        printf(\"0\");\n    }\n\n    return 0;\n}\n","index":10},{"title":"Decimal To Binary Recursion","category":"conversions","id":"decimal_to_binary_recursion_conversions","algorithm":"/**\n * @file\n * @brief Convert decimal to binary using recursion algorithm\n */\n#include <assert.h>\n\n/**\n * Decimal to binary using recursion algorithm.\n * For example, if number = 5, the function returns the decimal integer 101.\n * @param number positive integer number to convert\n * @returns integer with digits representing binary value representation of\n * number.\n */\nint decimal_to_binary(unsigned int number)\n{\n    return number == 0 ? 0 : number % 2 + 10 * decimal_to_binary(number / 2);\n}\n\n/** Test function */\nvoid test()\n{\n    const int sets[][2] = {\n        {0, 0}, {1, 1}, {2, 10}, {3, 11}, {4, 100}, {6, 110}, {7, 111},\n        /* add more data sets to test */\n    };\n\n    for (int i = 0, size = sizeof(sets) / sizeof(sets[0]); i < size; ++i)\n    {\n        assert(decimal_to_binary(sets[i][0]) == sets[i][1]);\n    }\n}\n\n/** Driver Code */\nint main()\n{\n    test();\n    return 0;\n}\n","index":11},{"title":"Decimal To Hexa","category":"conversions","id":"decimal_to_hexa_conversions","algorithm":"/*****Decimal to Hexadecimal conversion*******************/\n#include <stdio.h>\nvoid decimal2Hexadecimal(long num);\n\nint main()\n{\n    long decimalnum;\n\n    printf(\"Enter decimal number: \");\n    scanf(\"%ld\", &decimalnum);\n\n    decimal2Hexadecimal(decimalnum);\n\n    return 0;\n}\n\n/********function for convert decimal number to hexadecimal\n * number****************/\nvoid decimal2Hexadecimal(long num)\n{\n    long decimalnum = num;\n    long quotient, remainder;\n    int i, j = 0;\n    char hexadecimalnum[100];\n\n    quotient = decimalnum;\n\n    while (quotient != 0)\n    {\n        remainder = quotient % 16;\n        if (remainder < 10)\n            hexadecimalnum[j++] = 48 + remainder;\n\n        else\n            hexadecimalnum[j++] = 55 + remainder;\n\n        quotient = quotient / 16;\n    }\n\n    // print the hexadecimal number\n\n    for (i = j; i >= 0; i--)\n    {\n        printf(\"%c\", hexadecimalnum[i]);\n    }\n\n    printf(\"\\n\");\n}\n","index":12},{"title":"Decimal To Octal","category":"conversions","id":"decimal_to_octal_conversions","algorithm":"/*****Decimal to octal conversion*******************/\n#include <stdio.h>\nvoid decimal2Octal(long decimalnum);\n\nint main()\n{\n    long decimalnum;\n\n    printf(\"Enter the decimal number: \");\n    scanf(\"%ld\", &decimalnum);\n\n    decimal2Octal(decimalnum);\n\n    return 0;\n}\n\n/********function for convert decimal numbers to octal numbers************/\nvoid decimal2Octal(long decimalnum)\n{\n    long remainder, quotient;\n\n    int octalNumber[100], i = 1, j;\n    quotient = decimalnum;\n\n    while (quotient != 0)\n    {\n        octalNumber[i++] = quotient % 8;\n\n        quotient = quotient / 8;\n    }\n\n    for (j = i - 1; j > 0; j--) printf(\"%d\", octalNumber[j]);\n\n    printf(\"\\n\");\n}\n","index":13},{"title":"Decimal To Octal Recursion","category":"conversions","id":"decimal_to_octal_recursion_conversions","algorithm":"// Program to convert decimal number to octal (Using Reccursion)\n// This program only works for integer decimals\n// Created by Aromal Anil\n\n#include <stdio.h>\nint decimal_to_octal(int decimal)\n{\n    if ((decimal < 8) && (decimal > 0))\n    {\n        return decimal;\n    }\n    else if (decimal == 0)\n    {\n        return 0;\n    }\n    else\n    {\n        return ((decimal_to_octal(decimal / 8) * 10) + decimal % 8);\n    }\n}\nint main()\n{\n    int octalNumber, decimalNumber;\n    printf(\"\\nEnter your decimal number : \");\n    scanf(\"%d\", &decimalNumber);\n    octalNumber = decimal_to_octal(decimalNumber);\n    printf(\"\\nThe octal of %d is : %d\", decimalNumber, octalNumber);\n    return 0;\n}\n","index":14},{"title":"Hexadecimal To Octal","category":"conversions","id":"hexadecimal_to_octal_conversions","algorithm":"/* C program to convert Hexadecimal to Octal number system */\n\n#include <stdio.h>\n\nint main()\n{\n#define MAX_STR_LEN 17\n    char hex[MAX_STR_LEN];\n    long long octal, bin, place;\n    int i = 0, rem, val;\n\n    /* Input hexadecimal number from user */\n    printf(\"Enter any hexadecimal number: \");\n    fgets(hex, MAX_STR_LEN, stdin);\n\n    octal = 0ll;\n    bin = 0ll;\n    place = 0ll;\n\n    /* Hexadecimal to binary conversion */\n    for (i = 0; hex[i] != '\\0'; i++)\n    {\n        bin = bin * place;\n\n        switch (hex[i])\n        {\n        case '0':\n            bin += 0;\n            break;\n        case '1':\n            bin += 1;\n            break;\n        case '2':\n            bin += 10;\n            break;\n        case '3':\n            bin += 11;\n            break;\n        case '4':\n            bin += 100;\n            break;\n        case '5':\n            bin += 101;\n            break;\n        case '6':\n            bin += 110;\n            break;\n        case '7':\n            bin += 111;\n            break;\n        case '8':\n            bin += 1000;\n            break;\n        case '9':\n            bin += 1001;\n            break;\n        case 'a':\n        case 'A':\n            bin += 1010;\n            break;\n        case 'b':\n        case 'B':\n            bin += 1011;\n            break;\n        case 'c':\n        case 'C':\n            bin += 1100;\n            break;\n        case 'd':\n        case 'D':\n            bin += 1101;\n            break;\n        case 'e':\n        case 'E':\n            bin += 1110;\n            break;\n        case 'f':\n        case 'F':\n            bin += 1111;\n            break;\n        default:\n            printf(\"Invalid hexadecimal input.\");\n        }\n\n        place = 10000;\n    }\n\n    place = 1;\n\n    /* Binary to octal conversion */\n    while (bin > 0)\n    {\n        rem = bin % 1000;\n\n        switch (rem)\n        {\n        case 0:\n            val = 0;\n            break;\n        case 1:\n            val = 1;\n            break;\n        case 10:\n            val = 2;\n            break;\n        case 11:\n            val = 3;\n            break;\n        case 100:\n            val = 4;\n            break;\n        case 101:\n            val = 5;\n            break;\n        case 110:\n            val = 6;\n            break;\n        case 111:\n            val = 7;\n            break;\n        }\n\n        octal = (val * place) + octal;\n        bin /= 1000;\n\n        place *= 10;\n    }\n\n    printf(\"Hexadecimal number = %s\\n\", hex);\n    printf(\"Octal number = %lld\", octal);\n\n    return 0;\n}\n","index":15},{"title":"Int To String","category":"conversions","id":"int_to_string_conversions","algorithm":"/**\n * @file\n * @brief Convert a positive integer to string (non-standard function)\n * representation.\n */\n#include <assert.h>\n#include <inttypes.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\n/**\n * Converts an integer value to a null-terminated string using the specified\n * base and stores the result in the array given by str parameter.\n * @param value Value to be converted to a string.\n * @param dest pointer to array in memory to store the resulting null-terminated\n * string.\n * @param base Numerical base used to represent the value as a string, between 2\n * and 16, where 10 means decimal base, 16 hexadecimal, 8 octal, and 2 binary.\n * @returns A pointer to the resulting null-terminated string, same as parameter\n * str.\n * @note The destination array must be pre-allocated by the calling function.\n */\nchar *int_to_string(uint16_t value, char *dest, int base)\n{\n    const char hex_table[] = {'0', '1', '2', '3', '4', '5', '6', '7',\n                              '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};\n\n    int len = 0;\n    do\n    {\n        dest[len++] = hex_table[value % base];\n        value /= base;\n    } while (value != 0);\n\n    /* reverse characters */\n    for (int i = 0, limit = len / 2; i < limit; ++i)\n    {\n        char t = dest[i];\n        dest[i] = dest[len - 1 - i];\n        dest[len - 1 - i] = t;\n    }\n    dest[len] = '\\0';\n    return dest;\n}\n\n/** Test function\n * @returns `void`\n */\nstatic void test()\n{\n    const int MAX_SIZE = 100;\n    char *str1 = (char *)calloc(sizeof(char), MAX_SIZE);\n    char *str2 = (char *)calloc(sizeof(char), MAX_SIZE);\n\n    for (int i = 1; i <= 100; ++i) /* test 100 random numbers */\n    {\n        /* Generate value from 0 to 100 */\n        int value = rand() % 100;\n\n        // assert(strcmp(itoa(value, str1, 2), int_to_string(value, str2, 2)) ==\n        //        0);\n        snprintf(str1, MAX_SIZE, \"%o\", value);  //* standard C - to octal */\n        assert(strcmp(str1, int_to_string(value, str2, 8)) == 0);\n        snprintf(str1, MAX_SIZE, \"%d\", value); /* standard C - to decimal */\n        assert(strcmp(str1, int_to_string(value, str2, 10)) == 0);\n        snprintf(str1, MAX_SIZE, \"%x\", value); /* standard C - to hexadecimal */\n        assert(strcmp(str1, int_to_string(value, str2, 16)) == 0);\n    }\n\n    free(str1);\n    free(str2);\n}\n\n/** Driver Code */\nint main()\n{\n    /* Intializes random number generator */\n    srand(time(NULL));\n    test();\n    return 0;\n}\n","index":16},{"title":"Octal To Decimal","category":"conversions","id":"octal_to_decimal_conversions","algorithm":"#include <math.h>\n#include <stdio.h>\n\n// Converts octal number to decimal\nint convertValue(int num, int i) { return num * pow(8, i); }\n\nlong long toDecimal(int octal_value)\n{\n    int decimal_value = 0, i = 0;\n\n    while (octal_value)\n    {\n        // Extracts right-most digit and then multiplies by 8^i\n        decimal_value += convertValue(octal_value % 10, i++);\n\n        // Shift right in base 10\n        octal_value /= 10;\n    }\n\n    return decimal_value;\n}\n\nint main()\n{\n    printf(\"Enter octal value: \");\n\n    int octal_value;\n\n    scanf(\"%d\", &octal_value);\n\n    long long result = toDecimal(octal_value);\n\n    printf(\"%d in decimal is %lld\\n\", octal_value, result);\n\n    return 0;\n}\n","index":17},{"title":"To Decimal","category":"conversions","id":"to_decimal_conversions","algorithm":"/*\n * convert from any base to decimal\n */\n\n#include <ctype.h>\n#include <stdio.h>\n\nint main(void)\n{\n    int base, i, j;\n    char number[100];\n    unsigned long decimal = 0;\n\n    printf(\"Enter the base: \");\n    scanf(\"%d\", &base);\n    printf(\"Enter the number: \");\n    scanf(\"%s\", &number[0]);\n\n    for (i = 0; number[i] != '\\0'; i++)\n    {\n        if (isdigit(number[i]))\n            number[i] -= '0';\n        else if (isupper(number[i]))\n            number[i] -= 'A' - 10;\n        else if (islower(number[i]))\n            number[i] -= 'a' - 10;\n        else\n            number[i] = base + 1;\n\n        if (number[i] >= base)\n        {\n            printf(\"invalid number\\n\");\n            return 0;\n        }\n    }\n\n    for (j = 0; j < i; j++)\n    {\n        decimal *= base;\n        decimal += number[j];\n    }\n\n    printf(\"%lu\\n\", decimal);\n}\n","index":18},{"title":"Data Structures","category":null,"id":"data_structures","index":19},{"title":"Array","category":"data_structures","id":"array","index":20},{"title":"Carray","category":"array","id":"carray_array","algorithm":"/*\n * CArray.c\n *\n * Author: Leonardo Vencovsky\n * Created on 19/03/2018\n *\n * Modified by: Leonardo Vencovsky\n * Last modified: 19/03/2018\n *\n * Array Implementations in C\n *\n * Compiled in Visual Studio 2017\n *\n */\n\n/*\nReturn Codes\n\n-1 - Array Erased\n0 - Success\n1 - Invalid Position\n2 - Position already initialized (use update function)\n3 - Position not initialized (use insert function)\n4 - Position already empty\n5 - Array is full\n\n*/\n\n#include \"CArray.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\nvoid swap(CArray *array, int position1, int position2);\n\nCArray *getCArray(int size)\n{\n    CArray *array = (CArray *)malloc(sizeof(CArray));\n    array->array = (int *)malloc(sizeof(int) * size);\n    array->size = size;\n    int i;\n    for (i = 0; i < size; i++)\n    {\n        array->array[i] = 0;\n    }\n    return array;\n}\n\nint insertValueCArray(CArray *array, int position, int value)\n{\n    if (position >= 0 && position < array->size)\n    {\n        if (array->array[position] == 0)\n        {\n            array->array[position] = value;\n            return SUCCESS;\n        }\n        else\n            return POSITION_INIT;\n    }\n    return INVALID_POSITION;\n}\n\nint removeValueCArray(CArray *array, int position)\n{\n    if (position >= 0 && position < array->size)\n    {\n        if (array->array[position] != 0)\n        {\n            array->array[position] = 0;\n        }\n        else\n            return POSITION_EMPTY;\n    }\n    return INVALID_POSITION;\n}\n\nint pushValueCArray(CArray *array, int value)\n{\n    int i;\n    int ok = 0;\n    for (i = 0; i < array->size; i++)\n    {\n        if (array->array[i] == 0)\n        {\n            array->array[i] = value;\n            ok = 1;\n            break;\n        }\n    }\n    if (ok == 1)\n        return SUCCESS;\n    else\n        return ARRAY_FULL;\n}\n\nint updateValueCArray(CArray *array, int position, int value)\n{\n    if (position >= 0 && position < array->size)\n    {\n        if (array->array[position] != 0)\n        {\n        }\n\n        else\n            return POSITION_NOT_INIT;\n    }\n    return INVALID_POSITION;\n}\n\nint eraseCArray(CArray *array)\n{\n    int i;\n    for (i = 0; i < array->size; i++)\n    {\n        array->array[i] = 0;\n    }\n    return 0;\n}\n\nint switchValuesCArray(CArray *array, int position1, int position2)\n{\n    if (position1 >= 0 && position1 < array->size && position2 >= 0 &&\n        position2 < array->size)\n    {\n        int temp = array->array[position1];\n        array->array[position1] = array->array[position2];\n        array->array[position2] = temp;\n    }\n    return INVALID_POSITION;\n}\n\nint reverseCArray(CArray *array)\n{\n    int i;\n    for (i = 0; i < array->size / 2; i++)\n    {\n        swap(array, i, array->size - i - 1);\n    }\n    return SUCCESS;\n}\n\nint displayCArray(CArray *array)\n{\n    int i;\n    printf(\"\\nC ARRAY\\n\");\n    for (i = 0; i < array->size; i++)\n    {\n        printf(\"%d \", array->array[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n\nint blenderCArray(CArray *array)\n{\n    srand(time(NULL) * array->size);\n    int i;\n    int total = array->size * 100;\n    for (i = 0; i < total; i++)\n    {\n        swap(array, rand() % array->size, rand() % array->size);\n    }\n    return 0;\n}\n\nCArray *getCopyCArray(CArray *arr)\n{\n    CArray *array = (CArray *)malloc(sizeof(CArray));\n    array->array = (int *)malloc(sizeof(int) * arr->size);\n    array->size = arr->size;\n    int i;\n    for (i = 0; i < arr->size; i++)\n    {\n        array->array[i] = arr->array[i];\n    }\n    return array;\n}\n\nvoid swap(CArray *array, int position1, int position2)\n{\n    int temp = array->array[position1];\n    array->array[position1] = array->array[position2];\n    array->array[position2] = temp;\n}\n\nint bubbleSortCArray(CArray *array)\n{\n    int i, j;\n    for (i = 0; i < array->size - 1; i++)\n    {\n        for (j = 0; j < array->size - i - 1; j++)\n        {\n            if (array->array[j] > array->array[j + 1])\n            {\n                swap(array, j, j + 1);\n            }\n        }\n    }\n    return 0;\n}\n\nint selectionSortCArray(CArray *array)\n{\n    int i, j, min;\n    for (i = 0; i < array->size - 1; i++)\n    {\n        min = i;\n        for (j = i + 1; j < array->size; j++)\n            if (array->array[j] < array->array[min])\n                min = j;\n        swap(array, min, i);\n    }\n    return 0;\n}\n\nint insertionSortCArray(CArray *array)\n{\n    int i, j, num;\n    for (i = 1; i < array->size; i++)\n    {\n        num = array->array[i];\n        j = i - 1;\n        while (j >= 0 && array->array[j] > num)\n        {\n            array->array[j + 1] = array->array[j];\n            j--;\n        }\n        array->array[j + 1] = num;\n    }\n    return 0;\n}\n\nint valueOcurranceCArray(CArray *array, int value)\n{\n    int i, total = 0;\n    for (i = 0; i < array->size; i++)\n    {\n        if (array->array[i] == value)\n            total++;\n    }\n    return total;\n}\n\nCArray *valuePositionsCArray(CArray *array, int value)\n{\n    int i, j = 0;\n    int total = valueOcurranceCArray(array, value);\n    CArray *resultArray = getCArray(total);\n    for (i = 0; i < array->size; i++)\n    {\n        if (array->array[i] == value)\n        {\n            // Hopefully this won't overflow\n            resultArray->array[j] = i;\n            j++;\n        }\n    }\n    return resultArray;\n}\n\nint findMinCArray(CArray *array)\n{\n    int i;\n    int min = array->array[0];\n    for (i = 1; i < array->size; i++)\n    {\n        if (array->array[i] < min)\n        {\n            min = array->array[i];\n        }\n    }\n    return min;\n}\n\nint findMaxCArray(CArray *array)\n{\n    int i;\n    int max = array->array[0];\n    for (i = 1; i < array->size; i++)\n    {\n        if (array->array[i] > max)\n        {\n            max = array->array[i];\n        }\n    }\n    return max;\n}\n","index":21},{"title":"Carray.h","category":"array","id":"carray.h_array","algorithm":"/*\n * CArray.h\n *\n * Author: Leonardo Vencovsky\n * Created on 18/03/2018\n *\n * Modified by: Leonardo Vencovsky\n * Last modified: 19/03/2018\n *\n * Header for Array in C\n *\n * Compiled in Visual Studio 2017\n *\n */\n\n#pragma once\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\n#define ARRAY_ERASED -1\n#define SUCCESS 0\n#define INVALID_POSITION 1\n#define POSITION_INIT 2\n#define POSITION_NOT_INIT 3\n#define POSITION_EMPTY 4\n#define ARRAY_FULL 5\n\n    typedef struct CArray\n    {\n        int *array;\n        int size;\n    } CArray;\n\n    // +-------------------------------------+\n    // |           Returns array             |\n    // +-------------------------------------+\n    CArray *getCArray(int size);\n    CArray *getCopyCArray(CArray *array);\n\n    // +-------------------------------------+\n    // |           Input / Output            |\n    // +-------------------------------------+\n    int insertValueCArray(CArray *array, int position, int value);\n    int removeValueCArray(CArray *array, int position);\n    int pushValueCArray(CArray *array, int value);\n    int updateValueCArray(CArray *array, int position, int value);\n\n    // +-------------------------------------+\n    // |               Erase                 |\n    // +-------------------------------------+\n    int eraseCArray(CArray *array);\n\n    // +-------------------------------------+\n    // |             Switching               |\n    // +-------------------------------------+\n    int switchValuesCArray(CArray *array, int position1, int position2);\n    int reverseCArray(CArray *array);\n\n    // +-------------------------------------+\n    // |              Sorting                |\n    // +-------------------------------------+\n    int bubbleSortCArray(CArray *array);\n    int selectionSortCArray(CArray *array);\n    int insertionSortCArray(CArray *array);\n    int blenderCArray(CArray *array);\n\n    // +-------------------------------------+\n    // |             Searching               |\n    // +-------------------------------------+\n    int valueOcurranceCArray(CArray *array, int value);\n    CArray *valuePositionsCArray(CArray *array, int value);\n    int findMaxCArray(CArray *array);\n    int findMinCArray(CArray *array);\n\n    // +-------------------------------------+\n    // |              Display                |\n    // +-------------------------------------+\n    int displayCArray(CArray *array);\n\n#ifdef __cplusplus\n}\n#endif\n","index":22},{"title":"Carray Tests","category":"array","id":"carray_tests_array","algorithm":"/*\n * CArrayTests.c\n *\n * Author: Leonardo Vencovsky\n * Created on 19/03/2018\n *\n * Modified by: Leonardo Vencovsky\n * Last modified: 19/03/2018\n *\n * Test Cases for Array Implementations in C\n *\n * Compiled in Visual Studio 2017\n *\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include \"CArray.h\"\n\nint CArrayTests()\n{\n    printf(\"\\n\");\n    printf(\" +-------------------------------------+\\n\");\n    printf(\" |                                     |\\n\");\n    printf(\" |               C Array               |\\n\");\n    printf(\" |                                     |\\n\");\n    printf(\" +-------------------------------------+\\n\");\n    printf(\"\\n\");\n\n    CArray *array = getCArray(10);\n\n    int i;\n    for (i = 0; i < array->size; i++)\n    {\n        insertValueCArray(array, i, i + 1);\n    }\n    printf(\"Entered array is:\\n\");\n    displayCArray(array);\n    printf(\"\\nCode: %d\\n\", pushValueCArray(array, 11));  // 5\n\n    for (i = 0; i < array->size; i++)\n    {\n        removeValueCArray(array, i);\n    }\n\n    displayCArray(array);\n\n    printf(\"\\nCode: %d\", removeValueCArray(array, -1));       // 1\n    printf(\"\\nCode: %d\\n\", insertValueCArray(array, -1, 1));  // 1\n\n    // Erase\n    for (i = 0; i < array->size; i++)\n    {\n        insertValueCArray(array, i, i + 1);\n    }\n    eraseCArray(array);\n    displayCArray(array);  // Should give all 0s\n\n    // Switching\n    CArray *arr = getCArray(13);\n    for (i = 0; i < arr->size; i++)\n    {\n        insertValueCArray(arr, i, i + 1);\n    }\n    displayCArray(arr);\n    for (i = 0; i < arr->size / 2; i++)\n    {\n        switchValuesCArray(arr, i, arr->size - i - 1);\n    }\n\n    displayCArray(arr);\n\n    // Or simply...\n    reverseCArray(arr);\n\n    displayCArray(arr);\n\n    // Sorting\n    srand(time(NULL));\n    CArray *barray = getCArray(20);\n    for (i = 0; i < barray->size; i++)\n    {\n        insertValueCArray(barray, i, rand());\n    }\n    CArray *carray = getCopyCArray(barray);\n    CArray *darray = getCopyCArray(barray);\n    printf(\"\\nNot sorted Array:\");\n    displayCArray(barray);\n\n    printf(\"\\nBubble Sort:\");\n    clock_t begin1 = clock();\n    // Timing bubble sort\n    bubbleSortCArray(barray);\n    clock_t end1 = clock();\n    double time_spent1 = (double)(end1 - begin1) / CLOCKS_PER_SEC;\n    displayCArray(barray);\n\n    printf(\"\\nSelection Sort:\");\n    clock_t begin2 = clock();\n    // Timing selection sort\n    selectionSortCArray(carray);\n    clock_t end2 = clock();\n    double time_spent2 = (double)(end2 - begin2) / CLOCKS_PER_SEC;\n    displayCArray(carray);\n\n    printf(\"\\nInsertion Sort:\");\n    clock_t begin3 = clock();\n    // Timing insertion sort\n    insertionSortCArray(darray);\n    clock_t end3 = clock();\n    double time_spent3 = (double)(end3 - begin3) / CLOCKS_PER_SEC;\n    displayCArray(carray);\n\n    // Descending order\n    reverseCArray(barray);\n    // displayCArray(barray);\n\n    //\tprintf(\"\\nBlender:\");\n    //\tblenderCArray(barray);\n    //\tdisplayCArray(barray);\n\n    printf(\"\\nTotal time spent for bubble sort: %lf seconds\", time_spent1);\n    printf(\"\\nTotal time spent for selection sort: %lf seconds\", time_spent2);\n    printf(\"\\nTotal time spent for insertion sort: %lf seconds\", time_spent3);\n\n    // Searching\n    CArray *aarray = getCArray(1000);\n    for (i = 0; i < aarray->size; i++)\n    {\n        insertValueCArray(aarray, i, rand() % 100);\n    }\n\n    int j = 24;\n    printf(\"\\nOccurrences of the number %d in the array: %d\", j,\n           valueOcurranceCArray(aarray, j));\n    printf(\"\\nAnd its positions:\\n\");\n    CArray *positions = valuePositionsCArray(aarray, j);\n    displayCArray(positions);\n    // This should all give value of j\n    printf(\"\\nAll %d s\", j);\n    for (i = 0; i < positions->size; i++)\n    {\n        printf(\"\\nPosition %d has a value of %d\", positions->array[i],\n               aarray->array[positions->array[i]]);\n    }\n    printf(\"\\nThe list has a minimum value of %d and a maximum value of %d\",\n           findMinCArray(aarray), findMaxCArray(aarray));\n    insertionSortCArray(aarray);\n    // displayCArray(aarray);\n\n    free(arr);\n    free(array);\n    free(aarray);\n    free(barray);\n    free(carray);\n    free(darray);\n    printf(\"\\n\");\n    return 0;\n}\n","index":23},{"title":"Binary Trees","category":"data_structures","id":"binary_trees","index":24},{"title":"Avl","category":"binary_trees","id":"avl_binary_trees","algorithm":"#include <stdio.h>\n#include <stdlib.h>\n\nstruct AVLnode\n{\n    int key;\n    struct AVLnode *left;\n    struct AVLnode *right;\n    int height;\n};\ntypedef struct AVLnode avlNode;\n\nint max(int a, int b) { return (a > b) ? a : b; }\n\navlNode *newNode(int key)\n{\n    avlNode *node = (avlNode *)malloc(sizeof(avlNode));\n\n    if (node == NULL)\n        printf(\"!! Out of Space !!\\n\");\n    else\n    {\n        node->key = key;\n        node->left = NULL;\n        node->right = NULL;\n        node->height = 0;\n    }\n\n    return node;\n}\n\nint nodeHeight(avlNode *node)\n{\n    if (node == NULL)\n        return -1;\n    else\n        return (node->height);\n}\n\nint heightDiff(avlNode *node)\n{\n    if (node == NULL)\n        return 0;\n    else\n        return (nodeHeight(node->left) - nodeHeight(node->right));\n}\n\n/* Returns the node with min key in the left subtree*/\navlNode *minNode(avlNode *node)\n{\n    avlNode *temp = node;\n\n    while (temp->left != NULL) temp = temp->left;\n\n    return temp;\n}\n\nvoid printAVL(avlNode *node, int level)\n{\n    int i;\n    if (node != NULL)\n    {\n        printAVL(node->right, level + 1);\n        printf(\"\\n\\n\");\n\n        for (i = 0; i < level; i++) printf(\"\\t\");\n\n        printf(\"%d\", node->key);\n\n        printAVL(node->left, level + 1);\n    }\n}\n\navlNode *rightRotate(avlNode *z)\n{\n    avlNode *y = z->left;\n    avlNode *T3 = y->right;\n\n    y->right = z;\n    z->left = T3;\n\n    z->height = (max(nodeHeight(z->left), nodeHeight(z->right)) + 1);\n    y->height = (max(nodeHeight(y->left), nodeHeight(y->right)) + 1);\n\n    return y;\n}\n\navlNode *leftRotate(avlNode *z)\n{\n    avlNode *y = z->right;\n    avlNode *T3 = y->left;\n\n    y->left = z;\n    z->right = T3;\n\n    z->height = (max(nodeHeight(z->left), nodeHeight(z->right)) + 1);\n    y->height = (max(nodeHeight(y->left), nodeHeight(y->right)) + 1);\n\n    return y;\n}\n\navlNode *LeftRightRotate(avlNode *z)\n{\n    z->left = leftRotate(z->left);\n\n    return (rightRotate(z));\n}\n\navlNode *RightLeftRotate(avlNode *z)\n{\n    z->right = rightRotate(z->right);\n\n    return (leftRotate(z));\n}\n\navlNode *insert(avlNode *node, int key)\n{\n    if (node == NULL)\n        return (newNode(key));\n\n    /*Binary Search Tree insertion*/\n\n    if (key < node->key)\n        node->left =\n            insert(node->left, key); /*Recursive insertion in L subtree*/\n    else if (key > node->key)\n        node->right =\n            insert(node->right, key); /*Recursive insertion in R subtree*/\n\n    /* Node  Height as per the AVL formula*/\n    node->height = (max(nodeHeight(node->left), nodeHeight(node->right)) + 1);\n\n    /*Checking for the balance condition*/\n    int balance = heightDiff(node);\n\n    /*Left Left */\n    if (balance > 1 && key < (node->left->key))\n        return rightRotate(node);\n\n    /*Right Right */\n    if (balance < -1 && key > (node->right->key))\n        return leftRotate(node);\n\n    /*Left Right */\n    if (balance > 1 && key > (node->left->key))\n    {\n        node = LeftRightRotate(node);\n    }\n\n    /*Right Left */\n    if (balance < -1 && key < (node->right->key))\n    {\n        node = RightLeftRotate(node);\n    }\n\n    return node;\n}\n\navlNode *delete (avlNode *node, int queryNum)\n{\n    if (node == NULL)\n        return node;\n\n    if (queryNum < node->key)\n        node->left =\n            delete (node->left, queryNum); /*Recursive deletion in L subtree*/\n    else if (queryNum > node->key)\n        node->right =\n            delete (node->right, queryNum); /*Recursive deletion in R subtree*/\n    else\n    {\n        /*Single or No Child*/\n        if ((node->left == NULL) || (node->right == NULL))\n        {\n            avlNode *temp = node->left ? node->left : node->right;\n\n            /* No Child*/\n            if (temp == NULL)\n            {\n                temp = node;\n                node = NULL;\n            }\n            else /*Single Child : copy data to the parent*/\n                *node = *temp;\n\n            free(temp);\n        }\n        else\n        {\n            /*Two Child*/\n\n            /*Get the smallest key in the R subtree*/\n            avlNode *temp = minNode(node->right);\n            node->key = temp->key; /*Copy that to the root*/\n            node->right =\n                delete (node->right,\n                        temp->key); /*Delete the smallest in the R subtree.*/\n        }\n    }\n\n    /*single node in tree*/\n    if (node == NULL)\n        return node;\n\n    /*Update height*/\n    node->height = (max(nodeHeight(node->left), nodeHeight(node->right)) + 1);\n\n    int balance = heightDiff(node);\n\n    /*Left Left */\n    if ((balance > 1) && (heightDiff(node->left) >= 0))\n        return rightRotate(node);\n\n    /*Left Right */\n    if ((balance > 1) && (heightDiff(node->left) < 0))\n    {\n        node = LeftRightRotate(node);\n    }\n\n    /*Right Right */\n    if ((balance < -1) && (heightDiff(node->right) >= 0))\n        return leftRotate(node);\n\n    /*Right Left */\n    if ((balance < -1) && (heightDiff(node->right) < 0))\n    {\n        node = RightLeftRotate(node);\n    }\n\n    return node;\n}\n\navlNode *findNode(avlNode *node, int queryNum)\n{\n    if (node != NULL)\n    {\n        if (queryNum < node->key)\n            node = findNode(node->left, queryNum);\n        else if (queryNum > node->key)\n            node = findNode(node->right, queryNum);\n    }\n\n    return node;\n}\n\nvoid printPreOrder(avlNode *node)\n{\n    if (node == NULL)\n        return;\n\n    printf(\"  %d  \", (node->key));\n    printPreOrder(node->left);\n    printPreOrder(node->right);\n}\n\nvoid printInOrder(avlNode *node)\n{\n    if (node == NULL)\n        return;\n    printInOrder(node->left);\n    printf(\"  %d  \", (node->key));\n    printInOrder(node->right);\n}\n\nvoid printPostOrder(avlNode *node)\n{\n    if (node == NULL)\n        return;\n    printPostOrder(node->left);\n    printPostOrder(node->right);\n    printf(\"  %d  \", (node->key));\n}\n\nint main()\n{\n    int choice;\n    int flag = 1;\n    int insertNum;\n    int queryNum;\n\n    avlNode *root = NULL;\n    avlNode *tempNode;\n\n    while (flag == 1)\n    {\n        printf(\"\\n\\nEnter the Step to Run : \\n\");\n\n        printf(\"\\t1: Insert a node into AVL tree\\n\");\n        printf(\"\\t2: Delete a node in AVL tree\\n\");\n        printf(\"\\t3: Search a node into AVL tree\\n\");\n        printf(\"\\t4: printPreOrder (Ro L R) Tree\\n\");\n        printf(\"\\t5: printInOrder (L Ro R) Tree\\n\");\n        printf(\"\\t6: printPostOrder (L R Ro) Tree\\n\");\n        printf(\"\\t7: printAVL Tree\\n\");\n\n        printf(\"\\t0: EXIT\\n\");\n        scanf(\"%d\", &choice);\n\n        switch (choice)\n        {\n        case 0:\n        {\n            flag = 0;\n            printf(\"\\n\\t\\tExiting, Thank You !!\\n\");\n            break;\n        }\n\n        case 1:\n        {\n            printf(\"\\n\\tEnter the Number to insert: \");\n            scanf(\"%d\", &insertNum);\n\n            tempNode = findNode(root, insertNum);\n\n            if (tempNode != NULL)\n                printf(\"\\n\\t %d Already exists in the tree\\n\", insertNum);\n            else\n            {\n                printf(\"\\n\\tPrinting AVL Tree\\n\");\n                printAVL(root, 1);\n                printf(\"\\n\");\n\n                root = insert(root, insertNum);\n                printf(\"\\n\\tPrinting AVL Tree\\n\");\n                printAVL(root, 1);\n                printf(\"\\n\");\n            }\n\n            break;\n        }\n\n        case 2:\n        {\n            printf(\"\\n\\tEnter the Number to Delete: \");\n            scanf(\"%d\", &queryNum);\n\n            tempNode = findNode(root, queryNum);\n\n            if (tempNode == NULL)\n                printf(\"\\n\\t %d Does not exist in the tree\\n\", queryNum);\n            else\n            {\n                printf(\"\\n\\tPrinting AVL Tree\\n\");\n                printAVL(root, 1);\n                printf(\"\\n\");\n                root = delete (root, queryNum);\n\n                printf(\"\\n\\tPrinting AVL Tree\\n\");\n                printAVL(root, 1);\n                printf(\"\\n\");\n            }\n\n            break;\n        }\n\n        case 3:\n        {\n            printf(\"\\n\\tEnter the Number to Search: \");\n            scanf(\"%d\", &queryNum);\n\n            tempNode = findNode(root, queryNum);\n\n            if (tempNode == NULL)\n                printf(\"\\n\\t %d : Not Found\\n\", queryNum);\n            else\n            {\n                printf(\"\\n\\t %d : Found at height %d \\n\", queryNum,\n                       tempNode->height);\n\n                printf(\"\\n\\tPrinting AVL Tree\\n\");\n                printAVL(root, 1);\n                printf(\"\\n\");\n            }\n\n            break;\n        }\n\n        case 4:\n        {\n            printf(\"\\nPrinting Tree preOrder\\n\");\n            printPreOrder(root);\n\n            break;\n        }\n\n        case 5:\n        {\n            printf(\"\\nPrinting Tree inOrder\\n\");\n            printInOrder(root);\n\n            break;\n        }\n\n        case 6:\n        {\n            printf(\"\\nPrinting Tree PostOrder\\n\");\n            printPostOrder(root);\n\n            break;\n        }\n\n        case 7:\n        {\n            printf(\"\\nPrinting AVL Tree\\n\");\n            printAVL(root, 1);\n\n            break;\n        }\n\n        default:\n        {\n            flag = 0;\n            printf(\"\\n\\t\\tExiting, Thank You !!\\n\");\n            break;\n        }\n        }\n    }\n\n    return 0;\n}\n","index":25},{"title":"Binary Search Tree","category":"binary_trees","id":"binary_search_tree_binary_trees","algorithm":"/**\n * @file\n * @brief A basic unbalanced binary search tree implementation in C.\n * @details The implementation has the following functionalities implemented:\n * - Insertion\n * - Deletion\n * - Search by key value\n * - Listing of node keys in order of value (from left to right)\n */\n#include <stdio.h>\n#include <stdlib.h>\n\n/** Node, the basic data structure in the tree */\ntypedef struct node\n{\n    struct node *left;  /**< left child */\n    struct node *right; /**< right child */\n    int data;           /**< data of the node */\n} node;\n\n/** The node constructor, which receives the key value input and returns a node\n * pointer\n * @param data data to store in a new node\n * @returns new node with the provided data\n * @note the node must be deleted before program terminates to avoid memory\n * leaks\n */\nnode *newNode(int data)\n{\n    // creates a slug\n    node *tmp = (node *)malloc(sizeof(node));\n\n    // initializes the slug\n    tmp->data = data;\n    tmp->left = NULL;\n    tmp->right = NULL;\n\n    return tmp;\n}\n\n/** Insertion procedure, which inserts the input key in a new node in the tree\n * @param root pointer to parent node\n * @param data value to store int he new node\n * @returns pointer to parent node\n */\nnode *insert(node *root, int data)\n{\n    // If the root of the subtree is null, insert key here\n    if (root == NULL)\n    {\n        root = newNode(data);\n    }\n    else if (data > root->data)\n    {\n        // If it isn't null and the input key is greater than the root key,\n        // insert in the right leaf\n        root->right = insert(root->right, data);\n    }\n    else if (data < root->data)\n    {  // If it isn't null and the input key is lower than the root key, insert\n       // in the left leaf\n        root->left = insert(root->left, data);\n    }\n    // Returns the modified tree\n    return root;\n}\n\n/** Utilitary procedure to find the greatest key in the left subtree\n * @param root pointer to parent node\n * @returns pointer to parent node\n */\nnode *getMax(node *root)\n{\n    // If there's no leaf to the right, then this is the maximum key value\n    if (root->right != NULL)\n    {\n        return getMax(root->right);\n    }\n    return root;\n}\n\n/** Deletion procedure, which searches for the input key in the tree and removes\n * it if present\n * @param root pointer to parent node\n * @param data value to search for int the node\n * @returns pointer to parent node\n */\nnode *delete (node *root, int data)\n{\n    // If the root is null, nothing to be done\n    if (root == NULL)\n    {\n        return root;\n    }\n    else if (data > root->data)\n    {  // If the input key is greater than the root's, search in the right\n        // subtree\n        root->right = delete (root->right, data);\n    }\n    else if (data < root->data)\n    {  // If the input key is lower than the root's, search in the left subtree\n        root->left = delete (root->left, data);\n    }\n    else if (data == root->data)\n    {\n        // If the input key matches the root's, check the following cases\n        // termination condition\n        if ((root->left == NULL) && (root->right == NULL))\n        {  // Case 1: the root has no leaves, remove the node\n            free(root);\n            return NULL;\n        }\n        else if (root->left == NULL)\n        {  // Case 2: the root has one leaf, make the leaf the new root and\n            // remove\n            // the old root\n            node *tmp = root;\n            root = root->right;\n            free(tmp);\n            return root;\n        }\n        else if (root->right == NULL)\n        {\n            node *tmp = root;\n            root = root->left;\n            free(tmp);\n            return root;\n        }\n        else\n        {  // Case 3: the root has 2 leaves, find the greatest key in the left\n            // subtree and switch with the root's\n\n            // finds the biggest node in the left branch.\n            node *tmp = getMax(root->left);\n\n            // sets the data of this node equal to the data of the biggest node\n            // (lefts)\n            root->data = tmp->data;\n            root->left = delete (root->left, tmp->data);\n        }\n    }\n    return root;\n}\n\n/** Search procedure, which looks for the input key in the tree and returns 1 if\n * it's present or 0 if it's not in the tree\n * @param root pointer to parent node\n * @param data value to store int he new node\n * @returns 0 if value not found in the nodes\n * @returns 1 if value was found\n */\nint find(node *root, int data)\n{\n    // If the root is null, the key's not present\n    if (root == NULL)\n    {\n        return 0;\n    }\n    else if (data > root->data)\n    {\n        // If the input key is greater than the root's, search in the right\n        // subtree\n        return find(root->right, data);\n    }\n    else if (data < root->data)\n    {\n        // If the input key is lower than the root's, search in the left subtree\n        return find(root->left, data);\n    }\n    else if (data == root->data)\n    {\n        // If the input and the root key match, return 1\n        return 1;\n    }\n    else\n    {  // unknown result!!\n        return 0;\n    }\n}\n\n/** Utilitary procedure to measure the height of the binary tree\n * @param root pointer to parent node\n * @param data value to store int he new node\n * @returns 0 if value not found in the nodes\n * @returns height of nodes to get to data from parent node\n */\nint height(node *root)\n{\n    // If the root is null, this is the bottom of the tree (height 0)\n    if (root == NULL)\n    {\n        return 0;\n    }\n    else\n    {\n        // Get the height from both left and right subtrees to check which is\n        // the greatest\n        int right_h = height(root->right);\n        int left_h = height(root->left);\n\n        // The final height is the height of the greatest subtree(left or right)\n        // plus 1(which is the root's level)\n        if (right_h > left_h)\n        {\n            return (right_h + 1);\n        }\n        else\n        {\n            return (left_h + 1);\n        }\n    }\n}\n\n/** Utilitary procedure to free all nodes in a tree\n * @param root pointer to parent node\n */\nvoid purge(node *root)\n{\n    if (root != NULL)\n    {\n        if (root->left != NULL)\n        {\n            purge(root->left);\n        }\n        if (root->right != NULL)\n        {\n            purge(root->right);\n        }\n        free(root);\n        root = NULL;  // reset pointer\n    }\n}\n\n/** Traversal procedure to list the current keys in the tree in order of value\n * (from the left to the right)\n * @param root pointer to parent node\n */\nvoid inOrder(node *root)\n{\n    if (root != NULL)\n    {\n        inOrder(root->left);\n        printf(\"\\t[ %d ]\\t\", root->data);\n        inOrder(root->right);\n    }\n}\n\n/** Main funcion */\nint main()\n{\n    // this reference don't change.\n    // only the tree changes.\n    node *root = NULL;\n    int opt = -1;\n    int data = 0;\n\n    // event-loop.\n    while (opt != 0)\n    {\n        printf(\n            \"\\n\\n[1] Insert Node\\n[2] Delete Node\\n[3] Find a Node\\n[4] Get \"\n            \"current Height\\n[5] Print Tree in Crescent Order\\n[0] Quit\\n\");\n        scanf(\"%d\", &opt);  // reads the choice of the user\n\n        // processes the choice\n        switch (opt)\n        {\n        case 1:\n            printf(\"Enter the new node's value:\\n\");\n            scanf(\"%d\", &data);\n            root = insert(root, data);\n            break;\n\n        case 2:\n            printf(\"Enter the value to be removed:\\n\");\n            if (root != NULL)\n            {\n                scanf(\"%d\", &data);\n                root = delete (root, data);\n            }\n            else\n            {\n                printf(\"Tree is already empty!\\n\");\n            }\n            break;\n\n        case 3:\n            printf(\"Enter the searched value:\\n\");\n            scanf(\"%d\", &data);\n            find(root, data) ? printf(\"The value is in the tree.\\n\")\n                             : printf(\"The value is not in the tree.\\n\");\n            break;\n\n        case 4:\n            printf(\"Current height of the tree is: %d\\n\", height(root));\n            break;\n\n        case 5:\n            inOrder(root);\n            break;\n        }\n    }\n\n    // deletes the tree from the heap.\n    purge(root);\n\n    return 0;\n}\n","index":26},{"title":"Create Node","category":"binary_trees","id":"create_node_binary_trees","algorithm":"/* Includes structure for a node and a newNode() function which\n   can be used to create a new node in the tree.\n   It is assumed that the data in nodes will be an integer, though\n   function can be modified according to the data type, easily.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct node\n{\n    struct node *leftNode;\n    int data;\n    struct node *rightNode;\n};\n\nstruct node *newNode(int data)\n{\n    struct node *node = (struct node *)malloc(sizeof(struct node));\n\n    node->leftNode = NULL;\n    node->data = data;\n    node->rightNode = NULL;\n\n    return node;\n}\n\nint main(void)\n{\n    /* new node can be created here as :-\n\n       struct node *nameOfNode = newNode(data);\n\n       and tree can be formed by creating further nodes at\n       nameOfNode->leftNode and so on.\n    */\n\n    return 0;\n}","index":27},{"title":"Recursive Traversals","category":"binary_trees","id":"recursive_traversals_binary_trees","algorithm":"/* Includes the functions for Recursive Traversals\n   of a Binary Tree. It is assumed that nodes and\n   tree have been created as per create_node.c\n */\n\n#include <stdio.h>\n\nvoid inOrderTraversal(struct node *node)\n{\n    if (node == NULL)  // if tree is empty\n        return;\n\n    inOrderTraversal(node->leftNode);\n    printf(\"\\t%d\\t\", node->data);\n    inOrderTraversal(node->rightNode);\n}\n\nvoid preOrderTraversal(struct node *node)\n{\n    if (node == NULL)  // if tree is empty\n        return;\n\n    printf(\"\\t%d\\t\", node->data);\n    preOrderTraversal(node->leftNode);\n    preOrderTraversal(node->rightNode);\n}\n\nvoid postOrderTraversal(struct node *node)\n{\n    if (node == NULL)  // if tree is empty\n        return;\n\n    postOrderTraversal(node->leftNode);\n    postOrderTraversal(node->rightNode);\n    printf(\"\\t%d\\t\", node->data);\n}\n\nint main(void)\n{\n    /* traversals can be done by simply invoking the\n       function with a pointer to the root node.\n    */\n\n    return 0;\n}","index":28},{"title":"Redblacktree","category":"binary_trees","id":"redblacktree_binary_trees","algorithm":"#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct node\n{\n    int val;\n    struct node *par;\n    struct node *left;\n    struct node *right;\n    int color;\n} Node;\n\n// Create a new node\nNode *newNode(int val, Node *par)\n{\n    Node *create = (Node *)(malloc(sizeof(Node)));\n    create->val = val;\n    create->par = par;\n    create->left = NULL;\n    create->right = NULL;\n    create->color = 1;\n}\n\n// Check if the node is the leaf\nint isLeaf(Node *n)\n{\n    if (n->left == NULL && n->right == NULL)\n    {\n        return 1;\n    }\n    return 0;\n}\n\n// Left Rotate\nNode *leftRotate(Node *node)\n{\n    Node *parent = node->par;\n    Node *grandParent = parent->par;\n\n    parent->right = node->left;\n    if (node->left != NULL)\n    {\n        node->left->par = parent;\n    }\n    node->par = grandParent;\n    parent->par = node;\n    node->left = parent;\n    if (grandParent != NULL)\n    {\n        if (grandParent->right == parent)\n        {\n            grandParent->right = node;\n        }\n        else\n        {\n            grandParent->left = node;\n        }\n    }\n    return node;\n}\n\n// Right Rotate\nNode *rightRotate(Node *node)\n{\n    Node *parent = node->par;\n    Node *grandParent = parent->par;\n\n    parent->left = node->right;\n    if (node->right != NULL)\n    {\n        node->right->par = parent;\n    }\n    node->par = grandParent;\n    parent->par = node;\n    node->right = parent;\n    if (grandParent != NULL)\n    {\n        if (grandParent->right == parent)\n        {\n            grandParent->right = node;\n        }\n        else\n        {\n            grandParent->left = node;\n        }\n    }\n    return node;\n}\n\n// Check the node after the insertion step\nvoid checkNode(Node *node)\n{\n    // If the node is the root\n    if (node == NULL || node->par == NULL)\n    {\n        return;\n    }\n    Node *child = node;\n    // If it is a black node or its parent is a black node\n    if (node->color == 0 || (node->par)->color == 0)\n    {\n        // Dont Do Anything\n        return;\n    }\n\n    // Both parent and child are red\n    // Check For Uncle\n    Node *parent = node->par;\n    Node *grandParent = parent->par;\n\n    // If grandParent is NULL, then parent is the root.\n    // Just make the root black.\n    if (grandParent == NULL)\n    {\n        parent->color = 0;\n        return;\n    }\n\n    // If both the children of the grandParent are red\n    if (grandParent->right != NULL && (grandParent->right)->color == 1 &&\n        grandParent->left != NULL && (grandParent->left)->color == 1)\n    {\n        // Make the grandParent red and both of its children black\n        (grandParent->right)->color = 0;\n        (grandParent->left)->color = 0;\n        grandParent->color = 1;\n        return;\n    }\n    else\n    {\n        // The only option left is rotation.\n        Node *greatGrandParent = grandParent->par;\n        // Right Case\n        if (grandParent->right == parent)\n        {\n            // Right Right Case\n            if (parent->right == node)\n            {\n                grandParent->right = parent->left;\n                if (parent->left != NULL)\n                {\n                    (parent->left)->par = grandParent;\n                }\n                parent->left = grandParent;\n                grandParent->par = parent;\n\n                // Attach to existing Tree;\n                parent->par = greatGrandParent;\n                if (greatGrandParent != NULL)\n                {\n                    if (greatGrandParent->left != NULL &&\n                        greatGrandParent->left == grandParent)\n                    {\n                        greatGrandParent->left = parent;\n                    }\n                    else\n                    {\n                        greatGrandParent->right = parent;\n                    }\n                }\n\n                // Change the colors\n                parent->color = 0;\n                grandParent->color = 1;\n            }\n            else\n            {  // Right Left Case\n                // First step -> Parent Child Rotation\n                parent->left = child->right;\n                if (child->right != NULL)\n                {\n                    (child->right)->par = parent;\n                }\n                child->right = parent;\n                parent->par = child;\n\n                // Second step -> Child and GrandParent Rotation\n                grandParent->right = child->left;\n                if (child->left != NULL)\n                {\n                    (child->left)->par = grandParent;\n                }\n                child->left = grandParent;\n                grandParent->par = child;\n\n                // Attach to the existing tree\n                child->par = greatGrandParent;\n                if (greatGrandParent != NULL)\n                {\n                    if (greatGrandParent->left != NULL &&\n                        greatGrandParent->left == grandParent)\n                    {\n                        greatGrandParent->left = child;\n                    }\n                    else\n                    {\n                        greatGrandParent->right = child;\n                    }\n                }\n\n                // Change The Colors\n                child->color = 0;\n                grandParent->color = 1;\n            }\n        }\n        else\n        {  // Left Case\n            // Left Left Case\n            if (parent->left == node)\n            {\n                grandParent->left = parent->right;\n                if (parent->right != NULL)\n                {\n                    (parent->right)->par = grandParent;\n                }\n                parent->right = grandParent;\n                grandParent->par = parent;\n\n                // Attach to existing Tree;\n                parent->par = greatGrandParent;\n                if (greatGrandParent != NULL)\n                {\n                    if (greatGrandParent->left != NULL &&\n                        greatGrandParent->left == grandParent)\n                    {\n                        greatGrandParent->left = parent;\n                    }\n                    else\n                    {\n                        greatGrandParent->right = parent;\n                    }\n                }\n\n                // Change the colors\n                parent->color = 0;\n                grandParent->color = 1;\n            }\n            else\n            {  // Left Right Case\n\n                // First step -> Parent Child Rotation\n                parent->right = child->left;\n                if (child->left != NULL)\n                {\n                    (child->left)->par = parent;\n                }\n                child->left = parent;\n                parent->par = child;\n\n                // Second step -> Child and GrandParent Rotation\n                grandParent->left = child->right;\n                if (child->right != NULL)\n                {\n                    (child->right)->par = grandParent;\n                }\n                child->right = grandParent;\n                grandParent->par = child;\n\n                // Attach to the existing tree\n                child->par = greatGrandParent;\n                if (greatGrandParent != NULL)\n                {\n                    if (greatGrandParent->left != NULL &&\n                        greatGrandParent->left == grandParent)\n                    {\n                        greatGrandParent->left = child;\n                    }\n                    else\n                    {\n                        greatGrandParent->right = child;\n                    }\n                }\n\n                // Change The Colors\n                child->color = 0;\n                grandParent->color = 1;\n            }\n        }\n    }\n}\n\n// To insert a node in the existing tree\nvoid insertNode(int val, Node **root)\n{\n    Node *buffRoot = *root;\n    while (buffRoot)\n    {\n        if (buffRoot->val > val)\n        {\n            // Go left\n            if (buffRoot->left != NULL)\n            {\n                buffRoot = buffRoot->left;\n            }\n            else\n            {\n                // Insert The Node\n                Node *toInsert = newNode(val, buffRoot);\n                buffRoot->left = toInsert;\n                buffRoot = toInsert;\n\n                // Check For Double Red Problems\n                break;\n            }\n        }\n        else\n        {\n            // Go right\n            if (buffRoot->right != NULL)\n            {\n                buffRoot = buffRoot->right;\n            }\n            else\n            {\n                // Insert The Node\n                Node *toInsert = newNode(val, buffRoot);\n                buffRoot->right = toInsert;\n                buffRoot = toInsert;\n\n                // Check For Double Red Problems\n                break;\n            }\n        }\n    }\n\n    while (buffRoot != *root)\n    {\n        checkNode(buffRoot);\n        if (buffRoot->par == NULL)\n        {\n            *root = buffRoot;\n            break;\n        }\n        buffRoot = buffRoot->par;\n        if (buffRoot == *root)\n        {\n            buffRoot->color = 0;\n        }\n    }\n}\n\nvoid checkForCase2(Node *toDelete, int delete, int fromDirection, Node **root)\n{\n    if (toDelete == (*root))\n    {\n        (*root)->color = 0;\n        return;\n    }\n\n    if (!delete &&toDelete->color == 1)\n    {\n        if (!fromDirection)\n        {\n            if (toDelete->right != NULL)\n            {\n                toDelete->right->color = 1;\n            }\n        }\n        else\n        {\n            if (toDelete->left != NULL)\n            {\n                toDelete->left->color = 1;\n            }\n        }\n        toDelete->color = 0;\n        return;\n    }\n\n    // Get the sibling for further inspection\n    Node *sibling;\n    Node *parent = toDelete->par;\n    int locateChild = 0;  // 0 if toDeleted is left of its parent else 1\n    if (parent->right == toDelete)\n    {\n        sibling = parent->left;\n        locateChild = 1;\n    }\n    else\n    {\n        sibling = parent->right;\n    }\n\n    // Case 2.1. i.e. if the any children of the sibling is red\n    if ((sibling->right != NULL && sibling->right->color == 1) ||\n        (sibling->left != NULL && sibling->left->color == 1))\n    {\n        if (sibling->right != NULL && sibling->right->color == 1)\n        {\n            // Sibling is left and child is right. i.e. LEFT RIGHT ROTATION\n            if (locateChild == 1)\n            {\n                int parColor = parent->color;\n\n                // Step 1: Left rotate sibling\n                sibling = leftRotate(sibling->right);\n\n                // Step 2: Right rotate updated sibling\n                parent = rightRotate(sibling);\n\n                // Check if the root is rotated\n                if (parent->par == NULL)\n                {\n                    *root = parent;\n                }\n\n                // Step 3: Update the colors\n                parent->color = parColor;\n                parent->left->color = 0;\n                parent->right->color = 0;\n\n                // Delete the node (present at parent->right->right)\n                if (delete)\n                {\n                    if (toDelete->left != NULL)\n                    {\n                        toDelete->left->par = parent->right;\n                    }\n                    parent->right->right = toDelete->left;\n                    free(toDelete);\n                }\n            }\n            else\n            {  // Sibling is right and child is also right. i.e. LEFT LEFT\n               // ROTATION\n\n                int parColor = parent->color;\n\n                // Left Rotate the sibling\n                parent = leftRotate(sibling);\n\n                // Check if the root is rotated\n                if (parent->par == NULL)\n                {\n                    *root = parent;\n                }\n\n                // Update Colors\n                parent->color = parColor;\n                parent->left->color = 0;\n                parent->right->color = 0;\n\n                // Delete the node (present at parent->left->left)\n                if (delete)\n                {\n                    if (toDelete->right != NULL)\n                    {\n                        toDelete->right->par = parent->left;\n                    }\n                    parent->left->left = toDelete->left;\n                    free(toDelete);\n                }\n            }\n        }\n        else\n        {\n            // Sibling is right and child is left. i.e. RIGHT LEFT ROTATION\n            if (locateChild == 0)\n            {\n                int parColor = parent->color;\n\n                // Step 1: Right rotate sibling\n                sibling = rightRotate(sibling->left);\n\n                // printf(\"%d - reached\\n\", sibling->val);\n                // return;\n\n                // Step 2: Left rotate updated sibling\n                parent = leftRotate(sibling);\n\n                // Check if the root is rotated\n                if (parent->par == NULL)\n                {\n                    *root = parent;\n                }\n\n                // Step 3: Update the colors\n                parent->color = parColor;\n                parent->left->color = 0;\n                parent->right->color = 0;\n\n                // Delete the node (present at parent->left->left)\n                if (delete)\n                {\n                    if (toDelete->right != NULL)\n                    {\n                        toDelete->right->par = parent->left;\n                    }\n                    parent->left->left = toDelete->right;\n                    free(toDelete);\n                }\n            }\n            else\n            {  // Sibling is left and child is also left. i.e. RIGHT RIGHT\n               // ROTATION\n\n                int parColor = parent->color;\n\n                // Right Rotate the sibling\n                parent = rightRotate(sibling);\n\n                // Check if the root is rotated\n                if (parent->par == NULL)\n                {\n                    *root = parent;\n                }\n\n                // Update Colors\n                parent->color = parColor;\n                parent->left->color = 0;\n                parent->right->color = 0;\n\n                // Delete the node (present at parent->right->right)\n                if (delete)\n                {\n                    if (toDelete->left != NULL)\n                    {\n                        toDelete->left->par = parent->right;\n                    }\n                    parent->right->right = toDelete->left;\n                    free(toDelete);\n                }\n            }\n        }\n    }\n    else if (sibling->color == 0)\n    {  // Make the sibling red and recur for its parent\n\n        // Recolor the sibling\n        sibling->color = 1;\n\n        // Delete if necessary\n        if (delete)\n        {\n            if (locateChild)\n            {\n                toDelete->par->right = toDelete->left;\n                if (toDelete->left != NULL)\n                {\n                    toDelete->left->par = toDelete->par;\n                }\n            }\n            else\n            {\n                toDelete->par->left = toDelete->right;\n                if (toDelete->right != NULL)\n                {\n                    toDelete->right->par = toDelete->par;\n                }\n            }\n        }\n\n        checkForCase2(parent, 0, locateChild, root);\n    }\n    else\n    {  // Bring the sibling on top and apply 2.1 or 2.2 accordingly\n        if (locateChild)\n        {  // Right Rotate\n\n            toDelete->par->right = toDelete->left;\n            if (toDelete->left != NULL)\n            {\n                toDelete->left->par = toDelete->par;\n            }\n\n            parent = rightRotate(sibling);\n\n            // Check if the root is rotated\n            if (parent->par == NULL)\n            {\n                *root = parent;\n            }\n\n            parent->color = 0;\n            parent->right->color = 1;\n            checkForCase2(parent->right, 0, 1, root);\n        }\n        else\n        {  // Left Rotate\n\n            toDelete->par->left = toDelete->right;\n            if (toDelete->right != NULL)\n            {\n                toDelete->right->par = toDelete->par;\n            }\n            parent = leftRotate(sibling);\n\n            // Check if the root is rotated\n            if (parent->par == NULL)\n            {\n                *root = parent;\n            }\n\n            printf(\"\\nroot - %d - %d\\n\", parent->val, parent->left->val);\n\n            parent->color = 0;\n            parent->left->color = 1;\n            checkForCase2(parent->left, 0, 0, root);\n        }\n    }\n}\n\n// To delete a node from the tree\nvoid deleteNode(int val, Node **root)\n{\n    Node *buffRoot = *root;\n\n    // Search for the element in the tree\n    while (1)\n    {\n        if (val == buffRoot->val)\n        {\n            // Node Found\n            break;\n        }\n\n        if (val > buffRoot->val)\n        {\n            if (buffRoot->right != NULL)\n            {\n                buffRoot = buffRoot->right;\n            }\n            else\n            {\n                printf(\"Node Not Found!!!\");\n                return;\n            }\n        }\n        else\n        {\n            if (buffRoot->left != NULL)\n            {\n                buffRoot = buffRoot->left;\n            }\n            else\n            {\n                printf(\"Node Not Found!!!\");\n                return;\n            }\n        }\n    }\n\n    Node *toDelete = buffRoot;\n\n    // Look for the leftmost of right node or right most of left node\n    if (toDelete->left != NULL)\n    {\n        toDelete = toDelete->left;\n        while (toDelete->right != NULL)\n        {\n            toDelete = toDelete->right;\n        }\n    }\n    else if (toDelete->right != NULL)\n    {\n        toDelete = toDelete->right;\n        while (toDelete->left != NULL)\n        {\n            toDelete = toDelete->left;\n        }\n    }\n\n    if (toDelete == *root)\n    {\n        *root = NULL;\n        return;\n    }\n\n    // Swap the values\n    buffRoot->val = toDelete->val;\n    toDelete->val = val;\n\n    // Checking for case 1\n    if (toDelete->color == 1 ||\n        (toDelete->left != NULL && toDelete->left->color == 1) ||\n        (toDelete->right != NULL && toDelete->right->color == 1))\n    {\n        // if it is a leaf\n        if (toDelete->left == NULL && toDelete->right == NULL)\n        {\n            // Delete instantly\n            if (toDelete->par->left == toDelete)\n            {\n                toDelete->par->left = NULL;\n            }\n            else\n            {\n                toDelete->par->right = NULL;\n            }\n        }\n        else\n        {  // else its child should be red\n\n            // Check for the exitstence of left node\n            if (toDelete->left != NULL)\n            {\n                // The node should be right to its parent\n                toDelete->par->right = toDelete->left;\n                toDelete->left->par = toDelete->par;\n                toDelete->left->color = 1;\n            }\n            else\n            {  // else the right node should be red\n                toDelete->par->left = toDelete->right;\n                toDelete->right->par = toDelete->par;\n                toDelete->right->color = 1;\n            }\n        }\n\n        // Remove the node from memory\n        free(toDelete);\n    }\n    else\n    {  // Case 2\n        checkForCase2(toDelete, 1, ((toDelete->par->right == toDelete)), root);\n    }\n}\n\nvoid printInorder(Node *root)\n{\n    if (root != NULL)\n    {\n        printInorder(root->left);\n        printf(\"%d c-%d \", root->val, root->color);\n        printInorder(root->right);\n    }\n}\n\nvoid checkBlack(Node *temp, int c)\n{\n    if (temp == NULL)\n    {\n        printf(\"%d \", c);\n        return;\n    }\n    if (temp->color == 0)\n    {\n        c++;\n    }\n    checkBlack(temp->left, c);\n    checkBlack(temp->right, c);\n}\n\nint main()\n{\n    Node *root = NULL;\n    int scanValue, choice = 1;\n    printf(\n        \"1 - Input\\n2 - Delete\\n3 - Inorder Traversel\\n0 - Quit\\n\\nPlease \"\n        \"Enter the Choice - \");\n    scanf(\"%d\", &choice);\n    while (choice)\n    {\n        switch (choice)\n        {\n        case 1:\n            printf(\"\\n\\nPlease Enter A Value to insert - \");\n            scanf(\"%d\", &scanValue);\n            if (root == NULL)\n            {\n                root = newNode(scanValue, NULL);\n                root->color = 0;\n            }\n            else\n            {\n                insertNode(scanValue, &root);\n            }\n            printf(\"\\nSuccessfully Inserted %d in the tree\\n\\n\", scanValue);\n            break;\n        case 2:\n            printf(\"\\n\\nPlease Enter A Value to Delete - \");\n            scanf(\"%d\", &scanValue);\n            deleteNode(scanValue, &root);\n            printf(\"\\nSuccessfully Inserted %d in the tree\\n\\n\", scanValue);\n            break;\n        case 3:\n            printf(\"\\nInorder Traversel - \");\n            printInorder(root);\n            printf(\"\\n\\n\");\n            // checkBlack(root,0);\n            // printf(\"\\n\");\n            break;\n        default:\n            if (root != NULL)\n            {\n                printf(\"Root - %d\\n\", root->val);\n            }\n        }\n        printf(\n            \"1 - Input\\n2 - Delete\\n3 - Inorder Traversel\\n0 - \"\n            \"Quit\\n\\nPlease Enter the Choice - \");\n        scanf(\"%d\", &choice);\n    }\n}\n\n// 32 12 50 53 1 2 3 4 5 6 7 8 9\n","index":29},{"title":"Threaded Binary Trees","category":"binary_trees","id":"threaded_binary_trees_binary_trees","algorithm":"/**\n * @file\n * \\brief This file is a simple implementation of a Threaded Binary Tree\n *\n * Threaded Binary Tree is a binary tree variant in which all left child\n * pointers that are NULL (in Linked list representation) point to its\n * in-order predecessor, and all right child pointers that are NULL\n * (in Linked list representation) point to its in-order successor.\n * It has the following functionalities:\n * - Insertion\n * - Search\n * - Deletion\n * - Listing of node keys inorder,preorder,postorder\n *\n * -see binary_search_tree.c\n *\n * \\author [Amitha Nayak](https://github.com/amitnayakblr)\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n\n/**\n * Node, the basic data structure of the tree\n */\ntypedef struct Node\n{\n    int data;           /**< stores the number */\n    struct Node *llink; /**< link to left child */\n    struct Node *rlink; /**< link to right child */\n} node;\n\n/**\n * creates a new node\n * param[in] data value to be inserted\n * \\returns a pointer to the new node\n */\nnode *create_node(int data)\n{\n    node *ptr = (node *)malloc(sizeof(node));\n    ptr->rlink = ptr->llink = NULL;\n    ptr->data = data;\n    return ptr;\n}\n\n/**\n * inserts a node into the tree\n * param[in,out] root pointer to node pointer to the topmost node of the tree\n * param[in] data value to be inserted into the tree\n */\nvoid insert_bt(node **root, int data)\n{\n    node *new_node = create_node(data);\n    node *temp;  // to be deleted\n    node *prev;  // keeps track of the parent of the element deleted\n    if (*root == NULL)\n    {\n        *root = new_node;\n    }\n    else\n    {\n        temp = *root;\n        prev = NULL;\n        while (temp != NULL)\n        {\n            if (new_node->data > temp->data)\n            {\n                prev = temp;\n                temp = temp->rlink;\n            }\n            else if (new_node->data < temp->data)\n            {\n                prev = temp;\n                temp = temp->llink;\n            }\n            else\n            {\n                return;\n            }\n        }\n\n        if (new_node->data > prev->data)\n        {\n            prev->rlink = new_node;\n        }\n        else\n        {\n            prev->llink = new_node;\n        }\n    }\n}\n\n/**\n * searches for the element\n * \\param[in] root node pointer to the topmost node of the tree\n * \\param[in] ele value searched for\n */\nvoid search(node *root, int ele)\n{\n    node *temp = root;\n    while (temp != NULL)\n    {\n        if (temp->data == ele)\n        {\n            break;\n        }\n        else if (ele > temp->data)\n        {\n            temp = temp->rlink;\n        }\n        else\n        {\n            temp = temp->llink;\n        }\n    }\n\n    if (temp == NULL)\n    {\n        printf(\"%s\\n\", \"Element not found.\");\n    }\n    else\n        printf(\"%s\\n\", \"Element found.\");\n}\n\n/**\n * performs inorder traversal\n * param[in] curr node pointer to the topmost node of the tree\n */\nvoid inorder_display(node *curr)\n{\n    if (curr != NULL)\n    {\n        inorder_display(curr->llink);\n        printf(\"%d\\t\", curr->data);\n        inorder_display(curr->rlink);\n    }\n}\n\n/**\n * performs postorder traversal\n * param[in] curr node pointer to the topmost node of the tree\n */\nvoid postorder_display(node *curr)\n{\n    if (curr != NULL)\n    {\n        postorder_display(curr->llink);\n        postorder_display(curr->rlink);\n        printf(\"%d\\t\", curr->data);\n    }\n}\n\n/**\n * performs preorder traversal\n * param[in] curr node pointer to the topmost node of the tree\n */\nvoid preorder_display(node *curr)\n{\n    if (curr != NULL)\n    {\n        printf(\"%d\\t\", curr->data);\n        preorder_display(curr->llink);\n        preorder_display(curr->rlink);\n    }\n}\n\n/**\n * deletion of a node from the tree\n * if the node isn't present in the tree, it takes no action.\n * param[in,out] root pointer to node pointer to the topmost node of the tree\n * param[in] ele value to be deleted from the tree\n */\nvoid delete_bt(node **root, int ele)\n{\n    node *temp;\n    node *prev;\n    if (*root == NULL)\n        return;\n    else\n    {\n        temp = *root;\n        prev = NULL;\n        // search\n        while (temp != NULL)\n        {\n            if (temp->data == ele)\n            {\n                break;\n            }\n            else if (ele > temp->data)\n            {\n                prev = temp;\n                temp = temp->rlink;\n            }\n            else\n            {\n                prev = temp;\n                temp = temp->llink;\n            }\n        }\n    }\n\n    if (temp == NULL)\n        return;\n    else\n    {\n        node *replacement;  // deleted node's replacement\n        node *t;\n        if (temp->llink == NULL && temp->rlink == NULL)\n        {\n            replacement = NULL;\n        }\n        else if (temp->llink == NULL && temp->rlink != NULL)\n        {\n            replacement = temp->rlink;\n        }\n        else if (temp->llink != NULL && temp->rlink == NULL)\n        {\n            replacement = temp->llink;\n        }\n        else\n        {\n            replacement = temp->rlink;  // replaced with inorder successor\n            t = replacement;\n            while (t->llink != NULL)\n            {\n                t = t->llink;\n            }\n            t->llink =\n                temp->llink;  // leftmost node of the replacement is linked to\n                              // the left child of the deleted node\n        }\n\n        if (temp == *root)\n        {\n            free(*root);\n            *root = replacement;\n        }\n        else if (prev->llink == temp)\n        {\n            free(prev->llink);\n            prev->llink = replacement;\n        }\n        else if (prev->rlink == temp)\n        {\n            free(prev->rlink);\n            prev->rlink = replacement;\n        }\n    }\n}\n\n/**\n * main function\n */\nint main()\n{\n    printf(\"BINARY THREADED TREE: \\n\");\n    node *root = NULL;\n    int choice, n;\n    do\n    {\n        printf(\"%s\\n\", \"1. Insert into BT\");\n        printf(\"%s\\n\", \"2. Print BT - inorder\");\n        printf(\"%s\\n\", \"3. Print BT - preorder\");\n        printf(\"%s\\n\", \"4. print BT - postorder\");\n        printf(\"%s\\n\", \"5. delete from BT\");\n        printf(\"%s\\n\", \"6. search in BT\");\n        printf(\"%s\\n\", \"Type 0 to exit\");\n        scanf(\"%d\", &choice);\n\n        switch (choice)\n        {\n        case 1:\n            printf(\"%s\\n\", \"Enter a no:\");\n            scanf(\"%d\", &n);\n            insert_bt(&root, n);\n            break;\n        case 2:\n            inorder_display(root);\n            printf(\"\\n\");\n            break;\n        case 3:\n            preorder_display(root);\n            printf(\"\\n\");\n            break;\n        case 4:\n            postorder_display(root);\n            printf(\"\\n\");\n            break;\n        case 5:\n            printf(\"%s\\n\", \"Enter a no:\");\n            scanf(\"%d\", &n);\n            delete_bt(&root, n);\n            break;\n        case 6:\n            printf(\"%s\\n\", \"Enter a no:\");\n            scanf(\"%d\", &n);\n            search(root, n);\n            break;\n        }\n    } while (choice != 0);\n    return 0;\n}\n","index":30},{"title":"Dictionary","category":"data_structures","id":"dictionary","index":31},{"title":"Dict","category":"dictionary","id":"dict_dictionary","algorithm":"#include \"dict.h\"\n#include <stdio.h>\n#include <stdlib.h>\n\n/* simple constructor */\nDictionary *create_dict(void)\n{\n    Dictionary *p_dic = malloc(sizeof(Dictionary));\n    if (p_dic)\n    {\n        p_dic->number_of_elements = 0;\n\n        /* initializes the elemens of the array with NULL-pointer */\n        for (int i = 0; i < MAXELEMENTS; i++)\n        {\n            p_dic->elements[i] = NULL;\n        }\n\n        return p_dic;\n    }\n    else\n    {\n        printf(\"unable to create a dictionary\\n\");\n        return NULL;\n    }\n}\n\n/*\n    utility function\n    sdbm hash algorithm\n    returns a hashcode for the given string 's'\n*/\nint get_hash(char s[])\n{\n    unsigned int hash_code = 0;\n\n    /* iterates over string at each character */\n    for (int counter = 0; s[counter] != '\\0'; counter++)\n    {\n        /* actual computing of the hash code */\n        hash_code =\n            s[counter] + (hash_code << 6) + (hash_code << 16) - hash_code;\n    }\n\n    /* % modulo is for fitting the index in array. */\n    return hash_code % MAXELEMENTS;\n}\n\nint add_item_label(Dictionary *dic, char label[], void *item)\n{\n    unsigned int index = get_hash(label);\n\n    /* make sure index is fitting */\n    if (index < MAXELEMENTS)\n    {\n        dic->elements[index] = item;\n        return 0;\n    }\n\n    /* error case */\n    return -1;\n}\n\nint add_item_index(Dictionary *dic, int index, void *item)\n{\n    /* make sure whether this place is already given */\n    if (!dic->elements[index])\n    {\n        dic->elements[index] = item;\n        return 0;\n    }\n\n    /* error case */\n    return -1;\n}\n\nvoid *get_element_label(Dictionary *dict, char s[])\n{\n    int index = get_hash(s);\n    if (dict->elements[index])\n    {\n        return dict->elements[index];\n    }\n\n    printf(\"None entry at given label\\n\");\n    return NULL;\n}\n\nvoid *get_element_index(Dictionary *dict, int index)\n{\n    if (index >= 0 && index < MAXELEMENTS)\n    {\n        return dict->elements[index];\n    }\n\n    printf(\"index out of bounds!\\n\");\n    return NULL;\n}\n\nvoid destroy(Dictionary *dict) { free(dict); }","index":32},{"title":"Dict.h","category":"dictionary","id":"dict.h_dictionary","algorithm":"/*\n    author: Christian Bender\n    public interface for the dictionary.\n\n    The dictionary prepares space for 1000 elements.\n*/\n\n#ifndef __DICT__H\n#define __DICT__H\n\n#define MAXELEMENTS 1000\n\n/*\n    special data type called 'Dictionary'\n    for generic use\n*/\ntypedef struct Dict\n{\n    /*\n        void* array for generic use of the dictionary.\n        there actual saves the entries.\n    */\n    void *elements[MAXELEMENTS];\n\n    /* contains the number of elements in this dictionary */\n    int number_of_elements;\n\n} Dictionary;\n\n/*\n    create_dict: is a simple constructor for creating\n                a dictionary and setting up the\n                member field 'number_of_elements'\n                and prepares the inner array 'elements'\n*/\nDictionary *create_dict(void);\n\n/*\n    add_item_label: adds item (void*) to the dictionary at given label\n    returns 0 if adding was sucessful otherwise -1\n*/\nint add_item_label(Dictionary *, char label[], void *);\n\n/*\n    add_item_index: adds item (void*) to the dictionary at given index (int)\n    returns 0 if adding was sucessful otherwise -1\n*/\nint add_item_index(Dictionary *, int index, void *);\n\n/*\n    get_element: returns the element at given label\n*/\nvoid *get_element_label(Dictionary *, char[]);\n\n/*\n    get_element: returns the element at given index\n*/\nvoid *get_element_index(Dictionary *, int);\n\n/*\n    simple destrcutor function\n*/\nvoid destroy(Dictionary *);\n\n#endif","index":33},{"title":"Test Program","category":"dictionary","id":"test_program_dictionary","algorithm":"/*\n    author: Christian Bender\n    This is a simple test program for the dictionary.\n*/\n\n#include <stdio.h>\n\n/* includes the dictionary */\n#include \"dict.h\"\n\nint main(void)\n{\n    Dictionary *testObj1;\n    Dictionary *testObj2;\n\n    int value = 28;\n\n    testObj1 = create_dict();\n    testObj2 = create_dict();\n\n    add_item_label(testObj1, \"age\", &value);\n    add_item_label(testObj2, \"name\", \"Christian\");\n\n    /*\n        test for function add_item_label\n\n        attention:\n        The void* pointer must be convert into an int* pointer.\n        After that you can dereference it.\n    */\n    printf(\"My age is %d\\n\", *((int *)get_element_label(testObj1, \"age\")));\n    printf(\"My name is %s\\n\", get_element_label(testObj2, \"name\"));\n\n    /* test for function add_item_index */\n    if (!add_item_index(testObj1, 0, &value))\n    {\n        printf(\"My age at index %d is %d\\n\", 0,\n               *((int *)get_element_index(testObj1, 0)));\n    }\n\n    /* error scenario */\n    /* get_element_label(testObj,\"none\"); */\n\n    /* tidy up */\n    destroy(testObj1);\n    destroy(testObj2);\n\n    return 0;\n}","index":34},{"title":"Dynamic Array","category":"data_structures","id":"dynamic_array","index":35},{"title":"Dynamic Array","category":"dynamic_array","id":"dynamic_array_dynamic_array","algorithm":"#include \"dynamic_array.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ndynamic_array_t *init_dynamic_array()\n{\n    dynamic_array_t *da = malloc(sizeof(dynamic_array_t));\n    da->items = calloc(DEFAULT_CAPACITY, sizeof(void *));\n    da->capacity = DEFAULT_CAPACITY;\n\n    return da;\n}\n\nvoid *add(dynamic_array_t *da, const void *value)\n{\n    if (da->size >= da->capacity)\n    {\n        void **newItems =\n            realloc(da->items, (da->capacity <<= 1) * sizeof(void **));\n        free(da->items);\n\n        da->items = newItems;\n    }\n\n    void *copy_value = retrive_copy_of_value(value);\n    da->items[da->size++] = copy_value;\n\n    return copy_value;\n}\n\nvoid *put(dynamic_array_t *da, const void *value, const unsigned index)\n{\n    if (!contains(da->size, index))\n        return INDEX_OUT_OF_BOUNDS;\n\n    free(da->items[index]);\n    void *copy_value = retrive_copy_of_value(value);\n    da->items[index] = copy_value;\n\n    return copy_value;\n}\n\nvoid *get(dynamic_array_t *da, const unsigned index)\n{\n    if (!contains(da->size, index))\n        return INDEX_OUT_OF_BOUNDS;\n\n    return da->items[index];\n}\n\nvoid delete (dynamic_array_t *da, const unsigned index)\n{\n    if (!contains(da->size, index))\n        return;\n\n    for (unsigned i = index; i < da->size; i++)\n    {\n        da->items[i] = da->items[i + 1];\n    }\n\n    da->size--;\n\n    free(da->items[da->size]);\n}\n\nunsigned contains(const unsigned size, const unsigned index)\n{\n    if (size >= 0 && index < size)\n        return 1;\n\n    printf(\"index [%d] out of bounds!\\n\", index);\n    return 0;\n}\n\nvoid *retrive_copy_of_value(const void *value)\n{\n    void *value_copy = malloc(sizeof(void *));\n    memcpy(value_copy, value, sizeof(void *));\n\n    return value_copy;\n}","index":36},{"title":"Dynamic Array.h","category":"dynamic_array","id":"dynamic_array.h_dynamic_array","algorithm":"#ifndef __DYNAMIC_ARRAY__\n#define __DYNAMIC_ARRAY__\n#define DEFAULT_CAPACITY 1 << 4\n#define INDEX_OUT_OF_BOUNDS NULL\n\ntypedef struct dynamic_array\n{\n    void **items;\n    unsigned size;\n    unsigned capacity;\n} dynamic_array_t;\n\nextern dynamic_array_t *init_dynamic_array();\n\nextern void *add(dynamic_array_t *da, const void *value);\n\nextern void *put(dynamic_array_t *da, const void *value, unsigned index);\n\nextern void *get(dynamic_array_t *da, const unsigned index);\n\nextern void delete (dynamic_array_t *da, const unsigned index);\n\nunsigned contains(const unsigned size, const unsigned index);\n\nextern void *retrive_copy_of_value(const void *value);\n\n#endif","index":37},{"title":"Main","category":"dynamic_array","id":"main_dynamic_array","algorithm":"#include <stdio.h>\n#include <stdlib.h>\n#include \"dynamic_array.h\"\n\nint main()\n{\n    dynamic_array_t *da = init_dynamic_array();\n\n    for (int i = 1; i <= 50; i++)\n    {\n        add(da, &i);\n    }\n\n    delete (da, 10);\n\n    int value = 1000;\n\n    put(da, &value, 0);\n\n    value = 5000;\n\n    int another_value = 7000;\n\n    add(da, &another_value);\n\n    for (int i = 0; i < da->size; i++)\n    {\n        printf(\"value %d\\n\", *(int *)get(da, i));\n    }\n\n    int value_for_invalid_index = 10000;\n\n    put(da, &value_for_invalid_index, 150);\n    return 0;\n}","index":38},{"title":"Graphs","category":"data_structures","id":"graphs","index":39},{"title":"Bellman Ford","category":"graphs","id":"bellman_ford_graphs","algorithm":"#include <limits.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Structure for storing edge\nstruct Edge\n{\n    int src, dst, weight;\n};\n\n// Structure for storing a graph\nstruct Graph\n{\n    int vertexNum;\n    int edgeNum;\n    struct Edge *edges;\n};\n\n// Constructs a graph with V vertices and E edges\nvoid createGraph(struct Graph *G, int V, int E)\n{\n    G->vertexNum = V;\n    G->edgeNum = E;\n    G->edges = (struct Edge *)malloc(E * sizeof(struct Edge));\n}\n\n// Adds the given edge to the graph\nvoid addEdge(struct Graph *G, int src, int dst, int weight)\n{\n    static int ind;\n    struct Edge newEdge;\n    newEdge.src = src;\n    newEdge.dst = dst;\n    newEdge.weight = weight;\n    G->edges[ind++] = newEdge;\n}\n\n// Utility function to find minimum distance vertex in mdist\nint minDistance(int mdist[], int vset[], int V)\n{\n    int minVal = INT_MAX, minInd;\n    for (int i = 0; i < V; i++)\n        if (vset[i] == 0 && mdist[i] < minVal)\n        {\n            minVal = mdist[i];\n            minInd = i;\n        }\n\n    return minInd;\n}\n\n// Utility function to print distances\nvoid print(int dist[], int V)\n{\n    printf(\"\\nVertex  Distance\\n\");\n    for (int i = 0; i < V; i++)\n    {\n        if (dist[i] != INT_MAX)\n            printf(\"%d\\t%d\\n\", i, dist[i]);\n        else\n            printf(\"%d\\tINF\", i);\n    }\n}\n\n// The main function that finds the shortest path from given source\n// to all other vertices using Bellman-Ford.It also detects negative\n// weight cycle\nvoid BellmanFord(struct Graph *graph, int src)\n{\n    int V = graph->vertexNum;\n    int E = graph->edgeNum;\n    int dist[V];\n\n    // Initialize distances array as INF for all except source\n    // Intialize source as zero\n    for (int i = 0; i < V; i++) dist[i] = INT_MAX;\n    dist[src] = 0;\n\n    // Calculate shortest path distance from source to all edges\n    // A path can contain maximum (|V|-1) edges\n    for (int i = 0; i <= V - 1; i++)\n        for (int j = 0; j < E; j++)\n        {\n            int u = graph->edges[j].src;\n            int v = graph->edges[j].dst;\n            int w = graph->edges[j].weight;\n\n            if (dist[u] != INT_MAX && dist[u] + w < dist[v])\n                dist[v] = dist[u] + w;\n        }\n\n    // Iterate inner loop once more to check for negative cycle\n    for (int j = 0; j < E; j++)\n    {\n        int u = graph->edges[j].src;\n        int v = graph->edges[j].dst;\n        int w = graph->edges[j].weight;\n\n        if (dist[u] != INT_MAX && dist[u] + w < dist[v])\n        {\n            printf(\n                \"Graph contains negative weight cycle. Hence, shortest \"\n                \"distance not guaranteed.\");\n            return;\n        }\n    }\n\n    print(dist, V);\n\n    return;\n}\n\n// Driver Function\nint main()\n{\n    int V, E, gsrc;\n    int src, dst, weight;\n    struct Graph G;\n    printf(\"Enter number of vertices: \");\n    scanf(\"%d\", &V);\n    printf(\"Enter number of edges: \");\n    scanf(\"%d\", &E);\n    createGraph(&G, V, E);\n    for (int i = 0; i < E; i++)\n    {\n        printf(\"\\nEdge %d \\nEnter source: \", i + 1);\n        scanf(\"%d\", &src);\n        printf(\"Enter destination: \");\n        scanf(\"%d\", &dst);\n        printf(\"Enter weight: \");\n        scanf(\"%d\", &weight);\n        addEdge(&G, src, dst, weight);\n    }\n    printf(\"\\nEnter source:\");\n    scanf(\"%d\", &gsrc);\n    BellmanFord(&G, gsrc);\n\n    return 0;\n}\n","index":40},{"title":"Bfs","category":"graphs","id":"bfs_graphs","algorithm":"#include <stdio.h>\n#include <stdlib.h>\n#define SIZE 40\n// Assume max size of graph is 40 nodes\nstruct queue\n{\n    int items[SIZE];\n    int front;\n    int rear;\n};\n\n// Some declarations\nstruct queue *createQueue();\nvoid enqueue(struct queue *q, int);\nint dequeue(struct queue *q);\nvoid display(struct queue *q);\nint isEmpty(struct queue *q);\nint pollQueue(struct queue *q);\n\n// Structure to create a graph node\nstruct node\n{\n    int vertex;\n    struct node *next;\n};\n\nstruct node *createNode(int);\n\n// Graph data structure\nstruct Graph\n{\n    int numVertices;\n    struct node **adjLists;\n    int *visited;\n};\nstruct Graph *createGraph(int vertices);\nvoid addEdge(struct Graph *graph, int src, int dest);\nvoid printGraph(struct Graph *graph);\nvoid bfs(struct Graph *graph, int startVertex);\n\nint main()\n{\n    int vertices, edges, source, i, src, dst;\n    printf(\"Enter the number of vertices\\n\");\n    scanf(\"%d\", &vertices);\n    struct Graph *graph = createGraph(vertices);\n    printf(\"Enter the number of edges\\n\");\n    scanf(\"%d\", &edges);\n    for (i = 0; i < edges; i++)\n    {\n        printf(\"Edge %d \\nEnter source: \", i + 1);\n        scanf(\"%d\", &src);\n        printf(\"Enter destination: \");\n        scanf(\"%d\", &dst);\n        addEdge(graph, src, dst);\n    }\n    printf(\"Enter source of bfs\\n\");\n    scanf(\"%d\", &source);\n    bfs(graph, source);\n\n    // Uncomment below part to get a ready-made example\n    /*struct Graph* graph = createGraph(6);\n    addEdge(graph, 0, 1);\n    addEdge(graph, 0, 2);\n    addEdge(graph, 1, 2);\n    addEdge(graph, 1, 4);\n    addEdge(graph, 1, 3);\n    addEdge(graph, 2, 4);\n    addEdge(graph, 3, 4);\n    bfs(graph,0);*/\n\n    return 0;\n}\nvoid bfs(struct Graph *graph, int startVertex)\n{\n    struct queue *q = createQueue();\n\n    // Add to visited list and put in queue\n    graph->visited[startVertex] = 1;\n    enqueue(q, startVertex);\n    printf(\"Breadth first traversal from vertex %d is:\\n\", startVertex);\n\n    // Iterate while queue not empty\n    while (!isEmpty(q))\n    {\n        printf(\"%d \", pollQueue(q));\n        int currentVertex = dequeue(q);\n\n        struct node *temp = graph->adjLists[currentVertex];\n        // Add all unvisited neighbours of current vertex to queue to be printed\n        // next\n        while (temp)\n        {\n            int adjVertex = temp->vertex;\n            // Only add if neighbour is unvisited\n            if (graph->visited[adjVertex] == 0)\n            {\n                graph->visited[adjVertex] = 1;\n                enqueue(q, adjVertex);\n            }\n            temp = temp->next;\n        }\n    }\n}\n// Memory for a graph node\nstruct node *createNode(int v)\n{\n    struct node *newNode = malloc(sizeof(struct node));\n    newNode->vertex = v;\n    newNode->next = NULL;\n    return newNode;\n}\n// Allocates memory for graph data structure, in adjacency list format\nstruct Graph *createGraph(int vertices)\n{\n    struct Graph *graph = malloc(sizeof(struct Graph));\n    graph->numVertices = vertices;\n\n    graph->adjLists = malloc(vertices * sizeof(struct node *));\n    graph->visited = malloc(vertices * sizeof(int));\n\n    int i;\n    for (i = 0; i < vertices; i++)\n    {\n        graph->adjLists[i] = NULL;\n        graph->visited[i] = 0;\n    }\n\n    return graph;\n}\n// Adds bidirectional edge to graph\nvoid addEdge(struct Graph *graph, int src, int dest)\n{\n    // Add edge from src to dest\n    struct node *newNode = createNode(dest);\n    newNode->next = graph->adjLists[src];\n    graph->adjLists[src] = newNode;\n\n    // Add edge from dest to src; comment it out for directed graph\n    newNode = createNode(src);\n    newNode->next = graph->adjLists[dest];\n    graph->adjLists[dest] = newNode;\n}\n// Allocates memory for our queue data structure\nstruct queue *createQueue()\n{\n    struct queue *q = malloc(sizeof(struct queue));\n    q->front = -1;\n    q->rear = -1;\n    return q;\n}\n// Checks for empty queue\nint isEmpty(struct queue *q)\n{\n    if (q->rear == -1)\n        return 1;\n    else\n        return 0;\n}\n// Inserts item at start of queue\nvoid enqueue(struct queue *q, int value)\n{\n    if (q->rear == SIZE - 1)\n        printf(\"\\nQueue is Full!!\");\n    else\n    {\n        if (q->front == -1)\n            q->front = 0;\n        q->rear++;\n        q->items[q->rear] = value;\n    }\n}\n// Returns item at front of queue and removes it from queue\nint dequeue(struct queue *q)\n{\n    int item;\n    if (isEmpty(q))\n    {\n        printf(\"Queue is empty\");\n        item = -1;\n    }\n    else\n    {\n        item = q->items[q->front];\n        q->front++;\n        if (q->front > q->rear)\n        {\n            q->front = q->rear = -1;\n        }\n    }\n    return item;\n}\n\n// Returns element at front of queue\nint pollQueue(struct queue *q) { return q->items[q->front]; }\n","index":41},{"title":"Bfsqueue","category":"graphs","id":"bfsqueue_graphs","algorithm":"#include <stdbool.h>\n#include <stdio.h>\n#include \"Graph.h\"\n#include \"queue.h\"\n\n#define MAX_NODES 1000\n\nint visited[MAX_NODES];  // array to store visiting order\n                         // indexed by vertex 0..nV-1\n\nbool findPathBFS(Graph g, int nV, Vertex src, Vertex dest)\n{\n    Vertex v;\n    for (v = 0; v < nV; v++) visited[v] = -1;\n\n    visited[src] = src;\n    queue Q = newQueue();\n    QueueEnqueue(Q, src);\n    while (!QueueIsEmpty(Q))\n    {\n        v = QueueDequeue(Q);\n        Vertex w;\n        for (w = 0; w < nV; w++)\n            if (adjacent(g, v, w) && visited[w] == -1)\n            {\n                visited[w] = v;\n                if (w == dest)\n                    return true;\n                else\n                    QueueEnqueue(Q, w);\n            }\n    }\n    return false;\n}\n\nint main(void)\n{\n    int V = 10;\n    Graph g = newGraph(V);\n\n    Edge e;\n    e.v = 0;\n    e.w = 1;\n    insertEdge(g, e);\n    e.v = 0;\n    e.w = 2;\n    insertEdge(g, e);\n    e.v = 0;\n    e.w = 5;\n    insertEdge(g, e);\n    e.v = 1;\n    e.w = 5;\n    insertEdge(g, e);\n    e.v = 2;\n    e.w = 3;\n    insertEdge(g, e);\n    e.v = 3;\n    e.w = 4;\n    insertEdge(g, e);\n    e.v = 3;\n    e.w = 5;\n    insertEdge(g, e);\n    e.v = 3;\n    e.w = 8;\n    insertEdge(g, e);\n    e.v = 4;\n    e.w = 5;\n    insertEdge(g, e);\n    e.v = 4;\n    e.w = 7;\n    insertEdge(g, e);\n    e.v = 4;\n    e.w = 8;\n    insertEdge(g, e);\n    e.v = 5;\n    e.w = 6;\n    insertEdge(g, e);\n    e.v = 7;\n    e.w = 8;\n    insertEdge(g, e);\n    e.v = 7;\n    e.w = 9;\n    insertEdge(g, e);\n    e.v = 8;\n    e.w = 9;\n    insertEdge(g, e);\n\n    int src = 0, dest = 6;\n    if (findPathBFS(g, V, src, dest))\n    {\n        Vertex v = dest;\n        while (v != src)\n        {\n            printf(\"%d - \", v);\n            v = visited[v];\n        }\n        printf(\"%d\\n\", src);\n    }\n    return 0;\n}\n\n// By\n//  .----------------.  .----------------.  .----------------.\n//  .-----------------.  .----------------.  .----------------.\n// | .--------------. || .--------------. || .--------------. ||\n// .--------------. | | .--------------. || .--------------. | | |  _________ |\n// || | _____  _____ | || |      __      | || | ____  _____  | | | |  ____  ____\n// | || |     ____     | | | | |  _   _  |  | || ||_   _||_   _|| || |     /  \\\n// | || ||_   \\|_   _| | | | | |_   ||   _| | || |   .'    `.   | | | | |_/ | |\n// \\_|  | || |  | |    | |  | || |    / /\\ \\    | || |  |   \\ | |   | | | |   |\n// |__| |   | || |  /  .--.  \\  | | | |     | |      | || |  | '    ' |  | || |\n// / ____ \\   | || |  | |\\ \\| |   | | | |   |  __  |   | || |  | |    | |  | |\n// | |    _| |_     | || |   \\ `--' /   | || | _/ /    \\ \\_ | || | _| |_\\   |_\n// | | | |  _| |  | |_  | || |  \\  `--'  /  | | | |   |_____|    | || | `.__.'\n// | || ||____|  |____|| || ||_____|\\____| | | | | |____||____| | || | `.____.'\n// | | | |              | || |              | || |              | || | | | | |\n// | || |              | | | '--------------' || '--------------' ||\n// '--------------' || '--------------' | | '--------------' || '--------------'\n// |\n//  '----------------'  '----------------'  '----------------'\n//  '----------------'   '----------------'  '----------------'\n\n//  Email :    z5261243@unsw.edu.au\n//             hhoanhtuann@gmail.com\n","index":42},{"title":"Dfs","category":"graphs","id":"dfs_graphs","algorithm":"#include <stdio.h>\n#include <stdlib.h>\n\n// A vertex of the graph\nstruct node\n{\n    int vertex;\n    struct node *next;\n};\n// Some declarations\nstruct node *createNode(int v);\nstruct Graph\n{\n    int numVertices;\n    int *visited;\n    struct node *\n        *adjLists;  // we need int** to store a two dimensional array. Similary,\n                    // we need struct node** to store an array of Linked lists\n};\nstruct Graph *createGraph(int);\nvoid addEdge(struct Graph *, int, int);\nvoid printGraph(struct Graph *);\nvoid dfs(struct Graph *, int);\n\nint main()\n{\n    int vertices, edges, source, i, src, dst;\n    printf(\"Enter the number of vertices\\n\");\n    scanf(\"%d\", &vertices);\n    struct Graph *graph = createGraph(vertices);\n    printf(\"Enter the number of edges\\n\");\n    scanf(\"%d\", &edges);\n    for (i = 0; i < edges; i++)\n    {\n        printf(\"Edge %d \\nEnter source: \", i + 1);\n        scanf(\"%d\", &src);\n        printf(\"Enter destination: \");\n        scanf(\"%d\", &dst);\n        addEdge(graph, src, dst);\n    }\n    printf(\"Enter source of DFS\\n\");\n    scanf(\"%d\", &source);\n    printf(\"DFS from %d is:\\n\", source);\n    dfs(graph, source);\n    printf(\"\\n\");\n\n    // Uncomment below part to get a ready-made example\n    /*struct Graph* graph = createGraph(4);\n    addEdge(graph, 0, 1);\n    addEdge(graph, 0, 2);\n    addEdge(graph, 1, 2);\n    addEdge(graph, 2, 3);\n    printf(\"DFS from 0 is:\\n\");\n    dfs(graph,0);\n    printf(\"\\n\");*/\n\n    return 0;\n}\n// Recursive dfs approach\nvoid dfs(struct Graph *graph, int vertex)\n{\n    struct node *adjList = graph->adjLists[vertex];\n    struct node *temp = adjList;\n\n    // Add vertex to visited list and print it\n    graph->visited[vertex] = 1;\n    printf(\"%d \", vertex);\n\n    // Recursively call the dfs function on all unvisited neighbours\n    while (temp != NULL)\n    {\n        int connectedVertex = temp->vertex;\n        if (graph->visited[connectedVertex] == 0)\n        {\n            dfs(graph, connectedVertex);\n        }\n        temp = temp->next;\n    }\n}\n// Allocate memory for a node\nstruct node *createNode(int v)\n{\n    struct node *newNode = malloc(sizeof(struct node));\n    newNode->vertex = v;\n    newNode->next = NULL;\n    return newNode;\n}\n// Allocate memory for the entire graph structure\nstruct Graph *createGraph(int vertices)\n{\n    struct Graph *graph = malloc(sizeof(struct Graph));\n    graph->numVertices = vertices;\n\n    graph->adjLists = malloc(vertices * sizeof(struct node *));\n\n    graph->visited = malloc(vertices * sizeof(int));\n\n    int i;\n    for (i = 0; i < vertices; i++)\n    {\n        graph->adjLists[i] = NULL;\n        graph->visited[i] = 0;\n    }\n    return graph;\n}\n// Creates a bidirectional graph\nvoid addEdge(struct Graph *graph, int src, int dest)\n{\n    // Add edge from src to dest\n    struct node *newNode = createNode(dest);\n    newNode->next = graph->adjLists[src];\n    graph->adjLists[src] = newNode;\n\n    // Add edge from dest to src\n    newNode = createNode(src);\n    newNode->next = graph->adjLists[dest];\n    graph->adjLists[dest] = newNode;\n}\n// Utility function to see state of graph at a given time\nvoid printGraph(struct Graph *graph)\n{\n    int v;\n    for (v = 0; v < graph->numVertices; v++)\n    {\n        struct node *temp = graph->adjLists[v];\n        printf(\"\\n Adjacency list of vertex %d\\n \", v);\n        while (temp)\n        {\n            printf(\"%d -> \", temp->vertex);\n            temp = temp->next;\n        }\n        printf(\"\\n\");\n    }\n}\n","index":43},{"title":"Dfsrecursive","category":"graphs","id":"dfsrecursive_graphs","algorithm":"#include <stdbool.h>\n#include <stdio.h>\n#include \"Graph.h\"\n\n#define MAX_NODES 1000\n\nint visited[MAX_NODES];  // array to store visiting order\n                         // indexed by vertex 0..nV-1\n\nbool dfsPathCheck(Graph g, int nV, Vertex v, Vertex dest)\n{\n    Vertex w;\n    for (w = 0; w < nV; w++)\n        if (adjacent(g, v, w) && visited[w] == -1)\n        {\n            visited[w] = v;\n            if (w == dest)\n                return true;\n            else if (dfsPathCheck(g, nV, w, dest))\n                return true;\n        }\n    return false;\n}\n\nbool findPathDFS(Graph g, int nV, Vertex src, Vertex dest)\n{\n    Vertex v;\n    for (v = 0; v < nV; v++) visited[v] = -1;\n    visited[src] = src;\n    return dfsPathCheck(g, nV, src, dest);\n}\n\nint main(void)\n{\n    int V = 6;\n    Graph g = newGraph(V);\n\n    Edge e;\n    e.v = 0;\n    e.w = 1;\n    insertEdge(g, e);\n    e.v = 0;\n    e.w = 4;\n    insertEdge(g, e);\n    e.v = 0;\n    e.w = 5;\n    insertEdge(g, e);\n    e.v = 5;\n    e.w = 4;\n    insertEdge(g, e);\n    e.v = 4;\n    e.w = 2;\n    insertEdge(g, e);\n    e.v = 4;\n    e.w = 3;\n    insertEdge(g, e);\n    e.v = 5;\n    e.w = 3;\n    insertEdge(g, e);\n    e.v = 1;\n    e.w = 2;\n    insertEdge(g, e);\n    e.v = 3;\n    e.w = 2;\n    insertEdge(g, e);\n\n    int src = 0, dest = 5;\n    if (findPathDFS(g, V, src, dest))\n    {\n        Vertex v = dest;\n        while (v != src)\n        {\n            printf(\"%d - \", v);\n            v = visited[v];\n        }\n        printf(\"%d\\n\", src);\n    }\n    return 0;\n}\n\n// By\n//  .----------------.  .----------------.  .----------------.\n//  .-----------------.  .----------------.  .----------------.\n// | .--------------. || .--------------. || .--------------. ||\n// .--------------. | | .--------------. || .--------------. | | |  _________ |\n// || | _____  _____ | || |      __      | || | ____  _____  | | | |  ____  ____\n// | || |     ____     | | | | |  _   _  |  | || ||_   _||_   _|| || |     /  \\\n// | || ||_   \\|_   _| | | | | |_   ||   _| | || |   .'    `.   | | | | |_/ | |\n// \\_|  | || |  | |    | |  | || |    / /\\ \\    | || |  |   \\ | |   | | | |   |\n// |__| |   | || |  /  .--.  \\  | | | |     | |      | || |  | '    ' |  | || |\n// / ____ \\   | || |  | |\\ \\| |   | | | |   |  __  |   | || |  | |    | |  | |\n// | |    _| |_     | || |   \\ `--' /   | || | _/ /    \\ \\_ | || | _| |_\\   |_\n// | | | |  _| |  | |_  | || |  \\  `--'  /  | | | |   |_____|    | || | `.__.'\n// | || ||____|  |____|| || ||_____|\\____| | | | | |____||____| | || | `.____.'\n// | | | |              | || |              | || |              | || | | | | |\n// | || |              | | | '--------------' || '--------------' ||\n// '--------------' || '--------------' | | '--------------' || '--------------'\n// |\n//  '----------------'  '----------------'  '----------------'\n//  '----------------'   '----------------'  '----------------'\n\n//  Email :    z5261243@unsw.edu.au\n//             hhoanhtuann@gmail.com\n","index":44},{"title":"Dijkstra","category":"graphs","id":"dijkstra_graphs","algorithm":"#include <limits.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Structure for storing a graph\nstruct Graph\n{\n    int vertexNum;\n    int **edges;\n};\n\n// Constructs a graph with V vertices and E edges\nvoid createGraph(struct Graph *G, int V)\n{\n    G->vertexNum = V;\n    G->edges = (int **)malloc(V * sizeof(int *));\n    for (int i = 0; i < V; i++)\n    {\n        G->edges[i] = (int *)malloc(V * sizeof(int));\n        for (int j = 0; j < V; j++) G->edges[i][j] = INT_MAX;\n        G->edges[i][i] = 0;\n    }\n}\n\n// Adds the given edge to the graph\nvoid addEdge(struct Graph *G, int src, int dst, int weight)\n{\n    G->edges[src][dst] = weight;\n}\n\n// Utility function to find minimum distance vertex in mdist\nint minDistance(int mdist[], int vset[], int V)\n{\n    int minVal = INT_MAX, minInd;\n    for (int i = 0; i < V; i++)\n        if (vset[i] == 0 && mdist[i] < minVal)\n        {\n            minVal = mdist[i];\n            minInd = i;\n        }\n\n    return minInd;\n}\n\n// Utility function to print distances\nvoid print(int dist[], int V)\n{\n    printf(\"\\nVertex  Distance\\n\");\n    for (int i = 0; i < V; i++)\n    {\n        if (dist[i] != INT_MAX)\n            printf(\"%d\\t%d\\n\", i, dist[i]);\n        else\n            printf(\"%d\\tINF\", i);\n    }\n}\n\n// The main function that finds the shortest path from given source\n// to all other vertices using Dijkstra's Algorithm.It doesn't work on negative\n// weights\nvoid Dijkstra(struct Graph *graph, int src)\n{\n    int V = graph->vertexNum;\n    int mdist[V];  // Stores updated distances to vertex\n    int vset[V];   // vset[i] is true if the vertex i included\n                   // in the shortest path tree\n\n    // Initialise mdist and vset. Set distance of source as zero\n    for (int i = 0; i < V; i++) mdist[i] = INT_MAX, vset[i] = 0;\n\n    mdist[src] = 0;\n\n    // iterate to find shortest path\n    for (int count = 0; count < V - 1; count++)\n    {\n        int u = minDistance(mdist, vset, V);\n        vset[u] = 1;\n\n        for (int v = 0; v < V; v++)\n        {\n            if (!vset[v] && graph->edges[u][v] != INT_MAX &&\n                mdist[u] + graph->edges[u][v] < mdist[v])\n                mdist[v] = mdist[u] + graph->edges[u][v];\n        }\n    }\n\n    print(mdist, V);\n\n    return;\n}\n\n// Driver Function\nint main()\n{\n    int V, E, gsrc;\n    int src, dst, weight;\n    struct Graph G;\n    printf(\"Enter number of vertices: \");\n    scanf(\"%d\", &V);\n    printf(\"Enter number of edges: \");\n    scanf(\"%d\", &E);\n    createGraph(&G, V);\n    for (int i = 0; i < E; i++)\n    {\n        printf(\"\\nEdge %d \\nEnter source: \", i + 1);\n        scanf(\"%d\", &src);\n        printf(\"Enter destination: \");\n        scanf(\"%d\", &dst);\n        printf(\"Enter weight: \");\n        scanf(\"%d\", &weight);\n        addEdge(&G, src, dst, weight);\n    }\n    printf(\"\\nEnter source:\");\n    scanf(\"%d\", &gsrc);\n    Dijkstra(&G, gsrc);\n\n    return 0;\n}\n","index":45},{"title":"Euler","category":"graphs","id":"euler_graphs","algorithm":"#include <stdbool.h>\n#include <stdio.h>\n#include \"Graph.h\"\n\n// Return the number of vertices that v is\n// connected to\nint degree(Graph g, int nV, Vertex v)\n{\n    int deg = 0;\n    Vertex w;\n    for (w = 0; w < nV; w++)\n        if (adjacent(g, v, w))\n            deg++;\n    return deg;\n}\n\n// If start from vertex v, decide if the\n// graph has euler path\nbool hasEulerPath(Graph g, int nV, Vertex v, Vertex w)\n{\n    if (v != w)\n    {\n        if (degree(g, nV, v) % 2 == 0 || degree(g, nV, w) % 2 == 0)\n            return false;\n    }\n    else if (degree(g, nV, v) % 2 != 0)\n    {\n        return false;\n    }\n    Vertex x;\n    for (x = 0; x < nV; x++)\n        if (x != v && x != w && degree(g, nV, x) % 2 != 0)\n            return false;\n    return true;\n}\n\nint main(void)\n{\n    Edge e;\n    int n;\n\n    printf(\"Enter the number of vertices: \");\n    scanf(\"%d\", &n);\n    Graph g = newGraph(n);\n\n    Vertex src, dest;\n    printf(\"Enter source node: \");\n    scanf(\"%d\", &src);\n    printf(\"Enter destination node: \");\n    scanf(\"%d\", &dest);\n\n    printf(\"Enter an edge (from): \");\n    while (scanf(\"%d\", &e.v) == 1)\n    {\n        printf(\"Enter an edge (to): \");\n        scanf(\"%d\", &e.w);\n        insertEdge(g, e);\n        printf(\"Enter an edge (from): \");\n    }\n    printf(\"Finished.\\n\");\n\n    printf(\"The graph has \");\n    if (hasEulerPath(g, n, src, dest))\n        printf(\"an\");\n    else\n        printf(\"no\");\n    printf(\" Euler path from %d to %d.\\n\", src, dest);\n\n    freeGraph(g);\n    return 0;\n}\n\n// By\n//  .----------------.  .----------------.  .----------------.\n//  .-----------------.  .----------------.  .----------------.\n// | .--------------. || .--------------. || .--------------. ||\n// .--------------. | | .--------------. || .--------------. | | |  _________ |\n// || | _____  _____ | || |      __      | || | ____  _____  | | | |  ____  ____\n// | || |     ____     | | | | |  _   _  |  | || ||_   _||_   _|| || |     /  \\\n// | || ||_   \\|_   _| | | | | |_   ||   _| | || |   .'    `.   | | | | |_/ | |\n// \\_|  | || |  | |    | |  | || |    / /\\ \\    | || |  |   \\ | |   | | | |   |\n// |__| |   | || |  /  .--.  \\  | | | |     | |      | || |  | '    ' |  | || |\n// / ____ \\   | || |  | |\\ \\| |   | | | |   |  __  |   | || |  | |    | |  | |\n// | |    _| |_     | || |   \\ `--' /   | || | _/ /    \\ \\_ | || | _| |_\\   |_\n// | | | |  _| |  | |_  | || |  \\  `--'  /  | | | |   |_____|    | || | `.__.'\n// | || ||____|  |____|| || ||_____|\\____| | | | | |____||____| | || | `.____.'\n// | | | |              | || |              | || |              | || | | | | |\n// | || |              | | | '--------------' || '--------------' ||\n// '--------------' || '--------------' | | '--------------' || '--------------'\n// |\n//  '----------------'  '----------------'  '----------------'\n//  '----------------'   '----------------'  '----------------'\n\n//  Email :    z5261243@unsw.edu.au\n//             hhoanhtuann@gmail.com\n","index":46},{"title":"Floyd Warshall","category":"graphs","id":"floyd_warshall_graphs","algorithm":"#include <limits.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Structure for storing a graph\nstruct Graph\n{\n    int vertexNum;\n    int **edges;\n};\n\n// Constructs a graph with V vertices and E edges\nvoid createGraph(struct Graph *G, int V)\n{\n    G->vertexNum = V;\n    G->edges = (int **)malloc(V * sizeof(int *));\n    for (int i = 0; i < V; i++)\n    {\n        G->edges[i] = (int *)malloc(V * sizeof(int));\n        for (int j = 0; j < V; j++) G->edges[i][j] = INT_MAX;\n        G->edges[i][i] = 0;\n    }\n}\n\n// Adds the given edge to the graph\nvoid addEdge(struct Graph *G, int src, int dst, int weight)\n{\n    G->edges[src][dst] = weight;\n}\n\n// Utility function to print distances\nvoid print(int dist[], int V)\n{\n    printf(\"\\nThe Distance matrix for Floyd - Warshall\\n\");\n    for (int i = 0; i < V; i++)\n    {\n        for (int j = 0; j < V; j++)\n        {\n            if (dist[i * V + j] != INT_MAX)\n                printf(\"%d\\t\", dist[i * V + j]);\n            else\n                printf(\"INF\\t\");\n        }\n        printf(\"\\n\");\n    }\n}\n\n// The main function that finds the shortest path from a vertex\n// to all other vertices using Floyd-Warshall Algorithm.\nvoid FloydWarshall(struct Graph *graph)\n{\n    int V = graph->vertexNum;\n    int dist[V][V];\n\n    // Initialise distance array\n    for (int i = 0; i < V; i++)\n        for (int j = 0; j < V; j++) dist[i][j] = graph->edges[i][j];\n\n    // Calculate distances\n    for (int k = 0; k < V; k++)\n        // Choose an intermediate vertex\n\n        for (int i = 0; i < V; i++)\n            // Choose a source vertex for given intermediate\n\n            for (int j = 0; j < V; j++)\n                // Choose a destination vertex for above source vertex\n\n                if (dist[i][k] != INT_MAX && dist[k][j] != INT_MAX &&\n                    dist[i][k] + dist[k][j] < dist[i][j])\n                    // If the distance through intermediate vertex is less than\n                    // direct edge then update value in distance array\n                    dist[i][j] = dist[i][k] + dist[k][j];\n\n    // Convert 2d array to 1d array for print\n    int dist1d[V * V];\n    for (int i = 0; i < V; i++)\n        for (int j = 0; j < V; j++) dist1d[i * V + j] = dist[i][j];\n\n    print(dist1d, V);\n}\n\n// Driver Function\nint main()\n{\n    int V, E;\n    int src, dst, weight;\n    struct Graph G;\n    printf(\"Enter number of vertices: \");\n    scanf(\"%d\", &V);\n    printf(\"Enter number of edges: \");\n    scanf(\"%d\", &E);\n    createGraph(&G, V);\n    for (int i = 0; i < E; i++)\n    {\n        printf(\"\\nEdge %d \\nEnter source: \", i + 1);\n        scanf(\"%d\", &src);\n        printf(\"Enter destination: \");\n        scanf(\"%d\", &dst);\n        printf(\"Enter weight: \");\n        scanf(\"%d\", &weight);\n        addEdge(&G, src, dst, weight);\n    }\n    FloydWarshall(&G);\n\n    return 0;\n}\n","index":47},{"title":"Graph","category":"graphs","id":"graph_graphs","algorithm":"// Graph ADT\n// Adjacency Matrix Representation\n#include \"Graph.h\"\n#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct GraphRep\n{\n    int **edges;  // adjacency matrix\n    int nV;       // #vertices\n    int nE;       // #edges\n} GraphRep;\n\nGraph newGraph(int V)\n{\n    assert(V >= 0);\n    int i;\n\n    Graph g = malloc(sizeof(GraphRep));\n    assert(g != NULL);\n    g->nV = V;\n    g->nE = 0;\n\n    // allocate memory for each row\n    g->edges = malloc(V * sizeof(int *));\n    assert(g->edges != NULL);\n    // allocate memory for each column and initialise with 0\n    for (i = 0; i < V; i++)\n    {\n        g->edges[i] = calloc(V, sizeof(int));\n        assert(g->edges[i] != NULL);\n    }\n\n    return g;\n}\n\n// check if vertex is valid in a graph\nbool validV(Graph g, Vertex v) { return (g != NULL && v >= 0 && v < g->nV); }\n\nvoid insertEdge(Graph g, Edge e)\n{\n    assert(g != NULL && validV(g, e.v) && validV(g, e.w));\n\n    if (!g->edges[e.v][e.w])\n    {  // edge e not in graph\n        g->edges[e.v][e.w] = 1;\n        g->edges[e.w][e.v] = 1;\n        g->nE++;\n    }\n}\n\nvoid removeEdge(Graph g, Edge e)\n{\n    assert(g != NULL && validV(g, e.v) && validV(g, e.w));\n\n    if (g->edges[e.v][e.w])\n    {  // edge e in graph\n        g->edges[e.v][e.w] = 0;\n        g->edges[e.w][e.v] = 0;\n        g->nE--;\n    }\n}\n\nbool adjacent(Graph g, Vertex v, Vertex w)\n{\n    assert(g != NULL && validV(g, v) && validV(g, w));\n\n    return (g->edges[v][w] != 0);\n}\n\nvoid showGraph(Graph g)\n{\n    assert(g != NULL);\n    int i, j;\n\n    printf(\"Number of vertices: %d\\n\", g->nV);\n    printf(\"Number of edges: %d\\n\", g->nE);\n    for (i = 0; i < g->nV; i++)\n        for (j = i + 1; j < g->nV; j++)\n            if (g->edges[i][j])\n                printf(\"Edge %d - %d\\n\", i, j);\n}\n\nvoid freeGraph(Graph g)\n{\n    assert(g != NULL);\n\n    int i;\n    for (i = 0; i < g->nV; i++) free(g->edges[i]);\n    free(g->edges);\n    free(g);\n}\n\n// By\n//  .----------------.  .----------------.  .----------------.\n//  .-----------------.  .----------------.  .----------------.\n// | .--------------. || .--------------. || .--------------. ||\n// .--------------. | | .--------------. || .--------------. | | |  _________ |\n// || | _____  _____ | || |      __      | || | ____  _____  | | | |  ____  ____\n// | || |     ____     | | | | |  _   _  |  | || ||_   _||_   _|| || |     /  \\\n// | || ||_   \\|_   _| | | | | |_   ||   _| | || |   .'    `.   | | | | |_/ | |\n// \\_|  | || |  | |    | |  | || |    / /\\ \\    | || |  |   \\ | |   | | | |   |\n// |__| |   | || |  /  .--.  \\  | | | |     | |      | || |  | '    ' |  | || |\n// / ____ \\   | || |  | |\\ \\| |   | | | |   |  __  |   | || |  | |    | |  | |\n// | |    _| |_     | || |   \\ `--' /   | || | _/ /    \\ \\_ | || | _| |_\\   |_\n// | | | |  _| |  | |_  | || |  \\  `--'  /  | | | |   |_____|    | || | `.__.'\n// | || ||____|  |____|| || ||_____|\\____| | | | | |____||____| | || | `.____.'\n// | | | |              | || |              | || |              | || | | | | |\n// | || |              | | | '--------------' || '--------------' ||\n// '--------------' || '--------------' | | '--------------' || '--------------'\n// |\n//  '----------------'  '----------------'  '----------------'\n//  '----------------'   '----------------'  '----------------'\n\n//  Email :    z5261243@unsw.edu.au\n//             hhoanhtuann@gmail.com\n","index":48},{"title":"Graph.h","category":"graphs","id":"graph.h_graphs","algorithm":"// Graph ADT interface ... COMP2521\n#include <stdbool.h>\n\ntypedef struct GraphRep *Graph;\n\n// vertices are ints\ntypedef int Vertex;\n\n// edges are pairs of vertices (end-points)\ntypedef struct Edge\n{\n    Vertex v;\n    Vertex w;\n} Edge;\n\nGraph newGraph(int);\nvoid insertEdge(Graph, Edge);\nvoid removeEdge(Graph, Edge);\nbool adjacent(Graph, Vertex, Vertex);\nvoid showGraph(Graph);\nvoid freeGraph(Graph);\n\n// By\n//  .----------------.  .----------------.  .----------------.\n//  .-----------------.  .----------------.  .----------------.\n// | .--------------. || .--------------. || .--------------. ||\n// .--------------. | | .--------------. || .--------------. | | |  _________ |\n// || | _____  _____ | || |      __      | || | ____  _____  | | | |  ____  ____\n// | || |     ____     | | | | |  _   _  |  | || ||_   _||_   _|| || |     /  \\\n// | || ||_   \\|_   _| | | | | |_   ||   _| | || |   .'    `.   | | | | |_/ | |\n// \\_|  | || |  | |    | |  | || |    / /\\ \\    | || |  |   \\ | |   | | | |   |\n// |__| |   | || |  /  .--.  \\  | | | |     | |      | || |  | '    ' |  | || |\n// / ____ \\   | || |  | |\\ \\| |   | | | |   |  __  |   | || |  | |    | |  | |\n// | |    _| |_     | || |   \\ `--' /   | || | _/ /    \\ \\_ | || | _| |_\\   |_\n// | | | |  _| |  | |_  | || |  \\  `--'  /  | | | |   |_____|    | || | `.__.'\n// | || ||____|  |____|| || ||_____|\\____| | | | | |____||____| | || | `.____.'\n// | | | |              | || |              | || |              | || | | | | |\n// | || |              | | | '--------------' || '--------------' ||\n// '--------------' || '--------------' | | '--------------' || '--------------'\n// |\n//  '----------------'  '----------------'  '----------------'\n//  '----------------'   '----------------'  '----------------'\n\n//  Email :    z5261243@unsw.edu.au\n//             hhoanhtuann@gmail.com\n","index":49},{"title":"Hamiltonian","category":"graphs","id":"hamiltonian_graphs","algorithm":"#include <stdbool.h>\n#include <stdio.h>\n#include \"Graph.h\"\n\n#define MAX_NODES 1000\n\nbool visited[MAX_NODES];\n\nbool hamiltonR(Graph g, int nV, Vertex v, Vertex dest, int d)\n{\n    // v = current vertex considered\n    // dest = destination vertex\n    // d = distance \"remaining\" until path found\n\n    Vertex w;\n    if (v == dest)\n    {\n        return (d == 0);\n    }\n    else\n    {\n        visited[v] = true;\n        for (w = 0; w < nV; w++)\n        {\n            if (adjacent(g, v, w) && !visited[w])\n            {\n                if (hamiltonR(g, nV, w, dest, d - 1))\n                {\n                    return true;\n                }\n            }\n        }\n    }\n    visited[v] = false;\n    return false;\n}\n\nbool hasHamiltonianPath(Graph g, int nV, Vertex src, Vertex dest)\n{\n    Vertex v;\n    for (v = 0; v < nV; v++) visited[v] = false;\n    return hamiltonR(g, nV, src, dest, nV - 1);\n}\n\nint main(void)\n{\n    Edge e;\n    int n;\n\n    printf(\"Enter the number of vertices: \");\n    scanf(\"%d\", &n);\n    Graph g = newGraph(n);\n\n    Vertex src, dest;\n    printf(\"Enter source node: \");\n    scanf(\"%d\", &src);\n    printf(\"Enter destination node: \");\n    scanf(\"%d\", &dest);\n\n    printf(\"Enter an edge (from): \");\n    while (scanf(\"%d\", &e.v) == 1)\n    {\n        printf(\"Enter an edge (to): \");\n        scanf(\"%d\", &e.w);\n        insertEdge(g, e);\n        printf(\"Enter an edge (from): \");\n    }\n    printf(\"Finished.\\n\");\n\n    printf(\"The graph has \");\n    if (hasHamiltonianPath(g, n, src, dest))\n        printf(\"a\");\n    else\n        printf(\"no\");\n    printf(\" Hamiltonian path from %d to %d.\\n\", src, dest);\n\n    freeGraph(g);\n    return 0;\n}\n\n// By\n//  .----------------.  .----------------.  .----------------.\n//  .-----------------.  .----------------.  .----------------.\n// | .--------------. || .--------------. || .--------------. ||\n// .--------------. | | .--------------. || .--------------. | | |  _________ |\n// || | _____  _____ | || |      __      | || | ____  _____  | | | |  ____  ____\n// | || |     ____     | | | | |  _   _  |  | || ||_   _||_   _|| || |     /  \\\n// | || ||_   \\|_   _| | | | | |_   ||   _| | || |   .'    `.   | | | | |_/ | |\n// \\_|  | || |  | |    | |  | || |    / /\\ \\    | || |  |   \\ | |   | | | |   |\n// |__| |   | || |  /  .--.  \\  | | | |     | |      | || |  | '    ' |  | || |\n// / ____ \\   | || |  | |\\ \\| |   | | | |   |  __  |   | || |  | |    | |  | |\n// | |    _| |_     | || |   \\ `--' /   | || | _/ /    \\ \\_ | || | _| |_\\   |_\n// | | | |  _| |  | |_  | || |  \\  `--'  /  | | | |   |_____|    | || | `.__.'\n// | || ||____|  |____|| || ||_____|\\____| | | | | |____||____| | || | `.____.'\n// | | | |              | || |              | || |              | || | | | | |\n// | || |              | | | '--------------' || '--------------' ||\n// '--------------' || '--------------' | | '--------------' || '--------------'\n// |\n//  '----------------'  '----------------'  '----------------'\n//  '----------------'   '----------------'  '----------------'\n\n//  Email :    z5261243@unsw.edu.au\n//             hhoanhtuann@gmail.com\n","index":50},{"title":"Kruskal","category":"graphs","id":"kruskal_graphs","algorithm":"// C program for Kruskal's algorithm to find Minimum Spanning Tree\n// of a given connected, undirected and weighted graph\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// a structure to represent a weighted edge in graph\nstruct Edge\n{\n    int src, dest, weight;\n};\n\n// a structure to represent a connected, undirected\n// and weighted graph\nstruct Graph\n{\n    // V-> Number of vertices, E-> Number of edges\n    int V, E;\n\n    // graph is represented as an array of edges.\n    // Since the graph is undirected, the edge\n    // from src to dest is also edge from dest\n    // to src. Both are counted as 1 edge here.\n    struct Edge *edge;\n};\n\n// Creates a graph with V vertices and E edges\nstruct Graph *createGraph(int V, int E)\n{\n    struct Graph *graph = new Graph();\n    graph->V = V;\n    graph->E = E;\n\n    graph->edge = new Edge[E];\n\n    return graph;\n}\n\n// A structure to represent a subset for union-find\nstruct subset\n{\n    int parent;\n    int rank;\n};\n\n// A utility function to find set of an element i\n// (uses path compression technique)\nint find(struct subset subsets[], int i)\n{\n    // find root and make root as parent of i\n    // (path compression)\n    if (subsets[i].parent != i)\n        subsets[i].parent = find(subsets, subsets[i].parent);\n\n    return subsets[i].parent;\n}\n\n// A function that does union of two sets of x and y\n// (uses union by rank)\nvoid Union(struct subset subsets[], int x, int y)\n{\n    int xroot = find(subsets, x);\n    int yroot = find(subsets, y);\n\n    // Attach smaller rank tree under root of high\n    // rank tree (Union by Rank)\n    if (subsets[xroot].rank < subsets[yroot].rank)\n        subsets[xroot].parent = yroot;\n    else if (subsets[xroot].rank > subsets[yroot].rank)\n        subsets[yroot].parent = xroot;\n\n    // If ranks are same, then make one as root and\n    // increment its rank by one\n    else\n    {\n        subsets[yroot].parent = xroot;\n        subsets[xroot].rank++;\n    }\n}\n\n// Compare two edges according to their weights.\n// Used in qsort() for sorting an array of edges\nint myComp(const void *a, const void *b)\n{\n    struct Edge *a1 = (struct Edge *)a;\n    struct Edge *b1 = (struct Edge *)b;\n    return a1->weight > b1->weight;\n}\n\n// The main function to construct MST using Kruskal's algorithm\nvoid KruskalMST(struct Graph *graph)\n{\n    int V = graph->V;\n    struct Edge result[V];  // Tnis will store the resultant MST\n    int e = 0;              // An index variable, used for result[]\n    int i = 0;              // An index variable, used for sorted edges\n\n    // Step 1: Sort all the edges in non-decreasing\n    // order of their weight. If we are not allowed to\n    // change the given graph, we can create a copy of\n    // array of edges\n    qsort(graph->edge, graph->E, sizeof(graph->edge[0]), myComp);\n\n    // Allocate memory for creating V ssubsets\n    struct subset *subsets = (struct subset *)malloc(V * sizeof(struct subset));\n\n    // Create V subsets with single elements\n    for (int v = 0; v < V; ++v)\n    {\n        subsets[v].parent = v;\n        subsets[v].rank = 0;\n    }\n\n    // Number of edges to be taken is equal to V-1\n    while (e < V - 1 && i < graph->E)\n    {\n        // Step 2: Pick the smallest edge. And increment\n        // the index for next iteration\n        struct Edge next_edge = graph->edge[i++];\n\n        int x = find(subsets, next_edge.src);\n        int y = find(subsets, next_edge.dest);\n\n        // If including this edge does't cause cycle,\n        // include it in result and increment the index\n        // of result for next edge\n        if (x != y)\n        {\n            result[e++] = next_edge;\n            Union(subsets, x, y);\n        }\n        // Else discard the next_edge\n    }\n\n    // print the contents of result[] to display the\n    // built MST\n    printf(\"Following are the edges in the constructed MST\\n\");\n    for (i = 0; i < e; ++i)\n        printf(\"%d -- %d == %d\\n\", result[i].src, result[i].dest,\n               result[i].weight);\n    return;\n}\n\n// Driver program to test above functions\nint main()\n{\n    /* Let us create following weighted graph\n            10\n        0--------1\n        | \\\t |\n    6| 5\\ |15\n        |\t \\ |\n        2--------3\n            4\t */\n    int V = 4;  // Number of vertices in graph\n    int E = 5;  // Number of edges in graph\n    struct Graph *graph = createGraph(V, E);\n\n    // add edge 0-1\n    graph->edge[0].src = 0;\n    graph->edge[0].dest = 1;\n    graph->edge[0].weight = 10;\n\n    // add edge 0-2\n    graph->edge[1].src = 0;\n    graph->edge[1].dest = 2;\n    graph->edge[1].weight = 6;\n\n    // add edge 0-3\n    graph->edge[2].src = 0;\n    graph->edge[2].dest = 3;\n    graph->edge[2].weight = 5;\n\n    // add edge 1-3\n    graph->edge[3].src = 1;\n    graph->edge[3].dest = 3;\n    graph->edge[3].weight = 15;\n\n    // add edge 2-3\n    graph->edge[4].src = 2;\n    graph->edge[4].dest = 3;\n    graph->edge[4].weight = 4;\n\n    KruskalMST(graph);\n\n    return 0;\n}\n","index":51},{"title":"Queue","category":"graphs","id":"queue_graphs","algorithm":"// Queue ADT implementation ... COMP2521\n\n#include \"queue.h\"\n#include <assert.h>\n#include <stdlib.h>\n\ntypedef struct node\n{\n    int data;\n    struct node *next;\n} NodeT;\n\ntypedef struct QueueRep\n{\n    int length;\n    NodeT *head;\n    NodeT *tail;\n} QueueRep;\n\n// set up empty queue\nqueue newQueue()\n{\n    queue Q = malloc(sizeof(QueueRep));\n    Q->length = 0;\n    Q->head = NULL;\n    Q->tail = NULL;\n    return Q;\n}\n\n// remove unwanted queue\nvoid dropQueue(queue Q)\n{\n    NodeT *curr = Q->head;\n    while (curr != NULL)\n    {\n        NodeT *temp = curr->next;\n        free(curr);\n        curr = temp;\n    }\n    free(Q);\n}\n\n// check whether queue is empty\nint QueueIsEmpty(queue Q) { return (Q->length == 0); }\n\n// insert an int at end of queue\nvoid QueueEnqueue(queue Q, int v)\n{\n    NodeT *new = malloc(sizeof(NodeT));\n    assert(new != NULL);\n    new->data = v;\n    new->next = NULL;\n    if (Q->tail != NULL)\n    {\n        Q->tail->next = new;\n        Q->tail = new;\n    }\n    else\n    {\n        Q->head = new;\n        Q->tail = new;\n    }\n    Q->length++;\n}\n\n// remove int from front of queue\nint QueueDequeue(queue Q)\n{\n    assert(Q->length > 0);\n    NodeT *p = Q->head;\n    Q->head = Q->head->next;\n    if (Q->head == NULL)\n    {\n        Q->tail = NULL;\n    }\n    Q->length--;\n    int d = p->data;\n    free(p);\n    return d;\n}\n\n// By\n//  .----------------.  .----------------.  .----------------.\n//  .-----------------.  .----------------.  .----------------.\n// | .--------------. || .--------------. || .--------------. ||\n// .--------------. | | .--------------. || .--------------. | | |  _________ |\n// || | _____  _____ | || |      __      | || | ____  _____  | | | |  ____  ____\n// | || |     ____     | | | | |  _   _  |  | || ||_   _||_   _|| || |     /  \\\n// | || ||_   \\|_   _| | | | | |_   ||   _| | || |   .'    `.   | | | | |_/ | |\n// \\_|  | || |  | |    | |  | || |    / /\\ \\    | || |  |   \\ | |   | | | |   |\n// |__| |   | || |  /  .--.  \\  | | | |     | |      | || |  | '    ' |  | || |\n// / ____ \\   | || |  | |\\ \\| |   | | | |   |  __  |   | || |  | |    | |  | |\n// | |    _| |_     | || |   \\ `--' /   | || | _/ /    \\ \\_ | || | _| |_\\   |_\n// | | | |  _| |  | |_  | || |  \\  `--'  /  | | | |   |_____|    | || | `.__.'\n// | || ||____|  |____|| || ||_____|\\____| | | | | |____||____| | || | `.____.'\n// | | | |              | || |              | || |              | || | | | | |\n// | || |              | | | '--------------' || '--------------' ||\n// '--------------' || '--------------' | | '--------------' || '--------------'\n// |\n//  '----------------'  '----------------'  '----------------'\n//  '----------------'   '----------------'  '----------------'\n\n//  Email :    z5261243@unsw.edu.au\n//             hhoanhtuann@gmail.com\n","index":52},{"title":"Queue.h","category":"graphs","id":"queue.h_graphs","algorithm":"// Queue ADT header file ... COMP2521\n\ntypedef struct QueueRep *queue;\n\nqueue newQueue();               // set up empty queue\nvoid dropQueue(queue);          // remove unwanted queue\nint QueueIsEmpty(queue);        // check whether queue is empty\nvoid QueueEnqueue(queue, int);  // insert an int at end of queue\nint QueueDequeue(queue);        // remove int from front of queue\n\n// By\n//  .----------------.  .----------------.  .----------------.\n//  .-----------------.  .----------------.  .----------------.\n// | .--------------. || .--------------. || .--------------. ||\n// .--------------. | | .--------------. || .--------------. | | |  _________ |\n// || | _____  _____ | || |      __      | || | ____  _____  | | | |  ____  ____\n// | || |     ____     | | | | |  _   _  |  | || ||_   _||_   _|| || |     /  \\\n// | || ||_   \\|_   _| | | | | |_   ||   _| | || |   .'    `.   | | | | |_/ | |\n// \\_|  | || |  | |    | |  | || |    / /\\ \\    | || |  |   \\ | |   | | | |   |\n// |__| |   | || |  /  .--.  \\  | | | |     | |      | || |  | '    ' |  | || |\n// / ____ \\   | || |  | |\\ \\| |   | | | |   |  __  |   | || |  | |    | |  | |\n// | |    _| |_     | || |   \\ `--' /   | || | _/ /    \\ \\_ | || | _| |_\\   |_\n// | | | |  _| |  | |_  | || |  \\  `--'  /  | | | |   |_____|    | || | `.__.'\n// | || ||____|  |____|| || ||_____|\\____| | | | | |____||____| | || | `.____.'\n// | | | |              | || |              | || |              | || | | | | |\n// | || |              | | | '--------------' || '--------------' ||\n// '--------------' || '--------------' | | '--------------' || '--------------'\n// |\n//  '----------------'  '----------------'  '----------------'\n//  '----------------'   '----------------'  '----------------'\n\n//  Email :    z5261243@unsw.edu.au\n//             hhoanhtuann@gmail.com\n","index":53},{"title":"Strongly Connected Components","category":"graphs","id":"strongly_connected_components_graphs","algorithm":"#include <stdio.h>\n#include <stdlib.h>\n#define MAX_SIZE 40  // Assume 40 nodes at max in graph\n#define INT_MIN 0\n// A vertex of the graph\nstruct node\n{\n    int vertex;\n    struct node *next;\n};\n// Some declarations\nstruct node *createNode(int v);\nstruct Graph\n{\n    int numVertices;\n    int *visited;\n    struct node *\n        *adjLists;  // we need int** to store a two dimensional array. Similary,\n                    // we need struct node** to store an array of Linked lists\n};\n// Structure to create a stack, necessary for topological sorting\nstruct Stack\n{\n    int arr[MAX_SIZE];\n    int top;\n};\nstruct Graph *createGraph(int);\nvoid addEdge(struct Graph *, int, int);\nvoid printGraph(struct Graph *);\nstruct Graph *transpose(struct Graph *);\nvoid fillOrder(int, struct Graph *, struct Stack *);\nvoid scc(struct Graph *);\nvoid dfs(struct Graph *, int);\nstruct Stack *createStack();\nvoid push(struct Stack *, int);\nint pop(struct Stack *);\n\nint main()\n{\n    int vertices, edges, i, src, dst;\n    printf(\"Enter the number of vertices\\n\");\n    scanf(\"%d\", &vertices);\n    struct Graph *graph = createGraph(vertices);\n    printf(\"Enter the number of edges\\n\");\n    scanf(\"%d\", &edges);\n    for (i = 0; i < edges; i++)\n    {\n        printf(\"Edge %d \\nEnter source: \", i + 1);\n        scanf(\"%d\", &src);\n        printf(\"Enter destination: \");\n        scanf(\"%d\", &dst);\n        addEdge(graph, src, dst);\n    }\n    printf(\"The strongly connected conponents are:\\n\");\n    scc(graph);\n    printf(\"\\n\");\n\n    // Uncomment below part to get a ready-made example\n    /*struct Graph* graph2 = createGraph(4);\n    addEdge(graph2, 0, 1);\n    addEdge(graph2, 1, 2);\n    addEdge(graph2, 2, 0);\n    addEdge(graph2, 2, 3);\n    printf(\"The strongly connected components are:\\n\");\n    scc(graph2);\n    printf(\"\\n\");*/\n    return 0;\n}\n// Creates a topological sorting of the graph\nvoid fillOrder(int vertex, struct Graph *graph, struct Stack *stack)\n{\n    graph->visited[vertex] = 1;\n    struct node *adjList = graph->adjLists[vertex];\n    struct node *temp = adjList;\n    // First add all dependents (that is, children) to stack\n    while (temp != NULL)\n    {\n        int connectedVertex = temp->vertex;\n        if (graph->visited[connectedVertex] == 0)\n        {\n            fillOrder(connectedVertex, graph, stack);\n        }\n        temp = temp->next;\n    }\n    // and then add itself\n    push(stack, vertex);\n}\n// Transpose the adjacency list\nstruct Graph *transpose(struct Graph *g)\n{\n    struct Graph *graph =\n        createGraph(g->numVertices);  // Number of vertices is same\n    int i = 0;\n    for (i = 0; i < g->numVertices; i++)\n    {\n        struct node *temp = g->adjLists[i];\n        while (temp != NULL)\n        {\n            addEdge(graph, temp->vertex, i);  // Reverse all edges\n            temp = temp->next;\n        }\n    }\n    return graph;\n}\n// Recursive dfs aproach\nvoid dfs(struct Graph *graph, int vertex)\n{\n    struct node *adjList = graph->adjLists[vertex];\n    struct node *temp = adjList;\n\n    // Add vertex to visited list and print it\n    graph->visited[vertex] = 1;\n    printf(\"%d \", vertex);\n\n    // Recursively call the dfs function on all unvisited neighbours\n    while (temp != NULL)\n    {\n        int connectedVertex = temp->vertex;\n        if (graph->visited[connectedVertex] == 0)\n        {\n            dfs(graph, connectedVertex);\n        }\n        temp = temp->next;\n    }\n}\n\n// Strongly connected components\nvoid scc(struct Graph *graph)\n{\n    // Step I: Create a topological sort of the graph and store it in a stack\n    struct Stack *stack = createStack();\n    int i = 0;\n    for (i = 0; i < graph->numVertices; i++)\n    {\n        // Execute topological sort on all elements\n        if (graph->visited[i] == 0)\n        {\n            fillOrder(i, graph, stack);\n        }\n    }\n    // Step 2: Get the transpose graph\n    struct Graph *graphT = transpose(graph);\n    // Step 3: Perform a simple dfs by popping nodes from stack\n    while (stack->top != -1)\n    {\n        int v = pop(stack);\n        if (graphT->visited[v] == 0)\n        {\n            dfs(graphT, v);\n            printf(\"\\n\");\n        }\n    }\n}\n\n// Allocate memory for a node\nstruct node *createNode(int v)\n{\n    struct node *newNode = malloc(sizeof(struct node));\n    newNode->vertex = v;\n    newNode->next = NULL;\n    return newNode;\n}\n// Allocate memory for the entire graph structure\nstruct Graph *createGraph(int vertices)\n{\n    struct Graph *graph = malloc(sizeof(struct Graph));\n    graph->numVertices = vertices;\n    graph->adjLists = malloc(vertices * sizeof(struct node *));\n    graph->visited = malloc(vertices * sizeof(int));\n\n    int i;\n    for (i = 0; i < vertices; i++)\n    {\n        graph->adjLists[i] = NULL;\n        graph->visited[i] = 0;\n    }\n    return graph;\n}\n// Creates a unidirectional graph\nvoid addEdge(struct Graph *graph, int src, int dest)\n{\n    // Add edge from src to dest\n    struct node *newNode = createNode(dest);\n    newNode->next = graph->adjLists[src];\n    graph->adjLists[src] = newNode;\n}\n// Utility function to see state of graph at a given time\nvoid printGraph(struct Graph *graph)\n{\n    int v;\n    for (v = 0; v < graph->numVertices; v++)\n    {\n        struct node *temp = graph->adjLists[v];\n        printf(\"\\n Adjacency list of vertex %d\\n \", v);\n        while (temp)\n        {\n            printf(\"%d -> \", temp->vertex);\n            temp = temp->next;\n        }\n        printf(\"\\n\");\n    }\n}\n// Creates a stack\nstruct Stack *createStack()\n{\n    struct Stack *stack = malloc(sizeof(struct Stack));\n    stack->top = -1;\n    return stack;\n}\n// Pushes element into stack\nvoid push(struct Stack *stack, int element)\n{\n    stack->arr[++stack->top] =\n        element;  // Increment then add, as we start from -1\n}\n// Removes element from stack, or returns INT_MIN if stack empty\nint pop(struct Stack *stack)\n{\n    if (stack->top == -1)\n        return INT_MIN;\n    else\n        return stack->arr[stack->top--];\n}\n","index":54},{"title":"Topological Sort","category":"graphs","id":"topological_sort_graphs","algorithm":"#include <stdio.h>\n#include <stdlib.h>\n#define MAX_SIZE 40  // Assume 40 nodes at max in graph\n#define INT_MIN 0\n// A vertex of the graph\nstruct node\n{\n    int vertex;\n    struct node *next;\n};\n// Some declarations\nstruct node *createNode(int v);\nstruct Graph\n{\n    int numVertices;\n    int *visited;\n    struct node *\n        *adjLists;  // we need int** to store a two dimensional array. Similary,\n                    // we need struct node** to store an array of Linked lists\n};\n// Structure to create a stack, necessary for topological sorting\nstruct Stack\n{\n    int arr[MAX_SIZE];\n    int top;\n};\nstruct Graph *createGraph(int);\nvoid addEdge(struct Graph *, int, int);\nvoid printGraph(struct Graph *);\nvoid topologicalSortHelper(int, struct Graph *, struct Stack *);\nvoid topologicalSort(struct Graph *);\nstruct Stack *createStack();\nvoid push(struct Stack *, int);\nint pop(struct Stack *);\n\nint main()\n{\n    int vertices, edges, i, src, dst;\n    printf(\"Enter the number of vertices\\n\");\n    scanf(\"%d\", &vertices);\n    struct Graph *graph = createGraph(vertices);\n    printf(\"Enter the number of edges\\n\");\n    scanf(\"%d\", &edges);\n    for (i = 0; i < edges; i++)\n    {\n        printf(\"Edge %d \\nEnter source: \", i + 1);\n        scanf(\"%d\", &src);\n        printf(\"Enter destination: \");\n        scanf(\"%d\", &dst);\n        addEdge(graph, src, dst);\n    }\n    printf(\"One topological sort order is:\\n\");\n    topologicalSort(graph);\n    printf(\"\\n\");\n\n    // Uncomment below part to get a ready-made example\n    /*struct Graph* graph2 = createGraph(4);\n    addEdge(graph2, 0, 1);\n    addEdge(graph2, 0, 2);\n    addEdge(graph2, 1, 2);\n    addEdge(graph2, 2, 3);\n    printf(\"One topological sort is:\\n\");\n    topologicalSort(graph2);\n    printf(\"\\n\");*/\n    return 0;\n}\n\nvoid topologicalSortHelper(int vertex, struct Graph *graph, struct Stack *stack)\n{\n    graph->visited[vertex] = 1;\n    struct node *adjList = graph->adjLists[vertex];\n    struct node *temp = adjList;\n    // First add all dependents (that is, children) to stack\n    while (temp != NULL)\n    {\n        int connectedVertex = temp->vertex;\n        if (graph->visited[connectedVertex] == 0)\n        {\n            topologicalSortHelper(connectedVertex, graph, stack);\n        }\n        temp = temp->next;\n    }\n    // and then add itself\n    push(stack, vertex);\n}\n\n// Recursive topologial sort approach\nvoid topologicalSort(struct Graph *graph)\n{\n    struct Stack *stack = createStack();\n    int i = 0;\n    for (i = 0; i < graph->numVertices; i++)\n    {\n        // Execute topological sort on all elements\n        if (graph->visited[i] == 0)\n        {\n            topologicalSortHelper(i, graph, stack);\n        }\n    }\n    while (stack->top != -1) printf(\"%d \", pop(stack));\n}\n// Allocate memory for a node\nstruct node *createNode(int v)\n{\n    struct node *newNode = malloc(sizeof(struct node));\n    newNode->vertex = v;\n    newNode->next = NULL;\n    return newNode;\n}\n// Allocate memory for the entire graph structure\nstruct Graph *createGraph(int vertices)\n{\n    struct Graph *graph = malloc(sizeof(struct Graph));\n    graph->numVertices = vertices;\n    graph->adjLists = malloc(vertices * sizeof(struct node *));\n    graph->visited = malloc(vertices * sizeof(int));\n\n    int i;\n    for (i = 0; i < vertices; i++)\n    {\n        graph->adjLists[i] = NULL;\n        graph->visited[i] = 0;\n    }\n    return graph;\n}\n// Creates a unidirectional graph\nvoid addEdge(struct Graph *graph, int src, int dest)\n{\n    // Add edge from src to dest\n    struct node *newNode = createNode(dest);\n    newNode->next = graph->adjLists[src];\n    graph->adjLists[src] = newNode;\n}\n// Utility function to see state of graph at a given time\nvoid printGraph(struct Graph *graph)\n{\n    int v;\n    for (v = 0; v < graph->numVertices; v++)\n    {\n        struct node *temp = graph->adjLists[v];\n        printf(\"\\n Adjacency list of vertex %d\\n \", v);\n        while (temp)\n        {\n            printf(\"%d -> \", temp->vertex);\n            temp = temp->next;\n        }\n        printf(\"\\n\");\n    }\n}\n// Creates a stack\nstruct Stack *createStack()\n{\n    struct Stack *stack = malloc(sizeof(struct Stack));\n    stack->top = -1;\n    return stack;\n}\n// Pushes element into stack\nvoid push(struct Stack *stack, int element)\n{\n    stack->arr[++stack->top] =\n        element;  // Increment then add, as we start from -1\n}\n// Removes element from stack, or returns INT_MIN if stack empty\nint pop(struct Stack *stack)\n{\n    if (stack->top == -1)\n        return INT_MIN;\n    else\n        return stack->arr[stack->top--];\n}\n","index":55},{"title":"Transitive Closure","category":"graphs","id":"transitive_closure_graphs","algorithm":"#include <stdbool.h>\n#include <stdio.h>\n\n#define NODES 4\n\nint digraph[NODES][NODES] = {\n    {0, 1, 1, 1}, {1, 0, 1, 0}, {0, 1, 0, 0}, {0, 0, 0, 0}};\nint tc[NODES][NODES];\n\nvoid warshall()\n{\n    int i, s, t;\n    for (s = 0; s < NODES; s++)\n        for (t = 0; t < NODES; t++) tc[s][t] = digraph[s][t];\n\n    for (i = 0; i < NODES; i++)\n        for (s = 0; s < NODES; s++)\n            for (t = 0; t < NODES; t++)\n                if (tc[s][i] && tc[i][t])\n                    tc[s][t] = 1;\n}\n\nint main(void)\n{\n    warshall();\n    int i, j;\n    for (i = 0; i < NODES; i++)\n    {\n        for (j = 0; j < NODES; j++)\n        {\n            printf(\"%d \", tc[i][j]);\n        }\n        putchar('\\n');\n    }\n    return 0;\n}\n\n// By\n//  .----------------.  .----------------.  .----------------.\n//  .-----------------.  .----------------.  .----------------.\n// | .--------------. || .--------------. || .--------------. ||\n// .--------------. | | .--------------. || .--------------. | | |  _________ |\n// || | _____  _____ | || |      __      | || | ____  _____  | | | |  ____  ____\n// | || |     ____     | | | | |  _   _  |  | || ||_   _||_   _|| || |     /  \\\n// | || ||_   \\|_   _| | | | | |_   ||   _| | || |   .'    `.   | | | | |_/ | |\n// \\_|  | || |  | |    | |  | || |    / /\\ \\    | || |  |   \\ | |   | | | |   |\n// |__| |   | || |  /  .--.  \\  | | | |     | |      | || |  | '    ' |  | || |\n// / ____ \\   | || |  | |\\ \\| |   | | | |   |  __  |   | || |  | |    | |  | |\n// | |    _| |_     | || |   \\ `--' /   | || | _/ /    \\ \\_ | || | _| |_\\   |_\n// | | | |  _| |  | |_  | || |  \\  `--'  /  | | | |   |_____|    | || | `.__.'\n// | || ||____|  |____|| || ||_____|\\____| | | | | |____||____| | || | `.____.'\n// | | | |              | || |              | || |              | || | | | | |\n// | || |              | | | '--------------' || '--------------' ||\n// '--------------' || '--------------' | | '--------------' || '--------------'\n// |\n//  '----------------'  '----------------'  '----------------'\n//  '----------------'   '----------------'  '----------------'\n\n//  Email :    z5261243@unsw.edu.au\n//             hhoanhtuann@gmail.com\n","index":56},{"title":"Hash Set","category":"data_structures","id":"hash_set","index":57},{"title":"Hash Set","category":"hash_set","id":"hash_set_hash_set","algorithm":"#include <stdio.h>\n#include <stdlib.h>\n\n#include \"hash_set.h\"\n\nextern hash_set_t *init_hash_set()\n{\n    hash_set_t *set = (hash_set_t *)malloc(sizeof(hash_set_t));\n    set->keys = calloc(DEFAULT_HASH_SET_CAPACITY, sizeof(void **));\n    set->values = calloc(DEFAULT_HASH_SET_CAPACITY, sizeof(void **));\n    set->length = 0;\n    set->capacity = DEFAULT_HASH_SET_CAPACITY;\n\n    return set;\n}\n\nunsigned add(hash_set_t *set, void *value)\n{\n    return put(set, hash(value), value);\n}\n\nunsigned put(hash_set_t *set, long long hash, void *value)\n{\n    if (contains_hash(set, hash))\n    {\n        if (set->keys[retrieve_index_from_hash(hash, set->capacity)] == value)\n        {\n            return 0;\n        }\n\n        // collision\n        resize(set);\n\n        return put(set, hash, value);\n    }\n\n    set->keys[retrieve_index_from_hash(hash, set->capacity)] = value;\n    set->values[set->length++] = value;\n\n    return 1;\n}\n\nint contains(hash_set_t *set, void *value)\n{\n    return set->keys[retrieve_index_from_hash(hash(value), set->capacity)] ==\n                   value\n               ? 1\n               : 0;\n}\n\nint contains_hash(hash_set_t *set, long long hash)\n{\n    return set->keys[retrieve_index_from_hash(hash, set->capacity)] ? 1 : 0;\n}\n\nvoid delete (hash_set_t *set, void *value)\n{\n    set->keys[retrieve_index_from_hash(hash(value), set->capacity)] = NULL;\n}\n\n// adler_32 hash\nlong long hash(void *value)\n{\n    char *str = value;\n\n    int a = 1;\n    int b = 0;\n    const int MODADLER = 65521;\n\n    for (int i = 0; str[i] != '\\0'; i++)\n    {\n        a = (a + str[i]) % MODADLER;\n        b = (b + a) % MODADLER;\n    }\n\n    return (b << 16) | a;\n}\n\nunsigned retrieve_index_from_hash(const long long hash, const unsigned capacity)\n{\n    return (capacity - 1) & (hash ^ (hash >> 12));\n}\n\nvoid resize(hash_set_t *set)\n{\n    void **keys_resized = calloc((set->capacity <<= 1), sizeof(void **));\n\n    for (int i = 0; i < set->length; i++)\n    {\n        keys_resized[retrieve_index_from_hash(hash(set->values[i]),\n                                              set->capacity)] = set->values[i];\n    }\n\n    free(set->keys);\n\n    set->keys = keys_resized;\n\n    void **new_values =\n        (void **)realloc(set->values, set->capacity * sizeof(void **));\n    set->values = new_values;\n}\n","index":58},{"title":"Hash Set.h","category":"hash_set","id":"hash_set.h_hash_set","algorithm":"#ifndef __HASH_SET__\n#define __HASH_SET__\n\n#define DEFAULT_HASH_SET_CAPACITY 1 << 10\n\ntypedef struct\n{\n    unsigned capacity;\n    unsigned length;\n    void **values;\n    void **keys;\n} hash_set_t;\n\nextern hash_set_t *init_hash_set();\n\nextern unsigned add(hash_set_t *set, void *value);\n\nunsigned put(hash_set_t *set, long long hash, void *value);\n\nextern int contains(hash_set_t *set, void *value);\n\nint contains_hash(hash_set_t *set, long long hash);\n\nextern void delete (hash_set_t *set, void *value);\n\nextern long long hash(void *value);\n\nextern unsigned retrieve_index_from_hash(const long long hash,\n                                         const unsigned capacity);\n\nextern void resize(hash_set_t *set);\n\n#endif","index":59},{"title":"Main","category":"hash_set","id":"main_hash_set","algorithm":"#include <stdio.h>\n\n#include \"hash_set.h\"\n\nint main()\n{\n    hash_set_t *set = init_hash_set();\n\n    int v1 = 10, v2 = 20, v3 = 30, v4 = 40, v5 = 50, v6 = 60, v7 = 70;\n\n    printf(\"Value %d was add ? %d\\n\", v1, add(set, &v1));\n    printf(\"Value %d was add ? %d\\n\", v1, add(set, &v1));\n    printf(\"contains %d ? %d\\n\", v1, contains(set, &v1));\n\n    printf(\"Value %d was add ? %d\\n\", v2, add(set, &v2));\n    printf(\"Value %d was add ? %d\\n\", v2, add(set, &v2));\n    printf(\"contains %d ? %d\\n\", v2, contains(set, &v2));\n\n    printf(\"Value %d was add ? %d\\n\", v3, add(set, &v3));\n    printf(\"Value %d is add ? %d\\n\", v3, add(set, &v3));\n    printf(\"contains %d ? %d\\n\", v3, contains(set, &v3));\n\n    printf(\"Value %d was add ? %d\\n\", v4, add(set, &v4));\n    printf(\"Value %d was add ? %d\\n\", v4, add(set, &v4));\n    printf(\"contains %d ? %d\\n\", v4, contains(set, &v4));\n\n    printf(\"Value %d was add ? %d\\n\", v5, add(set, &v5));\n    printf(\"Value %d was add ? %d\\n\", v5, add(set, &v5));\n    printf(\"contains %d ? %d\\n\", v5, contains(set, &v5));\n\n    printf(\"Value %d is add ? %d\\n\", v6, add(set, &v6));\n    printf(\"Value %d is add ? %d\\n\", v6, add(set, &v6));\n    printf(\"contains %d ? %d\\n\", v6, contains(set, &v6));\n\n    printf(\"contains %d ? %d\\n\", v7, contains(set, &v7));\n\n    delete (set, &v6);\n\n    printf(\"contains %d ? %d\\n\", v6, contains(set, &v6));\n\n    return 0;\n}","index":60},{"title":"Heap","category":"data_structures","id":"heap","index":61},{"title":"Max Heap","category":"heap","id":"max_heap_heap","algorithm":"#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct max_heap\n{\n    int *p;\n    int size;\n    int count;\n} Heap;\n\nHeap *create_heap(Heap *heap); /*Creates a max_heap structure and returns a\n                                  pointer to the struct*/\nvoid down_heapify(Heap *heap, int index); /*Pushes an element downwards in the\n                                             heap to find its correct position*/\nvoid up_heapify(Heap *heap, int index); /*Pushes an element upwards in the heap\n                                           to find its correct position*/\nvoid push(Heap *heap, int x);           /*Inserts an element in the heap*/\nvoid pop(Heap *heap); /*Removes the top element from the heap*/\nint top(Heap *heap); /*Returns the top element of the heap or returns INT_MIN if\n                        heap is empty*/\nint empty(Heap *heap); /*Checks if heap is empty*/\nint size(Heap *heap);  /*Returns the size of heap*/\n\nint main()\n{\n    Heap *head = create_heap(head);\n    push(head, 10);\n    printf(\"Pushing element : 10\\n\");\n    push(head, 3);\n    printf(\"Pushing element : 3\\n\");\n    push(head, 2);\n    printf(\"Pushing element : 2\\n\");\n    push(head, 8);\n    printf(\"Pushing element : 8\\n\");\n    printf(\"Top element = %d \\n\", top(head));\n    push(head, 1);\n    printf(\"Pushing element : 1\\n\");\n    push(head, 7);\n    printf(\"Pushing element : 7\\n\");\n    printf(\"Top element = %d \\n\", top(head));\n    pop(head);\n    printf(\"Popping an element.\\n\");\n    printf(\"Top element = %d \\n\", top(head));\n    pop(head);\n    printf(\"Popping an element.\\n\");\n    printf(\"Top element = %d \\n\", top(head));\n    printf(\"\\n\");\n    return 0;\n}\nHeap *create_heap(Heap *heap)\n{\n    heap = (Heap *)malloc(sizeof(Heap));\n    heap->size = 1;\n    heap->p = (int *)malloc(heap->size * sizeof(int));\n    heap->count = 0;\n    return heap;\n}\n\nvoid down_heapify(Heap *heap, int index)\n{\n    if (index >= heap->count)\n        return;\n    int left = index * 2 + 1;\n    int right = index * 2 + 2;\n    int leftflag = 0, rightflag = 0;\n\n    int maximum = *((heap->p) + index);\n    if (left < heap->count && maximum < *((heap->p) + left))\n    {\n        maximum = *((heap->p) + left);\n        leftflag = 1;\n    }\n    if (right < heap->count && maximum < *((heap->p) + right))\n    {\n        maximum = *((heap->p) + right);\n        leftflag = 0;\n        rightflag = 1;\n    }\n    if (leftflag)\n    {\n        *((heap->p) + left) = *((heap->p) + index);\n        *((heap->p) + index) = maximum;\n        down_heapify(heap, left);\n    }\n    if (rightflag)\n    {\n        *((heap->p) + right) = *((heap->p) + index);\n        *((heap->p) + index) = maximum;\n        down_heapify(heap, right);\n    }\n}\nvoid up_heapify(Heap *heap, int index)\n{\n    int parent = (index - 1) / 2;\n    if (parent < 0)\n        return;\n    if (*((heap->p) + index) > *((heap->p) + parent))\n    {\n        int temp = *((heap->p) + index);\n        *((heap->p) + index) = *((heap->p) + parent);\n        *((heap->p) + parent) = temp;\n        up_heapify(heap, parent);\n    }\n}\n\nvoid push(Heap *heap, int x)\n{\n    if (heap->count >= heap->size)\n        return;\n    *((heap->p) + heap->count) = x;\n    heap->count++;\n    if (4 * heap->count >= 3 * heap->size)\n    {\n        heap->size *= 2;\n        (heap->p) = (int *)realloc((heap->p), (heap->size) * sizeof(int));\n    }\n    up_heapify(heap, heap->count - 1);\n}\nvoid pop(Heap *heap)\n{\n    if (heap->count == 0)\n        return;\n    heap->count--;\n    int temp = *((heap->p) + heap->count);\n    *((heap->p) + heap->count) = *(heap->p);\n    *(heap->p) = temp;\n    down_heapify(heap, 0);\n    if (4 * heap->count <= heap->size)\n    {\n        heap->size /= 2;\n        (heap->p) = (int *)realloc((heap->p), (heap->size) * sizeof(int));\n    }\n}\nint top(Heap *heap)\n{\n    if (heap->count != 0)\n        return *(heap->p);\n    else\n        return INT_MIN;\n}\nint empty(Heap *heap)\n{\n    if (heap->count != 0)\n        return 0;\n    else\n        return 1;\n}\nint size(Heap *heap) { return heap->count; }\n","index":62},{"title":"Min Heap","category":"heap","id":"min_heap_heap","algorithm":"#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct min_heap\n{\n    int *p;\n    int size;\n    int count;\n} Heap;\n\nHeap *create_heap(Heap *heap); /*Creates a min_heap structure and returns a\n                                  pointer to the struct*/\nvoid down_heapify(Heap *heap, int index); /*Pushes an element downwards in the\n                                             heap to find its correct position*/\nvoid up_heapify(Heap *heap, int index); /*Pushes an element upwards in the heap\n                                           to find its correct position*/\nvoid push(Heap *heap, int x);           /*Inserts an element in the heap*/\nvoid pop(Heap *heap); /*Removes the top element from the heap*/\nint top(Heap *heap); /*Returns the top element of the heap or returns INT_MIN if\n                        heap is empty*/\nint empty(Heap *heap); /*Checks if heap is empty*/\nint size(Heap *heap);  /*Returns the size of heap*/\n\nint main()\n{\n    Heap *head = create_heap(head);\n    push(head, 10);\n    printf(\"Pushing element : 10\\n\");\n    push(head, 3);\n    printf(\"Pushing element : 3\\n\");\n    push(head, 2);\n    printf(\"Pushing element : 2\\n\");\n    push(head, 8);\n    printf(\"Pushing element : 8\\n\");\n    printf(\"Top element = %d \\n\", top(head));\n    push(head, 1);\n    printf(\"Pushing element : 1\\n\");\n    push(head, 7);\n    printf(\"Pushing element : 7\\n\");\n    printf(\"Top element = %d \\n\", top(head));\n    pop(head);\n    printf(\"Popping an element.\\n\");\n    printf(\"Top element = %d \\n\", top(head));\n    pop(head);\n    printf(\"Popping an element.\\n\");\n    printf(\"Top element = %d \\n\", top(head));\n    printf(\"\\n\");\n    return 0;\n}\nHeap *create_heap(Heap *heap)\n{\n    heap = (Heap *)malloc(sizeof(Heap));\n    heap->size = 1;\n    heap->p = (int *)malloc(heap->size * sizeof(int));\n    heap->count = 0;\n    return heap;\n}\n\nvoid down_heapify(Heap *heap, int index)\n{\n    if (index >= heap->count)\n        return;\n    int left = index * 2 + 1;\n    int right = index * 2 + 2;\n    int leftflag = 0, rightflag = 0;\n\n    int minimum = *((heap->p) + index);\n    if (left < heap->count && minimum > *((heap->p) + left))\n    {\n        minimum = *((heap->p) + left);\n        leftflag = 1;\n    }\n    if (right < heap->count && minimum > *((heap->p) + right))\n    {\n        minimum = *((heap->p) + right);\n        leftflag = 0;\n        rightflag = 1;\n    }\n    if (leftflag)\n    {\n        *((heap->p) + left) = *((heap->p) + index);\n        *((heap->p) + index) = minimum;\n        down_heapify(heap, left);\n    }\n    if (rightflag)\n    {\n        *((heap->p) + right) = *((heap->p) + index);\n        *((heap->p) + index) = minimum;\n        down_heapify(heap, right);\n    }\n}\nvoid up_heapify(Heap *heap, int index)\n{\n    int parent = (index - 1) / 2;\n    if (parent < 0)\n        return;\n    if (*((heap->p) + index) < *((heap->p) + parent))\n    {\n        int temp = *((heap->p) + index);\n        *((heap->p) + index) = *((heap->p) + parent);\n        *((heap->p) + parent) = temp;\n        up_heapify(heap, parent);\n    }\n}\n\nvoid push(Heap *heap, int x)\n{\n    if (heap->count >= heap->size)\n        return;\n    *((heap->p) + heap->count) = x;\n    heap->count++;\n    if (4 * heap->count >= 3 * heap->size)\n    {\n        heap->size *= 2;\n        (heap->p) = (int *)realloc((heap->p), (heap->size) * sizeof(int));\n    }\n    up_heapify(heap, heap->count - 1);\n}\nvoid pop(Heap *heap)\n{\n    if (heap->count == 0)\n        return;\n    heap->count--;\n    int temp = *((heap->p) + heap->count);\n    *((heap->p) + heap->count) = *(heap->p);\n    *(heap->p) = temp;\n    down_heapify(heap, 0);\n    if (4 * heap->count <= heap->size)\n    {\n        heap->size /= 2;\n        (heap->p) = (int *)realloc((heap->p), (heap->size) * sizeof(int));\n    }\n}\nint top(Heap *heap)\n{\n    if (heap->count != 0)\n        return *(heap->p);\n    else\n        return INT_MIN;\n}\nint empty(Heap *heap)\n{\n    if (heap->count != 0)\n        return 0;\n    else\n        return 1;\n}\nint size(Heap *heap) { return heap->count; }\n","index":63},{"title":"Linked List","category":"data_structures","id":"linked_list","index":64},{"title":"Ascending Priority Queue","category":"linked_list","id":"ascending_priority_queue_linked_list","algorithm":"/* Ascending priority queue using Linked List - Program to implement Ascending\n * priority queue using Linked List */\n\n/*A priority queue is a special type of queue in which each element is\nassociated with a priority and is served according to its priority. If elements\nwith the same priority occur, they are served according to their order in the\nqueue.\n\nGenerally, the value of the element itself is considered for assigning the\npriority.\n\nFor example: The element with the highest value is considered as the highest\npriority element. However, in other cases, we can assume the element with the\nlowest value as the highest priority element. In other cases, we can set\npriorities according to our needs.\n\nIn a queue, the first-in-first-out rule is implemented whereas, in a priority\nqueue, the values are removed on the basis of priority. The element with the\nhighest priority is removed first.\n\ninsert() - Would insert an element in a queue\ndelete() -  Would delete the smallest element in the queue\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#define NULL ((void *)0)\n\nstruct node\n{\n    int data;\n    struct node *next;\n};\n\nstruct node *front, *rear;\n\n/* This function initializes the queue to empty by making both front and rear as\n * NULL */\nvoid createqueue() { front = rear = NULL; }\n\nint empty()\n{\n    if (front == NULL)\n        return 1;\n    else\n        return 0;\n}\n\nvoid insert(int x)\n{\n    struct node *pnode;\n\n    pnode = (struct node *)malloc(sizeof(struct node));\n    if (pnode == NULL)\n    {\n        printf(\"Memory overflow. Unable to insert.\\n\");\n        exit(1);\n    }\n\n    pnode->data = x;\n    pnode->next = NULL; /* New node is always last node */\n\n    if (empty())\n        front = rear = pnode;\n    else\n    {\n        rear->next = pnode;\n        rear = pnode;\n    }\n}\n\nint removes()\n{\n    int min;\n    struct node *follow, *follow1, *p, *p1;\n\n    if (empty())\n    {\n        printf(\"\\nQueue Underflow. Unable to remove.\");\n        exit(1);\n    }\n\n    /* finding the node with minimum value in the APQ.*/\n    p = p1 = front;\n    follow = follow1 = NULL;\n    min = front->data;\n    while (p != NULL)\n    {\n        if (p->data < min)\n        {\n            min = p->data;\n            follow1 = follow;\n            p1 = p;\n        }\n        follow = p;\n        p = p->next;\n    }\n\n    /* Deleting the node with min value */\n\n    if (p1 == front) /* deleting first node.*/\n    {\n        front = front->next;\n        if (front == NULL) /* Deleting the only one node */\n            rear = NULL;\n    }\n    else if (p1 == rear) /* Deleting last node */\n    {\n        rear = follow1;\n        rear->next = NULL;\n    }\n    else /* deleting any other node.*/\n        follow1->next = p1->next;\n\n    free(p1);\n    return min; /* DONT FORGET LAST 2 STATEMENTS.*/\n}\n\nvoid show()\n{\n    struct node *p;\n\n    if (empty())\n        printf(\"Queue empty. No data to display \\n\");\n    else\n    {\n        printf(\"Queue from front to rear is as shown: \\n\");\n\n        p = front;\n        while (p != NULL)\n        {\n            printf(\"%d \", p->data);\n            p = p->next;\n        }\n\n        printf(\"\\n\");\n    }\n}\n\nvoid destroyqueue() { front = rear = NULL; }\n\nint main()\n{\n    int x, ch;\n\n    createqueue();\n\n    do\n    {\n        printf(\"\\n\\n  Menu: \\n\");\n        printf(\"1:Insert \\n\");\n        printf(\"2:Remove \\n\");\n        printf(\"3:exit \\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &ch);\n\n        switch (ch)\n        {\n        case 1:\n            printf(\"Enter element to be inserted: \");\n            scanf(\"%d\", &x);\n            insert(x);\n            show();\n            break;\n\n        case 2:\n            x = removes();\n            printf(\"Element removed is: %d\\n\", x);\n            show();\n            break;\n\n        case 3:\n            break;\n        }\n    } while (ch != 3);\n\n    destroyqueue();\n\n    return 0;\n}\n\n/* Output of the Program*/\n\n/*\n  Menu:\n1:Insert\n2:Remove\n3:exit\nEnter your choice: 1\nEnter element to be inserted: 12\nQueue from front to rear is as shown:\n12\n\n\n  Menu:\n1:Insert\n2:Remove\n3:exit\nEnter your choice: 1\nEnter element to be inserted: 1\nQueue from front to rear is as shown:\n12 1\n\n\n  Menu:\n1:Insert\n2:Remove\n3:exit\nEnter your choice: 1\nEnter element to be inserted: 14\nQueue from front to rear is as shown:\n12 1 14\n\n\n  Menu:\n1:Insert\n2:Remove\n3:exit\nEnter your choice: 1\nEnter element to be inserted: 3\nQueue from front to rear is as shown:\n12 1 14 3\n\n\n  Menu:\n1:Insert\n2:Remove\n3:exit\nEnter your choice: 1\nEnter element to be inserted: 5\nQueue from front to rear is as shown:\n12 1 14 3 5\n\n\n  Menu:\n1:Insert\n2:Remove\n3:exit\nEnter your choice: 2\nElement removed is: 1\nQueue from front to rear is as shown:\n12 14 3 5\n\n\n  Menu:\n1:Insert\n2:Remove\n3:exit\nEnter your choice: 2\nElement removed is: 3\nQueue from front to rear is as shown:\n12 14 5\n\n\n  Menu:\n1:Insert\n2:Remove\n3:exit\nEnter your choice: 2\nElement removed is: 5\nQueue from front to rear is as shown:\n12 14\n\n\n  Menu:\n1:Insert\n2:Remove\n3:exit\nEnter your choice: 2\nElement removed is: 12\nQueue from front to rear is as shown:\n14\n\n\n  Menu:\n1:Insert\n2:Remove\n3:exit\nEnter your choice: 2\nElement removed is: 14\nQueue empty. No data to display\n\n*/\n","index":65},{"title":"Circular Linked List.c","category":"linked_list","id":"Circular_Linked_List.C_linked_list","algorithm":"/* Circularly Linked List (Basic Operations) - Program to create a Circularly linked list abstract data type and perform various operations on it (Variable first and last declared globally) */\r\n\r\n#include  <stdio.h>\r\n#include <conio.h>\r\n#include  <stdlib.h>\r\n#define  NULL  0\r\n\r\n/* Assume that the data portion of each node consists of ONLY an integer.*/\r\nstruct  node\r\n{\r\n  int  data ;\r\n  struct  node  *next ;\r\n} ;\r\n\r\nstruct  node  *first=NULL ;\r\nstruct  node  *last=NULL ;\r\n/* first and last are global variables and need not be passed to any function. Any changes made to variables first and last by any of the functions in the program will be reflected in the entire program */\r\n\r\n/* This function is responsible for creating the Circularly Linked List right from the BEGINING. */\r\nvoid  create()\r\n{\r\n  int  i , n ;\r\n  struct  node  *pnode , *p ;\r\n\r\n  printf(\"Enter the number of nodes required:\\n\") ;\r\n  scanf(\"%d\",&n) ;\r\n\r\n  printf(\"Enter the data value of each node:\\n\") ;\r\n  for(i=1 ; i<=n ; i++)\r\n  {\r\n    pnode=(struct node*)malloc(sizeof(struct node)) ;\r\n    if(pnode==NULL)\r\n    {\r\n      printf(\"Memory overflow. Unable to create.\\n\") ;\r\n      return ;\r\n    }\r\n\r\n    scanf(\"%d\",&pnode->data) ;\r\n\r\n    if(first==NULL)\r\n\t first=last=pnode ;\r\n    else\r\n    {\r\n\t  last->next=pnode ;\r\n\t  last=pnode ;    /* last keeps track of last node */\r\n    }\r\n\r\n    last->next=first ;\r\n  }\r\n}\r\n\r\n/* This function will delete a node with value k from the Linked List if such a node exists */\r\nvoid  deletenode(int  k)\r\n{\r\n  struct  node  *p , *follow ;\r\n\r\n  /* searching the required node */\r\n  p=first ;\r\n  follow=NULL ;\r\n  while(follow!=last)\r\n  {\r\n    if(p->data==k)\r\n\t  break ;\r\n    follow=p ;\r\n    p=p->next ;\r\n  }\r\n\r\n  if(follow==last)\r\n    printf(\"Required node not found.\\n\") ;\r\n  else\r\n  {\r\n    if(p==first&&p==last)  /* deleting the one and the only node */\r\n\t  first=last=NULL ;\r\n    else if(p==first)       /* deleting the first node */\r\n    {\r\n      first=first->next ;\r\n      last->next=first ;\r\n    }\r\n    else if(p==last)      /* deleting the last node */\r\n    {\r\n      last=follow ;\r\n      last->next=first ;\r\n    }\r\n    else\t\t/* deleting any other node */\r\n      follow->next=p->next ;\r\n\r\n    free(p) ;\r\n  }\r\n}\r\n\r\n/* This function will go through all the nodes of Linked List exactly once and will display data value of each node */\r\nvoid  traverse()\r\n{\r\n  struct  node  *p , *follow ;\r\n  if(first==NULL)\r\n    printf(\"Circularly Linked List Empty\") ;\r\n  else\r\n  {\r\n    printf(\"Circularly Linked List is as shown: \\n\") ;\r\n\r\n    p=first ;\r\n    follow = NULL ;\r\n    while(follow!=last)\r\n    {\r\n      printf(\"%d \" , p->data) ;\r\n      follow=p ;\r\n      p=p->next ;\r\n    }\r\n\r\n    printf(\"\\n\") ;\r\n  }\r\n}\r\n\r\nvoid main()\r\n{\r\n  int  x , k , ch ;\r\n  clrscr() ;\r\n  do\r\n  {\r\n    printf(\"\\n Menu: \\n\") ;\r\n    printf(\"1:Create Linked List \\n\") ;\r\n    printf(\"2:Delete Node \\n\") ;\r\n    printf(\"3:Traverse \\n\") ;\r\n    printf(\"4:Exit \\n\") ;\r\n\r\n    printf(\"\\nEnter your choice: \") ;\r\n    scanf(\"%d\",&ch) ;\r\n\r\n    switch(ch)\r\n    {\r\n      case 1:\r\n      create() ;\r\n      break ;\r\n\r\n      case 2:\r\n      printf(\"Enter the data value of the node to be deleted: \") ;\r\n      scanf(\"%d\",&k) ;\r\n      deletenode(k) ;\r\n      break ;\r\n\r\n      case 3:\r\n      traverse() ;\r\n      break ;\r\n\r\n      case 4:\r\n      break ;\r\n    }\r\n }\r\n while(ch!=4) ;\r\n\r\n getch() ;\r\n}\r\n\r\n\r\n\r\n","index":66},{"title":"Merge Linked Lists","category":"linked_list","id":"merge_linked_lists_linked_list","algorithm":"#include <stdio.h>\n#include <stdlib.h>\nstruct node\n{\n    int data;\n    struct node *next;\n};\n\nstruct node *head1 = NULL;\nstruct node *head2 = NULL;\n\n///// MAIN ALGORITHMIC FUNCTION to MERGE the two input linked lists ///////\n\nvoid merge()\n{\n    struct node *temp1 = head1;\n    struct node *temp2 = head2;\n\n    struct node *holder1 = NULL;\n    struct node *holder2 = NULL;\n    // Temporary pointer variables to store the address of next node of the two\n    // input linked list\n\n    while (temp1 != NULL && temp2 != NULL)\n    {\n        holder1 = temp1->next;\n        // Storing the address of next node of first linked list\n        temp1->next = temp2;\n        // Making the first node of first linked list point to first node of\n        // second linked list\n\n        if (holder1 != NULL)\n        {\n            // Making the first node of second linked list point to second node\n            // of first linked list\n            holder2 = temp2->next;\n            temp2->next = holder1;\n        }\n        temp1 = holder1;\n        temp2 = holder2;\n        // Updating the address location of two pointer variables temp1 and\n        // temp2\n    }\n}\n\nvoid printlist(struct node *temp)\n{\n    printf(\"%d\", temp->data);\n    temp = temp->next;\n    while (temp != NULL)\n    {\n        printf(\"->%d\", temp->data);\n        temp = temp->next;\n    }\n    printf(\"\\n\");\n}\n\nint main()\n{\n    // Linked List 1: 1->3->5->7   :   Linked List 2: 2->4->6\n    //  making lists\n    struct node *one = (struct node *)malloc(sizeof(struct node));\n    struct node *two = (struct node *)malloc(sizeof(struct node));\n    struct node *three = (struct node *)malloc(sizeof(struct node));\n    struct node *four = (struct node *)malloc(sizeof(struct node));\n    struct node *five = (struct node *)malloc(sizeof(struct node));\n    struct node *six = (struct node *)malloc(sizeof(struct node));\n    struct node *seven = (struct node *)malloc(sizeof(struct node));\n    // Seven nodes are created\n\n    head1 = one;\n    head2 = two;\n    // head1 points to first node of first linked list\n    // head2 points to first node of second linked list\n\n    one->data = 1;\n    one->next = three;\n\n    two->data = 2;\n    two->next = four;\n\n    three->data = 3;\n    three->next = five;\n\n    four->data = 4;\n    four->next = six;\n\n    five->data = 5;\n    five->next = seven;\n\n    six->data = 6;\n    six->next = NULL;\n    // Last node of second input linked list\n\n    seven->data = 7;\n    seven->next = NULL;\n    // Last node of first input linked list\n\n    printf(\"Linked List 1: \");\n    printlist(head1);\n    printf(\"\\nLinked List 2: \");\n    printlist(head2);\n\n    // Merging the two linked list into single linked list\n    merge();\n\n    printf(\"\\nMerged Linked List: \");\n    printlist(head1);  // list one has been modified\n\n    return 0;\n}\n","index":67},{"title":"Middle Element In List","category":"linked_list","id":"middle_element_in_list_linked_list","algorithm":"#include <stdio.h>\n#include <stdlib.h>\n\n/* Link list node */\nstruct Node\n{\n    int data;\n    struct Node *next;\n};\n\n/* Function to get the middle of the linked list*/\nvoid printMiddle(struct Node *head)\n{\n    struct Node *slow_ptr = head;\n    struct Node *fast_ptr = head;\n\n    if (head != NULL)\n    {\n        while (fast_ptr != NULL && fast_ptr->next != NULL)\n        {\n            fast_ptr = fast_ptr->next->next;\n            slow_ptr = slow_ptr->next;\n        }\n        printf(\"The middle element is [%d]\\n\\n\", slow_ptr->data);\n    }\n}\n\nvoid push(struct Node **head_ref, int new_data)\n{\n    /* allocate node */\n    struct Node *new_node = (struct Node *)malloc(sizeof(struct Node));\n\n    /* put in the data */\n    new_node->data = new_data;\n\n    /* link the old list off the new node */\n    new_node->next = (*head_ref);\n\n    /* move the head to point to the new node */\n    (*head_ref) = new_node;\n}\n\n// A utility function to print a given linked list\nvoid printList(struct Node *ptr)\n{\n    while (ptr != NULL)\n    {\n        printf(\"%d->\", ptr->data);\n        ptr = ptr->next;\n    }\n    printf(\"NULL\\n\");\n}\n\n/* Drier program to test above function*/\nint main()\n{\n    /* Start with the empty list */\n    struct Node *head = NULL;\n    int i;\n\n    for (i = 5; i > 0; i--)\n    {\n        push(&head, i);\n        printList(head);\n        printMiddle(head);\n    }\n\n    return 0;\n}\n","index":68},{"title":"Queue Linked List","category":"linked_list","id":"queue_linked_list_linked_list","algorithm":"/* Queue using Linked List - Program to create a queue ADT using linked list.\nADT should support the following operations 1)  Createqueue 2)  Insert into the\nqueue 3)  Delete from the queue 4)  destroyqueue\n*/\n\n/* queue q declared globally */\n\n#include <stdio.h>\n#include <stdlib.h>\n#define NULL 0\n\nstruct node\n{\n    int data;\n    struct node *next;\n};\n\nstruct queue\n{\n    struct node *front, *rear;\n};\n\nstruct queue q;\n\n/* This function initializes the queue to empty by making both front and rear as\n * NULL */\nvoid createqueue() { q.front = q.rear = NULL; }\n\nint empty()\n{\n    if (q.front == NULL)\n        return 1;\n    else\n        return 0;\n}\n\nvoid insert(int x)\n{\n    struct node *pnode;\n\n    pnode = (struct node *)malloc(sizeof(struct node));\n    if (pnode == NULL)\n    {\n        printf(\"Memory overflow. Unable to insert.\\n\");\n        exit(1);\n    }\n\n    pnode->data = x;\n    pnode->next = NULL; /* New node is always last node */\n\n    if (empty())\n        q.front = q.rear = pnode;\n    else\n    {\n        (q.rear)->next = pnode;\n        q.rear = pnode;\n    }\n}\n\nint removes()\n{\n    int x;\n    struct node *p;\n\n    if (empty())\n    {\n        printf(\"Queue Underflow. Unable to remove.\\n\");\n        exit(1);\n    }\n\n    p = q.front;\n    x = (q.front)->data;\n    q.front = (q.front)->next;\n    if (q.front == NULL) /* Queue contained only one node */\n        q.rear = NULL;\n    free(p);\n    return x;\n}\n\nvoid show()\n{\n    struct node *p;\n\n    if (empty())\n        printf(\"Queue empty. No data to display \\n\");\n    else\n    {\n        printf(\"Queue from front to rear is as shown: \\n\");\n\n        p = q.front;\n        while (p != NULL)\n        {\n            printf(\"%d \", p->data);\n            p = p->next;\n        }\n\n        printf(\"\\n\");\n    }\n}\n\nvoid destroyqueue() { q.front = q.rear = NULL; }\n\nint main()\n{\n    int x, ch;\n\n    createqueue();\n\n    do\n    {\n        printf(\"\\n\\n  Menu: \\n\");\n        printf(\"1:Insert \\n\");\n        printf(\"2:Remove \\n\");\n        printf(\"3:exit \\n\");\n        printf(\"Enter your choice: \");\n        scanf(\"%d\", &ch);\n\n        switch (ch)\n        {\n        case 1:\n            printf(\"Enter element to be inserted: \");\n            scanf(\"%d\", &x);\n            insert(x);\n            show();\n            break;\n\n        case 2:\n            x = removes();\n            printf(\"Element removed is: %d\\n\", x);\n            show();\n            break;\n\n        case 3:\n            break;\n        }\n    } while (ch != 3);\n\n    destroyqueue();\n\n    return 0;\n}\n","index":69},{"title":"Singly Link List Deletion","category":"linked_list","id":"singly_link_list_deletion_linked_list","algorithm":"/*Includes structure for a node which can be use to make new nodes of the Linked\n  List. It is assumed that the data in nodes will be an integer, though function\n  can be modified according to the data type, easily. deleteNode deletes a node\n  when passed with a key of the node.\n*/\n#include <stdio.h>\nstruct node\n{\n    int info;\n    struct node *link;\n};\nstruct node *start = NULL;\n///////////////////////////////////////////////////////////\nstruct node *createnode()  // function to create node\n{\n    struct node *t;\n    t = (struct node *)malloc(sizeof(struct node));\n    return (t);\n}\n////////////////////////////////////////////////////////\nvoid insert()  // function to insert at first location\n{\n    struct node *p;\n    p = createnode();\n    printf(\"\\nenter the number to insert\");\n    scanf(\"%d\", &p->info);\n    p->link = NULL;\n    if (start == NULL)\n    {\n        start = p;\n    }\n    else\n    {\n        p->link = start;\n        start = p;\n    }\n}\n///////////////////////////////////////////////////////////\nvoid deletion()  // function to delete from first position\n{\n    struct node *t;\n    if (start == NULL)\n    {\n        printf(\"\\nlist is empty\");\n    }\n    else\n    {\n        struct node *p;\n        p = start;\n        start = start->link;\n        free(p);\n    }\n}\n///////////////////////////////////////////////////////\nvoid viewlist()  // function to display values\n{\n    struct node *p;\n    if (start == NULL)\n    {\n        printf(\"\\nlist is empty\");\n    }\n    else\n    {\n        p = start;\n        while (p != NULL)\n        {\n            printf(\"%d \", p->info);\n            p = p->link;\n        }\n    }\n}\n//////////////////////////////////////////////////////////////////////\n\nint main()\n{\n    int n;\n    while (1)\n    {\n        printf(\"\\n1.add value at first location\");\n        printf(\"\\n2.delete value from first location\");\n        printf(\"\\n3.view value\");\n        printf(\"\\nenter your choice\");\n        scanf(\"%d\", &n);\n        switch (n)\n        {\n        case 1:\n            insert();\n            break;\n        case 2:\n            deletion();\n            break;\n        case 3:\n            viewlist();\n            break;\n        default:\n            printf(\"\\ninvalid choice\");\n        }\n    }\n    return (0);\n}\n","index":70},{"title":"Stack Using Linked Lists","category":"linked_list","id":"stack_using_linked_lists_linked_list","algorithm":"#include <stdio.h>\n#include <stdlib.h>\nstruct node\n{\n    int info;\n    struct node *link;\n};\nstruct node *top = NULL, *temp;\nvoid push(struct node *);\nvoid pop(struct node *);\nvoid display(struct node *);\n\nint main()\n{\n    int x = 0, item;\n    printf(\"\\t****stack using linked list****\\n\");\n    while (x != 4)\n    {\n        printf(\"enter your choice\");\n        printf(\"\\n1.push\\n2.pop\\n3.display\\n4.exit\\n\");\n        scanf(\"%d\", &x);\n        switch (x)\n        {\n        case 1:\n            push(top);\n            break;\n        case 2:\n            pop(top);\n            break;\n        case 3:\n            display(top);\n            break;\n        case 4:\n            return 0;\n        }\n    }\n}\n\nvoid push(struct node *p)\n{\n    int item;\n    struct node *temp;\n    temp = (struct node *)malloc(sizeof(struct node));\n    printf(\"enter element to be inserted\\n\");\n    scanf(\"%d\", &item);\n    temp->info = item;\n\n    temp->link = top;\n    top = temp;\n\n    printf(\"inserted succesfully\\n\");\n}\nvoid pop(struct node *p)\n{\n    int item;\n    struct node *temp;\n\n    if (top == NULL)\n        printf(\"stack is empty\\n\");\n    else\n    {\n        item = top->info;\n        temp = top;\n        top = top->link;\n        free(temp);\n        printf(\"Element popped is%d\\n\", item);\n    }\n}\n\nvoid display(struct node *p)\n{\n    if (top == NULL)\n        printf(\"stack is empty\\n\");\n    else\n    {\n        printf(\"Elements in the stack are\\n\");\n        while (p != NULL)\n        {\n            printf(\"%d\\n\", p->info);\n            p = p->link;\n        }\n        // printf(\"%d\\n\",p->info);\n    }\n}\n","index":71},{"title":"List","category":"data_structures","id":"list","index":72},{"title":"List","category":"list","id":"list_list","algorithm":"#include \"list.h\"\n#include <assert.h>\n#include <stdarg.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define L List_T\n\n/* Initial list */\nL List_init(void)\n{\n    L list;\n    list = (L)malloc(sizeof(L));\n    list->next = NULL;\n    return list;\n}\n\n/* Push an element into top of the list */\nL List_push(L list, void *val)\n{\n    L new_elem = (L)malloc(sizeof(L));\n    new_elem->val = val;\n    new_elem->next = list;\n    return new_elem;\n}\n\n/* Length of list */\nint List_length(L list)\n{\n    int n;\n    for (n = 0; list; list = list->next) n++;\n    return n;\n}\n\n/* Convert list to array */\nvoid **List_toArray(L list)\n{\n    int i, n = List_length(list);\n    void **array = (void **)malloc((n + 1) * sizeof(*array));\n\n    for (i = 0; i < n; i++)\n    {\n        array[i] = list->val;\n        list = list->next;\n    }\n    array[i] = NULL;\n    return array;\n}\n\n/* Create and return a list */\nL List_list(L list, void *val, ...)\n{\n    va_list ap;\n    L *p = &list;\n\n    va_start(ap, val);\n    for (; val; val = va_arg(ap, void *))\n    {\n        *p = malloc(sizeof(L));\n        (*p)->val = val;\n        p = &(*p)->next;\n    }\n    *p = NULL;\n    va_end(ap);\n    return list;\n}\n\n/* Append 2 lists together */\nL List_append(L list, L tail)\n{\n    L *p = &list;\n    while ((*p)->next)\n    {\n        p = &(*p)->next;\n    }\n\n    *p = tail;\n    return list;\n}\n","index":73},{"title":"List.h","category":"list","id":"list.h_list","algorithm":"#ifndef __LIST__\n#define __LIST__\n\n#define L List_T\ntypedef struct L *L;\n\nstruct L\n{\n    void *val;\n    L next;\n};\n\nextern L List_init(void);\nextern L List_push(L list, void *val);\nextern int List_length(L list);\nextern void **List_toArray(L list);\nextern L List_append(L list, L tail);\nextern L List_list(L list, void *val, ...);\n/* TODO */\nextern L List_copy(L list);\nextern int List_pop(L *list);\n\n#undef L\n#endif\n","index":74},{"title":"Main","category":"list","id":"main_list","algorithm":"#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"list.h\"\n\nvoid print_list(char **array)\n{\n    int i;\n    for (i = 0; array[i]; i++) printf(\"%s\", array[i]);\n    printf(\"\\n\");\n}\n\nint main()\n{\n    List_T list1, list2, list3;\n    char **str1 = (char **)malloc(100 * sizeof(char *));\n\n    list1 = List_init();\n    list1 = List_push(list1, \"Dang \");\n    list1 = List_push(list1, \"Hoang \");\n    list1 = List_push(list1, \"Hai \");\n    printf(\"List 1: \");\n    str1 = (char **)List_toArray(list1);\n    print_list(str1);\n\n    list2 = List_init();\n    list2 = List_list(list2, \"Mentor \", \"Graphics \", \"Siemens\", NULL);\n    printf(\"List 2: \");\n    print_list((char **)List_toArray(list2));\n\n    list3 = List_append(list1, list2);\n    printf(\"Test append list2 into list1: \");\n    print_list((char **)List_toArray(list3));\n\n    return 0;\n}\n","index":75},{"title":"Queue","category":"data_structures","id":"queue_data_structures","algorithm":"////////////////////////////////////////////////////////////////////////////////\n// INCLUDES\n#include <stdio.h>\n#include <stdlib.h>\n\n////////////////////////////////////////////////////////////////////////////////\n// MACROS: CONSTANTS\n\n////////////////////////////////////////////////////////////////////////////////\n// DATA STRUCTURES\nstruct node\n{\n    int data;\n    struct node *next;\n    struct node *pre;\n} * head, *tail, *tmp;\n\n////////////////////////////////////////////////////////////////////////////////\n// GLOBAL VARIABLES\nint count;\n\n////////////////////////////////////////////////////////////////////////////////\n// FORWARD DECLARATIONS\nvoid create();\nvoid enque(int x);\nint deque();\nint peek();\nint size();\nint isEmpty();\n\n////////////////////////////////////////////////////////////////////////////////\n// MAIN ENTRY POINT\n\nint main(int argc, char const *argv[])\n{\n    create();\n    enque(5);\n\n    return 0;\n}\n\nvoid create()\n{\n    head = NULL;\n    tail = NULL;\n}\n\n/**\n * Puts an item into the Queue.\n */\nvoid enque(int x)\n{\n    if (head == NULL)\n    {\n        head = (struct node *)malloc(1 * sizeof(struct node));\n        head->data = x;\n        head->pre = NULL;\n        tail = head;\n    }\n    else\n    {\n        tmp = (struct node *)malloc(1 * sizeof(struct node));\n        tmp->data = x;\n        tmp->next = tail;\n        tail = tmp;\n    }\n}\n\n/**\n * Takes the next item from the Queue.\n */\nint deque()\n{\n    int returnData = 0;\n    if (head == NULL)\n    {\n        printf(\"ERROR: Deque from empty queue.\\n\");\n        exit(1);\n    }\n    else\n    {\n        returnData = head->data;\n        if (head->pre == NULL)\n            head = NULL;\n        else\n            head = head->pre;\n        head->next = NULL;\n    }\n    return returnData;\n}\n\n/**\n * Returns the size of the Queue.\n */\nint size() { return count; }","index":76},{"title":"Stack","category":"data_structures","id":"stack","index":77},{"title":"Main","category":"stack","id":"main_stack","algorithm":"// program for stack using array\n\n#include <stdio.h>\n\nvoid push();\nvoid pop();\nvoid peek();\nvoid update();\n\nint a[100], top = -1;\n\nint main()\n{\n    int x;\n    while (1)\n    {\n        printf(\"\\n0.exit\");\n        printf(\"\\n1.push\");\n        printf(\"\\n2.pop\");\n        printf(\"\\n3.peek\");\n        printf(\"\\n4.update\");\n        printf(\"\\nenter your choice? \");\n        scanf(\"%d\", &x);\n        switch (x)\n        {\n        case 0:\n            return 0;\n        case 1:\n            push();\n            break;\n        case 2:\n            pop();\n            break;\n        case 3:\n            peek();\n            break;\n        case 4:\n            update();\n            break;\n        default:\n            printf(\"\\ninvalid choice\");\n        }\n    }\n    return (0);\n}\n\n// function for pushing the element\nvoid push()\n{\n    int n = 0;\n    printf(\"\\nenter the value to insert? \");\n    scanf(\"%d\", &n);\n    top += 1;\n    a[top] = n;\n}\n\n// function for poping the element out\nvoid pop()\n{\n    if (top == -1)\n    {\n        printf(\"\\nstack is empty\");\n    }\n    else\n    {\n        int item;\n        item = a[top];\n        top -= 1;\n        printf(\"\\npoped item is %d \", item);\n    }\n}\n\n// function for peeping the element from top of the stack\nvoid peek()\n{\n    if (top >= 0)\n        printf(\"\\n the top element is %d\", a[top]);\n    else\n        printf(\"\\nstack is empty\");\n}\n\n// function to update the element of stack\nvoid update()\n{\n    int i, n;\n    printf(\"\\nenter the position to update? \");\n    scanf(\"%d\", &i);\n    printf(\"\\nenter the item to insert? \");\n    scanf(\"%d\", &n);\n    if (top - i + 1 < 0)\n    {\n        printf(\"\\nunderflow condition\");\n    }\n    else\n    {\n        a[top - i + 1] = n;\n    }\n}","index":78},{"title":"Parenthesis","category":"stack","id":"parenthesis_stack","algorithm":"#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define SIZE 100\n\nstruct node\n{\n    char data;\n    struct node *link;\n};\n\nint c = 0;          // c used as counter to check if stack is empty or not\nstruct node *head;  // declaring head pointer globally assigned to NULL\n\nvoid push(char x)  // function for pushing\n{\n    struct node *p = head, *temp;\n    temp = (struct node *)malloc(sizeof(struct node));\n    temp->data = x;\n    if (head ==\n        NULL)  // will be execute only one time i.e, 1st time push is called\n    {\n        head = temp;\n        p = head;\n        p->link = NULL;\n        c++;\n    }\n    else\n    {\n        temp->link = p;\n        p = temp;\n        head = p;\n        c++;\n    }\n}\n\nchar pop(void)  // function for pop\n{\n    char x;\n    struct node *p = head;\n    x = p->data;\n    head = p->link;\n    free(p);\n    c--;\n    return x;\n}\n\nint isBalanced(char *s)\n{\n    int i = 0;\n    char x;\n    while (s[i] != '\\0')  // loop for covering entire string of brackets\n    {\n        // printf(\"\\t s[i]=%c\\n\", s[i]); //DEBUG\n        if (s[i] == '{' || s[i] == '(' ||\n            s[i] == '[')  // if opening bracket then push\n            push(s[i]);\n        else\n        {\n            if (c <= 0)  // i.e, stack is empty as only opening brackets are\n                         // added to stack\n                return 0;\n\n            x = pop();\n            if (x == '{' && s[i] != '}')\n                return 0;\n            if (x == '[' && s[i] != ']')\n                return 0;\n            if (x == '(' && s[i] != ')')\n                return 0;\n        }\n        i++;\n    }\n\n    // at end if stack is empy which means whole process has been performed\n    // correctly so return 1\n    return (c == 0) ? 1 : 0;\n}\n\nvoid destroyStack(void)\n{\n    struct node *p = head;\n    if (c > 0)\n    {\n        while (p->link)\n        {\n            struct node *tmp = p;\n            p = p->link;\n            free(tmp);\n        }\n\n        c = 0;\n    }\n}\n\nint main(void)\n{\n    int t;\n    printf(\"\\t\\tBalanced parenthesis\\n\\n\");\n    printf(\"\\nPlease enter the number of processing rounds? \");\n    scanf(\"%d\", &t);\n    for (int a0 = 0; a0 < t; a0++)\n    {\n        char s[SIZE];\n        printf(\"\\nPlease enter the expression? \");\n        scanf(\"%s\", s);\n\n        if (isBalanced(s))\n            printf(\"\\nYES\\n\");\n        else\n            printf(\"\\nNO\\n\");\n\n        /* tidy up stack for new round */\n        destroyStack();\n    }\n    return 0;\n}\n","index":79},{"title":"Stack","category":"stack","id":"stack_stack","algorithm":"/*\n    author: Christian Bender\n\n    This is the implementation of the (generic) stack.\n    The implementation uses the dynamic memory management and the principle\n    of data hiding.\n*/\n\n#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"stack.h\"\n\n/*\n   actual stack data structure\n   This pointer will pointing at the actual field (of void * pointers)\n   that represents the stack.\n */\nvoid **array;\n\n/* the current capacity of the stack */\nint max = 10;\n\n/* counter variable for counting the elements of the stack. */\nint counter = 0;\n\n/*\n    offset address\n    points at the top element of the stack.\n*/\nint offset = -1;\n\nvoid initStack()\n{\n    array = malloc(sizeof(void *) * max);\n    assert(array); /* tests whether pointer is assigned to memory. */\n}\n\n/*\n    grow: increases the stack by 10 elements.\n          This utility function isn't part of the public interface\n*/\nvoid grow()\n{\n    max += 10; /* increases the capacity */\n\n    int i;  // for the loop\n    void **tmp = malloc(sizeof(void *) * max);\n\n    /* copies the elements from the origin array in the new one. */\n    for (i = 0; i < max - 10; i++)\n    {\n        *(tmp + i) = *(array + i);\n    }\n    /*free the memory */\n    free(array);\n    array = tmp;\n}\n\n/* push: pushs the argument onto the stack */\nvoid push(void *object)\n{\n    assert(object); /* tests whether pointer isn't null */\n\n    if (counter < max)\n    {\n        offset++; /* increases the element-pointer */\n\n        /*\n            moves pointer by the offset address\n            pushs the object onto stack\n         */\n        *(array + offset) = object;\n\n        /* increases the inner counter */\n        counter++;\n    }\n    else /* stack is full */\n    {\n        grow();       /* lets grow stack */\n        push(object); /* recursive call */\n    }\n}\n\n/*\n    pop: pops the top element of the stack from the stack.\n*/\nvoid *pop()\n{\n    void *top = *(array + offset);\n\n    /* check pointers */\n    assert(top);\n\n    /* if use the pop-function, stack must not empty. */\n    assert(!isEmpty());\n\n    /* decreases the offset address for pointing of\n        the new top element */\n    offset--;\n\n    /* decreases the inner counter */\n    counter--;\n\n    return top;\n}\n\n/*\n    size: gets the number of elements of the stack.\n*/\nint size() { return counter; }\n\n/*\n    isEmpty(): returns 1 if stack is empty otherwise 0.\n*/\nint isEmpty() { return counter == 0; }\n\n/*\n    top: returns the top element from the stack without removing it.\n*/\nvoid *top()\n{\n    /* offset address points to the top element */\n    return array[offset];\n}\n","index":80},{"title":"Stack.h","category":"stack","id":"stack.h_stack","algorithm":"/*\n    author: Christian Bender\n\n    This header represents the public stack-interface.\n    The stack is generic and self growing.\n*/\n\n#ifndef __STACK__\n#define __STACK__\n\n/*\n    initStack: initializes the stack with a capacity of 10 elements.\n*/\nvoid initStack();\n\n/*\n    push: pushs the argument onto the stack\n*/\nvoid push(void *object);\n\n/*\n    pop: pops the top element of the stack from the stack.\n    assumes: stack not empty.\n*/\nvoid *pop();\n\n/*\n    size: gets the number of elements of the stack.\n*/\nint size();\n\n/*\n    isEmpty(): returns 1 if stack is empty otherwise 0.\n*/\nint isEmpty();\n\n/*\n    top: returns the top element from the stack without removing it.\n*/\nvoid *top();\n\n#endif","index":81},{"title":"Stack Linked List","category":"stack","id":"stack_linked_list","index":82},{"title":"Main","category":"stack_linked_list","id":"main_stack_linked_list","algorithm":"#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"stack.h\"\n\nint main()\n{\n    Stack_T stk;\n    stk = Stack_init();\n    Stack_push(stk, (int *)1);\n    Stack_push(stk, (int *)2);\n    Stack_push(stk, (int *)3);\n    Stack_push(stk, (int *)4);\n    printf(\"Size: %d\\n\", Stack_size(stk));\n    Stack_print(stk);\n    Stack_pop(stk);\n    printf(\"Stack after popping: \\n\");\n    Stack_print(stk);\n    Stack_pop(stk);\n    printf(\"Stack after popping: \\n\");\n    Stack_print(stk);\n    return 0;\n}\n","index":83},{"title":"Stack","category":"stack_linked_list","id":"stack_stack_linked_list","algorithm":"#include \"stack.h\"\n#include <assert.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define T Stack_T\n\ntypedef struct elem\n{\n    void *val;\n    struct elem *next;\n} elem_t;\n\nstruct T\n{\n    int count;\n    elem_t *head;\n};\n\n/* Initial stack */\nT Stack_init(void)\n{\n    T stack;\n    stack = (T)malloc(sizeof(T));\n    stack->count = 0;\n    stack->head = NULL;\n    return stack;\n}\n\n/* Check empty stack*/\nint Stack_empty(T stack)\n{\n    assert(stack);\n    return stack->count == 0;\n}\n\n/* Return size of the stack */\nint Stack_size(T stack)\n{\n    assert(stack);\n    return stack->count;\n}\n\n/* Push an element into the stack */\nvoid Stack_push(T stack, void *val)\n{\n    elem_t *t;\n\n    assert(stack);\n    t = (elem_t *)malloc(sizeof(elem_t));\n    t->val = val;\n    t->next = stack->head;\n    stack->head = t;\n    stack->count++;\n}\n\n/* Pop an element out of the stack */\nvoid *Stack_pop(T stack)\n{\n    void *val;\n    elem_t *t;\n\n    assert(stack);\n    assert(stack->count > 0);\n    t = stack->head;\n    stack->head = t->next;\n    stack->count--;\n    val = t->val;\n    free(t);\n    return val;\n}\n\n/* Print all elements in the stack */\nvoid Stack_print(Stack_T stack)\n{\n    assert(stack);\n\n    int i, size = Stack_size(stack);\n    elem_t *current_elem = stack->head;\n    printf(\"Stack [Top --- Bottom]: \");\n    for (i = 0; i < size; ++i)\n    {\n        printf(\"%p \", (int *)current_elem->val);\n        current_elem = current_elem->next;\n    }\n    printf(\"\\n\");\n}\n","index":84},{"title":"Stack.h","category":"stack_linked_list","id":"stack.h_stack_linked_list","algorithm":"#ifndef __STACK__\n#define __STACK__\n\n#define T Stack_T\ntypedef struct T *T;\n\nextern T Stack_init(void);\nextern int Stack_size(T stack);\nextern int Stack_empty(T stack);\nextern void Stack_push(T stack, void *val);\nextern void *Stack_pop(T stack);\nextern void Stack_print(T stack);\n\n#undef T\n#endif\n","index":85},{"title":"Stack","category":"data_structures","id":"stack_data_structures","algorithm":"/**\n * Kyler Smith, 2017\n * Stack data structure implementation.\n */\n\n////////////////////////////////////////////////////////////////////////////////\n// INCLUDES\n#include <stdio.h>\n#include <stdlib.h>\n\n////////////////////////////////////////////////////////////////////////////////\n// MACROS: CONSTANTS\n\n////////////////////////////////////////////////////////////////////////////////\n// DATA STRUCTURES\nstruct node\n{\n    int data;\n    struct node *next;\n    struct node *pre;\n} * head, *tmp;\n\n////////////////////////////////////////////////////////////////////////////////\n// GLOBAL VARIABLES\nint count = 0;\n\n////////////////////////////////////////////////////////////////////////////////\n// FUNCTION PROTOTYPES\nvoid create();\nvoid push(int x);\nint pop();\nint peek();\nint size();\nint isEmpty();\n\n////////////////////////////////////////////////////////////////////////////////\n// MAIN ENTRY POINT\n\nint main(int argc, char const *argv[])\n{\n    int x, y, z;\n\n    create();\n    push(4);\n    x = pop();\n    // 4. Count: 0. Empty: 1.\n    printf(\"%d.\\t\\tCount: %d.\\tEmpty: %d.\\n\", x, size(), isEmpty());\n\n    push(1);\n    push(2);\n    push(3);\n    x = pop();\n    y = pop();\n    // 3, 2. Count: 1. Empty: 0;\n    printf(\"%d, %d.\\t\\tCount: %d.\\tEmpty: %d.\\n\", x, y, size(), isEmpty());\n    pop();  // Empty the stack.\n\n    push(5);\n    push(6);\n    x = peek();\n    push(7);\n    y = pop();\n    push(8);\n    z = pop();\n    // 1, 6, 7, 8. Count: 2. Empty: 0.\n    printf(\"%d, %d, %d.\\tCount: %d.\\tEmpty: %d.\\n\", x, y, z, size(), isEmpty());\n\n    return 0;\n}\n\n/**\n * Initialize the stack to NULL.\n */\nvoid create() { head = NULL; }\n\n/**\n * Push data onto the stack.\n */\nvoid push(int x)\n{\n    if (head == NULL)\n    {\n        head = (struct node *)malloc(1 * sizeof(struct node));\n        head->next = NULL;\n        head->pre = NULL;\n        head->data = x;\n    }\n    else\n    {\n        tmp = (struct node *)malloc(1 * sizeof(struct node));\n        tmp->data = x;\n        tmp->next = NULL;\n        tmp->pre = head;\n        head->next = tmp;\n        head = tmp;\n    }\n    ++count;\n}\n\n/**\n * Pop data from the stack\n */\nint pop()\n{\n    int returnData;\n    if (head == NULL)\n    {\n        printf(\"ERROR: Pop from empty stack.\\n\");\n        exit(1);\n    }\n    else\n    {\n        returnData = head->data;\n\n        if (head->pre == NULL)\n        {\n            free(head);\n            head = NULL;\n        }\n        else\n        {\n            head = head->pre;\n            free(head->next);\n        }\n    }\n    --count;\n    return returnData;\n}\n\n/**\n * Returns the next value to be popped.\n */\nint peek()\n{\n    if (head != NULL)\n        return head->data;\n    else\n    {\n        printf(\"ERROR: Peeking from empty stack.\");\n        exit(1);\n    }\n}\n\n/**\n * Returns the size of the stack.\n */\nint size() { return count; }\n\n/**\n * Returns 1 if stack is empty, returns 0 if not empty.\n */\nint isEmpty()\n{\n    if (count == 0)\n        return 1;\n    return 0;\n}\n","index":86},{"title":"Trie","category":"data_structures","id":"trie","index":87},{"title":"Trie","category":"trie","id":"trie_trie","algorithm":"/*------------------Trie Data Structure----------------------------------*/\n/*-------------Implimented for search a word in dictionary---------------*/\n\n/*-----character - 97 used for get the character from the ASCII value-----*/\n\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define ALPHABET_SIZE 26\n\n/*--Node in the Trie--*/\ntypedef struct TrieNode\n{\n    struct TrieNode *children[ALPHABET_SIZE];\n    char character;\n    bool isEndOfWord;\n\n} TrieNode;\n\n/*--Create new node--*/\nTrieNode *createTrieNode()\n{\n    TrieNode *node;\n    node = malloc(sizeof(TrieNode));\n    node->isEndOfWord = false;\n    int i = 0;\n    while (i < ALPHABET_SIZE)\n    {\n        node->children[i] = NULL;\n        i++;\n    }\n    return node;\n}\n\n/*--Insert new word to Trie--*/\nvoid insert(TrieNode *root, char *word)\n{\n    /*----Addition of the word done by recurcively----*/\n\n    // Check wheather word character pointer is NULL\n    if ((strlen(word) - 1) != 0)\n    {\n        char character = *word;\n        if (root->children[character - 97] == NULL)\n        {\n            TrieNode *node = NULL;\n            node = createTrieNode();\n            node->character = character;\n            root->children[character - 97] = node;\n        }\n        word++;\n        insert(root->children[character - 97], word);\n    }\n    else\n    {\n        root->isEndOfWord = true;\n    }\n    return;\n}\n\n/*--Search a word in the Trie--*/\nTrieNode *search(TrieNode *root, char *word)\n{\n    TrieNode *temp;\n    while (*word != '\\0')\n    {\n        char character = *word;\n        if (root->children[character - 97] != NULL)\n        {\n            temp = root->children[character - 97];\n            word++;\n            root = temp;\n        }\n        else\n        {\n            printf(\"No possible words!!\\n\");\n            return NULL;\n        }\n    }\n    return root;\n}\n\n/*---Print a word in the array--*/\nvoid printArray(char chars[], int len)\n{\n    int i;\n    for (i = 0; i < len; i++)\n    {\n        printf(\"%c\", chars[i]);\n    }\n    printf(\"\\n\");\n}\n\n/*---Return all the related words------*/\nvoid printPathsRecur(TrieNode *node, char prefix[], int filledLen)\n{\n    if (node == NULL)\n        return;\n\n    prefix[filledLen] = node->character;\n    filledLen++;\n\n    if (node->isEndOfWord)\n    {\n        printArray(prefix, filledLen);\n    }\n\n    int i;\n    for (i = 0; i < ALPHABET_SIZE; i++)\n    {\n        printPathsRecur(node->children[i], prefix, filledLen);\n    }\n}\n\n/*--Travel through the Trie and return words from it--*/\nvoid traverse(char prefix[], TrieNode *root)\n{\n    TrieNode *temp = NULL;\n    temp = search(root, prefix);\n    int j = 0;\n    while (prefix[j] != '\\0')\n    {\n        j++;\n    }\n    printPathsRecur(temp, prefix, j - 1);\n}\n\n/*------Demonstrate purposes uses text file called dictionary -------*/\n\n#define NUMBER_OF_WORDS (354935)\n#define INPUT_WORD_SIZE (100)\n\n/*----Get input from the user------*/\nchar *receiveInput(char *s)\n{\n    scanf(\"%99s\", s);\n    return s;\n}\n\nint main()\n{\n    // Read the file dictionary\n    int word_count = 0;\n    char *words[NUMBER_OF_WORDS];\n    FILE *fp = fopen(\"dictionary.txt\", \"r\");\n\n    if (fp == 0)\n    {\n        fprintf(stderr, \"Error while opening dictionary file\");\n        exit(1);\n    }\n\n    words[word_count] = malloc(INPUT_WORD_SIZE);\n\n    while (fgets(words[word_count], INPUT_WORD_SIZE, fp))\n    {\n        word_count++;\n        words[word_count] = malloc(INPUT_WORD_SIZE);\n    }\n\n    // Push the words in to Trie\n    TrieNode *root = NULL;\n    root = createTrieNode();\n    int i;\n    for (i = 0; i < NUMBER_OF_WORDS; i++)\n    {\n        insert(root, words[i]);\n    }\n\n    while (1)\n    {\n        printf(\"Enter keyword: \");\n        char str[100];\n        receiveInput(str);\n        printf(\n            \"\\n==========================================================\\n\");\n        printf(\"\\n********************* Possible Words ********************\\n\");\n\n        // Find the word through the Trie\n        traverse(str, root);\n\n        printf(\n            \"\\n==========================================================\\n\");\n    }\n}\n","index":88},{"title":"Exercism","category":null,"id":"exercism","index":89},{"title":"Acronym","category":"exercism","id":"acronym","index":90},{"title":"Acronym","category":"acronym","id":"acronym_acronym","algorithm":"#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n\nchar *abbreviate(const char *phrase)\n{\n    char str[80];\n    strcpy(str, phrase);\n    char *p_str = str;\n    static char acr[80];\n    strcpy(acr, \"\");\n\n    /* for counting the words */\n    int counter = 0;\n\n    /* for position the words */\n    int index = 0;\n\n    /* for -loop variable */\n    int i = 0;\n\n    /*\n        counts the empty-characters.\n        for determine the number of words\n    */\n    while (p_str && (i < 80))\n    {\n        if (*p_str == ' ')\n        {\n            counter++;\n        }\n        if (i < 80)\n        {\n            p_str++;\n            i++;\n        }\n    }\n\n    i = 0;\n    counter++;\n    char **words = (char **)malloc(counter * sizeof(char *));\n\n    /* initalizes words-array with empty strings */\n    for (i = 0; i < counter; i++)\n    {\n        words[i] = (char *)malloc(80 * sizeof(char));\n        strcpy(words[i], \"\");\n    }\n\n    /* rewind string */\n    p_str = str;\n\n    char *p_start = p_str;\n\n    /* collects each word in array 'words' */\n    while (p_str && (i <= 80))\n    {\n        if (*p_str == ' ')\n        {\n            *p_str = '\\0';\n            strncat(words[index], p_start, 80);\n            index++;\n            p_start = p_str + 1;\n        }\n\n        if (i <= 80)\n        {\n            p_str++;\n            i++;\n        }\n    }\n\n    /* adds the last word */\n    *p_str = '\\0';\n    strncat(words[index], p_start, 80);\n    index++;\n\n    /* builds the actual acronym */\n    for (i = 0; i < index; i++)\n    {\n        /* capitalize the first character */\n        words[i][0] = toupper(words[i][0]);\n        words[i][1] = '\\0';\n        strcat(acr, words[i]);\n    }\n\n    for (i = 0; i < counter; i++) free(words[i]);\n    free(words);\n\n    return acr;\n}\n","index":91},{"title":"Acronym.h","category":"acronym","id":"acronym.h_acronym","algorithm":"#ifndef ACRONYM_H\n#define ACRONYM_H\n\nchar *abbreviate(const char *phrase);\n\n#endif\n","index":92},{"title":"Hello World","category":"exercism","id":"hello_world","index":93},{"title":"Hello World","category":"hello_world","id":"hello_world_hello_world","algorithm":"#include \"hello_world.h\"\n#include <stdlib.h>\n#include <string.h>\n\nconst char *hello(void)\n{\n    char *ans = strdup(\"Hello, World!\");\n    /* string is pointer of the first character */\n    return ans;\n}\n","index":94},{"title":"Hello World.h","category":"hello_world","id":"hello_world.h_hello_world","algorithm":"#ifndef HELLO_WORLD_H\n#define HELLO_WORLD_H\n\nconst char *hello(void);\n\n#endif\n","index":95},{"title":"Isogram","category":"exercism","id":"isogram","index":96},{"title":"Isogram","category":"isogram","id":"isogram_isogram","algorithm":"#include <stdbool.h>\n#include <string.h>\n\n/*\n    is_isogram: returns true if the given string a isogram, otherwise false.\n*/\nbool is_isogram(const char phrase[])\n{\n    /* use 'unsigned' because of the function strlen(...) */\n    unsigned int i = 0;\n    unsigned int j = 0;\n\n    /* the current read character in the first for-loop */\n    char current_char = ' ';\n\n    /* return status */\n    bool status = true;\n\n    /* contains the length of the given string */\n    unsigned int len_phrase = strlen(phrase);\n\n    for (i = 0; i < len_phrase; i++)\n    {\n        current_char = phrase[i];\n\n        /* makes sure the current character has no repetition */\n        for (j = i + 1; j < len_phrase; j++)\n        {\n            if (current_char == phrase[j])\n            {\n                status = false;\n\n                /*\n                    because the given string is none isogram.\n                    that means we can exit the nested for-loop.\n                */\n                goto end;\n            }\n        }\n    }\n\n/* exit label */\nend:\n    return status;\n}","index":97},{"title":"Isogram.h","category":"isogram","id":"isogram.h_isogram","algorithm":"#ifndef ISOGRAM_H\n#define ISOGRAM_H\n\n#include <stdbool.h>\n\nbool is_isogram(const char phrase[]);\n\n#endif\n","index":98},{"title":"Rna Transcription","category":"exercism","id":"rna_transcription","index":99},{"title":"Rna Transcription","category":"rna_transcription","id":"rna_transcription_rna_transcription","algorithm":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar *to_rna(const char s[])\n{\n    /* determines the length of the given string */\n    int len = strlen(s);\n\n    /* creates a return string */\n    char *ans = malloc(sizeof(char) * len);\n\n    /* for the loop */\n    int i = 0;\n\n    /* actual compile process */\n    for (i = 0; i < len; i++)\n    {\n        switch (s[i])\n        {\n        case 'G':\n            ans[i] = 'C';\n            break;\n        case 'C':\n            ans[i] = 'G';\n            break;\n        case 'T':\n            ans[i] = 'A';\n            break;\n        case 'A':\n            ans[i] = 'U';\n            break;\n        }\n    }\n\n    return ans;\n}","index":100},{"title":"Rna Transcription.h","category":"rna_transcription","id":"rna_transcription.h_rna_transcription","algorithm":"#ifndef __RNA_TRANSCRIPTION__H\n#define __RNA_TRANSCRIPTION__H\n\n/* to_rna: compiles a DNA strand in its RNA complement */\nchar *to_rna(const char s[]);\n\n#endif","index":101},{"title":"Word Count","category":"exercism","id":"word_count","index":102},{"title":"Word Count","category":"word_count","id":"word_count_word_count","algorithm":"#include \"word_count.h\"\n#include <string.h>\n\n/*\n    word_count: returns the full number of words in the input_text,\n                otherwise an error code: (see below)\n\n    error codes: EXCESSIVE_LENGTH_WORD     -1\n                 EXCESSIVE_NUMBER_OF_WORDS -2\n\n    The function manipulates the given structure of type word_count_word_t\n    After that process the member count contains the number of occures.\n*/\nint word_count(const char *input_text, word_count_word_t *words)\n{\n    char word_list[MAX_WORDS][MAX_WORD_LENGTH];\n    char input[1000];\n    strcpy(input, input_text);\n    char *p_str = input;\n\n    /* index for iteration over input string */\n    int index = 0;\n\n    /* index for word_list */\n    int index_list = 0;\n\n    /* counts all words */\n    int count_all = 0;\n\n    /* for controlling the while loop */\n    int loop = 1;\n\n    /* for the for-loop */\n    int i = 0;\n\n    /* collects all words in the word_list */\n    while (input[index] && loop)\n    {\n        if (input[index] == ' ')\n        {\n            input[index] = '\\0';\n            if (strlen(p_str) <= MAX_WORD_LENGTH)\n            {\n                if (index_list <= MAX_WORDS)\n                {\n                    strcpy(word_list[index_list], p_str);\n\n                    /* sets pointer to the next position */\n                    p_str = input + index + 1;\n                    index_list++;\n\n                    /* counts the word */\n                    count_all++;\n                }\n                else /* error case too many words */\n                {\n                    count_all = EXCESSIVE_NUMBER_OF_WORDS;\n                    loop = 0;\n                }\n            }\n            else /* error case: word is too long */\n            {\n                count_all = EXCESSIVE_LENGTH_WORD;\n                loop = 0;\n            }\n        }\n\n        index++;\n    }\n\n    words->count = 0;\n\n    /* make sure none error is occured */\n    if (loop)\n    {\n        /* collects the last word up to the \\0-character. and counts it.*/\n        strcpy(word_list[index_list], p_str);\n        count_all++;\n\n        for (i = 0; i <= index_list; i++)\n        {\n            if (strcmp(word_list[i], words->text) == 0)\n            {\n                words->count++;\n            }\n        }\n    }\n\n    /* returns the number of words or an error code */\n    return count_all;\n}","index":103},{"title":"Word Count.h","category":"word_count","id":"word_count.h_word_count","algorithm":"#ifndef WORD_COUNT_H\n#define WORD_COUNT_H\n\n#define MAX_WORDS 20  // at most MAX_WORDS can be found in the test input string\n#define MAX_WORD_LENGTH 50  // no individual word can exceed this length\n\n// results structure\ntypedef struct word_count_word\n{\n    char text[MAX_WORD_LENGTH];\n    int count;\n} word_count_word_t;\n\n#define EXCESSIVE_LENGTH_WORD -1\n#define EXCESSIVE_NUMBER_OF_WORDS -2\n\n// word_count - routine to classify the unique words and their frequency in a\n// test input string inputs:\n//    input_text =  a null-terminated string containing that is analyzed\n//\n// outputs:\n//    words = allocated structure to record the words found and their frequency\n//    uniqueWords - number of words in the words structure\n//           returns a negative number if an error.\n//           words will contain the results up to that point.\nint word_count(const char *input_text, word_count_word_t *words);\n\n#endif\n","index":104},{"title":"Games","category":null,"id":"games","index":105},{"title":"Tic Tac Toe","category":"games","id":"tic_tac_toe_games","algorithm":"/**\n * @file tic-tac-toe.c\n * @author [vivekboss99](github.com/vivekboss99)\n * @author [Krishna Vedala](https://github.com/kvedala)\n * @brief [Tic-Tac-Toe game](https://en.wikipedia.org/wiki/Tic-tac-toe)\n * implementation in C\n * @details  Tic-Tac-Toe Game,where the user can decide to play with the\n * computer(single player mode) or with other user(double player mode) , the\n * code as an array named 'game_table' which is the table and user needs to enter the\n * position inside the array(from 1-9) where he/she wants to place 'X' or 'O' on the\n * table.\n */\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n// Functions Declarations\nstatic void singlemode();\nstatic void doublemode();\nstatic void placex(int);  // used for placing position of X by the 1st player\nstatic void place();      // used by the computer to place O\nstatic void placey(int);  // used in Double Player mode by the 2nd player to\n                          // place the position of O\nint checkwin();  // checks everytime when a player or computer places 'X' or 'O'\n\n/** Tic-Tac-Toe table, so basically we are using variable 'game_table' as the table(size:3X3) and\n * updating it regularly\n */\nstatic char game_table[9];\n\n/**\n * Main program function.\n * @returns 0 on clean exit. \n * @note No checks are included for program execution failures!\n */\nint main()\n{   srand(time(NULL));\n    int l = 0;\n    do\n    {\n        int n = 0;\n\n        // filling the table with multiple asterisks\n        for (int i = 0; i < 9; i++) game_table[i] = '*';\n\n        // displaying the main menu\n        printf(\"***************************************\\n\");\n        printf(\"*************TIC TAC TOE***************\\n\");\n        printf(\"***************************************\\n\");\n        printf(\"***********1. YOU vs COMPUTER ***********\\n\");\n        printf(\"***********2. YOU vs PLAYER ***********\\n\");\n        printf(\"***********3.EXIT *********************\\n\");\n        printf(\"Enter your choice : \");\n        scanf(\"%d\", &n);\n\n        switch (n)  // switch case to select between single player mode or\n                    // double player mode\n        {\n        case 1:\n            singlemode();\n            break;\n        case 2:\n            doublemode();\n            break;\n        default:\n            printf(\"THANK YOU and EXIT!\");\n        }\n\n        printf(\"Next game ? : \");\n        printf(\"Enter 1  YES and 0 - NO \");\n        scanf(\"%d\", &l);\n\n    } while (l == 1);\n\n    return 0;\n}\n\n/**\n * @brief Implementation of game vs computer\n *\n * @returns None\n */\nvoid singlemode()\n{\n    int m;\n    int k = 0;\n    int table_fill_count=0;\n\n    for (int i = 0; i < 3; i++)\n    {\n        for (int j = 0; j < 3; j++)\n        {\n            printf(\"%c \", game_table[k]);\n            k++;\n        }\n\n        printf(\"\\n\");\n    }\n\n    for (int x = 1; x < 10; x++)\n    {\n        k = 0;\n\n        printf(\"Where would you like to place 'x' \");\n        scanf(\"%d\", &m);\n\n        placex(m);\n        if(table_fill_count<4)\n        {\n          place();\n        }\n\n        for (int i = 0; i < 3; i++)\n        {\n            for (int j = 0; j < 3; j++)\n            {\n                printf(\"%c \", game_table[k]);\n                k++;\n\n            }\n\n            printf(\"\\n\");\n        }\n        table_fill_count++;\n        int o = checkwin();\n\n        if (o == -1 || o == -2)\n        {\n            if (o == -1)\n            {\n                printf(\"YOU WIN\\n\");\n            }\n            if (o == -2)\n            {\n                printf(\"YOU LOSE\\n\");\n            }\n\n            break;\n        }\n\n        if (table_fill_count==4)\n        {\n            printf(\"\\nDRAW \");\n            break;\n        }\n    }\n}\n\n/**\n * @brief Implementation of game vs another player.\n *\n * @returns None\n */\nvoid doublemode()\n{\n    int m;\n    int e1;\n    int k = 0;\n    int doublemode_table_count=0;\n\n    for (int i = 0; i < 3; i++)\n    {\n        for (int j = 0; j < 3; j++)\n        {\n            printf(\"%c \", game_table[k]);\n            k++;\n        }\n\n        printf(\"\\n\");\n    }\n    for (int x = 1; x < 10; x++)\n    {\n        k = 0;\n\n        printf(\"PLAYER1 - where would you like to place 'x' : \");\n        scanf(\"%d\", &m);\n\n        placex(m);\n        if(doublemode_table_count<4)\n        {\n        printf(\"PLAYER2 - where would you like to place 'o' : \");\n        scanf(\"%d\", &e1);\n\n        placey(e1);\n        }\n\n        for (int i = 0; i < 3; i++)\n        {\n            for (int j = 0; j < 3; j++)\n            {\n                printf(\"%c \", game_table[k]);\n                k++;\n            }\n\n            printf(\"\\n\");\n        }\n        doublemode_table_count++;\n        int o = checkwin();\n\n        if (o == -1 || o == -2)\n        {\n            if (o == -1)\n            {\n                printf(\"Player 1 WIN\\n\");\n            }\n            if (o == -2)\n            {\n                printf(\"Player 2 WIN\\n\");\n            }\n\n            break;\n        }\n        if (doublemode_table_count==4)\n        {\n            printf(\"\\nDRAW \");\n            break;\n        }\n    }\n}\n\n/**\n * @brief Update table by placing an `X`\n *\n * @param m location to place `X`\n *\n * @returns None\n */\nvoid placex(int m)\n{\n    int n1;\n    if (m >= 1 && m <= 9)\n    {\n        if (game_table[m - 1] != 'x' && game_table[m - 1] != 'o')\n        {\n            game_table[m - 1] = 'x';\n        }\n        else\n        {\n            printf(\"Invalid move\\n\");\n\n            printf(\"Enter new position : \");\n            scanf(\"%d\", &n1);\n\n            placex(n1);\n        }\n    }\n    else\n    {\n        printf(\"Invalid move \\n\");\n\n        printf(\"Enter new position : \");\n        scanf(\"%d\", &n1);\n\n        placex(n1);\n    }\n}\n/**\n * @brief Update table by placing an `O`\n *\n * @returns None\n */\nvoid place()\n{\n\n    int e = rand() % 9;\n\n    if (e >= 0 && e <= 8)\n    {\n        if (game_table[e] != 'x' && game_table[e] != 'o')\n        {\n            game_table[e] = 'o';\n            printf(\"\\n Computer placed at %d position\\n\", e + 1);\n        }\n        else\n        {\n            place();\n        }\n    }\n}\n/**\n * @brief Update table by placing an `O`\n *\n * @param e1 location to place `O`\n *\n * @returns None\n */\nvoid placey(int e1)\n{\n    int n1;\n    if (e1 >= 1 && e1 <= 9)\n    {\n        if (game_table[e1 - 1] != 'x' && game_table[e1 - 1] != 'o')\n        {\n            game_table[e1 - 1] = 'o';\n        }\n        else\n        {\n            printf(\"Invalid move \\n\");\n\n            printf(\"Enter new position : \");\n            scanf(\"%d\", &n1);\n\n            placey(n1);\n        }\n    }\n    else\n    {\n        printf(\"Invalid move \\n\");\n\n        printf(\"Enter new position : \");\n        scanf(\"%d\", &n1);\n\n        placey(n1);\n    }\n}\n/**\n * @brief Implementation of win conditon checker for 'X' or 'O' whenever the table is updated\n *\n * @returns -1: if 'X' won \n * @returns -2: if 'O' won\n * @returns 0: if there is no win condition for 'X' or 'O' \n */\nint checkwin()\n{\n    if (game_table[0] == game_table[1] && game_table[1] == game_table[2])\n    {\n        if (game_table[0] == 'x' && game_table[1] == 'x' &&\n            game_table[2] == 'x')\n        {\n            return -1;\n        }\n\n        if (game_table[0] == 'o' && game_table[1] == 'o' &&\n            game_table[2] == 'o')\n        {\n            return -2;\n        }\n    }\n    else if (game_table[0] == game_table[4] && game_table[4] == game_table[8])\n    {\n        if (game_table[0] == 'x' && game_table[4] == 'x' &&\n            game_table[8] == 'x')\n        {\n            return -1;\n        }\n\n        if (game_table[0] == 'o' && game_table[4] == 'o' &&\n            game_table[8] == 'o')\n        {\n            return -2;\n        }\n    }\n    else if (game_table[0] == game_table[3] && game_table[3] == game_table[6])\n    {\n        if (game_table[0] == 'x' && game_table[3] == 'x' &&\n            game_table[6] == 'x')\n        {\n            return -1;\n        }\n\n        if (game_table[0] == 'o' && game_table[3] == 'o' &&\n            game_table[6] == 'o')\n        {\n            return -2;\n        }\n    }\n    else if (game_table[3] == game_table[4] && game_table[4] == game_table[5])\n    {\n        if (game_table[3] == 'x' && game_table[4] == 'x' &&\n            game_table[5] == 'x')\n        {\n            return -1;\n        }\n\n        if (game_table[3] == 'o' && game_table[4] == 'o' &&\n            game_table[5] == 'o')\n        {\n            return -2;\n        }\n    }\n    else if (game_table[6] == game_table[7] && game_table[7] == game_table[8])\n    {\n        if (game_table[6] == 'x' && game_table[7] == 'x' &&\n            game_table[8] == 'x')\n        {\n            return -1;\n        }\n\n        if (game_table[6] == 'o' && game_table[7] == 'o' &&\n            game_table[8] == 'o')\n        {\n            return -2;\n        }\n    }\n    else if (game_table[1] == game_table[4] && game_table[4] == game_table[7])\n    {\n        if (game_table[1] == 'x' && game_table[4] == 'x' &&\n            game_table[7] == 'x')\n        {\n            return -1;\n        }\n\n        if (game_table[1] == 'o' && game_table[4] == 'o' &&\n            game_table[7] == 'o')\n        {\n            return -2;\n        }\n    }\n    else if (game_table[2] == game_table[5] && game_table[5] == game_table[8])\n    {\n        if (game_table[2] == 'x' && game_table[5] == 'x' &&\n            game_table[8] == 'x')\n        {\n            return -1;\n        }\n\n        if (game_table[2] == 'o' && game_table[5] == 'o' &&\n            game_table[8] == 'o')\n        {\n            return -2;\n        }\n    }\n    else if (game_table[2] == game_table[4] && game_table[4] == game_table[6])\n    {\n        if (game_table[2] == 'x' && game_table[4] == 'x' &&\n            game_table[6] == 'x')\n        {\n            return -1;\n        }\n\n        if (game_table[2] == 'o' && game_table[4] == 'o' &&\n            game_table[6] == 'o')\n        {\n            return -2;\n        }\n    }\n    return 0;\n}\n","index":106},{"title":"Geometry","category":null,"id":"geometry","index":107},{"title":"Geometry Datatypes.h","category":"geometry","id":"geometry_datatypes.h_geometry","algorithm":"/**\n * @addtogroup quaternions Library for 3D Vectors & Quaternions\n * @{\n * @file\n * @brief Generic header that provides data types for 3D vectors and quaternions\n * @author Krishna Vedala\n */\n\n#ifndef __LIBQUAT_H_\n#define __LIBQUAT_H_\n\n/** Minimum recognizable value. Any value less than this is considered to be\n * @f$=0@f$ */\n#define EPSILON 1e-9\n\n/**\n * @addtogroup vec_3d 3D Vector operations\n * @{\n */\n/** 3D vector type */\ntypedef struct vec_3d_\n{\n    float x; /**< X co-ordinate */\n    float y; /**< Y co-ordinate */\n    float z; /**< Z co-ordinate */\n} vec_3d;\n/** @} */\n\n/**\n * @addtogroup matrix Matrix operations\n * @{\n */\n/** A 3x3 Matrix type definition */\ntypedef struct mat_3x3_\n{\n    union\n    { /**< 3 element row 1 */\n        float row1[3];\n        vec_3d vec1;\n    };\n    union\n    { /**< 3 element row 2 */\n        float row2[3];\n        vec_3d vec2;\n    };\n    union\n    { /**< 3 element row 3 */\n        float row3[3];\n        vec_3d vec3;\n    };\n} mat_3x3;\n/** @} */\n\n/** @addtogroup quats 3D Quaternion operations\n * @{\n */\n/** a Quaternion type represented using a scalar \\f$w\\f$ or \\f$q_0\\f$ and a\n * 3D vector \\f$\\left(q_1,q_2,q_3\\right)\\f$\n */\ntypedef struct quaternion_\n{\n    union\n    {\n        float w;  /**< real part of quaternion */\n        float q0; /**< real part of quaternion */\n    };\n    /**< dual part of quaternion */\n    union\n    {\n        vec_3d dual; /**< can be a 3D vector */\n        /** or individual values */\n        struct\n        {\n            float q1, q2, q3;\n        };\n    };\n} quaternion;\n\n/** 3D Euler or Tait-Bryan angles (in radian) */\ntypedef struct euler_\n{\n    union\n    {\n        float roll; /**< or bank \\f$\\phi\\f$ = rotation about X axis */\n        float bank; /**< or roll \\f$\\phi\\f$ = rotation about X axis */\n    };\n    union\n    {\n        float pitch; /**< or elevation \\f$\\theta\\f$ = rotation about Y axis */\n        float elevation; /**< or pitch \\f$\\theta\\f$ = rotation about Y axis */\n    };\n    union\n    {\n        float yaw;     /**< or heading \\f$\\psi\\f$ = rotation about Z axis */\n        float heading; /**< or yaw \\f$\\psi\\f$ = rotation about Z axis */\n    };\n} euler;\n\n/** @} */\n\n/** @addtogroup dual_quats 3D Dual-Quaternion operations\n * @{\n */\n/** a dual quaternion type */\ntypedef struct dual_quat_\n{\n    quaternion real; /**< real part of dual quaternion */\n    quaternion dual; /**< dual part of dual quaternion */\n} dual_quat;\n\n/** @} */\n\n#endif  // __LIBQUAT_H_\n\n/** @} */\n","index":108},{"title":"Quaternions","category":"geometry","id":"quaternions_geometry","algorithm":"/**\n * @file\n * @brief Functions related to 3D quaternions and Euler angles.\n * @author Krishna Vedala\n */\n\n#include <stdio.h>\n#ifdef __arm__  // if compiling for ARM-Cortex processors\n#define LIBQUAT_ARM\n#include <arm_math.h>\n#else\n#include <math.h>\n#endif\n#include <assert.h>\n\n#include \"geometry_datatypes.h\"\n\n/**\n * @addtogroup quats 3D Quaternion operations\n * @{\n */\n\n/**\n * Function to convert given Euler angles to a quaternion.\n * \\f{eqnarray*}{\n * q_{0} & =\n * &\\cos\\left(\\frac{\\phi}{2}\\right)\\cos\\left(\\frac{\\theta}{2}\\right)\\cos\\left(\\frac{\\psi}{2}\\right)\n * +\n * \\sin\\left(\\frac{\\phi}{2}\\right)\\sin\\left(\\frac{\\theta}{2}\\right)\\sin\\left(\\frac{\\psi}{2}\\right)\\\\\n * q_{1} & =\n * &\\sin\\left(\\frac{\\phi}{2}\\right)\\cos\\left(\\frac{\\theta}{2}\\right)\\cos\\left(\\frac{\\psi}{2}\\right)\n * -\n * \\cos\\left(\\frac{\\phi}{2}\\right)\\sin\\left(\\frac{\\theta}{2}\\right)\\sin\\left(\\frac{\\psi}{2}\\right)\\\\\n * q_{2} & =\n * &\\cos\\left(\\frac{\\phi}{2}\\right)\\sin\\left(\\frac{\\theta}{2}\\right)\\cos\\left(\\frac{\\psi}{2}\\right)\n * +\n * \\sin\\left(\\frac{\\phi}{2}\\right)\\cos\\left(\\frac{\\theta}{2}\\right)\\sin\\left(\\frac{\\psi}{2}\\right)\\\\\n * q_{3} & =\n * &\\cos\\left(\\frac{\\phi}{2}\\right)\\cos\\left(\\frac{\\theta}{2}\\right)\\sin\\left(\\frac{\\psi}{2}\\right)\n * -\n * \\sin\\left(\\frac{\\phi}{2}\\right)\\sin\\left(\\frac{\\theta}{2}\\right)\\cos\\left(\\frac{\\psi}{2}\\right)\\\\\n * \\f}\n *\n * @param [in] in_euler input Euler angles instance\n * @returns converted quaternion\n */\nquaternion quat_from_euler(const euler *in_euler)\n{\n    quaternion out_quat;\n\n    if (!in_euler)  // if null\n    {\n        fprintf(stderr, \"%s: Invalid input.\", __func__);\n        return out_quat;\n    }\n\n    quaternion temp;\n\n    float cy = cosf(in_euler->yaw * 0.5f);\n    float sy = sinf(in_euler->yaw * 0.5f);\n    float cp = cosf(in_euler->pitch * 0.5f);\n    float sp = sinf(in_euler->pitch * 0.5f);\n    float cr = cosf(in_euler->roll * 0.5f);\n    float sr = sinf(in_euler->roll * 0.5f);\n\n    temp.w = cr * cp * cy + sr * sp * sy;\n    temp.q1 = sr * cp * cy - cr * sp * sy;\n    temp.q2 = cr * sp * cy + sr * cp * sy;\n    temp.q3 = cr * cp * sy - sr * sp * cy;\n\n    return temp;\n}\n\n/**\n * Function to convert given quaternion to Euler angles.\n * \\f{eqnarray*}{\n * \\phi & = &\n * \\tan^{-1}\\left[\\frac{2\\left(q_0q_1+q_2q_3\\right)}{1-2\\left(q_1^2+q_2^2\\right)}\\right]\\\\\n * \\theta & =\n * &-\\sin^{-1}\\left[2\\left(q_0q_2-q_3q_1\\right)\\right]\\\\\n * \\psi & = &\n * \\tan^{-1}\\left[\\frac{2\\left(q_0q_3+q_1q_2\\right)}{1-2\\left(q_2^2+q_3^2\\right)}\\right]\\\\\n * \\f}\n *\n * @param [in] in_quat input quaternion instance\n * @returns converted euler angles\n */\neuler euler_from_quat(const quaternion *in_quat)\n{\n    euler out_euler;\n    if (!in_quat)  // if null\n    {\n        fprintf(stderr, \"%s: Invalid input.\", __func__);\n        return out_euler;\n    }\n\n    out_euler.roll = atan2f(\n        2.f * (in_quat->w * in_quat->q1 + in_quat->q2 * in_quat->q3),\n        1.f - 2.f * (in_quat->q1 * in_quat->q1 + in_quat->q2 * in_quat->q2));\n    out_euler.pitch =\n        asinf(2.f * (in_quat->w * in_quat->q2 + in_quat->q1 * in_quat->q3));\n    out_euler.yaw = atan2f(\n        2.f * (in_quat->w * in_quat->q3 + in_quat->q1 * in_quat->q2),\n        1.f - 2.f * (in_quat->q2 * in_quat->q2 + in_quat->q3 * in_quat->q3));\n\n    return out_euler;\n}\n\n/**\n * Function to multiply two quaternions.\n * \\f{eqnarray*}{\n * \\mathbf{c} & = & \\mathbf{a}\\otimes\\mathbf{b}\\\\\n * & = & \\begin{bmatrix}a_{0} & a_{1} & a_{2} &\n *  a_{3}\\end{bmatrix}\\otimes\\begin{bmatrix}b_{0} & b_{1} & b_{2} &\n *  b_{3}\\end{bmatrix}\\\\\n * & = &\n * \\begin{bmatrix}\n *  a_{0}b_{0}-a_{1}b_{1}-a_{2}b_{2}-a_{3}b_{3}\\\\\n *  a_{0}b_{1}+a_{1}b_{0}+a_{2}b_{3}-a_{3}b_{2}\\\\\n *  a_{0}b_{2}-a_{1}b_{3}+a_{2}b_{0}+a_{3}b_{1}\\\\\n *  a_{0}b_{3}+a_{1}b_{2}-a_{2}b_{1}+a_{3}b_{0}\n * \\end{bmatrix}^{T}\n * \\f}\n *\n * @param [in] in_quat1 first input quaternion instance\n * @param [in] in_quat2 second input quaternion instance\n * @returns resultant quaternion\n */\nquaternion quaternion_multiply(const quaternion *in_quat1,\n                               const quaternion *in_quat2)\n{\n    quaternion out_quat;\n    if (!in_quat1 || !in_quat2)  // if null\n    {\n        fprintf(stderr, \"%s: Invalid input.\", __func__);\n        return out_quat;\n    }\n\n    out_quat.w = in_quat1->w * in_quat2->w - in_quat1->q1 * in_quat2->q1 -\n                 in_quat1->q2 * in_quat2->q2 - in_quat1->q3 * in_quat2->q3;\n    out_quat.q1 = in_quat1->w * in_quat2->q1 + in_quat1->q1 * in_quat2->w +\n                  in_quat1->q2 * in_quat2->q3 - in_quat1->q3 * in_quat2->q2;\n    out_quat.q2 = in_quat1->w * in_quat2->q2 - in_quat1->q1 * in_quat2->q3 +\n                  in_quat1->q2 * in_quat2->w + in_quat1->q3 * in_quat2->q1;\n    out_quat.q3 = in_quat1->w * in_quat2->q3 + in_quat1->q1 * in_quat2->q2 -\n                  in_quat1->q2 * in_quat2->q1 + in_quat1->q3 * in_quat2->w;\n\n    return out_quat;\n}\n\n/** @} */\n\nstatic void test()\n{\n    quaternion quat = {0.7071f, 0.7071f, 0.f, 0.f};\n    euler eul = euler_from_quat(&quat);\n    printf(\"Euler: %.4g, %.4g, %.4g\\n\", eul.pitch, eul.roll, eul.yaw);\n\n    quaternion test_quat = quat_from_euler(&eul);\n    printf(\"Quaternion: %.4g %+.4g %+.4g %+.4g\\n\", test_quat.w,\n           test_quat.dual.x, test_quat.dual.y, test_quat.dual.z);\n\n    assert(fabsf(test_quat.w - quat.w) < .01);\n    assert(fabsf(test_quat.q1 - quat.q1) < .01);\n    assert(fabsf(test_quat.q2 - quat.q2) < .01);\n    assert(fabsf(test_quat.q3 - quat.q3) < .01);\n}\n\nint main()\n{\n    test();\n    return 0;\n}\n","index":109},{"title":"Vectors 3d","category":"geometry","id":"vectors_3d_geometry","algorithm":"/**\n * @file\n * @brief Functions related to 3D vector operations.\n * @author Krishna Vedala\n */\n\n#include <stdio.h>\n#ifdef __arm__  // if compiling for ARM-Cortex processors\n#define LIBQUAT_ARM\n#include <arm_math.h>\n#else\n#include <math.h>\n#endif\n#include <assert.h>\n\n#include \"geometry_datatypes.h\"\n\n/**\n * @addtogroup vec_3d 3D Vector operations\n * @{\n */\n\n/**\n * Subtract one vector from another. @f[\n * \\vec{c}=\\vec{a}-\\vec{b}=\\left(a_x-b_x\\right)\\hat{i}+\n * \\left(a_y-b_y\\right)\\hat{j}+\\left(a_z-b_z\\right)\\hat{k}@f]\n * @param[in] a vector to subtract from\n * @param[in] b vector to subtract\n * @returns resultant vector\n */\nvec_3d vector_sub(const vec_3d *a, const vec_3d *b)\n{\n    vec_3d out;\n#ifdef LIBQUAT_ARM\n    arm_sub_f32((float *)a, (float *)b, (float *)&out);\n#else\n    out.x = a->x - b->x;\n    out.y = a->y - b->y;\n    out.z = a->z - b->z;\n#endif\n\n    return out;\n}\n\n/**\n * Add one vector to another. @f[\n * \\vec{c}=\\vec{a}+\\vec{b}=\\left(a_x+b_x\\right)\\hat{i}+\n * \\left(a_y+b_y\\right)\\hat{j}+\\left(a_z+b_z\\right)\\hat{k}@f]\n * @param[in] a vector to add to\n * @param[in] b vector to add\n * @returns resultant vector\n */\nvec_3d vector_add(const vec_3d *a, const vec_3d *b)\n{\n    vec_3d out;\n#ifdef LIBQUAT_ARM\n    arm_add_f32((float *)a, (float *)b, (float *)&out);\n#else\n    out.x = a->x + b->x;\n    out.y = a->y + b->y;\n    out.z = a->z + b->z;\n#endif\n\n    return out;\n}\n\n/**\n * Obtain the dot product of two 3D vectors.\n * @f[\n * \\vec{a}\\cdot\\vec{b}=a_xb_x + a_yb_y + a_zb_z\n * @f]\n * @param[in] a first vector\n * @param[in] b second vector\n * @returns resulting dot product\n */\nfloat dot_prod(const vec_3d *a, const vec_3d *b)\n{\n    float dot;\n#ifdef LIBQUAT_ARM\n    arm_dot_prod_f32((float *)a, (float *)b, &dot);\n#else\n    dot = a->x * b->x;\n    dot += a->y * b->y;\n    dot += a->z * b->z;\n#endif\n\n    return dot;\n}\n\n/**\n * Compute the vector product of two 3d vectors.\n * @f[\\begin{align*}\n * \\vec{a}\\times\\vec{b} &= \\begin{vmatrix}\n *  \\hat{i} & \\hat{j} & \\hat{k}\\\\\n *  a_x & a_y & a_z\\\\\n *  b_x & b_y & b_z\n *  \\end{vmatrix}\\\\\n *  &= \\left(a_yb_z-b_ya_z\\right)\\hat{i} - \\left(a_xb_z-b_xa_z\\right)\\hat{j}\n * + \\left(a_xb_y-b_xa_y\\right)\\hat{k} \\end{align*}\n * @f]\n * @param[in] a first vector @f$\\vec{a}@f$\n * @param[in] b second vector @f$\\vec{b}@f$\n * @returns resultant vector @f$\\vec{o}=\\vec{a}\\times\\vec{b}@f$\n */\nvec_3d vector_prod(const vec_3d *a, const vec_3d *b)\n{\n    vec_3d out;  // better this way to avoid copying results to input\n                 // vectors themselves\n    out.x = a->y * b->z - a->z * b->y;\n    out.y = -a->x * b->z + a->z * b->x;\n    out.z = a->x * b->y - a->y * b->x;\n\n    return out;\n}\n\n/**\n * Print formatted vector on stdout.\n * @param[in] a vector to print\n * @param[in] name  name of the vector\n * @returns string representation of vector\n */\nconst char *print_vector(const vec_3d *a, const char *name)\n{\n    static char vec_str[100];  // static to ensure the string life extends the\n                               // life of function\n\n    snprintf(vec_str, 99, \"vec(%s) = (%.3g)i + (%.3g)j + (%.3g)k\\n\", name, a->x,\n             a->y, a->z);\n    return vec_str;\n}\n\n/**\n * Compute the norm a vector.\n * @f[\\lVert\\vec{a}\\rVert = \\sqrt{\\vec{a}\\cdot\\vec{a}} @f]\n * @param[in] a input vector\n * @returns norm of the given vector\n */\nfloat vector_norm(const vec_3d *a)\n{\n    float n = dot_prod(a, a);\n#ifdef LIBQUAT_ARM\n    arm_sqrt_f32(*n, n);\n#else\n    n = sqrtf(n);\n#endif\n\n    return n;\n}\n\n/**\n * Obtain unit vector in the same direction as given vector.\n * @f[\\hat{a}=\\frac{\\vec{a}}{\\lVert\\vec{a}\\rVert}@f]\n * @param[in] a input vector\n * @returns n unit vector in the direction of @f$\\vec{a}@f$\n */\nvec_3d unit_vec(const vec_3d *a)\n{\n    vec_3d n = {0};\n\n    float norm = vector_norm(a);\n    if (fabsf(norm) < EPSILON)\n    {  // detect possible divide by 0\n        return n;\n    }\n\n    if (norm != 1.F)  // perform division only if needed\n    {\n        n.x = a->x / norm;\n        n.y = a->y / norm;\n        n.z = a->z / norm;\n    }\n    return n;\n}\n\n/**\n * The cross product of vectors can be represented as a matrix\n * multiplication operation. This function obtains the `3x3` matrix\n * of the cross-product operator from the first vector.\n * @f[\\begin{align*}\n * \\left(\\vec{a}\\times\\right)\\vec{b} &= \\tilde{A}_a\\vec{b}\\\\\n * \\tilde{A}_a &=\n * \\begin{bmatrix}0&-a_z&a_y\\\\a_z&0&-a_x\\\\-a_y&a_x&0\\end{bmatrix}\n * \\end{align*}@f]\n * @param[in] a input vector\n * @returns the `3x3` matrix for the cross product operator\n * @f$\\left(\\vec{a}\\times\\right)@f$\n */\nmat_3x3 get_cross_matrix(const vec_3d *a)\n{\n    mat_3x3 A = {0., -a->z, a->y, a->z, 0., -a->x, -a->y, a->x, 0.};\n    return A;\n}\n\n/** @} */\n\n/**\n * @brief Testing function\n * @returns `void`\n */\nstatic void test()\n{\n    vec_3d a = {1., 2., 3.};\n    vec_3d b = {1., 1., 1.};\n    float d;\n\n    // printf(\"%s\", print_vector(&a, \"a\"));\n    // printf(\"%s\", print_vector(&b, \"b\"));\n\n    d = vector_norm(&a);\n    // printf(\"|a| = %.4g\\n\", d);\n    assert(fabsf(d - 3.742f) < 0.01);\n    d = vector_norm(&b);\n    // printf(\"|b| = %.4g\\n\", d);\n    assert(fabsf(d - 1.732f) < 0.01);\n\n    d = dot_prod(&a, &b);\n    // printf(\"Dot product: %f\\n\", d);\n    assert(fabsf(d - 6.f) < 0.01);\n\n    vec_3d c = vector_prod(&a, &b);\n    // printf(\"Vector product \");\n    // printf(\"%s\", print_vector(&c, \"c\"));\n    assert(fabsf(c.x - (-1.f)) < 0.01);\n    assert(fabsf(c.y - (2.f)) < 0.01);\n    assert(fabsf(c.z - (-1.f)) < 0.01);\n}\n\n/**\n * @brief Main function\n *\n * @return 0 on exit\n */\nint main(void)\n{\n    test();\n\n    return 0;\n}\n","index":110},{"title":"Graphics","category":null,"id":"graphics","index":111},{"title":"Spirograph","category":"graphics","id":"spirograph_graphics","algorithm":"/**\n * @file\n * @author [Krishna Vedala](https://github.com/kvedala)\n * @brief Implementation of\n * [Spirograph](https://en.wikipedia.org/wiki/Spirograph)\n *\n * @details\n * Implementation of the program is based on the geometry shown in the figure\n * below:\n *\n * <a\n * href=\"https://commons.wikimedia.org/wiki/File:Resonance_Cascade.svg\"><img\n * src=\"https://upload.wikimedia.org/wikipedia/commons/3/39/Resonance_Cascade.svg\"\n * alt=\"Spirograph geometry from Wikipedia\" style=\"width: 250px\"/></a>\n */\n#define _USE_MATH_DEFINES /**< required for MSVC compiler */\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n/** Generate spirograph curve into arrays `x` and `y` such that the i^th point\n * in 2D is represented by `(x[i],y[i])`. The generating function is given by:\n * \\f{eqnarray*}{\n * x &=& R\\left[ (1-k) \\cos (t) + l\\cdot k\\cdot\\cos \\left(\\frac{1-k}{k}t\\right)\n * \\right]\\\\\n * y &=& R\\left[ (1-k) \\sin (t) - l\\cdot k\\cdot\\sin \\left(\\frac{1-k}{k}t\\right)\n * \\right] \\f}\n * where\n * * \\f$R\\f$ is the scaling parameter that we will consider \\f$=1\\f$\n * * \\f$l=\\frac{\\rho}{r}\\f$ is the relative distance of marker from the centre\n * of inner circle and \\f$0\\le l\\le1\\f$\n * * \\f$\\rho\\f$ is physical distance of marker from centre of inner circle\n * * \\f$r\\f$ is the radius of inner circle\n * * \\f$k=\\frac{r}{R}\\f$ is the ratio of radius of inner circle to outer circle\n * and \\f$0<k<1\\f$\n * * \\f$R\\f$ is the radius of outer circle\n * * \\f$t\\f$ is the angle of rotation of the point i.e., represents the time\n * parameter\n *\n * Since we are considering ratios, the actual values of \\f$r\\f$ and\n * \\f$R\\f$ are immaterial.\n *\n * @param [out] x output array containing absicca of points (must be\n * pre-allocated)\n * @param [out] y output array containing ordinates of points (must be\n * pre-allocated)\n * @param l the relative distance of marker from the centre of\n * inner circle and \\f$0\\le l\\le1\\f$\n * @param k the ratio of radius of inner circle to outer circle and\n * \\f$0<k<1\\f$\n * @param N number of sample points along the trajectory (higher = better\n * resolution but consumes more time and memory)\n * @param num_rot the number of rotations to perform (can be fractional value)\n */\nvoid spirograph(double *x, double *y, double l, double k, size_t N, double rot)\n{\n    double dt = rot * 2.f * M_PI / N;\n    double t = 0.f, R = 1.f;\n    const double k1 = 1.f - k;\n\n    for (size_t dk = 0; dk < N; dk++, t += dt)\n    {\n        x[dk] = R * (k1 * cos(t) + l * k * cos(k1 * t / k));\n        y[dk] = R * (k1 * sin(t) - l * k * sin(k1 * t / k));\n    }\n}\n\n/**\n * @brief Test function to save resulting points to a CSV file.\n *\n */\nvoid test(void)\n{\n    size_t N = 500;\n    double l = 0.3, k = 0.75, rot = 10.;\n    char fname[50];\n    snprintf(fname, 50, \"spirograph_%.2f_%.2f_%.2f.csv\", l, k, rot);\n    FILE *fp = fopen(fname, \"wt\");\n    if (!fp)\n    {\n        perror(fname);\n        exit(EXIT_FAILURE);\n    }\n\n    double *x = (double *)malloc(N * sizeof(double));\n    double *y = (double *)malloc(N * sizeof(double));\n\n    spirograph(x, y, l, k, N, rot);\n\n    for (size_t i = 0; i < N; i++)\n    {\n        fprintf(fp, \"%.5g, %.5g\", x[i], y[i]);\n        if (i < N - 1)\n        {\n            fputc('\\n', fp);\n        }\n    }\n\n    fclose(fp);\n\n    free(x);\n    free(y);\n}\n\n#ifdef USE_GLUT  // this is set by CMAKE automatically, if available\n#ifdef __APPLE__\n#include <GLUT/glut.h>  // include path on Macs is different\n#else\n#include <GL/glut.h>\n#endif\n\nstatic bool paused = 0; /**< flag to set pause/unpause animation */\nstatic const int animation_speed = 25; /**< animation delate in ms */\n\nstatic const double step = 0.01;   /**< animation step size */\nstatic double l_ratio = 0.1;       /**< the l-ratio defined in docs */\nstatic double k_ratio = 0.1;       /**< the k-ratio defined in docs */\nstatic const double num_rot = 20.; /**< number of rotations to simulate */\n\n/** A wrapper that is not available in all GLUT implementations.\n */\nstatic inline void glutBitmapString(void *font, char *string)\n{\n    for (char *ch = string; *ch != '\\0'; ch++) glutBitmapCharacter(font, *ch);\n}\n\n/**\n * @brief Function to graph (x,y) points on the OpenGL graphics window.\n *\n * @param x array containing absicca of points (must be pre-allocated)\n * @param y array containing ordinates of points (must be pre-allocated)\n * @param N number of points in the the arrays\n */\nvoid display_graph(const double *x, const double *y, size_t N, double l,\n                   double k)\n{\n    glClearColor(1.0f, 1.0f, 1.0f,\n                 0.0f);            // Set background color to white and opaque\n    glClear(GL_COLOR_BUFFER_BIT);  // Clear the color buffer (background)\n\n    if (x && y)\n    {\n        glBegin(GL_LINES);         // draw line segments\n        glColor3f(0.f, 0.f, 1.f);  // blue\n        glPointSize(2.f);          // point size in pixels\n\n        for (size_t i = 1; i < N; i++)\n        {\n            glVertex2f(x[i - 1], y[i - 1]);  // line from\n            glVertex2f(x[i], y[i]);          // line to\n        }\n        glEnd();\n    }\n    glColor3f(0.f, 0.f, 0.f);\n    char buffer[20];\n    snprintf(buffer, 20, \"l = %.3f\", l);\n    glRasterPos2f(-.85, .85);\n    glutBitmapString(GLUT_BITMAP_HELVETICA_18, buffer);\n    snprintf(buffer, 20, \"k = %.3f\", k);\n    glRasterPos2f(-.85, .75);\n    glutBitmapString(GLUT_BITMAP_HELVETICA_18, buffer);\n\n    glutSwapBuffers();\n}\n\n/**\n * @brief Test function with animation\n *\n */\nvoid test2(void)\n{\n    const size_t N = 1000;  // number of samples\n\n    static bool direction1 = true;  // increment if true, otherwise decrement\n    static bool direction2 = true;  // increment if true, otherwise decrement\n\n    double *x = (double *)malloc(N * sizeof(double));\n    double *y = (double *)malloc(N * sizeof(double));\n\n    spirograph(x, y, l_ratio, k_ratio, N, num_rot);\n    display_graph(x, y, N, l_ratio, k_ratio);\n\n    free(x);  // free dynamic memories\n    free(y);\n\n    if (paused)\n        // if paused, do not update l_ratio and k_ratio\n        return;\n\n    if (direction1)  // increment k_ratio\n    {\n        if (k_ratio >= (1.f - step))  // maximum limit\n            direction1 = false;       // reverse direction of k_ratio\n        else\n            k_ratio += step;\n    }\n    else  // decrement k_ratio\n    {\n        if (k_ratio <= step)  // minimum limit\n        {\n            direction1 = true;  // reverse direction of k_ratio\n\n            if (direction2)  // increment l_ratio\n            {\n                if (l_ratio >= (1.f - step))  // max limit of l_ratio\n                    direction2 = false;       // reverse direction of l_ratio\n                else\n                    l_ratio += step;\n            }\n            else  // decrement l_ratio\n            {\n                if (l_ratio <= step)    // minimum limit of l_ratio\n                    direction2 = true;  // reverse direction of l_ratio\n                else\n                    l_ratio -= step;\n            }\n        }\n        else  // no min limit of k_ratio\n            k_ratio -= step;\n    }\n}\n\n/**\n * @brief GLUT timer callback function to add animation delay.\n */\nvoid timer_cb(int id)\n{\n    glutPostRedisplay();\n    glutTimerFunc(animation_speed, timer_cb, 0);\n}\n\n/**\n * @brief Keypress event call back function.\n *\n * @param key ID of the key pressed\n * @param x mouse pointer position at event\n * @param y mouse pointer position at event\n */\nvoid keyboard_cb(unsigned char key, int x, int y)\n{\n    switch (key)\n    {\n    case ' ':              // spacebar toggles pause\n        paused = !paused;  // toggle\n        break;\n    case '+':  // up arrow key\n        k_ratio += step;\n        display_graph(NULL, NULL, 1, l_ratio, k_ratio);\n        break;\n    case '_':  // down arrow key\n        k_ratio -= step;\n        display_graph(NULL, NULL, 1, l_ratio, k_ratio);\n        break;\n    case '=':  // left arrow key\n        l_ratio += step;\n        display_graph(NULL, NULL, 1, l_ratio, k_ratio);\n        break;\n    case '-':  // right arrow key\n        l_ratio -= step;\n        display_graph(NULL, NULL, 1, l_ratio, k_ratio);\n        break;\n    case 0x1B:  // escape key exits\n        exit(EXIT_SUCCESS);\n    }\n}\n#endif\n\n/** Main function */\nint main(int argc, char **argv)\n{\n    test();\n\n#ifdef USE_GLUT\n    glutInit(&argc, argv);\n    glutInitDisplayMode(GLUT_RGB | GLUT_DOUBLE);\n    glutCreateWindow(\"Spirograph\");\n    glutInitWindowSize(400, 400);\n    // glutIdleFunc(glutPostRedisplay);\n    glutTimerFunc(animation_speed, timer_cb, 0);\n    glutKeyboardFunc(keyboard_cb);\n    glutDisplayFunc(test2);\n    glutMainLoop();\n#endif\n\n    return 0;\n}\n","index":112},{"title":"Greedy Approach","category":null,"id":"greedy_approach","index":113},{"title":"Djikstra","category":"greedy_approach","id":"djikstra_greedy_approach","algorithm":"#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 20\n#define INF 999\n\nint mat[MAX][MAX];\nint V;\n\nint dist[MAX];\n\nint q[MAX];\nint qp = 0;\n\nvoid enqueue(int v) { q[qp++] = v; }\n\nint cf(void *a, void *b)\n{\n    int *x = (int *)a;\n    int *y = (int *)b;\n    return *y - *x;\n}\n\nint dequeue()\n{\n    qsort(q, qp, sizeof(int), cf);\n    return q[--qp];\n}\n\nint queue_has_something() { return (qp > 0); }\n\nint visited[MAX];\nint vp = 0;\n\nvoid dijkstra(int s)\n{\n    dist[s] = 0;\n    int i;\n    for (i = 0; i < V; ++i)\n    {\n        if (i != s)\n        {\n            dist[i] = INF;\n        }\n        enqueue(i);\n    }\n    while (queue_has_something())\n    {\n        int u = dequeue();\n        visited[vp++] = u;\n        for (i = 0; i < V; ++i)\n        {\n            if (mat[u][i])\n            {\n                if (dist[i] > dist[u] + mat[u][i])\n                {\n                    dist[i] = dist[u] + mat[u][i];\n                }\n            }\n        }\n    }\n}\n\nint main(int argc, char const *argv[])\n{\n    printf(\"Enter the number of vertices: \");\n    scanf(\" %d\", &V);\n    printf(\"Enter the adj matrix: \");\n    int i, j;\n    for (i = 0; i < V; ++i)\n    {\n        for (j = 0; j < V; ++j)\n        {\n            scanf(\" %d\", &mat[i][j]);\n        }\n    }\n\n    dijkstra(0);\n\n    printf(\"\\nNode\\tDist\\n\");\n    for (i = 0; i < V; ++i)\n    {\n        printf(\"%d\\t%d\\n\", i, dist[i]);\n    }\n\n    return 0;\n}\n","index":114},{"title":"Hash","category":null,"id":"hash","index":115},{"title":"Hash Adler32","category":"hash","id":"hash_adler32_hash","algorithm":"/**\n * @addtogroup hash Hash algorithms\n * @{\n * @file hash_adler32.c\n * @author [Christian Bender](https://github.com/christianbender)\n * @brief 32-bit [Adler hash](https://en.wikipedia.org/wiki/Adler-32) algorithm\n */\n#include <assert.h>\n#include <inttypes.h>\n#include <stdio.h>\n\n/**\n * @brief 32-bit Adler algorithm implementation\n *\n * @param s NULL terminated ASCII string to hash\n * @return 32-bit hash result\n */\nuint32_t adler32(const char* s)\n{\n    uint32_t a = 1;\n    uint32_t b = 0;\n    const uint32_t MODADLER = 65521;\n\n    size_t i = 0;\n    while (s[i] != '\\0')\n    {\n        a = (a + s[i]) % MODADLER;\n        b = (b + a) % MODADLER;\n        i++;\n    }\n    return (b << 16) | a;\n}\n\n/**\n * @brief Test function for ::adler32\n * \\returns None\n */\nvoid test_adler32()\n{\n    assert(adler32(\"Hello World\") == 403375133);\n    assert(adler32(\"Hello World!\") == 474547262);\n    assert(adler32(\"Hello world\") == 413860925);\n    assert(adler32(\"Hello world!\") == 487130206);\n    printf(\"Tests passed\\n\");\n}\n\n/** @} */\n\n/** Main function */\nint main()\n{\n    test_adler32();\n    return 0;\n}\n","index":116},{"title":"Hash Crc32","category":"hash","id":"hash_crc32_hash","algorithm":"/**\n * @addtogroup hash Hash algorithms\n * @{\n * @file hash_crc32.c\n * @author [Christian Bender](https://github.com/christianbender)\n * @brief 32-bit [CRC\n * hash](https://en.wikipedia.org/wiki/Cyclic_redundancy_check#CRC-32_algorithm)\n * algorithm\n */\n#include <assert.h>\n#include <inttypes.h>\n#include <stdio.h>\n\n/**\n * @brief 32-bit CRC algorithm implementation\n *\n * @param s NULL terminated ASCII string to hash\n * @return 32-bit hash result\n */\nuint32_t crc32(const char* s)\n{\n    uint32_t crc = 0xffffffff;\n    size_t i = 0;\n    while (s[i] != '\\0')\n    {\n        uint8_t byte = s[i];\n        crc = crc ^ byte;\n        for (uint8_t j = 8; j > 0; --j)\n        {\n            crc = (crc >> 1) ^ (0xEDB88320 & (-(crc & 1)));\n        }\n\n        i++;\n    }\n    return crc ^ 0xffffffff;\n}\n\n/**\n * @brief Test function for ::crc32\n * \\returns None\n */\nvoid test_crc32()\n{\n    assert(crc32(\"Hello World\") == 1243066710);\n    assert(crc32(\"Hello World!\") == 472456355);\n    assert(crc32(\"Hello world\") == 2346098258);\n    assert(crc32(\"Hello world!\") == 461707669);\n    // printf(\"%\" PRIu32 \"\\n\", crc32(\"Hello World\"));\n    // printf(\"%\" PRIu32 \"\\n\", crc32(\"Hello World!\"));\n    // printf(\"%\" PRIu32 \"\\n\", crc32(\"Hello world\"));\n    // printf(\"%\" PRIX32 \"\\n\", crc32(\"Hello world!\"));\n    printf(\"Tests passed\\n\");\n}\n\n/** @} */\n\n/** Main function */\nint main()\n{\n    test_crc32();\n    return 0;\n}\n","index":117},{"title":"Hash Djb2","category":"hash","id":"hash_djb2_hash","algorithm":"/**\n * @addtogroup hash Hash algorithms\n * @{\n * @file hash_djb2.c\n * @author [Christian Bender](https://github.com/christianbender)\n * @brief [DJB2 hash algorithm](http://www.cse.yorku.ca/~oz/hash.html)\n */\n#include <assert.h>\n#include <inttypes.h>\n#include <stdio.h>\n\n/**\n * @brief DJB2 algorithm implementation\n *\n * @param s NULL terminated string to hash\n * @return 64-bit hash result\n */\nuint64_t djb2(const char* s)\n{\n    uint64_t hash = 5381; /* init value */\n    size_t i = 0;\n    while (s[i] != '\\0')\n    {\n        hash = ((hash << 5) + hash) + s[i];\n        i++;\n    }\n    return hash;\n}\n\n/**\n * Test function for ::djb2\n * \\returns none\n */\nvoid test_djb2(void)\n{\n    assert(djb2(\"Hello World\") == 13827776004929097857);\n    assert(djb2(\"Hello World!\") == 13594750393630990530);\n    assert(djb2(\"Hello world\") == 13827776004967047329);\n    assert(djb2(\"Hello world!\") == 13594750394883323106);\n    printf(\"Tests passed\\n\");\n}\n\n/** @} */\n\n/** Main function */\nint main()\n{\n    test_djb2();\n    return 0;\n}\n","index":118},{"title":"Hash Sdbm","category":"hash","id":"hash_sdbm_hash","algorithm":"/**\n * @addtogroup hash Hash algorithms\n * @{\n * @file hash_sdbm.c\n * @author [Christian Bender](https://github.com/christianbender)\n * @brief [SDBM hash algorithm](http://www.cse.yorku.ca/~oz/hash.html)\n */\n#include <assert.h>\n#include <inttypes.h>\n#include <stdio.h>\n\n/**\n * @brief SDBM algorithm implementation\n *\n * @param s NULL terminated string to hash\n * @return 64-bit hash result\n */\nuint64_t sdbm(const char* s)\n{\n    uint64_t hash = 0;\n    size_t i = 0;\n    while (s[i] != '\\0')\n    {\n        hash = s[i] + (hash << 6) + (hash << 16) - hash;\n        i++;\n    }\n    return hash;\n}\n\n/**\n * @brief Test function for ::sdbm\n * \\returns None\n */\nvoid test_sdbm()\n{\n    assert(sdbm(\"Hello World\") == 12881824461405877380);\n    assert(sdbm(\"Hello World!\") == 7903571203300273309);\n    assert(sdbm(\"Hello world\") == 15154913742888948900);\n    assert(sdbm(\"Hello world!\") == 15254999417003201661);\n    printf(\"Tests passed\\n\");\n}\n\n/** @} */\n\n/** Main function */\nint main()\n{\n    test_sdbm();\n    return 0;\n}\n","index":119},{"title":"Hash Xor8","category":"hash","id":"hash_xor8_hash","algorithm":"/**\n * @addtogroup hash Hash algorithms\n * @{\n * @file hash_xor8.c\n * @author [Christian Bender](https://github.com/christianbender)\n * @brief 8-bit [XOR hash](https://en.wikipedia.org/wiki/XOR_cipher) algorithm\n * for ASCII characters\n */\n#include <assert.h>\n#include <inttypes.h>\n#include <stdio.h>\n\n/**\n * @brief 8-bit XOR algorithm implementation\n *\n * @param s NULL terminated ASCII string to hash\n * @return 8-bit hash result\n */\nuint8_t xor8(const char* s)\n{\n    uint8_t hash = 0;\n    size_t i = 0;\n    while (s[i] != '\\0')\n    {\n        hash = (hash + s[i]) & 0xff;\n        i++;\n    }\n    return (((hash ^ 0xff) + 1) & 0xff);\n}\n\n/**\n * @brief Test function for ::xor8\n * \\returns None\n */\nvoid test_xor8()\n{\n    assert(xor8(\"Hello World\") == 228);\n    assert(xor8(\"Hello World!\") == 195);\n    assert(xor8(\"Hello world\") == 196);\n    assert(xor8(\"Hello world!\") == 163);\n    printf(\"Tests passed\\n\");\n}\n\n/** @} */\n\n/** Main function */\nint main()\n{\n    test_xor8();\n    return 0;\n}\n","index":120},{"title":"Leetcode","category":null,"id":"leetcode","index":121},{"title":"Src","category":"leetcode","id":"src","index":122},{"title":"1","category":"src","id":"1_src","algorithm":"int *twoSum(int *nums, int numsSize, int target, int *returnSize)\n{\n    int i, j;\n    int *ret = calloc(2, sizeof(int));\n    for (i = 0; i < numsSize; i++)\n    {\n        int key = target - nums[i];\n        for (j = i + 1; j < numsSize; j++)\n            if (nums[j] == key)\n            {\n                ret[0] = i;\n                ret[1] = j;\n            }\n    }\n    *returnSize = 2;\n    return ret;\n}\n","index":123},{"title":"101","category":"src","id":"101_src","algorithm":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\nbool checkSymmetric(struct TreeNode *left, struct TreeNode *right)\n{\n    if (!left || !right)\n        return left == right;\n    if (left->val != right->val)\n        return 0;\n    return checkSymmetric(left->left, right->right) &&\n           checkSymmetric(left->right, right->left);\n}\n\nbool isSymmetric(struct TreeNode *root)\n{\n    return root == NULL || checkSymmetric(root->left, root->right);\n}\n","index":124},{"title":"104","category":"src","id":"104_src","algorithm":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\nint maxval(int a, int b)\n{\n    if (a > b)\n        return a;\n    else\n        return b;\n}\nint maxDepth(struct TreeNode *root)\n{\n    if (root == NULL)\n        return 0;\n    else\n        return 1 + maxval(maxDepth(root->left), maxDepth(root->right));\n}\n","index":125},{"title":"108","category":"src","id":"108_src","algorithm":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\nstruct TreeNode *convertBST(int *nums, int left, int right)\n{\n    if (left > right)\n        return NULL;\n    else\n    {\n        int mid = (right + left) / 2;\n        struct TreeNode *new_val = malloc(sizeof(struct TreeNode));\n        new_val->val = nums[mid];\n        new_val->left = convertBST(nums, left, mid - 1);\n        new_val->right = convertBST(nums, mid + 1, right);\n        return new_val;\n    }\n}\n\nstruct TreeNode *sortedArrayToBST(int *nums, int numsSize)\n{\n    if (numsSize == 0)\n        return NULL;\n    else\n        return convertBST(nums, 0, numsSize - 1);\n}\n","index":126},{"title":"1089","category":"src","id":"1089_src","algorithm":"void duplicateZeros(int *arr, int arrSize)\n{\n    int i, start = 0;\n    int *tmp = malloc(arrSize * sizeof(int));\n    /* Copy arr into tmp arr */\n    for (i = 0; i < arrSize; i++)\n    {\n        tmp[i] = arr[i];\n    }\n    i = 0;\n    for (start = 0; start < arrSize; start++)\n    {\n        arr[start] = tmp[i];\n        if (tmp[i] == 0)\n        {\n            start++;\n            if (start < arrSize)\n                arr[start] = 0;\n        }\n        i++;\n    }\n}\n","index":127},{"title":"109","category":"src","id":"109_src","algorithm":"struct TreeNode *buildBST(struct ListNode *head, struct ListNode *tail)\n{\n    if (head == tail)\n        return NULL;\n    struct ListNode *slow = head, *fast = head;\n    while (fast != tail && fast->next != tail)\n    {\n        fast = fast->next->next;\n        slow = slow->next;\n    }\n    struct TreeNode *node = malloc(sizeof(struct TreeNode));\n    node->val = slow->val;\n    node->left = buildBST(head, slow);\n    node->right = buildBST(slow->next, tail);\n    return node;\n}\nstruct TreeNode *sortedListToBST(struct ListNode *head)\n{\n    if (!head)\n        return NULL;\n    else\n        return buildBST(head, NULL);\n}\n","index":128},{"title":"11","category":"src","id":"11_src","algorithm":"// Fucntion to calculate min of values a and b\nint min(int a, int b) { return ((a < b) ? a : b); }\n\n// Two pointer approach to find maximum container area\nint maxArea(int *height, int heightSize)\n{\n    // Start with maximum container width\n    int start = 0;\n    int end = heightSize - 1;\n    int res = 0;\n\n    while (start < end)\n    {\n        // Calculate current area by taking minimum of two heights\n        int currArea = (end - start) * min(height[start], height[end]);\n\n        if (currArea > res)\n            res = currArea;\n\n        if (height[start] < height[end])\n            start = start + 1;\n        else\n            end = end - 1;\n    }\n\n    return res;\n}\n","index":129},{"title":"110","category":"src","id":"110_src","algorithm":"int max(int a, int b) { return a >= b ? a : b; }\n\nint height(struct TreeNode *root)\n{\n    if (root == NULL)\n        return 0;\n    else\n        return 1 + max(height(root->left), height(root->right));\n}\n\nbool isBalanced(struct TreeNode *root)\n{\n    if (root == NULL)\n        return 1;\n    int left = height(root->left);\n    int right = height(root->right);\n    return abs(left - right) <= 1 && isBalanced(root->left) &&\n           isBalanced(root->right);\n}\n","index":130},{"title":"112","category":"src","id":"112_src","algorithm":"bool hasPathSum(struct TreeNode *root, int sum)\n{\n    if (root == NULL)\n        return 0;\n    if (!root->left && !root->right && sum - root->val == 0)\n        return 1;\n    return hasPathSum(root->left, sum - root->val) ||\n           hasPathSum(root->right, sum - root->val);\n}\n","index":131},{"title":"1184","category":"src","id":"1184_src","algorithm":"int distanceBetweenBusStops(int *distance, int distanceSize, int start,\n                            int destination)\n{\n    int sum1 = 0, sum2 = 0;\n    if (start > destination)\n    {\n        int tmp = start;\n        start = destination;\n        destination = tmp;\n    }\n    for (auto i = 0; i < distanceSize; ++i)\n    {\n        if (i >= start && i < destination)\n            sum1 += distance[i];\n        else\n            sum2 += distance[i];\n    }\n    return sum1 < sum2 ? sum1 : sum2;\n}\n","index":132},{"title":"1189","category":"src","id":"1189_src","algorithm":"int maxNumberOfBalloons(char *text)\n{\n    /*\n        0 -> b,\n        1 -> a,\n        2 -> l,\n        3 -> o,\n        4 -> n\n    */\n    int count_letters[5] = {0};\n    int i, min_counter_ballons;\n\n    for (char *ptr = text; *ptr; ptr++)\n    {\n        if (*ptr == 'b')\n        {\n            count_letters[0]++;\n        }\n        else if (*ptr == 'a')\n        {\n            count_letters[1]++;\n        }\n        else if (*ptr == 'l')\n        {\n            count_letters[2]++;\n        }\n        else if (*ptr == 'o')\n        {\n            count_letters[3]++;\n        }\n        else if (*ptr == 'n')\n        {\n            count_letters[4]++;\n        }\n    }\n\n    /* Divide by 2 the repeted letters */\n    count_letters[2] /= 2;\n    count_letters[3] /= 2;\n\n    /* Max number of times which we can write ballon is equal to min value of\n     * letters on count_letter */\n    min_counter_ballons = count_letters[0];\n    for (i = 1; i < 5; i++)\n    {\n        if (count_letters[i] < min_counter_ballons)\n            min_counter_ballons = count_letters[i];\n    }\n\n    return min_counter_ballons;\n}\n","index":133},{"title":"12","category":"src","id":"12_src","algorithm":"char *getOne(char c)\n{\n    switch (c)\n    {\n    case '9':\n        return \"IX\";\n\n    case '8':\n        return \"VIII\";\n\n    case '7':\n        return \"VII\";\n\n    case '6':\n        return \"VI\";\n\n    case '5':\n        return \"V\";\n\n    case '4':\n        return \"IV\";\n\n    case '3':\n        return \"III\";\n\n    case '2':\n        return \"II\";\n\n    case '1':\n        return \"I\";\n\n    case '0':\n        return \"\";\n\n    default:\n        return NULL;\n    }\n}\n\nchar *getTen(char c)\n{\n    switch (c)\n    {\n    case '9':\n        return \"XC\";\n\n    case '8':\n        return \"LXXX\";\n\n    case '7':\n        return \"LXX\";\n\n    case '6':\n        return \"LX\";\n\n    case '5':\n        return \"L\";\n\n    case '4':\n        return \"XL\";\n\n    case '3':\n        return \"XXX\";\n\n    case '2':\n        return \"XX\";\n\n    case '1':\n        return \"X\";\n\n    case '0':\n        return \"\";\n\n    default:\n        return NULL;\n    }\n}\n\nchar *getHundred(char c)\n{\n    switch (c)\n    {\n    case '9':\n        return \"CM\";\n\n    case '8':\n        return \"DCCC\";\n\n    case '7':\n        return \"DCC\";\n\n    case '6':\n        return \"DC\";\n\n    case '5':\n        return \"D\";\n\n    case '4':\n        return \"CD\";\n\n    case '3':\n        return \"CCC\";\n\n    case '2':\n        return \"CC\";\n\n    case '1':\n        return \"C\";\n\n    case '0':\n        return \"\";\n\n    default:\n        return NULL;\n    }\n}\n\nchar *getThousand(char c)\n{\n    switch (c)\n    {\n    case '3':\n        return \"MMM\";\n\n    case '2':\n        return \"MM\";\n\n    case '1':\n        return \"M\";\n\n    default:\n        return NULL;\n    }\n}\n\nchar *intToRoman(int num)\n{\n    int length;\n    char number[5];\n    char *s = malloc(16 * sizeof(char));\n\n    sprintf(number, \"%i\", num);\n\n    length = strlen(number);\n\n    switch (length)\n    {\n    case 4:\n        sprintf(s, \"%s%s%s%s\", getThousand(number[0]), getHundred(number[1]),\n                getTen(number[2]), getOne(number[3]));\n        break;\n\n    case 3:\n        sprintf(s, \"%s%s%s\", getHundred(number[0]), getTen(number[1]),\n                getOne(number[2]));\n\n        break;\n\n    case 2:\n        sprintf(s, \"%s%s\", getTen(number[0]), getOne(number[1]));\n\n        break;\n\n    case 1:\n        s = getOne(number[0]);\n        break;\n\n    default:\n        break;\n    }\n    return s;\n}\n","index":134},{"title":"1207","category":"src","id":"1207_src","algorithm":"#define MAP_SIZE 2048\n\nint cmpvalue(const void *a, const void *b) { return *(int *)b - *(int *)a; }\nbool uniqueOccurrences(int *arr, int arrSize)\n{\n    int *map = calloc(MAP_SIZE, sizeof(int));\n    int i;\n    for (i = 0; i < arrSize; i++)\n    {\n        if (arr[i] < 0)\n            map[arr[i] + MAP_SIZE / 2] += 1;\n        else\n            map[arr[i]] += 1;\n    }\n    /* number of occurrences is sorted by decreasing order\n       Ex: 3 2 1 0 0 0 0 */\n    qsort(map, MAP_SIZE, sizeof(int), cmpvalue);\n    i = 0;\n    while (map[i])\n    {\n        if (map[i] == map[i + 1])\n            return 0;\n        i++;\n    }\n    return 1;\n}\n","index":135},{"title":"121","category":"src","id":"121_src","algorithm":"int maxcmp(int a, int b) { return (a >= b) ? a : b; }\n\n/* max subarray problem by using Kadane's Algorithm\n */\nint maxProfit(int *prices, int pricesSize)\n{\n    /* maxCur: current maximum\n     * maxSoFar: found maximum for subarray so far\n     */\n    int maxCur = 0, maxSoFar = 0;\n    for (int i = 1; i < pricesSize; i++)\n    {\n        maxCur = maxcmp(0, maxCur + prices[i] - prices[i - 1]);\n        maxSoFar = maxcmp(maxSoFar, maxCur);\n    }\n    return maxSoFar;\n}\n","index":136},{"title":"125","category":"src","id":"125_src","algorithm":"bool isPalindrome(char *s)\n{\n    int start = 0, end = strlen(s) - 1;\n    while (start < end)\n    {\n        if (!isalpha(s[start]) && !isalnum(s[start]))\n        {\n            start++;\n        }\n        else if (!isalpha(s[end]) && !isalnum(s[end]))\n        {\n            end--;\n        }\n        else\n        {\n            char c1 = tolower(s[start]);\n            char c2 = tolower(s[end]);\n            if (c1 != c2)\n                return 0;\n            start++;\n            end--;\n        }\n    }\n    return 1;\n}\n","index":137},{"title":"13","category":"src","id":"13_src","algorithm":"int romanToInt(char *s)\n{\n    int romanToInt = 0;\n    for (int i = 0; i < strlen(s); i++)\n    {\n        switch (s[i])\n        {\n        case 'I':\n            if (i + 1 < strlen(s))\n            {\n                if (s[i + 1] == 'V' || s[i + 1] == 'X')\n                {\n                    romanToInt -= 1;\n                    break;\n                }\n            }\n            romanToInt += 1;\n            break;\n        case 'V':\n            romanToInt += 5;\n            break;\n        case 'X':\n            if (i + 1 < strlen(s))\n            {\n                if (s[i + 1] == 'L' || s[i + 1] == 'C')\n                {\n                    romanToInt -= 10;\n                    break;\n                }\n            }\n            romanToInt += 10;\n            break;\n        case 'L':\n            romanToInt += 50;\n            break;\n        case 'C':\n            if (i + 1 < strlen(s))\n            {\n                if (s[i + 1] == 'D' || s[i + 1] == 'M')\n                {\n                    romanToInt -= 100;\n                    break;\n                }\n            }\n            romanToInt += 100;\n            break;\n        case 'D':\n            romanToInt += 500;\n            break;\n        case 'M':\n            romanToInt += 1000;\n            break;\n        default:\n            break;\n        }\n    }\n    return romanToInt;\n}","index":138},{"title":"136","category":"src","id":"136_src","algorithm":"int singleNumber(int *nums, int numsSize)\n{\n    int i, result = 0;\n    for (i = 0; i < numsSize; i++) result = result ^ nums[i];\n    return result;\n}\n","index":139},{"title":"141","category":"src","id":"141_src","algorithm":"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nbool hasCycle(struct ListNode *head)\n{\n    struct ListNode *fast = head, *slow = head;\n    while (slow && fast && fast->next)\n    {\n        fast = fast->next->next;\n        slow = slow->next;\n        if (fast == slow)\n            return true;\n    }\n    return false;\n}\n","index":140},{"title":"142","category":"src","id":"142_src","algorithm":"struct ListNode *detectCycle(struct ListNode *head)\n{\n    if (head == NULL || head->next == NULL)\n        return NULL;\n    struct ListNode *slow, *fast;\n    slow = fast = head;\n    while (fast && fast->next)\n    {\n        slow = slow->next;\n        fast = fast->next->next;\n        if (slow == fast)\n        {\n            struct ListNode *entry = head;\n            while (slow != entry)\n            {\n                slow = slow->next;\n                entry = entry->next;\n            }\n            return entry;\n        }\n    }\n    return NULL;\n}\n","index":141},{"title":"153","category":"src","id":"153_src","algorithm":"int findMin(int *nums, int numsSize)\n{\n    int low = 0, high = numsSize - 1;\n    while (low < high)\n    {\n        int mid = low + (high - low) / 2;\n        /* minimum is on left side */\n        if (nums[mid] < nums[high])\n            high = mid;\n        /* minimum is on right side */\n        else\n            low = mid + 1;\n    }\n    return nums[low];\n}\n","index":142},{"title":"160","category":"src","id":"160_src","algorithm":"struct ListNode *getIntersectionNode(struct ListNode *headA,\n                                     struct ListNode *headB)\n{\n    struct ListNode *cur1 = headA, *cur2 = headB;\n    if (cur1 == NULL || cur2 == NULL)\n        return NULL;\n    while (cur1 && cur2 && cur1 != cur2)\n    {\n        cur1 = cur1->next;\n        cur2 = cur2->next;\n        if (cur1 == cur2)\n            return cur1;\n        if (!cur1)\n            cur1 = headB;\n        if (!cur2)\n            cur2 = headA;\n    }\n    return cur1;\n}\n","index":143},{"title":"169","category":"src","id":"169_src","algorithm":"/* Boyer-Moore Majority Vote Algorithm\n * http://www.cs.utexas.edu/~moore/best-ideas/mjrty/ */\nint majorityElement(int *nums, int numsSize)\n{\n    int count = 1;\n    int majorNum = nums[0];\n    for (int i = 1; i < numsSize; i++)\n    {\n        if (count == 0)\n        {\n            majorNum = nums[i];\n            count++;\n        }\n        else if (majorNum == nums[i])\n            count++;\n        else\n            count--;\n    }\n    return majorNum;\n}\n","index":144},{"title":"173","category":"src","id":"173_src","algorithm":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\n#include <limits.h>\n\ntypedef struct\n{\n    int *values;\n    int CurrentIndex;\n    int NumberOfNodes;\n} BSTIterator;\n\nvoid TraverseAndAssign(struct TreeNode *root, BSTIterator *obj)\n{\n    if (!root)\n        return;\n    if (root->left)\n        TraverseAndAssign(root->left, obj);\n    obj->values[obj->CurrentIndex] = root->val;\n    obj->CurrentIndex++;\n    if (root->right)\n        TraverseAndAssign(root->right, obj);\n}\n\nint TotalNodes(struct TreeNode *root)\n{\n    if (!root)\n        return 0;\n    int nodes_left = TotalNodes(root->left);\n    int nodes_right = TotalNodes(root->right);\n    return nodes_left + nodes_right + 1;\n}\n\nBSTIterator *bSTIteratorCreate(struct TreeNode *root)\n{\n    int n = TotalNodes(root);\n    int size = n + 1;\n    printf(\"%d\", size);\n    BSTIterator *obj = (BSTIterator *)malloc(sizeof(BSTIterator));\n    obj->values = (int *)calloc(size, sizeof(int));\n    obj->CurrentIndex = 0;\n    obj->NumberOfNodes = n;\n    obj->values[size - 1] = INT_MAX;\n    TraverseAndAssign(root, obj);\n    obj->CurrentIndex = 0;\n    return obj;\n}\n\n/** @return the next smallest number */\nint bSTIteratorNext(BSTIterator *obj)\n{\n    int NextValue = obj->values[obj->CurrentIndex];\n    obj->CurrentIndex++;\n    return NextValue;\n}\n\n/** @return whether we have a next smallest number */\nbool bSTIteratorHasNext(BSTIterator *obj)\n{\n    if (!obj->NumberOfNodes)\n    {\n        return false;\n    }\n    printf(\" Here \");\n    return (obj->values[obj->CurrentIndex] == INT_MAX) ? false : true;\n}\n\nvoid bSTIteratorFree(BSTIterator *obj)\n{\n    free(obj->values);\n    free(obj);\n}\n","index":145},{"title":"189","category":"src","id":"189_src","algorithm":"void rotate(int *nums, int numsSize, int k)\n{\n    for (int i = 1; i <= k; i++)\n    {\n        int j;\n        int lastElement;\n        lastElement = nums[numsSize - 1];\n        for (j = numsSize - 1; j > 0; j--)\n        {\n            nums[j] = nums[j - 1];\n        }\n        nums[0] = lastElement;\n    }\n}","index":146},{"title":"190","category":"src","id":"190_src","algorithm":"uint32_t reverseBits(uint32_t n)\n{\n    uint TotalBits = 32;\n    uint32_t reverse_int = 0;  // stored in memory as 32 bits, each bit valued 0\n    uint i;\n    for (i = 0; i < TotalBits; i++)\n    {\n        if ((n & (UINT32_C(1)\n                  << i)))  // if the bit on the ith position of 32 bit input is\n                           // 1, then proceed Further note the use of UINT32_C\n                           // to convert 1 to unsigned 32 bit int, since just 1\n                           // is treated as int which cannot be shifted left\n                           // more than 30 times\n            reverse_int =\n                reverse_int |\n                (UINT32_C(1)\n                 << (TotalBits - 1 -\n                     i));  // Convert the ith bit from the end in reverse_int\n                           // from 0 to 1, if ith bit from beginning in n is 1\n                           // This is achieved by using bitwise OR on\n                           // reverse_int (where ith bit from end is currently\n                           // 0) and 1 shifted left 31 - i bits (to ith bit from\n                           // the end)\n    }\n    return reverse_int;\n}","index":147},{"title":"191","category":"src","id":"191_src","algorithm":"int hammingWeight(uint32_t n)\n{\n    int TotalBits = 32;\n    int i, weight = 0;\n    for (i = 0; i < TotalBits; i++)\n    {\n        if (n &\n            (UINT32_C(1)\n             << i))  // if the bit on the ith position of 32 bit input is 1,\n                     // then proceed Further note the use of UINT32_C to\n                     // convert 1 to unsigned 32 bit int, as just 1 is treated\n                     // as int which cannot be shifted left more than 30 times\n            weight += 1;\n    }\n    return weight;\n}","index":148},{"title":"2","category":"src","id":"2_src","algorithm":"/*\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\n\nstruct ListNode *addTwoNumbers(struct ListNode *l1, struct ListNode *l2)\n{\n    struct ListNode *head = NULL;\n    struct ListNode *walk = NULL;\n    struct ListNode *tmp = NULL;\n\n    int carry = 0;\n    int val1 = 0;\n    int val2 = 0;\n    int val = 0;\n\n    while (l1 != NULL || l2 != NULL || carry)\n    {\n        val1 = 0;\n        val2 = 0;\n        val = 0;\n\n        if (l1)\n        {\n            val1 = l1->val;\n            l1 = l1->next;\n        }\n\n        if (l2)\n        {\n            val2 = l2->val;\n            l2 = l2->next;\n        }\n\n        val = carry + val1 + val2;\n        carry = val / 10;\n\n        tmp = malloc(sizeof(struct ListNode));\n        tmp->val = val % 10;\n        tmp->next = NULL;\n\n        if (!head)\n        {\n            head = walk = tmp;\n        }\n        else\n        {\n            walk->next = tmp;\n            walk = walk->next;\n        }\n    }\n\n    return head;\n}\n","index":149},{"title":"20","category":"src","id":"20_src","algorithm":"bool isValid(char *s)\n{\n    int i, k = 0, len = strlen(s);\n    char *store = calloc(len, sizeof(char));\n\n    for (i = 0; s[i] != '\\0'; i++)\n    {\n        switch (s[i])\n        {\n        case '(':\n        case '{':\n        case '[':\n            store[k++] = s[i];\n            break;\n        case ')':\n            if (k < 1 || store[--k] != '(')\n                goto out;\n            break;\n        case '}':\n            if (k < 1 || store[--k] != '{')\n                goto out;\n            break;\n        case ']':\n            if (k < 1 || store[--k] != '[')\n                goto out;\n            break;\n        }\n    }\nout:\n    free(store);\n    return s[i] == '\\0' && k == 0;\n}\n","index":150},{"title":"201","category":"src","id":"201_src","algorithm":"int rangeBitwiseAnd(int m, int n)\n{\n    while (m < n)\n    {\n        n &= n - 1;\n    }\n    return n;\n}","index":151},{"title":"203","category":"src","id":"203_src","algorithm":"struct ListNode *removeElements(struct ListNode *head, int val)\n{\n    if (head == NULL)\n        return NULL;\n    if (head->val == val)\n    {\n        return removeElements(head->next, val);\n    }\n    else\n    {\n        head->next = removeElements(head->next, val);\n    }\n    return head;\n}\n","index":152},{"title":"206","category":"src","id":"206_src","algorithm":"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\n\nstruct ListNode *reverseList(struct ListNode *head)\n{\n    struct ListNode *res = NULL;\n    while (head)\n    {\n        struct ListNode *pre_node = head;\n        head = head->next;\n        pre_node->next = res;\n        res = pre_node;\n    }\n    return res;\n}\n","index":153},{"title":"21","category":"src","id":"21_src","algorithm":"/*\n * Iterative approach\n */\nstruct ListNode *mergeTwoLists(struct ListNode *l1, struct ListNode *l2)\n{\n    struct ListNode *list = NULL;\n    struct ListNode *tmp = NULL;\n\n    if (!l1)\n        return l2;\n    if (!l2)\n        return l1;\n\n    if (l1 && l2)\n    {\n        if (l1->val < l2->val)\n        {\n            list = tmp = l1;\n            l1 = l1->next;\n        }\n        else\n        {\n            list = tmp = l2;\n            l2 = l2->next;\n        }\n\n        while (l1 && l2)\n        {\n            if (l1->val < l2->val)\n            {\n                tmp->next = l1;\n                l1 = l1->next;\n            }\n            else\n            {\n                tmp->next = l2;\n                l2 = l2->next;\n            }\n            tmp = tmp->next;\n        }\n\n        if (l1)\n            tmp->next = l1;\n        if (l2)\n            tmp->next = l2;\n\n        return list;\n    }\n\n    return NULL;\n}\n\n/*\n * Recursive approach\n */\nstruct ListNode *mergeTwoLists(struct ListNode *l1, struct ListNode *l2)\n{\n    if (!l1)\n        return l2;\n    if (!l2)\n        return l1;\n    if (l1->val < l2->val)\n    {\n        l1->next = mergeTwoLists(l1->next, l2);\n        return l1;\n    }\n    else\n    {\n        l2->next = mergeTwoLists(l1, l2->next);\n        return l2;\n    }\n}\n","index":154},{"title":"215","category":"src","id":"215_src","algorithm":"int *cmpval(const void *a, const void *b) { return *(int *)b - *(int *)a; }\n\nint findKthLargest(int *nums, int numsSize, int k)\n{\n    qsort(nums, numsSize, sizeof(int), cmpval);\n    return nums[k - 1];\n}\n","index":155},{"title":"217","category":"src","id":"217_src","algorithm":"int numcmp(const void *a, const void *b) { return *(int *)a - *(int *)b; }\n\nbool containsDuplicate(int *nums, int numsSize)\n{\n    int i;\n    qsort(nums, numsSize, sizeof(int), numcmp);\n    for (i = 0; i < numsSize - 1; i++)\n    {\n        if (nums[i] == nums[i + 1])\n            return 1;\n    }\n    return 0;\n}\n","index":156},{"title":"226","category":"src","id":"226_src","algorithm":"struct TreeNode *invertTree(struct TreeNode *root)\n{\n    struct TreeNode *tmp;\n    if (root == NULL)\n        return NULL;\n    tmp = root->left;\n    root->left = root->right;\n    root->right = tmp;\n\n    invertTree(root->left);\n    invertTree(root->right);\n    return root;\n}\n","index":157},{"title":"231","category":"src","id":"231_src","algorithm":"bool isPowerOfTwo(int n)\n{\n    if (!n)\n        return false;\n    while (n % 2 == 0) n /= 2;\n    return n == 1;\n}","index":158},{"title":"234","category":"src","id":"234_src","algorithm":"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\n\nstruct ListNode *reverse(struct ListNode *head)\n{\n    struct ListNode *res = NULL;\n    while (head)\n    {\n        struct ListNode *pre_node = head;\n        head = head->next;\n        pre_node->next = res;\n        res = pre_node;\n    }\n    return res;\n}\nbool isPalindrome(struct ListNode *head)\n{\n    struct ListNode *slow = head;\n    struct ListNode *fast = head;\n    struct ListNode *last;\n    while (fast && fast->next)\n    {\n        slow = slow->next;\n        fast = fast->next->next;\n    }\n    if (fast != NULL)\n        slow = slow->next;\n    last = reverse(slow);\n    while (last)\n    {\n        if (head->val != last->val)\n            return 0;\n        head = head->next;\n        last = last->next;\n    }\n    return 1;\n}\n","index":159},{"title":"24","category":"src","id":"24_src","algorithm":"struct ListNode *swapPairs(struct ListNode *head)\n{\n    if (!head || !head->next)\n        return head;\n    struct ListNode *tmp = head->next;\n    head->next = swapPairs(head->next->next);\n    tmp->next = head;\n    return tmp;\n}\n","index":160},{"title":"242","category":"src","id":"242_src","algorithm":"bool isAnagram(char *s, char *t)\n{\n    int n = strlen(s);\n    int m = strlen(t);\n\n    int cnt_s[1000], cnt_t[1000];\n    for (int c = 97; c < 97 + 26; c++) cnt_s[c] = cnt_t[c] = 0;\n\n    for (int i = 0; i < n; i++) cnt_s[s[i]]++;\n\n    for (int i = 0; i < m; i++) cnt_t[t[i]]++;\n\n    for (int c = 97; c < 97 + 26; c++)\n        if (cnt_s[c] != cnt_t[c])\n            return false;\n\n    return true;\n}\n","index":161},{"title":"26","category":"src","id":"26_src","algorithm":"int removeDuplicates(int *nums, int numsSize)\n{\n    int count = 0, i;\n    for (i = 1; i < numsSize; i++)\n    {\n        if (nums[i] == nums[i - 1])\n            count++;\n        else\n            nums[i - count] = nums[i];\n    }\n    return numsSize - count;\n}\n","index":162},{"title":"268","category":"src","id":"268_src","algorithm":"int missingNumber(int *nums, int numsSize)\n{\n    int i, actual_sum = 0, sum = 0;\n    for (i = 0; i < numsSize; i++)\n    {\n        sum = sum + nums[i];\n        actual_sum = actual_sum + i;\n    }\n    return actual_sum + numsSize - sum;\n}\n","index":163},{"title":"27","category":"src","id":"27_src","algorithm":"int removeElement(int *nums, int numsSize, int val)\n{\n    int i, start = 0;\n    for (i = 0; i < numsSize; i++)\n    {\n        if (nums[i] != val)\n            nums[start++] = nums[i];\n    }\n    return start;\n}\n","index":164},{"title":"278","category":"src","id":"278_src","algorithm":"// Forward declaration of isBadVersion API.\nbool isBadVersion(int version);\n\nint firstBadVersion(int n)\n{\n    int low = 1, high = n;\n    while (low <= high)\n    {\n        int mid = low + (high - low) / 2;\n        if (isBadVersion(mid))\n        {\n            high = mid - 1;\n        }\n        else\n        {\n            low = mid + 1;\n        }\n    }\n    return low;\n}\n","index":165},{"title":"28","category":"src","id":"28_src","algorithm":"/*\n * brute force approach\n * time complexity: O(mn)\n */\nint strStr(char *haystack, char *needle)\n{\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int hlen = 0;\n    int nlen = 0;\n\n    if (needle == NULL || *needle == 0)\n        return 0;\n\n    if (haystack == NULL || *haystack == 0)\n        return -1;\n\n    hlen = strlen(haystack);\n    nlen = strlen(needle);\n\n    if (hlen < nlen)\n        return -1;\n\n    for (i = 0; i <= hlen - nlen; i++)\n    {\n        j = 0;\n        if (haystack[i] != needle[j++])\n            continue;\n\n        k = i + 1;\n        for (; j < nlen; j++)\n        {\n            if (haystack[k] != needle[j])\n            {\n                break;\n            }\n            else\n                k++;\n        }\n        if (j == nlen)\n            return i;\n    }\n    return -1;\n}\n\n/* ----------------------------------------------------------------------------------------\n */\n\n/*\n * KMP algorithm\n * time complexity: O(m + n)\n */\n\n/* fills overlap with longest proper prefix which is also suffix for each index\n * in needle */\nvoid fill_overlap(char *needle, int len_needle, int *overlap)\n{\n    int len = 0;\n    int i = 0;\n\n    overlap[0] = 0;\n\n    for (i = 1; i < len_needle;)\n    {\n        if (needle[i] == needle[len])\n        {\n            len++;\n            overlap[i++] = len;\n        }\n        else\n        {\n            if (len)\n                len = overlap[len - 1];\n            else\n                overlap[i++] = 0;\n        }\n    }\n}\n\nint strStr(char *haystack, char *needle)\n{\n    int i = 0; /* index for haystack */\n    int j = 0; /* index for needle */\n\n    int len_needle = strlen(needle);\n    int len_haystack = strlen(haystack);\n\n    if (!len_needle)\n        return 0;\n\n    int overlap[len_needle];\n\n    fill_overlap(needle, len_needle, overlap);\n\n    while (i < len_haystack)\n    {\n        if (needle[j] == haystack[i])\n        {\n            i++;\n            j++;\n        }\n\n        if (j == len_needle)\n        {\n            return (i - j);\n        }\n        else if (i < len_haystack && needle[j] != haystack[i])\n        {\n            if (j != 0)\n                j = overlap[j - 1];\n            else\n                i = i + 1;\n        }\n    }\n    return -1;\n}\n\n/* ----------------------------------------------------------------------------------------\n */\n","index":166},{"title":"283","category":"src","id":"283_src","algorithm":"void moveZeroes(int *nums, int numsSize)\n{\n    int i = 0, start = 0;\n\n    for (i = 0; i < numsSize; i++)\n    {\n        if (nums[i])\n            nums[start++] = nums[i];\n    }\n\n    for (start; start < numsSize; start++)\n    {\n        nums[start] = 0;\n    }\n}\n","index":167},{"title":"287","category":"src","id":"287_src","algorithm":"int cmpval(const void *a, const void *b) { return *(int *)a - *(int *)b; }\nint findDuplicate(int *nums, int numsSize)\n{\n    int i;\n    qsort(nums, numsSize, sizeof(int), cmpval);\n    for (i = 0; i < numsSize - 1; i++)\n    {\n        if (nums[i] == nums[i + 1])\n            return nums[i];\n    }\n    return nums[i];\n}\n","index":168},{"title":"29","category":"src","id":"29_src","algorithm":"int divide(int dividend, int divisor)\n{\n    int sign = 1;\n    long int output = 0;\n    if (dividend < 0)\n    {\n        sign *= -1;\n    }\n    else\n    {\n        dividend *= -1;\n    }\n    if (divisor < 0)\n    {\n        sign *= -1;\n    }\n    else\n    {\n        divisor *= -1;\n    }\n    while (dividend <= divisor)\n    {\n        long int tmp = 0;\n        long int div = divisor;\n        while (dividend <= div)\n        {\n            tmp += (tmp + 1);\n            dividend -= div;\n            div += div;\n        }\n        if (output >= INT_MAX)\n        {\n            if (sign == -1)\n            {\n                return INT_MIN;\n            }\n            else\n            {\n                return INT_MAX;\n            }\n        }\n        output += tmp;\n    }\n\n    return output * sign;\n}\n","index":169},{"title":"3","category":"src","id":"3_src","algorithm":"int lengthOfLongestSubstring(char *str)\n{\n    int n = strlen(str);\n\n    if (!n)\n        return 0;\n\n    int L_len = 1;  // lenght of longest substring\n    int C_len = 1;  // lenght of current substring\n\n    int P_ind, i;      //  P_ind for previous index\n    int visited[256];  //  visited will keep track of visiting char for the last\n                       //  instance. since there are 256 ASCII char, its size is\n                       //  limited to that value.\n    memset(visited, -1, sizeof(int) * 256);\n    visited[str[0]] =\n        0;  //  the index of that char will tell us that when it was visited.\n    for (i = 1; i < n; i++)\n    {\n        P_ind = visited[str[i]];\n        if (P_ind == -1 || i - C_len > P_ind)\n            C_len++;  //  if the current char was not visited earlier, or it is\n                      //  not the part of current substring\n        else\n        {  //  otherwise, we need to change the current/longest substring length\n            if (C_len > L_len)\n                L_len = C_len;\n            C_len = i - P_ind;\n        }\n        visited[str[i]] = i;\n    }\n    if (C_len > L_len)\n        L_len = C_len;\n    return L_len;\n}\n/* Brute force */\nint lengthOfLongestSubstring(char *s)\n{\n    int cur_max = 0, max = 0;\n    int counter[255];\n    int end = 0;\n\n    memset(counter, 0, sizeof(int) * 255);\n    while (end < strlen(s))\n    {\n        if (counter[s[end]] == 0)\n        {\n            counter[s[end]]++;\n            end++;\n            cur_max++;\n        }\n        else\n        {\n            char c = s[end];\n            memset(counter, 0, 255 * sizeof(int));\n            if (cur_max >= max)\n                max = cur_max;\n            cur_max = 0;\n            while (s[end - 1] != c) end--;\n        }\n    }\n    if (cur_max >= max)\n        max = cur_max;\n    return max;\n}\n","index":170},{"title":"344","category":"src","id":"344_src","algorithm":"void reverseString(char *s, int sSize)\n{\n    int last = sSize - 1, i;\n    for (i = 0; i < last; i++)\n    {\n        char tmp = s[i];\n        s[i] = s[last];\n        s[last] = tmp;\n        last--;\n    }\n}\n","index":171},{"title":"35","category":"src","id":"35_src","algorithm":"int searchInsert(int *nums, int numsSize, int target)\n{\n    int low = 0, high = numsSize - 1, mid;\n    while (low <= high)\n    {\n        mid = low + (high - low) / 2;\n        if (target > nums[mid])\n            low = mid + 1;\n        else if (target < nums[mid])\n            high = mid - 1;\n        else\n            return mid;\n    }\n    return low;\n}\n\n/* Recursive version */\nint searchInsert(int *nums, int numsSize, int target)\n{\n    int idx = numsSize - 1;\n    if (numsSize > 0)\n    {\n        if (target > nums[idx])\n        {\n            return numsSize;\n        }\n        return searchInsert(nums, numsSize - 1, target);\n    }\n    return 0;\n}\n","index":172},{"title":"367","category":"src","id":"367_src","algorithm":"bool isPerfectSquare(int num)\n{\n    for (long i = 1; i * i <= num; i++)\n        if (i * i == num)\n            return true;\n    return false;\n}\n","index":173},{"title":"38","category":"src","id":"38_src","algorithm":"char *countAndSay(int n)\n{\n    // Calculating the length of array\n    double result = 1.0;\n    for (int i = 0; i < n - 1; i++)\n    {\n        result *= 1.4;\n    }\n\n    int k, j, count, convert = (int)result;\n\n    // Creating array with the length calculated above\n    char *arr = malloc(convert + 4);\n    arr[0] = '1';\n    arr[1] = '\\0';\n\n    for (int i = 2, length; i <= n; i++)\n    {\n        length = strlen(arr);\n        char newArr[length * 2];\n        strcpy(newArr, arr);\n\n        k = 0;\n        j = 0;\n        count = 1;\n\n        while (newArr[j] != '\\0')\n        {\n            if (newArr[j] == newArr[j + 1])\n            {\n                count++;\n                j++;\n            }\n            else\n            {\n                arr[k] = (48 + count);\n                arr[k + 1] = newArr[j];\n                arr[k + 2] = '\\0';\n                j++;\n                k += 2;\n                count = 1;\n            }\n        }\n    }\n\n    return arr;\n}\n","index":174},{"title":"387","category":"src","id":"387_src","algorithm":"int firstUniqChar(char *s)\n{\n    int *arr = calloc(256, sizeof(int));\n    int i;\n    for (i = 0; i < strlen(s); i++) arr[s[i]] = arr[s[i]] + 1;\n    for (i = 0; i < strlen(s); i++)\n    {\n        if (arr[s[i]] == 1)\n            return i;\n    }\n    return -1;\n}\n","index":175},{"title":"389","category":"src","id":"389_src","algorithm":"char findTheDifference(char *s, char *t)\n{\n    int sum1 = 0, sum2 = 0;\n    int i;\n    for (i = 0; i < strlen(s); i++) sum1 += s[i];\n    for (i = 0; i < strlen(t); i++) sum2 += t[i];\n    return (char)(sum2 - sum1);\n}\n","index":176},{"title":"4","category":"src","id":"4_src","algorithm":"\n\ndouble findMedianSortedArrays(int *nums1, int nums1Size, int *nums2,\n                              int nums2Size)\n{\n    int index1 = 0;\n    int index2 = 0;\n    int v[nums1Size + nums2Size];\n    int v_index = 0;\n\n    while (index1 < nums1Size && index2 < nums2Size)\n    {\n        if (nums1[index1] <= nums2[index2])\n        {\n            v[v_index++] = nums1[index1++];\n        }\n        else\n        {\n            v[v_index++] = nums2[index2++];\n        }\n    }\n    if (index1 < nums1Size)\n    {\n        while (index1 < nums1Size)\n        {\n            v[v_index++] = nums1[index1++];\n        }\n    }\n    if (index2 < nums2Size)\n    {\n        while (index2 < nums2Size)\n        {\n            v[v_index++] = nums2[index2++];\n        }\n    }\n    if (v_index == 1)\n    {\n        return v[0];\n    }\n    if (v_index % 2 == 0)\n    {\n        double n1, n2;\n        n1 = v[v_index / 2];\n        n2 = v[(v_index / 2) - 1];\n        return (n1 + n2) / 2;\n    }\n    int new_index = (int)v_index / 2;\n    int i = 0;\n    return v[new_index];\n}\n","index":177},{"title":"404","category":"src","id":"404_src","algorithm":"bool isleaf(struct TreeNode *root)\n{\n    return root->left == NULL && root->right == NULL;\n}\n\nint sumOfLeftLeaves(struct TreeNode *root)\n{\n    if (root == NULL)\n        return 0;\n    if (root->left)\n    {\n        if (isleaf(root->left))\n            return root->left->val + sumOfLeftLeaves(root->right);\n    }\n    return sumOfLeftLeaves(root->left) + sumOfLeftLeaves(root->right);\n}\n","index":178},{"title":"442","category":"src","id":"442_src","algorithm":"int cmpval(const void *a, const void *b) { return *(int *)a - *(int *)b; }\n\nint *findDuplicates(int *nums, int numsSize, int *returnSize)\n{\n    int i;\n    qsort(nums, numsSize, sizeof(int), cmpval);\n    int *retArr = malloc(numsSize * sizeof(int));\n    *returnSize = 0;\n    for (i = 0; i < numsSize - 1;)\n    {\n        if (nums[i] == nums[i + 1])\n        {\n            retArr[*returnSize] = nums[i];\n            *returnSize = *returnSize + 1;\n            i = i + 2;\n        }\n        else\n        {\n            i = i + 1;\n        }\n    }\n    return retArr;\n}\n","index":179},{"title":"461","category":"src","id":"461_src","algorithm":"int hammingDistance(int x, int y)\n{\n    int difference =\n        x ^ y;  // The XOR operator generates the bitwise difference in the\n                // binary representation of two numbers If bit in ith position\n                // of both numbers is same, bit in difference is 0, otherwise 1\n    int TotalBits = sizeof(difference) * 8;  // total number of bits\n    int i, distance = 0;\n    for (i = 0; i < TotalBits; i++)\n    {\n        if (difference &\n            (UINT32_C(1)\n             << i))  // if the bit on the ith position of 32 bit input is 1,\n                     // then proceed Further note the use of UINT32_C to convert\n                     // 1 to unsigned 32 bit int, as just 1 is treated as int\n                     // which cannot be shifted left more than 30 times\n            distance += 1;\n    }\n    return distance;\n}","index":180},{"title":"476","category":"src","id":"476_src","algorithm":"int findComplement(int num)\n{\n    int TotalBits = 0;\n    int temp = num;\n    while (temp)\n    {  // To find position of MSB in given num. Since num is represented as a\n       // standard size in memory, we cannot rely on size for that information.\n        TotalBits++;  // increment TotalBits till temp becomes 0\n        temp >>= 1;   // shift temp right by 1 bit every iteration; temp loses 1\n                      // bit to underflow every iteration till it becomes 0\n    }\n    int i,\n        flipNumber = 1;  // Eg: 1's complement of 101(binary) can be found as\n                         // 101^111 (XOR with 111 flips all bits that are 1 to 0\n                         // and flips 0 to 1)\n    for (i = 1; i < TotalBits; i++)\n    {\n        flipNumber += UINT32_C(1)\n                      << i;  // Note the use of unsigned int to facilitate left\n                             // shift more than 31 times, if needed\n    }\n    num = num ^ flipNumber;\n    return num;\n}","index":181},{"title":"509","category":"src","id":"509_src","algorithm":"int fib(int N)\n{\n    if (N == 0)\n        return 0;\n    if (N == 1)\n        return 1;\n    return fib(N - 1) + fib(N - 2);\n}\n","index":182},{"title":"520","category":"src","id":"520_src","algorithm":"bool detectCapitalUse(char *word)\n{\n    int len = strlen(word);\n    if (len == 1)\n        return 1;\n    int countUpper = 0, i;\n    for (i = 0; i < len; i++)\n    {\n        if (isupper(word[i]))\n            countUpper++;\n    }\n    /* All lower case */\n    if (countUpper == 0)\n        return 1;\n    /* 1st character is upper, and the rest is lower case */\n    if (countUpper == 1 && isupper(word[0]))\n        return 1;\n    /* Check all character is upper case? */\n    else\n        return countUpper == len;\n}\n\n/* Another way */\nbool isAllUpper(char *word)\n{\n    int len = strlen(word);\n    for (int i = 0; i < len; i++)\n    {\n        if (islower(word[i]))\n            return 0;\n    }\n    return 1;\n}\nbool detectCapitalUse(char *word)\n{\n    int len = strlen(word);\n    for (int i = 1; i < len; i++)\n    {\n        if (isupper(word[i]) && !isAllUpper(word))\n            return 0;\n    }\n    return 1;\n}\n","index":183},{"title":"53","category":"src","id":"53_src","algorithm":"\nint maxcmp(int a, int b) { return a >= b ? a : b; }\n\nint maxSubArray(int *nums, int numsSize)\n{\n    int maxSoFar = nums[0], maxEndingHere = nums[0];\n    for (int i = 1; i < numsSize; i++)\n    {\n        maxEndingHere = maxcmp(maxEndingHere + nums[i], nums[i]);\n        maxSoFar = maxcmp(maxSoFar, maxEndingHere);\n    }\n    return maxSoFar;\n}\n","index":184},{"title":"561","category":"src","id":"561_src","algorithm":"int cmpval(const void *a, const void *b) { return *(int *)a - *(int *)b; }\nint arrayPairSum(int *nums, int numsSize)\n{\n    int sum = 0, i;\n    qsort(nums, numsSize, sizeof(int), cmpval);\n    for (i = 0; i < numsSize; i = i + 2) sum = sum + nums[i];\n    return sum;\n}\n","index":185},{"title":"617","category":"src","id":"617_src","algorithm":"struct TreeNode *newNode(int item)\n{\n    struct TreeNode *node = (struct TreeNode *)malloc(sizeof(struct TreeNode));\n    node->val = item;\n    node->left = node->right = NULL;\n    return node;\n}\n\nstruct TreeNode *mergeTrees(struct TreeNode *t1, struct TreeNode *t2)\n{\n    if (t1 == NULL && t2 == NULL)\n        return NULL;\n    int item = (t1 == NULL ? 0 : t1->val) + (t2 == NULL ? 0 : t2->val);\n    struct TreeNode *node = newNode(item);\n    node->left =\n        mergeTrees(t1 == NULL ? NULL : t1->left, t2 == NULL ? NULL : t2->left);\n    node->right = mergeTrees(t1 == NULL ? NULL : t1->right,\n                             t2 == NULL ? NULL : t2->right);\n    return node;\n}\n","index":186},{"title":"647","category":"src","id":"647_src","algorithm":"\n/* Author : Saurav Dubey */\n\nint countSubstrings(char *s)\n{\n    int len = strlen(s);\n    int i;\n    int count = 0;\n    for (i = 0; i < len; i++)\n    {\n        // cases handled for both odd and even lenghted Palindrome\n\n        count += countPalin(s, i, i, len);\n        if (i != len - 1)\n            count += countPalin(s, i, i + 1, len);\n    }\n    return count;\n}\nint countPalin(char *s, int head, int tail, int len)\n{\n    int ret = (s[head] == s[tail]) ? 1 : 0;\n    if (ret && head - 1 >= 0 && tail + 1 < len)\n        ret += countPalin(s, head - 1, tail + 1, len);\n    return ret;\n}\n","index":187},{"title":"66","category":"src","id":"66_src","algorithm":"/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint *plusOne(int *digits, int digitsSize, int *returnSize)\n{\n    for (int i = digitsSize - 1; i >= 0; i--)\n    {\n        if (digits[i] < 9)\n        {\n            digits[i]++;\n            *returnSize = digitsSize;\n            return digits;\n        }\n        else\n        {\n            digits[i] = 0;\n        }\n    }\n\n    int *newdigit = (int *)malloc((digitsSize + 1) * sizeof(int));\n    newdigit[0] = 1;\n    for (int i = 1; i < (digitsSize + 1); i++)\n    {\n        newdigit[i] = digits[i - 1];\n    }\n    *returnSize = digitsSize + 1;\n    return newdigit;\n}","index":188},{"title":"674","category":"src","id":"674_src","algorithm":"int findLengthOfLCIS(int *nums, int numsSize)\n{\n    int maxval = 1, i, count = 1;\n    if (numsSize == 0)\n        return 0;\n    for (i = 1; i < numsSize; i++)\n    {\n        if (nums[i] > nums[i - 1])\n        {\n            count++;\n            if (count >= maxval)\n                maxval = count;\n        }\n        else\n        {\n            count = 1;\n        }\n    }\n    return maxval;\n}\n","index":189},{"title":"7","category":"src","id":"7_src","algorithm":"#include <limits.h>\n\nint reverse(int x)\n{\n    int rev = 0;\n    while (x != 0)\n    {\n        int pop = x % 10;\n        x /= 10;\n        if (rev > INT_MAX / 10 || (rev == INT_MAX / 10 && pop > 7))\n            return 0;\n        if (rev < INT_MIN / 10 || (rev == INT_MIN / 10 && pop < -8))\n            return 0;\n        rev = rev * 10 + pop;\n    }\n    return rev;\n}\n","index":190},{"title":"700","category":"src","id":"700_src","algorithm":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\nstruct TreeNode *searchBST(struct TreeNode *root, int val)\n{\n    if (!root)\n        return NULL;\n\n    if (root->val == val)\n    {\n        return root;\n    }\n    else if (root->val > val)\n    {\n        return searchBST(root->left, val);\n    }\n    else\n    {\n        return searchBST(root->right, val);\n    }\n}\n","index":191},{"title":"701","category":"src","id":"701_src","algorithm":"struct TreeNode *insertIntoBST(struct TreeNode *root, int val)\n{\n    if (root == NULL)\n    {\n        struct TreeNode *new_val = malloc(sizeof(struct TreeNode));\n        new_val->val = val;\n        new_val->left = new_val->right = NULL;\n        return new_val;\n    }\n    else\n    {\n        if (root->val >= val)\n            root->left = insertIntoBST(root->left, val);\n        else\n            root->right = insertIntoBST(root->right, val);\n    }\n    return root;\n}\n","index":192},{"title":"704","category":"src","id":"704_src","algorithm":"int search(int *nums, int numsSize, int target)\n{\n    int low = 0, high = numsSize - 1;\n    while (low <= high)\n    {\n        int mid = low + (high - low) / 2;\n        if (target > nums[mid])\n        {\n            low = mid + 1;\n        }\n        else if (target < nums[mid])\n        {\n            high = mid - 1;\n        }\n        else\n        {\n            return mid;\n        }\n    }\n    return -1;\n}\n\n/* Another solution: Using bsearch() */\nint cmpint(const void *a, const void *b) { return *(int *)a - *(int *)b; }\n\nint search(int *nums, int numsSize, int target)\n{\n    int *ret = bsearch(&target, nums, numsSize, sizeof(int), cmpint);\n    if (ret)\n        return (ret - nums);\n    else\n        return -1;\n}\n","index":193},{"title":"709","category":"src","id":"709_src","algorithm":"char *toLowerCase(char *str)\n{\n    for (int i = 0; i < strlen(str); i++) str[i] = tolower(str[i]);\n    return str;\n}\n","index":194},{"title":"771","category":"src","id":"771_src","algorithm":"// for strlen()\n#include <string.h>\n\nint numJewelsInStones(char *j, char *s)\n{\n    // as strlen is O(n), store it once rather than using it in for loop\n    int cnt[500], lens = strlen(s), lenj = strlen(j), sol = 0;\n    memset(cnt, 0, sizeof(cnt));\n\n    // lookup to know which character occurs in j\n    for (int i = 0; i < lenj; i++) cnt[j[i]]++;\n\n    // count the characters in s\n    for (int i = 0; i < lens; i++) sol += cnt[s[i]];\n\n    return sol;\n}\n","index":195},{"title":"8","category":"src","id":"8_src","algorithm":"int myAtoi(char *str)\n{\n    int minusFlag = 0;\n    int length = strlen(str);\n    long int result = 0;\n    char numberBuffer[11];\n    int counter = 0;\n    while (str[counter] == ' ')\n    {\n        counter++;\n    }\n    str = &str[counter];\n    counter = 0;\n\n    for (int i = 0; i < length; i++)\n    {\n        if (i == 0)\n        {\n            if (str[0] == '-')\n            {\n                minusFlag = 1;\n                i++;\n            }\n            else if (str[0] == '+')\n            {\n                i++;\n            }\n        }\n        if (counter > 10)\n        {\n            if (minusFlag)\n            {\n                return __INT_MAX__ * -1 - 1;\n            }\n            else\n            {\n                return __INT_MAX__;\n            }\n        }\n\n        if (str[i] < '0' || str[i] > '9')\n        {\n            break;\n        }\n        if (counter == 0 && str[i] == '0')\n        {\n            continue;\n        }\n\n        numberBuffer[counter] = str[i];\n        counter++;\n    }\n\n    int i = 0;\n    while (counter > 0)\n    {\n        if (minusFlag)\n        {\n            result -= (numberBuffer[i] - '0') * pow(10.0, counter - 1);\n        }\n        else\n        {\n            result += (numberBuffer[i] - '0') * pow(10.0, counter - 1);\n        }\n        i++;\n        counter--;\n    }\n\n    if (result > __INT_MAX__)\n    {\n        return __INT_MAX__;\n    }\n    else if (result < __INT_MAX__ * -1 - 1)\n    {\n        return __INT_MAX__ * -1 - 1;\n    }\n    return result;\n}\n","index":196},{"title":"82","category":"src","id":"82_src","algorithm":"struct ListNode *deleteDuplicates(struct ListNode *head)\n{\n    if (head == NULL)\n        return NULL;\n\n    if (head->next && head->val == head->next->val)\n    {\n        /* Remove all duplicate numbers */\n        while (head->next && head->val == head->next->val)\n        {\n            head = head->next;\n        }\n        return deleteDuplicates(head->next);\n    }\n    else\n    {\n        head->next = deleteDuplicates(head->next);\n    }\n    return head;\n}\n","index":197},{"title":"83","category":"src","id":"83_src","algorithm":"\nstruct ListNode *deleteDuplicates(struct ListNode *head)\n{\n    struct ListNode *cur = head;\n    while (cur && cur->next)\n    {\n        if (cur->val == cur->next->val)\n            cur->next = cur->next->next;\n        else\n            cur = cur->next;\n    }\n    return head;\n}\n","index":198},{"title":"852","category":"src","id":"852_src","algorithm":"int peakIndexInMountainArray(int *A, int ASize)\n{\n    int low = 1, high = ASize;\n    while (low <= high)\n    {\n        int mid = low + (high - low) / 2;\n        if (A[mid - 1] < A[mid] && A[mid] > A[mid + 1])\n            return mid;\n        else if (A[mid - 1] < A[mid] && A[mid] < A[mid + 1])\n            low = mid + 1;\n        else\n            high = mid - 1;\n    }\n    return -1;\n}\n","index":199},{"title":"876","category":"src","id":"876_src","algorithm":"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\n\nstruct ListNode *middleNode(struct ListNode *head)\n{\n    struct ListNode *fast, *slow;\n    fast = slow = head;\n    while (fast && fast->next)\n    {\n        slow = slow->next;\n        fast = fast->next->next;\n    }\n    return slow;\n}\n","index":200},{"title":"9","category":"src","id":"9_src","algorithm":"bool isPalindrome(int x)\n{\n    if (x < 0 || (x % 10 == 0 && x != 0))\n    {\n        return false;\n    }\n\n    int revertedNumber = 0;\n    while (x > revertedNumber)\n    {\n        revertedNumber = revertedNumber * 10 + x % 10;\n        x /= 10;\n    }\n\n    return x == revertedNumber || x == revertedNumber / 10;\n}\n","index":201},{"title":"905","category":"src","id":"905_src","algorithm":"/**\n * 905. Sort Array By Parity\n * Given an array A of non-negative integers, return an array consisting of\n * all the even elements of A, followed by all the odd elements of A.\n * You may return any answer array that satisfies this condition.\n * Example 1:\n * Input: [3,1,2,4]\n * Output: [2,4,3,1]\n * The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.\n *\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint *sortArrayByParity(int *A, int ASize, int *returnSize)\n{\n    int *retArr = malloc(ASize * sizeof(int));\n    int oddIndex = ASize - 1;\n    int evenIndex = 0;\n    *returnSize = ASize;\n    for (int i = 0; i < ASize; i++)\n    {\n        if (A[i] % 2 == 0)\n        {\n            retArr[evenIndex] = A[i];\n            evenIndex++;\n        }\n        else\n        {\n            retArr[oddIndex] = A[i];\n            oddIndex--;\n        }\n    }\n\n    return retArr;\n}\n","index":202},{"title":"917","category":"src","id":"917_src","algorithm":"char *reverseOnlyLetters(char *S)\n{\n    int last = strlen(S) - 1, i;\n    for (i = 0; i < last;)\n    {\n        if (!isalpha(S[i]))\n        {\n            i++;\n            continue;\n        }\n        if (!isalpha(S[last]))\n        {\n            last--;\n            continue;\n        }\n        char tmp = S[i];\n        S[i] = S[last];\n        S[last] = tmp;\n        i++;\n        last--;\n    }\n    return S;\n}\n","index":203},{"title":"938","category":"src","id":"938_src","algorithm":"int rangeSumBST(struct TreeNode *root, int L, int R)\n{\n    if (root == NULL)\n    {\n        return 0;\n    }\n    else if (root->val >= L && root->val <= R)\n    {\n        return root->val + rangeSumBST(root->left, L, R) +\n               rangeSumBST(root->right, L, R);\n    }\n    else\n    {\n        return rangeSumBST(root->left, L, R) + rangeSumBST(root->right, L, R);\n    }\n}\n","index":204},{"title":"94","category":"src","id":"94_src","algorithm":"void processTraversal(struct TreeNode *root, int *res, int *size)\n{\n    if (!root)\n        return;\n    processTraversal(root->left, res, size);\n    res[*size] = root->val;\n    *size = *size + 1;\n    processTraversal(root->right, res, size);\n}\n\nint *inorderTraversal(struct TreeNode *root, int *returnSize)\n{\n    int *res = malloc(256 * sizeof(int));\n    *returnSize = 0;\n    processTraversal(root, res, returnSize);\n    return res;\n}\n","index":205},{"title":"965","category":"src","id":"965_src","algorithm":"bool isUnivalTree(struct TreeNode *root)\n{\n    if (root == NULL)\n        return 1;\n    if (root->left)\n    {\n        if (root->left->val != root->val)\n            return 0;\n    }\n    if (root->right)\n    {\n        if (root->right->val != root->val)\n            return 0;\n    }\n    return isUnivalTree(root->left) && isUnivalTree(root->right);\n}\n","index":206},{"title":"977","category":"src","id":"977_src","algorithm":"/* 1st way: Using 2 pointers */\nint *sortedSquares(int *A, int ASize, int *returnSize)\n{\n    int i, start = 0, end = ASize - 1;\n    int *res = malloc(ASize * sizeof(int));\n    *returnSize = ASize;\n    for (i = ASize - 1; i >= 0; i--)\n    {\n        if (abs(A[start]) > A[end])\n        {\n            res[i] = A[start] * A[start];\n            start++;\n        }\n        else\n        {\n            res[i] = A[end] * A[end];\n            end--;\n        }\n    }\n    return res;\n}\n\n/* 2nd way: Using qsort */\nint cmpval(const void *a, const void *b) { return *(int *)a - *(int *)b; }\n\nint *sortedSquares(int *A, int ASize, int *returnSize)\n{\n    int *res = malloc(ASize * sizeof(int));\n    for (int i = 0; i < ASize; i++) res[i] = A[i] * A[i];\n    *returnSize = ASize;\n    qsort(res, ASize, sizeof(int), cmpval);\n    return res;\n}\n","index":207},{"title":"Machine Learning","category":null,"id":"machine_learning","index":208},{"title":"Adaline Learning","category":"machine_learning","id":"adaline_learning_machine_learning","algorithm":"/**\n * \\file\n * \\brief [Adaptive Linear Neuron\n * (ADALINE)](https://en.wikipedia.org/wiki/ADALINE) implementation\n * \\details\n * <img\n * src=\"https://upload.wikimedia.org/wikipedia/commons/b/be/Adaline_flow_chart.gif\"\n * width=\"200px\">\n * [source](https://commons.wikimedia.org/wiki/File:Adaline_flow_chart.gif)\n * ADALINE is one of the first and simplest single layer artificial neural\n * network. The algorithm essentially implements a linear function\n * \\f[ f\\left(x_0,x_1,x_2,\\ldots\\right) =\n * \\sum_j x_jw_j+\\theta\n * \\f]\n * where \\f$x_j\\f$ are the input features of a sample, \\f$w_j\\f$ are the\n * coefficients of the linear function and \\f$\\theta\\f$ is a constant. If we\n * know the \\f$w_j\\f$, then for any given set of features, \\f$y\\f$ can be\n * computed. Computing the \\f$w_j\\f$ is a supervised learning algorithm wherein\n * a set of features and their corresponding outputs are given and weights are\n * computed using stochastic gradient descent method.\n * \\author [Krishna Vedala](https://github.com/kvedala)\n */\n\n#include <assert.h>\n#include <limits.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n/**\n * @addtogroup machine_learning Machine learning algorithms\n * @{\n * @addtogroup adaline Adaline learning algorithm\n * @{\n */\n\n/** Maximum number of iterations to learn */\n#define MAX_ADALINE_ITER 500  // INT_MAX\n\n/** structure to hold adaline model parameters */\nstruct adaline\n{\n    double eta;      /**< learning rate of the algorithm */\n    double *weights; /**< weights of the neural network */\n    int num_weights; /**< number of weights of the neural network */\n};\n\n/** convergence accuracy \\f$=1\\times10^{-5}\\f$ */\n#define ADALINE_ACCURACY 1e-5\n\n/**\n * Default constructor\n * \\param[in] num_features number of features present\n * \\param[in] eta learning rate (optional, default=0.1)\n * \\returns new adaline model\n */\nstruct adaline new_adaline(const int num_features, const double eta)\n{\n    if (eta <= 0.f || eta >= 1.f)\n    {\n        fprintf(stderr, \"learning rate should be > 0 and < 1\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    // additional weight is for the constant bias term\n    int num_weights = num_features + 1;\n    struct adaline ada;\n    ada.eta = eta;\n    ada.num_weights = num_weights;\n    ada.weights = (double *)malloc(num_weights * sizeof(double));\n    if (!ada.weights)\n    {\n        perror(\"Unable to allocate error for weights!\");\n        return ada;\n    }\n\n    // initialize with random weights in the range [-50, 49]\n    for (int i = 0; i < num_weights; i++) ada.weights[i] = 1.f;\n    // ada.weights[i] = (double)(rand() % 100) - 50);\n\n    return ada;\n}\n\n/** delete dynamically allocated memory\n * \\param[in] ada model from which the memory is to be freed.\n */\nvoid delete_adaline(struct adaline *ada)\n{\n    if (ada == NULL)\n        return;\n\n    free(ada->weights);\n};\n\n/** [Heaviside activation\n * function](https://en.wikipedia.org/wiki/Heaviside_step_function) <img\n * src=\"https://upload.wikimedia.org/wikipedia/commons/d/d9/Dirac_distribution_CDF.svg\"\n * width=\"200px\"/>\n * @param x activation function input\n * @returns \\f$f(x)= \\begin{cases}1 & \\forall\\; x > 0\\\\ -1 & \\forall\\; x \\le0\n * \\end{cases}\\f$\n */\nint adaline_activation(double x) { return x > 0 ? 1 : -1; }\n\n/**\n * Operator to print the weights of the model\n * @param ada model for which the values to print\n * @returns pointer to a NULL terminated string of formatted weights\n */\nchar *adaline_get_weights_str(const struct adaline *ada)\n{\n    static char out[100];  // static so the value is persistent\n\n    sprintf(out, \"<\");\n    for (int i = 0; i < ada->num_weights; i++)\n    {\n        sprintf(out, \"%s%.4g\", out, ada->weights[i]);\n        if (i < ada->num_weights - 1)\n            sprintf(out, \"%s, \", out);\n    }\n    sprintf(out, \"%s>\", out);\n    return out;\n}\n\n/**\n * predict the output of the model for given set of features\n *\n * \\param[in] ada adaline model to predict\n * \\param[in] x input vector\n * \\param[out] out optional argument to return neuron output before applying\n * activation function (`NULL` to ignore)\n * \\returns model prediction output\n */\nint adaline_predict(struct adaline *ada, const double *x, double *out)\n{\n    double y = ada->weights[ada->num_weights - 1];  // assign bias value\n\n    for (int i = 0; i < ada->num_weights - 1; i++) y += x[i] * ada->weights[i];\n\n    if (out)  // if out variable is not NULL\n        *out = y;\n\n    // quantizer: apply ADALINE threshold function\n    return adaline_activation(y);\n}\n\n/**\n * Update the weights of the model using supervised learning for one feature\n * vector\n *\n * \\param[in] ada adaline model to fit\n * \\param[in] x feature vector\n * \\param[in] y known output  value\n * \\returns correction factor\n */\ndouble adaline_fit_sample(struct adaline *ada, const double *x, const int y)\n{\n    /* output of the model with current weights */\n    int p = adaline_predict(ada, x, NULL);\n    int prediction_error = y - p;  // error in estimation\n    double correction_factor = ada->eta * prediction_error;\n\n    /* update each weight, the last weight is the bias term */\n    for (int i = 0; i < ada->num_weights - 1; i++)\n    {\n        ada->weights[i] += correction_factor * x[i];\n    }\n    ada->weights[ada->num_weights - 1] += correction_factor;  // update bias\n\n    return correction_factor;\n}\n\n/**\n * Update the weights of the model using supervised learning for an array of\n * vectors.\n *\n * \\param[in] ada adaline model to train\n * \\param[in] X array of feature vector\n * \\param[in] y known output value for each feature vector\n * \\param[in] N number of training samples\n */\nvoid adaline_fit(struct adaline *ada, double **X, const int *y, const int N)\n{\n    double avg_pred_error = 1.f;\n\n    int iter;\n    for (iter = 0;\n         (iter < MAX_ADALINE_ITER) && (avg_pred_error > ADALINE_ACCURACY);\n         iter++)\n    {\n        avg_pred_error = 0.f;\n\n        // perform fit for each sample\n        for (int i = 0; i < N; i++)\n        {\n            double err = adaline_fit_sample(ada, X[i], y[i]);\n            avg_pred_error += fabs(err);\n        }\n        avg_pred_error /= N;\n\n        // Print updates every 200th iteration\n        // if (iter % 100 == 0)\n        printf(\"\\tIter %3d: Training weights: %s\\tAvg error: %.4f\\n\", iter,\n               adaline_get_weights_str(ada), avg_pred_error);\n    }\n\n    if (iter < MAX_ADALINE_ITER)\n        printf(\"Converged after %d iterations.\\n\", iter);\n    else\n        printf(\"Did not converged after %d iterations.\\n\", iter);\n}\n\n/** @}\n *  @}\n */\n\n/**\n * test function to predict points in a 2D coordinate system above the line\n * \\f$x=y\\f$ as +1 and others as -1.\n * Note that each point is defined by 2 values or 2 features.\n * \\param[in] eta learning rate (optional, default=0.01)\n */\nvoid test1(double eta)\n{\n    struct adaline ada = new_adaline(2, eta);  // 2 features\n\n    const int N = 10;  // number of sample points\n    const double saved_X[10][2] = {{0, 1},  {1, -2},   {2, 3},   {3, -1},\n                                   {4, 1},  {6, -5},   {-7, -3}, {-8, 5},\n                                   {-9, 2}, {-10, -15}};\n\n    double **X = (double **)malloc(N * sizeof(double *));\n    const int Y[10] = {1,  -1, 1, -1, -1,\n                       -1, 1,  1, 1,  -1};  // corresponding y-values\n    for (int i = 0; i < N; i++)\n    {\n        X[i] = (double *)saved_X[i];\n    }\n\n    printf(\"------- Test 1 -------\\n\");\n    printf(\"Model before fit: %s\", adaline_get_weights_str(&ada));\n\n    adaline_fit(&ada, X, Y, N);\n    printf(\"Model after fit: %s\\n\", adaline_get_weights_str(&ada));\n\n    double test_x[] = {5, -3};\n    int pred = adaline_predict(&ada, test_x, NULL);\n    printf(\"Predict for x=(5,-3): % d\", pred);\n    assert(pred == -1);\n    printf(\" ...passed\\n\");\n\n    double test_x2[] = {5, 8};\n    pred = adaline_predict(&ada, test_x2, NULL);\n    printf(\"Predict for x=(5, 8): % d\", pred);\n    assert(pred == 1);\n    printf(\" ...passed\\n\");\n\n    // for (int i = 0; i < N; i++)\n    //     free(X[i]);\n    free(X);\n    delete_adaline(&ada);\n}\n\n/**\n * test function to predict points in a 2D coordinate system above the line\n * \\f$x+3y=-1\\f$ as +1 and others as -1.\n * Note that each point is defined by 2 values or 2 features.\n * The function will create random sample points for training and test purposes.\n * \\param[in] eta learning rate (optional, default=0.01)\n */\nvoid test2(double eta)\n{\n    struct adaline ada = new_adaline(2, eta);  // 2 features\n\n    const int N = 50;  // number of sample points\n\n    double **X = (double **)malloc(N * sizeof(double *));\n    int *Y = (int *)malloc(N * sizeof(int));  // corresponding y-values\n    for (int i = 0; i < N; i++) X[i] = (double *)malloc(2 * sizeof(double));\n\n    // generate sample points in the interval\n    // [-range2/100 , (range2-1)/100]\n    int range = 500;          // sample points full-range\n    int range2 = range >> 1;  // sample points half-range\n    for (int i = 0; i < N; i++)\n    {\n        double x0 = ((rand() % range) - range2) / 100.f;\n        double x1 = ((rand() % range) - range2) / 100.f;\n        X[i][0] = x0;\n        X[i][1] = x1;\n        Y[i] = (x0 + 3. * x1) > -1 ? 1 : -1;\n    }\n\n    printf(\"------- Test 2 -------\\n\");\n    printf(\"Model before fit: %s\", adaline_get_weights_str(&ada));\n\n    adaline_fit(&ada, X, Y, N);\n    printf(\"Model after fit: %s\\n\", adaline_get_weights_str(&ada));\n\n    int N_test_cases = 5;\n    double test_x[2];\n    for (int i = 0; i < N_test_cases; i++)\n    {\n        double x0 = ((rand() % range) - range2) / 100.f;\n        double x1 = ((rand() % range) - range2) / 100.f;\n\n        test_x[0] = x0;\n        test_x[1] = x1;\n        int pred = adaline_predict(&ada, test_x, NULL);\n        printf(\"Predict for x=(% 3.2f,% 3.2f): % d\", x0, x1, pred);\n\n        int expected_val = (x0 + 3. * x1) > -1 ? 1 : -1;\n        assert(pred == expected_val);\n        printf(\" ...passed\\n\");\n    }\n\n    for (int i = 0; i < N; i++) free(X[i]);\n    free(X);\n    free(Y);\n    delete_adaline(&ada);\n}\n\n/**\n * test function to predict points in a 3D coordinate system lying within the\n * sphere of radius 1 and centre at origin as +1 and others as -1. Note that\n * each point is defined by 3 values but we use 6 features. The function will\n * create random sample points for training and test purposes.\n * The sphere centred at origin and radius 1 is defined as:\n * \\f$x^2+y^2+z^2=r^2=1\\f$ and if the \\f$r^2<1\\f$, point lies within the sphere\n * else, outside.\n *\n * \\param[in] eta learning rate (optional, default=0.01)\n */\nvoid test3(double eta)\n{\n    struct adaline ada = new_adaline(6, eta);  // 2 features\n\n    const int N = 50;  // number of sample points\n\n    double **X = (double **)malloc(N * sizeof(double *));\n    int *Y = (int *)malloc(N * sizeof(int));  // corresponding y-values\n    for (int i = 0; i < N; i++) X[i] = (double *)malloc(6 * sizeof(double));\n\n    // generate sample points in the interval\n    // [-range2/100 , (range2-1)/100]\n    int range = 200;          // sample points full-range\n    int range2 = range >> 1;  // sample points half-range\n    for (int i = 0; i < N; i++)\n    {\n        double x0 = ((rand() % range) - range2) / 100.f;\n        double x1 = ((rand() % range) - range2) / 100.f;\n        double x2 = ((rand() % range) - range2) / 100.f;\n        X[i][0] = x0;\n        X[i][1] = x1;\n        X[i][2] = x2;\n        X[i][3] = x0 * x0;\n        X[i][4] = x1 * x1;\n        X[i][5] = x2 * x2;\n        Y[i] = (x0 * x0 + x1 * x1 + x2 * x2) <= 1 ? 1 : -1;\n    }\n\n    printf(\"------- Test 3 -------\\n\");\n    printf(\"Model before fit: %s\", adaline_get_weights_str(&ada));\n\n    adaline_fit(&ada, X, Y, N);\n    printf(\"Model after fit: %s\\n\", adaline_get_weights_str(&ada));\n\n    int N_test_cases = 5;\n    double test_x[6];\n    for (int i = 0; i < N_test_cases; i++)\n    {\n        double x0 = ((rand() % range) - range2) / 100.f;\n        double x1 = ((rand() % range) - range2) / 100.f;\n        double x2 = ((rand() % range) - range2) / 100.f;\n        test_x[0] = x0;\n        test_x[1] = x1;\n        test_x[2] = x2;\n        test_x[3] = x0 * x0;\n        test_x[4] = x1 * x1;\n        test_x[5] = x2 * x2;\n        int pred = adaline_predict(&ada, test_x, NULL);\n        printf(\"Predict for x=(% 3.2f,% 3.2f): % d\", x0, x1, pred);\n\n        int expected_val = (x0 * x0 + x1 * x1 + x2 * x2) <= 1 ? 1 : -1;\n        assert(pred == expected_val);\n        printf(\" ...passed\\n\");\n    }\n\n    for (int i = 0; i < N; i++) free(X[i]);\n    free(X);\n    free(Y);\n    delete_adaline(&ada);\n}\n\n/** Main function */\nint main(int argc, char **argv)\n{\n    srand(time(NULL));  // initialize random number generator\n\n    double eta = 0.1;  // default value of eta\n    if (argc == 2)     // read eta value from commandline argument if present\n        eta = strtof(argv[1], NULL);\n\n    test1(eta);\n\n    printf(\"Press ENTER to continue...\\n\");\n    getchar();\n\n    test2(eta);\n\n    printf(\"Press ENTER to continue...\\n\");\n    getchar();\n\n    test3(eta);\n\n    return 0;\n}\n","index":209},{"title":"Kohonen Som Topology","category":"machine_learning","id":"kohonen_som_topology_machine_learning","algorithm":"/**\n * \\file\n * \\brief [Kohonen self organizing\n * map](https://en.wikipedia.org/wiki/Self-organizing_map) (topological map)\n *\n * This example implements a powerful unsupervised learning algorithm called as\n * a self organizing map. The algorithm creates a connected network of weights\n * that closely follows the given data points. This thus creates a topological\n * map of the given data i.e., it maintains the relationship between various\n * data points in a much higher dimensional space by creating an equivalent in a\n * 2-dimensional space.\n * <img alt=\"Trained topological maps for the test cases in the program\"\n * src=\"https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/machine_learning/kohonen/2D_Kohonen_SOM.svg\"\n * />\n * \\author [Krishna Vedala](https://github.com/kvedala)\n * \\warning MSVC 2019 compiler generates code that does not execute as expected.\n * However, MinGW, Clang for GCC and Clang for MSVC compilers on windows perform\n * as expected. Any insights and suggestions should be directed to the author.\n * \\see kohonen_som_trace.c\n */\n#define _USE_MATH_DEFINES /**< required for MS Visual C */\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#ifdef _OPENMP  // check if OpenMP based parallellization is available\n#include <omp.h>\n#endif\n\n/**\n * @addtogroup machine_learning Machine learning algorithms\n * @{\n * @addtogroup kohonen_2d Kohonen SOM topology algorithm\n * @{\n */\n\n#ifndef max\n/** shorthand for maximum value */\n#define max(a, b) (((a) > (b)) ? (a) : (b))\n#endif\n#ifndef min\n/** shorthand for minimum value */\n#define min(a, b) (((a) < (b)) ? (a) : (b))\n#endif\n\n/** to store info regarding 3D arrays */\nstruct kohonen_array_3d\n{\n    int dim1;     /**< lengths of first dimension */\n    int dim2;     /**< lengths of second dimension */\n    int dim3;     /**< lengths of thirddimension */\n    double *data; /**< pointer to data */\n};\n\n/** Function that returns the pointer to (x, y, z) ^th location in the\n * linear 3D array given by:\n * \\f[\n * X_{i,j,k} = i\\times M\\times N + j\\times N + k\n * \\f]\n * where \\f$L\\f$, \\f$M\\f$ and \\f$N\\f$ are the 3D matrix dimensions.\n * \\param[in] arr pointer to ::kohonen_array_3d structure\n * \\param[in] x     first index\n * \\param[in] y     second index\n * \\param[in] z     third index\n * \\returns pointer to (x,y,z)^th location of data\n */\ndouble *kohonen_data_3d(const struct kohonen_array_3d *arr, int x, int y, int z)\n{\n    int offset = (x * arr->dim2 * arr->dim3) + (y * arr->dim3) + z;\n    return arr->data + offset;\n}\n\n/**\n * Helper function to generate a random number in a given interval.\n * \\n Steps:\n * 1. `r1 = rand() % 100` gets a random number between 0 and 99\n * 2. `r2 = r1 / 100` converts random number to be between 0 and 0.99\n * 3. scale and offset the random number to given range of \\f$[a,b)\\f$\n * \\f[\n * y = (b - a) \\times \\frac{\\text{(random number between 0 and RAND_MAX)} \\;\n * \\text{mod}\\; 100}{100} + a \\f]\n *\n * \\param[in] a lower limit\n * \\param[in] b upper limit\n * \\returns random number in the range \\f$[a,b)\\f$\n */\ndouble _random(double a, double b)\n{\n    return ((b - a) * (rand() % 100) / 100.f) + a;\n}\n\n/**\n * Save a given n-dimensional data martix to file.\n *\n * \\param[in] fname filename to save in (gets overwritten without confirmation)\n * \\param[in] X matrix to save\n * \\param[in] num_points rows in the matrix = number of points\n * \\param[in] num_features columns in the matrix = dimensions of points\n * \\returns 0 if all ok\n * \\returns -1 if file creation failed\n */\nint save_2d_data(const char *fname, double **X, int num_points,\n                 int num_features)\n{\n    FILE *fp = fopen(fname, \"wt\");\n    if (!fp)  // error with fopen\n    {\n        char msg[120];\n        sprintf(msg, \"File error (%s): \", fname);\n        perror(msg);\n        return -1;\n    }\n\n    for (int i = 0; i < num_points; i++)  // for each point in the array\n    {\n        for (int j = 0; j < num_features; j++)  // for each feature in the array\n        {\n            fprintf(fp, \"%.4g\", X[i][j]);  // print the feature value\n            if (j < num_features - 1)      // if not the last feature\n                fputc(',', fp);            // suffix comma\n        }\n        if (i < num_points - 1)  // if not the last row\n            fputc('\\n', fp);     // start a new line\n    }\n    fclose(fp);\n    return 0;\n}\n\n/**\n * Create the distance matrix or\n * [U-matrix](https://en.wikipedia.org/wiki/U-matrix) from the trained weights\n * and save to disk.\n *\n * \\param [in] fname filename to save in (gets overwriten without confirmation)\n * \\param [in] W model matrix to save\n * \\returns 0 if all ok\n * \\returns -1 if file creation failed\n */\nint save_u_matrix(const char *fname, struct kohonen_array_3d *W)\n{\n    FILE *fp = fopen(fname, \"wt\");\n    if (!fp)  // error with fopen\n    {\n        char msg[120];\n        sprintf(msg, \"File error (%s): \", fname);\n        perror(msg);\n        return -1;\n    }\n\n    int R = max(W->dim1 >> 3, 2); /* neighborhood range */\n\n    for (int i = 0; i < W->dim1; i++)  // for each x\n    {\n        for (int j = 0; j < W->dim2; j++)  // for each y\n        {\n            double distance = 0.f;\n            int k;\n\n            int from_x = max(0, i - R);\n            int to_x = min(W->dim1, i + R + 1);\n            int from_y = max(0, j - R);\n            int to_y = min(W->dim2, j + R + 1);\n            int l;\n#ifdef _OPENMP\n#pragma omp parallel for reduction(+ : distance)\n#endif\n            for (l = from_x; l < to_x; l++)  // scan neighborhoor in x\n            {\n                for (int m = from_y; m < to_y; m++)  // scan neighborhood in y\n                {\n                    double d = 0.f;\n                    for (k = 0; k < W->dim3; k++)  // for each feature\n                    {\n                        double *w1 = kohonen_data_3d(W, i, j, k);\n                        double *w2 = kohonen_data_3d(W, l, m, k);\n                        d += (w1[0] - w2[0]) * (w1[0] - w2[0]);\n                        // distance += w1[0] * w1[0];\n                    }\n                    distance += sqrt(d);\n                    // distance += d;\n                }\n            }\n\n            distance /= R * R;              // mean distance from neighbors\n            fprintf(fp, \"%.4g\", distance);  // print the mean separation\n            if (j < W->dim2 - 1)            // if not the last column\n                fputc(',', fp);             // suffix comma\n        }\n        if (i < W->dim1 - 1)  // if not the last row\n            fputc('\\n', fp);  // start a new line\n    }\n    fclose(fp);\n    return 0;\n}\n\n/**\n * Get minimum value and index of the value in a matrix\n * \\param[in] X matrix to search\n * \\param[in] N number of points in the vector\n * \\param[out] val minimum value found\n * \\param[out] x_idx x-index where minimum value was found\n * \\param[out] y_idx y-index where minimum value was found\n */\nvoid get_min_2d(double **X, int N, double *val, int *x_idx, int *y_idx)\n{\n    val[0] = INFINITY;  // initial min value\n\n    for (int i = 0; i < N; i++)  // traverse each x-index\n    {\n        for (int j = 0; j < N; j++)  // traverse each y-index\n        {\n            if (X[i][j] < val[0])  // if a lower value is found\n            {                      // save the value and its index\n                x_idx[0] = i;\n                y_idx[0] = j;\n                val[0] = X[i][j];\n            }\n        }\n    }\n}\n\n/**\n * Update weights of the SOM using Kohonen algorithm\n *\n * \\param[in] X data point\n * \\param[in,out] W weights matrix\n * \\param[in,out] D temporary vector to store distances\n * \\param[in] num_out number of output points\n * \\param[in] num_features number of features per input sample\n * \\param[in] alpha learning rate \\f$0<\\alpha\\le1\\f$\n * \\param[in] R neighborhood range\n * \\returns minimum distance of sample and trained weights\n */\ndouble kohonen_update_weights(const double *X, struct kohonen_array_3d *W,\n                              double **D, int num_out, int num_features,\n                              double alpha, int R)\n{\n    int x, y, k;\n    double d_min = 0.f;\n\n#ifdef _OPENMP\n#pragma omp for\n#endif\n    // step 1: for each 2D output point\n    for (x = 0; x < num_out; x++)\n    {\n        for (y = 0; y < num_out; y++)\n        {\n            D[x][y] = 0.f;\n            // compute Euclidian distance of each output\n            // point from the current sample\n            for (k = 0; k < num_features; k++)\n            {\n                double *w = kohonen_data_3d(W, x, y, k);\n                D[x][y] += (w[0] - X[k]) * (w[0] - X[k]);\n            }\n            D[x][y] = sqrt(D[x][y]);\n        }\n    }\n\n    // step 2:  get closest node i.e., node with smallest Euclidian distance to\n    // the current pattern\n    int d_min_x, d_min_y;\n    get_min_2d(D, num_out, &d_min, &d_min_x, &d_min_y);\n\n    // step 3a: get the neighborhood range\n    int from_x = max(0, d_min_x - R);\n    int to_x = min(num_out, d_min_x + R + 1);\n    int from_y = max(0, d_min_y - R);\n    int to_y = min(num_out, d_min_y + R + 1);\n\n    // step 3b: update the weights of nodes in the\n    // neighborhood\n#ifdef _OPENMP\n#pragma omp for\n#endif\n    for (x = from_x; x < to_x; x++)\n    {\n        for (y = from_y; y < to_y; y++)\n        {\n            /* you can enable the following normalization if needed.\n               personally, I found it detrimental to convergence */\n            // const double s2pi = sqrt(2.f * M_PI);\n            // double normalize = 1.f / (alpha * s2pi);\n\n            /* apply scaling inversely proportional to distance from the\n               current node */\n            double d2 =\n                (d_min_x - x) * (d_min_x - x) + (d_min_y - y) * (d_min_y - y);\n            double scale_factor = exp(-d2 / (2.f * alpha * alpha));\n\n            for (k = 0; k < num_features; k++)\n            {\n                double *w = kohonen_data_3d(W, x, y, k);\n                // update weights of nodes in the neighborhood\n                w[0] += alpha * scale_factor * (X[k] - w[0]);\n            }\n        }\n    }\n    return d_min;\n}\n\n/**\n * Apply incremental algorithm with updating neighborhood and learning rates\n * on all samples in the given datset.\n *\n * \\param[in] X data set\n * \\param[in,out] W weights matrix\n * \\param[in] num_samples number of output points\n * \\param[in] num_features number of features per input sample\n * \\param[in] num_out number of output points\n * \\param[in] alpha_min terminal value of alpha\n */\nvoid kohonen_som(double **X, struct kohonen_array_3d *W, int num_samples,\n                 int num_features, int num_out, double alpha_min)\n{\n    int R = num_out >> 2, iter = 0;\n    double **D = (double **)malloc(num_out * sizeof(double *));\n    for (int i = 0; i < num_out; i++)\n        D[i] = (double *)malloc(num_out * sizeof(double));\n\n    double dmin = 1.f;  // average minimum distance of all samples\n\n    // Loop alpha from 1 to slpha_min\n    for (double alpha = 1.f; alpha > alpha_min && dmin > 1e-3;\n         alpha -= 0.001, iter++)\n    {\n        dmin = 0.f;\n        // Loop for each sample pattern in the data set\n        for (int sample = 0; sample < num_samples; sample++)\n        {\n            // update weights for the current input pattern sample\n            dmin += kohonen_update_weights(X[sample], W, D, num_out,\n                                           num_features, alpha, R);\n        }\n\n        // every 20th iteration, reduce the neighborhood range\n        if (iter % 100 == 0 && R > 1)\n            R--;\n\n        dmin /= num_samples;\n        printf(\"iter: %5d\\t alpha: %.4g\\t R: %d\\td_min: %.4g\\r\", iter, alpha, R,\n               dmin);\n    }\n    putchar('\\n');\n\n    for (int i = 0; i < num_out; i++) free(D[i]);\n    free(D);\n}\n\n/**\n * @}\n * @}\n */\n\n/** Creates a random set of points distributed in four clusters in\n * 3D space with centroids at the points\n * * \\f$(0,5, 0.5, 0.5)\\f$\n * * \\f$(0,5,-0.5, -0.5)\\f$\n * * \\f$(-0,5, 0.5, 0.5)\\f$\n * * \\f$(-0,5,-0.5, -0.5)\\f$\n *\n * \\param[out] data matrix to store data in\n * \\param[in] N number of points required\n */\nvoid test_2d_classes(double *const *data, int N)\n{\n    const double R = 0.3;  // radius of cluster\n    int i;\n    const int num_classes = 4;\n    const double centres[][2] = {\n        // centres of each class cluster\n        {.5, .5},   // centre of class 1\n        {.5, -.5},  // centre of class 2\n        {-.5, .5},  // centre of class 3\n        {-.5, -.5}  // centre of class 4\n    };\n\n#ifdef _OPENMP\n#pragma omp for\n#endif\n    for (i = 0; i < N; i++)\n    {\n        int class =\n            rand() % num_classes;  // select a random class for the point\n\n        // create random coordinates (x,y,z) around the centre of the class\n        data[i][0] = _random(centres[class][0] - R, centres[class][0] + R);\n        data[i][1] = _random(centres[class][1] - R, centres[class][1] + R);\n\n        /* The follosing can also be used\n        for (int j = 0; j < 2; j++)\n            data[i][j] = _random(centres[class][j] - R, centres[class][j] + R);\n        */\n    }\n}\n\n/** Test that creates a random set of points distributed in four clusters in\n * 2D space and trains an SOM that finds the topological pattern.\n * The following [CSV](https://en.wikipedia.org/wiki/Comma-separated_values)\n * files are created to validate the execution:\n * * `test1.csv`: random test samples points with a circular pattern\n * * `w11.csv`: initial random U-matrix\n * * `w12.csv`: trained SOM U-matrix\n */\nvoid test1()\n{\n    int j, N = 300;\n    int features = 2;\n    int num_out = 30;  // image size - N x N\n\n    // 2D space, hence size = number of rows * 2\n    double **X = (double **)malloc(N * sizeof(double *));\n\n    // cluster nodex in 'x' * cluster nodes in 'y' * 2\n    struct kohonen_array_3d W;\n    W.dim1 = num_out;\n    W.dim2 = num_out;\n    W.dim3 = features;\n    W.data = (double *)malloc(num_out * num_out * features *\n                              sizeof(double));  // assign rows\n\n    for (int i = 0; i < max(num_out, N); i++)  // loop till max(N, num_out)\n    {\n        if (i < N)  // only add new arrays if i < N\n            X[i] = (double *)malloc(features * sizeof(double));\n        if (i < num_out)  // only add new arrays if i < num_out\n        {\n            for (int k = 0; k < num_out; k++)\n            {\n#ifdef _OPENMP\n#pragma omp for\n#endif\n                // preallocate with random initial weights\n                for (j = 0; j < features; j++)\n                {\n                    double *w = kohonen_data_3d(&W, i, k, j);\n                    w[0] = _random(-5, 5);\n                }\n            }\n        }\n    }\n\n    test_2d_classes(X, N);  // create test data around circumference of a circle\n    save_2d_data(\"test1.csv\", X, N, features);  // save test data points\n    save_u_matrix(\"w11.csv\", &W);               // save initial random weights\n    kohonen_som(X, &W, N, features, num_out, 1e-4);  // train the SOM\n    save_u_matrix(\"w12.csv\", &W);  // save the resultant weights\n\n    for (int i = 0; i < N; i++) free(X[i]);\n    free(X);\n    free(W.data);\n}\n\n/** Creates a random set of points distributed in four clusters in\n * 3D space with centroids at the points\n * * \\f$(0,5, 0.5, 0.5)\\f$\n * * \\f$(0,5,-0.5, -0.5)\\f$\n * * \\f$(-0,5, 0.5, 0.5)\\f$\n * * \\f$(-0,5,-0.5, -0.5)\\f$\n *\n * \\param[out] data matrix to store data in\n * \\param[in] N number of points required\n */\nvoid test_3d_classes1(double *const *data, int N)\n{\n    const double R = 0.2;  // radius of cluster\n    int i;\n    const int num_classes = 4;\n    const double centres[][3] = {\n        // centres of each class cluster\n        {.5, .5, .5},    // centre of class 1\n        {.5, -.5, -.5},  // centre of class 2\n        {-.5, .5, .5},   // centre of class 3\n        {-.5, -.5 - .5}  // centre of class 4\n    };\n\n#ifdef _OPENMP\n#pragma omp for\n#endif\n    for (i = 0; i < N; i++)\n    {\n        int class =\n            rand() % num_classes;  // select a random class for the point\n\n        // create random coordinates (x,y,z) around the centre of the class\n        data[i][0] = _random(centres[class][0] - R, centres[class][0] + R);\n        data[i][1] = _random(centres[class][1] - R, centres[class][1] + R);\n        data[i][2] = _random(centres[class][2] - R, centres[class][2] + R);\n\n        /* The follosing can also be used\n        for (int j = 0; j < 3; j++)\n            data[i][j] = _random(centres[class][j] - R, centres[class][j] + R);\n        */\n    }\n}\n\n/** Test that creates a random set of points distributed in 4 clusters in\n * 3D space and trains an SOM that finds the topological pattern. The following\n * [CSV](https://en.wikipedia.org/wiki/Comma-separated_values) files are created\n * to validate the execution:\n * * `test2.csv`: random test samples points\n * * `w21.csv`: initial random U-matrix\n * * `w22.csv`: trained SOM U-matrix\n */\nvoid test2()\n{\n    int j, N = 500;\n    int features = 3;\n    int num_out = 30;  // image size - N x N\n\n    // 3D space, hence size = number of rows * 3\n    double **X = (double **)malloc(N * sizeof(double *));\n\n    // cluster nodex in 'x' * cluster nodes in 'y' * 2\n    struct kohonen_array_3d W;\n    W.dim1 = num_out;\n    W.dim2 = num_out;\n    W.dim3 = features;\n    W.data = (double *)malloc(num_out * num_out * features *\n                              sizeof(double));  // assign rows\n\n    for (int i = 0; i < max(num_out, N); i++)  // loop till max(N, num_out)\n    {\n        if (i < N)  // only add new arrays if i < N\n            X[i] = (double *)malloc(features * sizeof(double));\n        if (i < num_out)  // only add new arrays if i < num_out\n        {\n            for (int k = 0; k < num_out; k++)\n            {\n#ifdef _OPENMP\n#pragma omp for\n#endif\n                for (j = 0; j < features; j++)\n                {  // preallocate with random initial weights\n                    double *w = kohonen_data_3d(&W, i, k, j);\n                    w[0] = _random(-5, 5);\n                }\n            }\n        }\n    }\n\n    test_3d_classes1(X, N);                     // create test data\n    save_2d_data(\"test2.csv\", X, N, features);  // save test data points\n    save_u_matrix(\"w21.csv\", &W);               // save initial random weights\n    kohonen_som(X, &W, N, features, num_out, 1e-4);  // train the SOM\n    save_u_matrix(\"w22.csv\", &W);  // save the resultant weights\n\n    for (int i = 0; i < N; i++) free(X[i]);\n    free(X);\n    free(W.data);\n}\n\n/** Creates a random set of points distributed in four clusters in\n * 3D space with centroids at the points\n * * \\f$(0,5, 0.5, 0.5)\\f$\n * * \\f$(0,5,-0.5, -0.5)\\f$\n * * \\f$(-0,5, 0.5, 0.5)\\f$\n * * \\f$(-0,5,-0.5, -0.5)\\f$\n *\n * \\param[out] data matrix to store data in\n * \\param[in] N number of points required\n */\nvoid test_3d_classes2(double *const *data, int N)\n{\n    const double R = 0.2;  // radius of cluster\n    int i;\n    const int num_classes = 8;\n    const double centres[][3] = {\n        // centres of each class cluster\n        {.5, .5, .5},    // centre of class 1\n        {.5, .5, -.5},   // centre of class 2\n        {.5, -.5, .5},   // centre of class 3\n        {.5, -.5, -.5},  // centre of class 4\n        {-.5, .5, .5},   // centre of class 5\n        {-.5, .5, -.5},  // centre of class 6\n        {-.5, -.5, .5},  // centre of class 7\n        {-.5, -.5, -.5}  // centre of class 8\n    };\n\n#ifdef _OPENMP\n#pragma omp for\n#endif\n    for (i = 0; i < N; i++)\n    {\n        int class =\n            rand() % num_classes;  // select a random class for the point\n\n        // create random coordinates (x,y,z) around the centre of the class\n        data[i][0] = _random(centres[class][0] - R, centres[class][0] + R);\n        data[i][1] = _random(centres[class][1] - R, centres[class][1] + R);\n        data[i][2] = _random(centres[class][2] - R, centres[class][2] + R);\n\n        /* The follosing can also be used\n        for (int j = 0; j < 3; j++)\n            data[i][j] = _random(centres[class][j] - R, centres[class][j] + R);\n        */\n    }\n}\n\n/** Test that creates a random set of points distributed in eight clusters in\n * 3D space and trains an SOM that finds the topological pattern. The following\n * [CSV](https://en.wikipedia.org/wiki/Comma-separated_values) files are created\n * to validate the execution:\n * * `test3.csv`: random test samples points\n * * `w31.csv`: initial random U-matrix\n * * `w32.csv`: trained SOM U-matrix\n */\nvoid test3()\n{\n    int j, N = 500;\n    int features = 3;\n    int num_out = 30;\n    double **X = (double **)malloc(N * sizeof(double *));\n\n    // cluster nodex in 'x' * cluster nodes in 'y' * 2\n    struct kohonen_array_3d W;\n    W.dim1 = num_out;\n    W.dim2 = num_out;\n    W.dim3 = features;\n    W.data = (double *)malloc(num_out * num_out * features *\n                              sizeof(double));  // assign rows\n\n    for (int i = 0; i < max(num_out, N); i++)  // loop till max(N, num_out)\n    {\n        if (i < N)  // only add new arrays if i < N\n            X[i] = (double *)malloc(features * sizeof(double));\n        if (i < num_out)  // only add new arrays if i < num_out\n        {\n            for (int k = 0; k < num_out; k++)\n            {\n#ifdef _OPENMP\n#pragma omp for\n#endif\n                // preallocate with random initial weights\n                for (j = 0; j < features; j++)\n                {\n                    double *w = kohonen_data_3d(&W, i, k, j);\n                    w[0] = _random(-5, 5);\n                }\n            }\n        }\n    }\n\n    test_3d_classes2(X, N);  // create test data around the lamniscate\n    save_2d_data(\"test3.csv\", X, N, features);  // save test data points\n    save_u_matrix(\"w31.csv\", &W);               // save initial random weights\n    kohonen_som(X, &W, N, features, num_out, 0.01);  // train the SOM\n    save_u_matrix(\"w32.csv\", &W);  // save the resultant weights\n\n    for (int i = 0; i < N; i++) free(X[i]);\n    free(X);\n    free(W.data);\n}\n\n/**\n * Convert clock cycle difference to time in seconds\n *\n * \\param[in] start_t start clock\n * \\param[in] end_t end clock\n * \\returns time difference in seconds\n */\ndouble get_clock_diff(clock_t start_t, clock_t end_t)\n{\n    return (double)(end_t - start_t) / (double)CLOCKS_PER_SEC;\n}\n\n/** Main function */\nint main(int argc, char **argv)\n{\n#ifdef _OPENMP\n    printf(\"Using OpenMP based parallelization\\n\");\n#else\n    printf(\"NOT using OpenMP based parallelization\\n\");\n#endif\n    clock_t start_clk, end_clk;\n\n    start_clk = clock();\n    test1();\n    end_clk = clock();\n    printf(\"Test 1 completed in %.4g sec\\n\",\n           get_clock_diff(start_clk, end_clk));\n\n    start_clk = clock();\n    test2();\n    end_clk = clock();\n    printf(\"Test 2 completed in %.4g sec\\n\",\n           get_clock_diff(start_clk, end_clk));\n\n    start_clk = clock();\n    test3();\n    end_clk = clock();\n    printf(\"Test 3 completed in %.4g sec\\n\",\n           get_clock_diff(start_clk, end_clk));\n\n    printf(\"(Note: Calculated times include: writing files to disk.)\\n\\n\");\n    return 0;\n}\n","index":210},{"title":"Kohonen Som Trace","category":"machine_learning","id":"kohonen_som_trace_machine_learning","algorithm":"/**\n * \\file\n * \\brief [Kohonen self organizing\n * map](https://en.wikipedia.org/wiki/Self-organizing_map) (data tracing)\n *\n * \\details\n * This example implements a powerful self organizing map algorithm.\n * The algorithm creates a connected network of weights that closely\n * follows the given data points. This this creates a chain of nodes that\n * resembles the given input shape.\n * \\author [Krishna Vedala](https://github.com/kvedala)\n * \\see kohonen_som_topology.c\n */\n#define _USE_MATH_DEFINES /**< required for MS Visual C */\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#ifdef _OPENMP  // check if OpenMP based parallelization is available\n#include <omp.h>\n#endif\n\n/**\n * @addtogroup machine_learning Machine learning algorithms\n * @{\n * @addtogroup kohonen_1d Kohonen SOM trace/chain algorithm\n * @{\n */\n\n#ifndef max\n/** shorthand for maximum value */\n#define max(a, b) (((a) > (b)) ? (a) : (b))\n#endif\n#ifndef min\n/** shorthand for minimum value */\n#define min(a, b) (((a) < (b)) ? (a) : (b))\n#endif\n\n/**\n * \\brief Helper function to generate a random number in a given interval.\n * \\details\n * \\n Steps:\n * 1. `r1 = rand() % 100` gets a random number between 0 and 99\n * 2. `r2 = r1 / 100` converts random number to be between 0 and 0.99\n * 3. scale and offset the random number to given range of \\f$[a,b)\\f$\n * \\f[\n * y = (b - a) \\times \\frac{\\text{(random number between 0 and RAND_MAX)} \\;\n * \\text{mod}\\; 100}{100} + a \\f]\n *\n * \\param a lower limit\n * \\param b upper limit\n * \\returns random number in the range \\f$[a,b)\\f$\n */\ndouble _random(double a, double b)\n{\n    int r = rand() % 100;\n    return ((b - a) * r / 100.f) + a;\n}\n\n/**\n * Save a given n-dimensional data martix to file.\n *\n * \\param [in] fname filename to save in (gets overwriten without confirmation)\n * \\param [in] X matrix to save\n * \\param [in] num_points rows in the matrix = number of points\n * \\param [in] num_features columns in the matrix = dimensions of points\n * \\returns 0 if all ok\n * \\returns -1 if file creation failed\n */\nint save_nd_data(const char *fname, double **X, int num_points,\n                 int num_features)\n{\n    FILE *fp = fopen(fname, \"wt\");\n    if (!fp)  // error with fopen\n    {\n        char msg[120];\n        sprintf(msg, \"File error (%s): \", fname);\n        perror(msg);\n        return -1;\n    }\n\n    for (int i = 0; i < num_points; i++)  // for each point in the array\n    {\n        for (int j = 0; j < num_features; j++)  // for each feature in the array\n        {\n            fprintf(fp, \"%.4g\", X[i][j]);  // print the feature value\n            if (j < num_features - 1)      // if not the last feature\n                fprintf(fp, \",\");          // suffix comma\n        }\n        if (i < num_points - 1)  // if not the last row\n            fprintf(fp, \"\\n\");   // start a new line\n    }\n    fclose(fp);\n    return 0;\n}\n\n/**\n * Get minimum value and index of the value in a vector\n * \\param[in] X vector to search\n * \\param[in] N number of points in the vector\n * \\param[out] val minimum value found\n * \\param[out] idx index where minimum value was found\n */\nvoid kohonen_get_min_1d(double const *X, int N, double *val, int *idx)\n{\n    val[0] = INFINITY;  // initial min value\n\n    for (int i = 0; i < N; i++)  // check each value\n    {\n        if (X[i] < val[0])  // if a lower value is found\n        {                   // save the value and its index\n            idx[0] = i;\n            val[0] = X[i];\n        }\n    }\n}\n\n/**\n * Update weights of the SOM using Kohonen algorithm\n *\n * \\param[in] x data point\n * \\param[in,out] W weights matrix\n * \\param[in,out] D temporary vector to store distances\n * \\param[in] num_out number of output points\n * \\param[in] num_features number of features per input sample\n * \\param[in] alpha learning rate \\f$0<\\alpha\\le1\\f$\n * \\param[in] R neighborhood range\n */\nvoid kohonen_update_weights(double const *x, double *const *W, double *D,\n                            int num_out, int num_features, double alpha, int R)\n{\n    int j, k;\n\n#ifdef _OPENMP\n#pragma omp for\n#endif\n    // step 1: for each output point\n    for (j = 0; j < num_out; j++)\n    {\n        D[j] = 0.f;\n        // compute Euclidian distance of each output\n        // point from the current sample\n        for (k = 0; k < num_features; k++)\n            D[j] += (W[j][k] - x[k]) * (W[j][k] - x[k]);\n    }\n\n    // step 2:  get closest node i.e., node with smallest Euclidian distance to\n    // the current pattern\n    int d_min_idx;\n    double d_min;\n    kohonen_get_min_1d(D, num_out, &d_min, &d_min_idx);\n\n    // step 3a: get the neighborhood range\n    int from_node = max(0, d_min_idx - R);\n    int to_node = min(num_out, d_min_idx + R + 1);\n\n    // step 3b: update the weights of nodes in the\n    // neighborhood\n#ifdef _OPENMP\n#pragma omp for\n#endif\n    for (j = from_node; j < to_node; j++)\n        for (k = 0; k < num_features; k++)\n            // update weights of nodes in the neighborhood\n            W[j][k] += alpha * (x[k] - W[j][k]);\n}\n\n/**\n * Apply incremental algorithm with updating neighborhood and learning rates\n * on all samples in the given datset.\n *\n * \\param[in] X data set\n * \\param[in,out] W weights matrix\n * \\param[in] num_samples number of output points\n * \\param[in] num_features number of features per input sample\n * \\param[in] num_out number of output points\n * \\param[in] alpha_min terminal value of alpha\n */\nvoid kohonen_som_tracer(double **X, double *const *W, int num_samples,\n                        int num_features, int num_out, double alpha_min)\n{\n    int R = num_out >> 2, iter = 0;\n    double alpha = 1.f;\n    double *D = (double *)malloc(num_out * sizeof(double));\n\n    // Loop alpha from 1 to alpha_min\n    for (; alpha > alpha_min; alpha -= 0.01, iter++)\n    {\n        // Loop for each sample pattern in the data set\n        for (int sample = 0; sample < num_samples; sample++)\n        {\n            const double *x = X[sample];\n            // update weights for the current input pattern sample\n            kohonen_update_weights(x, W, D, num_out, num_features, alpha, R);\n        }\n\n        // every 10th iteration, reduce the neighborhood range\n        if (iter % 10 == 0 && R > 1)\n            R--;\n    }\n\n    free(D);\n}\n\n/**\n * @}\n * @}\n */\n\n/** Creates a random set of points distributed *near* the circumference\n * of a circle and trains an SOM that finds that circular pattern. The\n * generating function is\n * \\f{eqnarray*}{\n * r &\\in& [1-\\delta r, 1+\\delta r)\\\\\n * \\theta &\\in& [0, 2\\pi)\\\\\n * x &=& r\\cos\\theta\\\\\n * y &=& r\\sin\\theta\n * \\f}\n *\n * \\param[out] data matrix to store data in\n * \\param[in] N number of points required\n */\nvoid test_circle(double *const *data, int N)\n{\n    const double R = 0.75, dr = 0.3;\n    double a_t = 0., b_t = 2.f * M_PI;  // theta random between 0 and 2*pi\n    double a_r = R - dr, b_r = R + dr;  // radius random between R-dr and R+dr\n    int i;\n\n#ifdef _OPENMP\n#pragma omp for\n#endif\n    for (i = 0; i < N; i++)\n    {\n        double r = _random(a_r, b_r);      // random radius\n        double theta = _random(a_t, b_t);  // random theta\n        data[i][0] = r * cos(theta);       // convert from polar to cartesian\n        data[i][1] = r * sin(theta);\n    }\n}\n\n/** Test that creates a random set of points distributed *near* the\n * circumference of a circle and trains an SOM that finds that circular pattern.\n * The following [CSV](https://en.wikipedia.org/wiki/Comma-separated_values)\n * files are created to validate the execution:\n * * `test1.csv`: random test samples points with a circular pattern\n * * `w11.csv`: initial random map\n * * `w12.csv`: trained SOM map\n *\n * The outputs can be readily plotted in [gnuplot](https:://gnuplot.info) using\n * the following snippet\n * ```gnuplot\n * set datafile separator ','\n * plot \"test1.csv\" title \"original\", \\\n *      \"w11.csv\" title \"w1\", \\\n *      \"w12.csv\" title \"w2\"\n * ```\n * ![Sample execution\n * output](https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/machine_learning/kohonen/test1.svg)\n */\nvoid test1()\n{\n    int j, N = 500;\n    int features = 2;\n    int num_out = 50;\n\n    // 2D space, hence size = number of rows * 2\n    double **X = (double **)malloc(N * sizeof(double *));\n\n    // number of clusters nodes * 2\n    double **W = (double **)malloc(num_out * sizeof(double *));\n\n    for (int i = 0; i < max(num_out, N); i++)  // loop till max(N, num_out)\n    {\n        if (i < N)  // only add new arrays if i < N\n            X[i] = (double *)malloc(features * sizeof(double));\n        if (i < num_out)  // only add new arrays if i < num_out\n        {\n            W[i] = (double *)malloc(features * sizeof(double));\n#ifdef _OPENMP\n#pragma omp for\n#endif\n            // preallocate with random initial weights\n            for (j = 0; j < features; j++) W[i][j] = _random(-1, 1);\n        }\n    }\n\n    test_circle(X, N);  // create test data around circumference of a circle\n    save_nd_data(\"test1.csv\", X, N, features);  // save test data points\n    save_nd_data(\"w11.csv\", W, num_out,\n                 features);  // save initial random weights\n    kohonen_som_tracer(X, W, N, features, num_out, 0.1);  // train the SOM\n    save_nd_data(\"w12.csv\", W, num_out,\n                 features);  // save the resultant weights\n\n    for (int i = 0; i < max(num_out, N); i++)\n    {\n        if (i < N)\n            free(X[i]);\n        if (i < num_out)\n            free(W[i]);\n    }\n}\n\n/** Creates a random set of points distributed *near* the locus\n * of the [Lamniscate of\n * Gerono](https://en.wikipedia.org/wiki/Lemniscate_of_Gerono).\n * \\f{eqnarray*}{\n * \\delta r &=& 0.2\\\\\n * \\delta x &\\in& [-\\delta r, \\delta r)\\\\\n * \\delta y &\\in& [-\\delta r, \\delta r)\\\\\n * \\theta &\\in& [0, \\pi)\\\\\n * x &=& \\delta x + \\cos\\theta\\\\\n * y &=& \\delta y + \\frac{\\sin(2\\theta)}{2}\n * \\f}\n * \\param[out] data matrix to store data in\n * \\param[in] N number of points required\n */\nvoid test_lamniscate(double *const *data, int N)\n{\n    const double dr = 0.2;\n    int i;\n\n#ifdef _OPENMP\n#pragma omp for\n#endif\n    for (i = 0; i < N; i++)\n    {\n        double dx = _random(-dr, dr);     // random change in x\n        double dy = _random(-dr, dr);     // random change in y\n        double theta = _random(0, M_PI);  // random theta\n        data[i][0] = dx + cos(theta);     // convert from polar to cartesian\n        data[i][1] = dy + sin(2. * theta) / 2.f;\n    }\n}\n\n/** Test that creates a random set of points distributed *near* the locus\n * of the [Lamniscate of\n * Gerono](https://en.wikipedia.org/wiki/Lemniscate_of_Gerono) and trains an SOM\n * that finds that circular pattern. The following\n * [CSV](https://en.wikipedia.org/wiki/Comma-separated_values) files are created\n * to validate the execution:\n * * `test2.csv`: random test samples points with a lamniscate pattern\n * * `w21.csv`: initial random map\n * * `w22.csv`: trained SOM map\n *\n * The outputs can be readily plotted in [gnuplot](https:://gnuplot.info) using\n * the following snippet\n * ```gnuplot\n * set datafile separator ','\n * plot \"test2.csv\" title \"original\", \\\n *      \"w21.csv\" title \"w1\", \\\n *      \"w22.csv\" title \"w2\"\n * ```\n * ![Sample execution\n * output](https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/machine_learning/kohonen/test2.svg)\n */\nvoid test2()\n{\n    int j, N = 500;\n    int features = 2;\n    int num_out = 20;\n    double **X = (double **)malloc(N * sizeof(double *));\n    double **W = (double **)malloc(num_out * sizeof(double *));\n    for (int i = 0; i < max(num_out, N); i++)\n    {\n        if (i < N)  // only add new arrays if i < N\n            X[i] = (double *)malloc(features * sizeof(double));\n        if (i < num_out)  // only add new arrays if i < num_out\n        {\n            W[i] = (double *)malloc(features * sizeof(double));\n\n#ifdef _OPENMP\n#pragma omp for\n#endif\n            // preallocate with random initial weights\n            for (j = 0; j < features; j++) W[i][j] = _random(-1, 1);\n        }\n    }\n\n    test_lamniscate(X, N);  // create test data around the lamniscate\n    save_nd_data(\"test2.csv\", X, N, features);  // save test data points\n    save_nd_data(\"w21.csv\", W, num_out,\n                 features);  // save initial random weights\n    kohonen_som_tracer(X, W, N, features, num_out, 0.01);  // train the SOM\n    save_nd_data(\"w22.csv\", W, num_out,\n                 features);  // save the resultant weights\n\n    for (int i = 0; i < max(num_out, N); i++)\n    {\n        if (i < N)\n            free(X[i]);\n        if (i < num_out)\n            free(W[i]);\n    }\n    free(X);\n    free(W);\n}\n\n/** Creates a random set of points distributed in four clusters in\n * 3D space with centroids at the points\n * * \\f$(0,5, 0.5, 0.5)\\f$\n * * \\f$(0,5,-0.5, -0.5)\\f$\n * * \\f$(-0,5, 0.5, 0.5)\\f$\n * * \\f$(-0,5,-0.5, -0.5)\\f$\n *\n * \\param[out] data matrix to store data in\n * \\param[in] N number of points required\n */\nvoid test_3d_classes(double *const *data, int N)\n{\n    const double R = 0.1;  // radius of cluster\n    int i;\n    const int num_classes = 4;\n    const double centres[][3] = {\n        // centres of each class cluster\n        {.5, .5, .5},    // centre of class 1\n        {.5, -.5, -.5},  // centre of class 2\n        {-.5, .5, .5},   // centre of class 3\n        {-.5, -.5 - .5}  // centre of class 4\n    };\n\n#ifdef _OPENMP\n#pragma omp for\n#endif\n    for (i = 0; i < N; i++)\n    {\n        int class =\n            rand() % num_classes;  // select a random class for the point\n\n        // create random coordinates (x,y,z) around the centre of the class\n        data[i][0] = _random(centres[class][0] - R, centres[class][0] + R);\n        data[i][1] = _random(centres[class][1] - R, centres[class][1] + R);\n        data[i][2] = _random(centres[class][2] - R, centres[class][2] + R);\n\n        /* The follosing can also be used\n        for (int j = 0; j < 3; j++)\n            data[i][j] = _random(centres[class][j] - R, centres[class][j] + R);\n        */\n    }\n}\n\n/** Test that creates a random set of points distributed in six clusters in\n * 3D space. The following\n * [CSV](https://en.wikipedia.org/wiki/Comma-separated_values) files are created\n * to validate the execution:\n * * `test3.csv`: random test samples points with a circular pattern\n * * `w31.csv`: initial random map\n * * `w32.csv`: trained SOM map\n *\n * The outputs can be readily plotted in [gnuplot](https:://gnuplot.info) using\n * the following snippet\n * ```gnuplot\n * set datafile separator ','\n * plot \"test3.csv\" title \"original\", \\\n *      \"w31.csv\" title \"w1\", \\\n *      \"w32.csv\" title \"w2\"\n * ```\n * ![Sample execution\n * output](https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/machine_learning/kohonen/test3.svg)\n */\nvoid test3()\n{\n    int j, N = 200;\n    int features = 3;\n    int num_out = 20;\n    double **X = (double **)malloc(N * sizeof(double *));\n    double **W = (double **)malloc(num_out * sizeof(double *));\n    for (int i = 0; i < max(num_out, N); i++)\n    {\n        if (i < N)  // only add new arrays if i < N\n            X[i] = (double *)malloc(features * sizeof(double));\n        if (i < num_out)  // only add new arrays if i < num_out\n        {\n            W[i] = (double *)malloc(features * sizeof(double));\n\n#ifdef _OPENMP\n#pragma omp for\n#endif\n            // preallocate with random initial weights\n            for (j = 0; j < features; j++) W[i][j] = _random(-1, 1);\n        }\n    }\n\n    test_3d_classes(X, N);  // create test data around the lamniscate\n    save_nd_data(\"test3.csv\", X, N, features);  // save test data points\n    save_nd_data(\"w31.csv\", W, num_out,\n                 features);  // save initial random weights\n    kohonen_som_tracer(X, W, N, features, num_out, 0.01);  // train the SOM\n    save_nd_data(\"w32.csv\", W, num_out,\n                 features);  // save the resultant weights\n\n    for (int i = 0; i < max(num_out, N); i++)\n    {\n        if (i < N)\n            free(X[i]);\n        if (i < num_out)\n            free(W[i]);\n    }\n    free(X);\n    free(W);\n}\n\n/**\n * Convert clock cycle difference to time in seconds\n *\n * \\param[in] start_t start clock\n * \\param[in] end_t end clock\n * \\returns time difference in seconds\n */\ndouble get_clock_diff(clock_t start_t, clock_t end_t)\n{\n    return (double)(end_t - start_t) / (double)CLOCKS_PER_SEC;\n}\n\n/** Main function */\nint main(int argc, char **argv)\n{\n#ifdef _OPENMP\n    printf(\"Using OpenMP based parallelization\\n\");\n#else\n    printf(\"NOT using OpenMP based parallelization\\n\");\n#endif\n    clock_t start_clk = clock();\n    test1();\n    clock_t end_clk = clock();\n    printf(\"Test 1 completed in %.4g sec\\n\",\n           get_clock_diff(start_clk, end_clk));\n    start_clk = clock();\n    test2();\n    end_clk = clock();\n    printf(\"Test 2 completed in %.4g sec\\n\",\n           get_clock_diff(start_clk, end_clk));\n    start_clk = clock();\n    test3();\n    end_clk = clock();\n    printf(\"Test 3 completed in %.4g sec\\n\",\n           get_clock_diff(start_clk, end_clk));\n    printf(\n        \"(Note: Calculated times include: creating test sets, training \"\n        \"model and writing files to disk.)\\n\\n\");\n    return 0;\n}\n","index":211},{"title":"K Means Clustering","category":"machine_learning","id":"k_means_clustering_machine_learning","algorithm":"/**\n * @file k_means_clustering.c\n * @brief K Means Clustering Algorithm implemented\n * @details\n * This file has K Means algorithm implemmented\n * It prints test output in eps format\n *\n * Note:\n * Though the code for clustering works for all the\n * 2D data points and can be extended for any size vector\n * by making the required changes, but note that\n * the output method i.e. printEPS is only good for\n * polar data points i.e. in a circle and both test\n * use the same.\n * @author [Lakhan Nad](https://github.com/Lakhan-Nad)\n */\n\n#define _USE_MATH_DEFINES /* required for MS Visual C */\n#include <float.h>        /* DBL_MAX, DBL_MIN */\n#include <math.h>         /* PI, sin, cos */\n#include <stdio.h>        /* printf */\n#include <stdlib.h>       /* rand */\n#include <string.h>       /* memset */\n#include <time.h>         /* time */\n\n/*!\n * @addtogroup machine_learning Machine Learning Algorithms\n * @{\n * @addtogroup k_means K-Means Clustering Algorithm\n * @{\n */\n\n/*! @struct observation\n *  a class to store points in 2d plane\n *  the name observation is used to denote\n *  a random point in plane\n */\ntypedef struct observation\n{\n    double x;  /**< abscissa of 2D data point */\n    double y;  /**< ordinate of 2D data point */\n    int group; /**< the group no in which this observation would go */\n} observation;\n\n/*! @struct cluster\n *  this class stores the coordinates\n *  of centroid of all the points\n *  in that cluster it also\n *  stores the count of observations\n *  belonging to this cluster\n */\ntypedef struct cluster\n{\n    double x;     /**< abscissa centroid of this cluster */\n    double y;     /**< ordinate of centroid of this cluster */\n    size_t count; /**< count of observations present in this cluster */\n} cluster;\n\n/*!\n * Returns the index of centroid nearest to\n * given observation\n *\n * @param o  observation\n * @param clusters  array of cluster having centroids coordinates\n * @param k  size of clusters array\n *\n * @returns the index of nearest centroid for given observation\n */\nint calculateNearst(observation* o, cluster clusters[], int k)\n{\n    double minD = DBL_MAX;\n    double dist = 0;\n    int index = -1;\n    int i = 0;\n    for (; i < k; i++)\n    {\n        /* Calculate Squared Distance*/\n        dist = (clusters[i].x - o->x) * (clusters[i].x - o->x) +\n               (clusters[i].y - o->y) * (clusters[i].y - o->y);\n        if (dist < minD)\n        {\n            minD = dist;\n            index = i;\n        }\n    }\n    return index;\n}\n\n/*!\n * Calculate centoid and assign it to the cluster variable\n *\n * @param observations  an array of observations whose centroid is calculated\n * @param size  size of the observations array\n * @param centroid  a reference to cluster object to store information of\n * centroid\n */\nvoid calculateCentroid(observation observations[], size_t size,\n                       cluster* centroid)\n{\n    size_t i = 0;\n    centroid->x = 0;\n    centroid->y = 0;\n    centroid->count = size;\n    for (; i < size; i++)\n    {\n        centroid->x += observations[i].x;\n        centroid->y += observations[i].y;\n        observations[i].group = 0;\n    }\n    centroid->x /= centroid->count;\n    centroid->y /= centroid->count;\n}\n\n/*!\n *    --K Means Algorithm--\n * 1. Assign each observation to one of k groups\n *    creating a random initial clustering\n * 2. Find the centroid of observations for each\n *    cluster to form new centroids\n * 3. Find the centroid which is nearest for each\n *    observation among the calculated centroids\n * 4. Assign the observation to its nearest centroid\n *    to create a new clustering.\n * 5. Repeat step 2,3,4 until there is no change\n *    the current clustering and is same as last\n *    clustering.\n *\n * @param observations  an array of observations to cluster\n * @param size  size of observations array\n * @param k  no of clusters to be made\n *\n * @returns pointer to cluster object\n */\ncluster* kMeans(observation observations[], size_t size, int k)\n{\n    cluster* clusters = NULL;\n    if (k <= 1)\n    {\n        /*\n        If we have to cluster them only in one group\n        then calculate centroid of observations and\n        that will be a ingle cluster\n        */\n        clusters = (cluster*)malloc(sizeof(cluster));\n        memset(clusters, 0, sizeof(cluster));\n        calculateCentroid(observations, size, clusters);\n    }\n    else if (k < size)\n    {\n        clusters = malloc(sizeof(cluster) * k);\n        memset(clusters, 0, k * sizeof(cluster));\n        /* STEP 1 */\n        for (size_t j = 0; j < size; j++)\n        {\n            observations[j].group = rand() % k;\n        }\n        size_t changed = 0;\n        size_t minAcceptedError =\n            size /\n            10000;  // Do until 99.99 percent points are in correct cluster\n        int t = 0;\n        do\n        {\n            /* Initialize clusters */\n            for (int i = 0; i < k; i++)\n            {\n                clusters[i].x = 0;\n                clusters[i].y = 0;\n                clusters[i].count = 0;\n            }\n            /* STEP 2*/\n            for (size_t j = 0; j < size; j++)\n            {\n                t = observations[j].group;\n                clusters[t].x += observations[j].x;\n                clusters[t].y += observations[j].y;\n                clusters[t].count++;\n            }\n            for (int i = 0; i < k; i++)\n            {\n                clusters[i].x /= clusters[i].count;\n                clusters[i].y /= clusters[i].count;\n            }\n            /* STEP 3 and 4 */\n            changed = 0;  // this variable stores change in clustering\n            for (size_t j = 0; j < size; j++)\n            {\n                t = calculateNearst(observations + j, clusters, k);\n                if (t != observations[j].group)\n                {\n                    changed++;\n                    observations[j].group = t;\n                }\n            }\n        } while (changed > minAcceptedError);  // Keep on grouping until we have\n                                               // got almost best clustering\n    }\n    else\n    {\n        /* If no of clusters is more than observations\n           each observation can be its own cluster\n        */\n        clusters = (cluster*)malloc(sizeof(cluster) * k);\n        memset(clusters, 0, k * sizeof(cluster));\n        for (int j = 0; j < size; j++)\n        {\n            clusters[j].x = observations[j].x;\n            clusters[j].y = observations[j].y;\n            clusters[j].count = 1;\n            observations[j].group = j;\n        }\n    }\n    return clusters;\n}\n\n/**\n * @}\n * @}\n */\n\n/*!\n * A function to print observations and clusters\n * The code is taken from\n * http://rosettacode.org/wiki/K-means%2B%2B_clustering.\n * Even the K Means code is also inspired from it\n *\n * @note To print in a file use pipeline operator\n * ```sh\n * ./k_means_clustering > image.eps\n * ```\n *\n * @param observations  observations array\n * @param len  size of observation array\n * @param cent  clusters centroid's array\n * @param k  size of cent array\n */\nvoid printEPS(observation pts[], size_t len, cluster cent[], int k)\n{\n    int W = 400, H = 400;\n    double min_x = DBL_MAX, max_x = DBL_MIN, min_y = DBL_MAX, max_y = DBL_MIN;\n    double scale = 0, cx = 0, cy = 0;\n    double* colors = (double*)malloc(sizeof(double) * (k * 3));\n    int i;\n    size_t j;\n    double kd = k * 1.0;\n    for (i = 0; i < k; i++)\n    {\n        *(colors + 3 * i) = (3 * (i + 1) % k) / kd;\n        *(colors + 3 * i + 1) = (7 * i % k) / kd;\n        *(colors + 3 * i + 2) = (9 * i % k) / kd;\n    }\n\n    for (j = 0; j < len; j++)\n    {\n        if (max_x < pts[j].x)\n        {\n            max_x = pts[j].x;\n        }\n        if (min_x > pts[j].x)\n        {\n            min_x = pts[j].x;\n        }\n        if (max_y < pts[j].y)\n        {\n            max_y = pts[j].y;\n        }\n        if (min_y > pts[j].y)\n        {\n            min_y = pts[j].y;\n        }\n    }\n    scale = W / (max_x - min_x);\n    if (scale > (H / (max_y - min_y)))\n    {\n        scale = H / (max_y - min_y);\n    };\n    cx = (max_x + min_x) / 2;\n    cy = (max_y + min_y) / 2;\n\n    printf(\"%%!PS-Adobe-3.0 EPSF-3.0\\n%%%%BoundingBox: -5 -5 %d %d\\n\", W + 10,\n           H + 10);\n    printf(\n        \"/l {rlineto} def /m {rmoveto} def\\n\"\n        \"/c { .25 sub exch .25 sub exch .5 0 360 arc fill } def\\n\"\n        \"/s { moveto -2 0 m 2 2 l 2 -2 l -2 -2 l closepath \"\n        \"\tgsave 1 setgray fill grestore gsave 3 setlinewidth\"\n        \" 1 setgray stroke grestore 0 setgray stroke }def\\n\");\n    for (int i = 0; i < k; i++)\n    {\n        printf(\"%g %g %g setrgbcolor\\n\", *(colors + 3 * i),\n               *(colors + 3 * i + 1), *(colors + 3 * i + 2));\n        for (j = 0; j < len; j++)\n        {\n            if (pts[j].group != i)\n            {\n                continue;\n            }\n            printf(\"%.3f %.3f c\\n\", (pts[j].x - cx) * scale + W / 2,\n                   (pts[j].y - cy) * scale + H / 2);\n        }\n        printf(\"\\n0 setgray %g %g s\\n\", (cent[i].x - cx) * scale + W / 2,\n               (cent[i].y - cy) * scale + H / 2);\n    }\n    printf(\"\\n%%%%EOF\");\n\n    // free accquired memory\n    free(colors);\n}\n\n/*!\n * A function to test the kMeans function\n * Generates 100000 points in a circle of\n * radius 20.0 with center at (0,0)\n * and cluster them into 5 clusters\n *\n * <img alt=\"Output for 100000 points divided in 5 clusters\" src=\n * \"https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/machine_learning/k_means_clustering/kMeansTest1.png\"\n * width=\"400px\" heiggt=\"400px\">\n * @returns None\n */\nstatic void test()\n{\n    size_t size = 100000L;\n    observation* observations =\n        (observation*)malloc(sizeof(observation) * size);\n    double maxRadius = 20.00;\n    double radius = 0;\n    double ang = 0;\n    size_t i = 0;\n    for (; i < size; i++)\n    {\n        radius = maxRadius * ((double)rand() / RAND_MAX);\n        ang = 2 * M_PI * ((double)rand() / RAND_MAX);\n        observations[i].x = radius * cos(ang);\n        observations[i].y = radius * sin(ang);\n    }\n    int k = 5;  // No of clusters\n    cluster* clusters = kMeans(observations, size, k);\n    printEPS(observations, size, clusters, k);\n    // Free the accquired memory\n    free(observations);\n    free(clusters);\n}\n\n/*!\n * A function to test the kMeans function\n * Generates 1000000 points in a circle of\n * radius 20.0 with center at (0,0)\n * and cluster them into 11 clusters\n *\n * <img alt=\"Output for 1000000 points divided in 11 clusters\" src=\n * \"https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/machine_learning/k_means_clustering/kMeansTest2.png\"\n * width=\"400px\" heiggt=\"400px\">\n * @returns None\n */\nvoid test2()\n{\n    size_t size = 1000000L;\n    observation* observations =\n        (observation*)malloc(sizeof(observation) * size);\n    double maxRadius = 20.00;\n    double radius = 0;\n    double ang = 0;\n    size_t i = 0;\n    for (; i < size; i++)\n    {\n        radius = maxRadius * ((double)rand() / RAND_MAX);\n        ang = 2 * M_PI * ((double)rand() / RAND_MAX);\n        observations[i].x = radius * cos(ang);\n        observations[i].y = radius * sin(ang);\n    }\n    int k = 11;  // No of clusters\n    cluster* clusters = kMeans(observations, size, k);\n    printEPS(observations, size, clusters, k);\n    // Free the accquired memory\n    free(observations);\n    free(clusters);\n}\n\n/*!\n * This function calls the test\n * function\n */\nint main()\n{\n    srand(time(NULL));\n    test();\n    /* test2(); */\n    return 0;\n}\n","index":212},{"title":"Misc","category":null,"id":"misc","index":213},{"title":"Armstrong Number","category":"misc","id":"armstrong_number_misc","algorithm":"// A number is called as Armstrong number if sum of cubes of digits of number is\n// equal to the number itself.\n// For Example 153 is an Armstrong number because 153 = 1+5+3.\n#include <stdio.h>\n\n// Function to calculate x raised to the power y\nint power(int x, unsigned int y)\n{\n    if (y == 0)\n        return 1;\n    if (y % 2 == 0)\n        return power(x, y / 2) * power(x, y / 2);\n    return x * power(x, y / 2) * power(x, y / 2);\n}\n\n// Function to calculate order of the number\nint order(int x)\n{\n    int n = 0;\n    while (x)\n    {\n        n++;\n        x = x / 10;\n    }\n    return n;\n}\n\n// Function to check whether the given number is\n// Armstrong number or not\nint isArmstrong(int x)\n{\n    // Calling order function\n    int n = order(x);\n    int temp = x, sum = 0;\n    while (temp)\n    {\n        int r = temp % 10;\n        sum += power(r, n);\n        temp = temp / 10;\n    }\n\n    // If satisfies Armstrong condition\n    if (sum == x)\n        return 1;\n    else\n        return 0;\n}\n\n//\nint main()\n{\n    int x = 153;\n    if (isArmstrong(x) == 1)\n        printf(\"True\\n\");\n    else\n        printf(\"False\\n\");\n\n    x = 1253;\n    if (isArmstrong(x) == 1)\n        printf(\"True\\n\");\n    else\n        printf(\"False\\n\");\n\n    return 0;\n}\n","index":214},{"title":"Cantor Set","category":"misc","id":"cantor_set_misc","algorithm":"/**\n * @file\n * @brief Program to generate [Cantor ternary\n * set](https://en.wikipedia.org/wiki/Cantor_set)\n */\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n/** structure to define Cantor set */\ntypedef struct _cantor_set\n{\n    double start;             /**< start of interval */\n    double end;               /**< end of interval */\n    struct _cantor_set *next; /**< pointer to next set */\n} CantorSet;\n\n/** Iterative constructor of all sets in the current level. This function\n * dynamically allocates memory when creating new sets. These are freed by the\n * function ::free_memory.\n * @param head pointer to interval set instance to update\n */\nvoid propagate(CantorSet *head)\n{\n    // if input is NULL, ignore the process\n    if (head == NULL)\n        return;\n\n    CantorSet *temp = head;  // local pointer to track propagation\n\n    // create new node for the new set\n    CantorSet *newNode = (CantorSet *)malloc(sizeof(CantorSet));\n\n    // get 1/3rd of interval\n    double diff = (((temp->end) - (temp->start)) / 3);\n\n    // update interval ranges\n    newNode->end = temp->end;\n    temp->end = ((temp->start) + diff);\n    newNode->start = (newNode->end) - diff;\n\n    // update pointer to next set in this level\n    newNode->next = temp->next;\n\n    // point to next set\n    temp->next = newNode;\n\n    // create next set\n    propagate(temp->next->next);\n}\n\n/** Print sets in the current range to `stdout`\n * @param head pointer to first set in the current level\n */\nvoid print(CantorSet *head)\n{\n    CantorSet *temp = head;\n    while (temp != NULL)  // print while a valid set is found\n    {\n        printf(\"\\t\");\n        printf(\"[%lf] -- \", temp->start);\n        printf(\"[%lf]\", temp->end);\n        temp = temp->next;\n    }\n\n    printf(\"\\n\");\n}\n\n/** Clear memory allocated by ::propagate function.\n * @param head pointer to first allocated instance.\n */\nvoid free_memory(CantorSet *head)\n{\n    if (!head)\n        return;\n\n    if (head->next)\n        free_memory(head->next);\n\n    free(head);\n}\n\n/** Main function */\nint main(int argc, char const *argv[])\n{\n    int start_num, end_num, levels;\n\n    if (argc < 2)\n    {\n        printf(\"Enter 3 arguments: start_num \\t end_num \\t levels\\n\");\n        scanf(\"%d %d %d\", &start_num, &end_num, &levels);\n    }\n    else\n    {\n        start_num = atoi(argv[1]);\n        end_num = atoi(argv[2]);\n        levels = atoi(argv[3]);\n    }\n\n    if (start_num < 0 || end_num < 0 || levels < 0)\n    {\n        fprintf(stderr, \"All numbers must be positive\\n\");\n        return -1;\n    }\n\n    CantorSet head = {.start = start_num, .end = end_num, .next = NULL};\n\n    // loop to propagate each level from top to bottom\n    for (int i = 0; i < levels; i++)\n    {\n        printf(\"Level %d\\t\", i);\n        print(&head);\n        propagate(&head);\n        printf(\"\\n\");\n    }\n    printf(\"Level %d\\t\", levels);\n    print(&head);\n\n    // delete all memory allocated\n    free_memory(head.next);\n\n    return 0;\n}\n","index":215},{"title":"Cartesian To Polar","category":"misc","id":"cartesian_to_polar_misc","algorithm":"/**\n * @file\n * @brief Function to convert a Cartesian co-ordinate to polar form.\n */\n#define _USE_MATH_DEFINES /**< required for MS Visual C */\n#include <assert.h>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n/**\n * @brief Function to convert cartesian coordinates to polar.\n *\\f{eqnarray*}{\n r &=& \\sqrt{x^2+y^2}\\\\\n \\theta &=& \\atan\\frac{y}{x}\n \\f}\n * @param [in] x absicca value\n * @param [in] y ordinate value\n * @param [out] r pointer to store polar radius\n * @param [out] theta pointer to store polar angle (in radian)\n */\nvoid to_polar(double x, double y, double *r, double *theta)\n{\n    double thetaFinal = 0.f;\n\n    *r = sqrt(x * x + y * y);\n\n    if (x != 0)\n    {\n        if (y != 0)\n        {\n            *theta = atan(y / x);\n            if ((x > 0 && y > 0) || (x == -y))\n            {  // Q1\n                thetaFinal = *theta;\n            }\n            else if (x < 0 && y > 0)\n            {  // Q2\n                thetaFinal = *theta + M_PI;\n            }\n            else if (x < 0 && y < 0)\n            {  // Q3\n                thetaFinal = *theta - M_PI;\n            }\n            else if (x > 0 && y < 0)\n            {  // Q4\n                thetaFinal = 2 * M_PI - *theta;\n            }\n            else\n            {\n                fprintf(stderr, \"Should not reach here!\\n\");\n            }\n        }\n    }\n    else\n    {  // exceptions when no actual angle is present\n        if (y > 0)\n        {\n            thetaFinal = M_PI / 2;\n        }\n        else\n        {\n            thetaFinal = -(M_PI / 2);\n        }\n    }\n    if (y == 0)\n    {\n        if (x > 0)\n        {\n            thetaFinal = 0;\n        }\n        else\n        {\n            thetaFinal = -M_PI;\n        }\n    }\n\n    *theta = thetaFinal;\n}\n\n/**\n * @brief Generate a random number in the given limits\n *\n * @param lim1 lower limit\n * @param lim2 upper limit\n * @return random number in the given range\n */\ndouble get_rand(double lim1, double lim2)\n{\n    double r = (double)rand() / RAND_MAX;  // value in [0,1)\n    return (lim2 - lim1) * r + lim1;       // scale to range\n}\n\n/**\n * @brief Test implementation\n *\n */\nvoid test()\n{\n    srand(10);\n    int NUM_TESTS = 5;\n\n    for (int i = 0; i < NUM_TESTS; i++)\n    {\n        double r, theta;\n        printf(\"Test %d.... \", i);\n        double x = get_rand(-5, 5);\n        double y = get_rand(-5, 5);\n        printf(\"(%.2g, %.2g).... \", x, y);\n        to_polar(x, y, &r, &theta);\n        assert(fabs(r - hypot(x, y)) < 0.01);\n        assert(fabs(theta - atan2(y, x)) < 0.01);\n        printf(\"passed\\n\");\n    }\n}\n\n/** Main function */\nint main()\n{\n    test();\n\n    return 0;\n}\n","index":216},{"title":"Catalan","category":"misc","id":"catalan_misc","algorithm":"/*\ncode for computing nth catalan number\n*/\n#include <stdio.h>\nlong int factorial(int x)  // long int for more than 10 factorial\n{\n    int i;\n    long int fac;  // fac stores x factorial\n    fac = x;\n    for (i = 1; i < x; i++)  // loop to calculate x factorial\n    {\n        fac = fac * (x - i);\n    }\n    return fac;  // returning x factorial\n}\nint main()\n{\n    long int f1, f2, f3;  // long int for more than 10 factorial\n    int n;\n    float C;  // C is catalan number for n;\n    scanf(\"%d\", &n);\n    f1 = factorial(2 * n);\n    f2 = factorial(n + 1);\n    f3 = factorial(n);\n    C = f1 / (f2 * f3);  // formula for catalan number for n\n    printf(\"%0.2f\", C);\n    return 0;\n}\n","index":217},{"title":"Collatz","category":"misc","id":"collatz_misc","algorithm":"/**\n * \\file\n *\n * \\brief Implementation of [Collatz'\n * conjecture](https://en.wikipedia.org/wiki/Collatz_conjecture)\n *\n * Collatz conjecture: a series for a number \\f$n\\f$ in which if \\f$n\\f$ even\n * then the next number is \\f$\\frac{n}{2}\\f$ ,but if n is odd then the next\n * number is \\f$3n+1\\f$. This series continues till \\f$n\\f$ reaches 1\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n\n/** Main function */\nint main(int argc, char *argv[])\n{\n    unsigned long long n, curr_no, num_steps = 0;\n    if (argc == 2)\n        n = strtoull(argv[1], NULL, 10);\n    else\n    {\n        printf(\"Enter starting number: \");\n        scanf(\"%lu\", &n);  // input number\n    }\n\n    curr_no = n;          // curr_no stores input number n\n    while (curr_no != 1)  // loop till series reaches 1\n    {\n        num_steps++;\n        printf(\"%llu->\", curr_no);\n        if (curr_no % 2 == 0)  // condition   for even number\n            curr_no = curr_no / 2;\n        else\n            curr_no = (curr_no * 3) + 1;  // condition for odd number\n    }\n    printf(\"1\\nNumber of steps: %llu\\n\", num_steps);\n    return 0;\n}\n","index":218},{"title":"Demonetization","category":"misc","id":"demonetization_misc","algorithm":"// Recursion problem\n// Given the denominations of currencies available in a system, find the number\n// of ways an ATM machine can generate notes for an entered amount N.\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint ways(int n, int *a, int k)\n{\n    if (n < 0 || k < 0)\n        return 0;\n    if (n == 0)\n        return 1;\n    if (k == 0)\n        return 0;\n    return ways(n, a, k - 1) + ways(n - a[k - 1], a, k);\n}\n\nint main()\n{\n    int m;\n    int t;\n    int n;\n\n    printf(\"Number of coins? \");\n    scanf(\"%d\", &m);\n    int *coin = (int *)malloc(m * sizeof(int)), i;\n    for (i = 0; i < m; i++)\n    {\n        printf(\"coin? \");\n        scanf(\"%d\", &coin[i]);\n    }\n\n    printf(\"---- your requests --- \\n\");\n    while (1)\n    {\n        printf(\"amount? exit(0) \");\n        scanf(\"%d\", &n);\n        if (!n)\n        {\n            break;\n        }\n        printf(\"%d\\n\", ways(n, coin, m));\n    }\n\n    free(coin);\n    return 0;\n}\n","index":219},{"title":"Factorial","category":"misc","id":"factorial_misc","algorithm":"#include <stdio.h>\nint main()\n{\n    int a[200], n, counter, temp, i;\n    a[0] = 1;\n    counter = 0;\n    printf(\"Enter a whole number to Find its Factorial: \");\n    scanf(\"%d\", &n);\n    if (n < 0)\n        printf(\"Cannot Calculate factorials for negative numbers.\");\n    else\n    {\n        for (; n >= 2; n--)\n        {\n            temp = 0;\n            for (i = 0; i <= counter; i++)\n            {\n                temp = (a[i] * n) + temp;\n                a[i] = temp % 10;\n                temp = temp / 10;\n            }\n            while (temp > 0)\n            {\n                a[++counter] = temp % 10;\n                temp = temp / 10;\n            }\n        }\n        for (i = counter; i >= 0; i--) printf(\"%d\", a[i]);\n    }\n    return 0;\n}\n","index":220},{"title":"Factorial Large Number","category":"misc","id":"factorial_large_number_misc","algorithm":"/**\n * @file\n * \\brief Compute factorial of arbitrarily large numbers by\n * storing individual digits in a byte.\n * \\author [Krishna Vedala](https://github.com/kvedala)\n */\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n/**\n * dynamically large number\n */\ntypedef struct _large_num\n{\n    char *digits;            /**< array to store individual digits */\n    unsigned int num_digits; /**< number of digits in the number */\n} large_num;\n\n/**\n * create a new large number\n * \\returns pointer to a large number\n */\nlarge_num *new_number(void)\n{\n    large_num *new_num = (large_num *)malloc(sizeof(large_num));\n    new_num->num_digits = 1;\n    new_num->digits = (char *)malloc(1 * sizeof(char));\n    new_num->digits[0] = 1;\n    return new_num;\n}\n\n/**\n * delete all memory allocated for large number\n * \\param[in] num pointer to large_num to delete\n */\nvoid delete_number(large_num *num)\n{\n    free(num->digits);\n    free(num);\n}\n\n/**\n * add a digit to the large number\n * \\param[in,out] num\n * \\param[in] value value of the digit to insert\n */\nvoid add_digit(large_num *num, unsigned int value)\n{\n    if (value > 9)\n    {\n        fprintf(stderr, \"digit > 9!!\\n\");\n        delete_number(num);\n        exit(EXIT_FAILURE);\n    }\n\n    num->num_digits++;\n    num->digits = (char *)realloc(num->digits, num->num_digits * sizeof(char));\n    num->digits[num->num_digits - 1] = value;\n}\n\n/**\n * multiply large number with another integer and\n * store the result in the same large number\n */\nvoid multiply(large_num *num, unsigned long n)\n{\n    int i;\n    unsigned long carry = 0, temp;\n    for (i = 0; i < num->num_digits; i++)\n    {\n        temp = num->digits[i] * n;\n        temp += carry;\n        if (temp < 10)\n            carry = 0;\n        else\n        {\n            carry = temp / 10;\n            temp = temp % 10;\n        }\n        num->digits[i] = temp;\n    }\n\n    while (carry != 0)\n    {\n        add_digit(num, carry % 10);\n        carry /= 10;\n    }\n}\n\n/**\n * main function\n */\nint main(int argc, char *argv[])\n{\n    int number, i;\n\n    // Asks for the number/position of term in Fibonnacci sequence\n    if (argc == 2)\n        number = atoi(argv[1]);\n    else\n    {\n        printf(\"Enter the value of n(n starts from 0 ): \");\n        scanf(\"%d\", &number);\n    }\n\n    large_num *result = new_number();\n\n    clock_t start_time = clock();\n    for (i = 2; i <= number; i++) /* Multiply every number from 2 thru N */\n        multiply(result, i);\n    double time_taken = (clock() - start_time) * (double)1e3 / CLOCKS_PER_SEC;\n    // time_taken = (clock() - start_time) / (double) CLOCKS_PER_SEC;\n\n    printf(\"%d! = \", number);\n    for (i = result->num_digits; i > 0; i--)\n        putchar(result->digits[i - 1] + '0');\n    printf(\"\\nTime taken: %.4g ms\\n\", time_taken);\n\n    delete_number(result);\n    return 0;\n}\n","index":221},{"title":"Factorial Trailing Zeroes","category":"misc","id":"factorial_trailing_zeroes_misc","algorithm":"/*\nprogramme for computing number of zeroes at the end of factorial of a given\nnumber n\n*/\n#include <math.h>  //including math.h header file to use pow function\n#include <stdio.h>\nint main()\n{\n    int i, n, test = 0, count = 0;\n    // taking input number n\n    scanf(\"%d\", &n);\n\n    // looping from 1 till loop break\n    for (i = 1;; i++)\n    {\n        test =\n            n /\n            pow(5,\n                i);  // division of n by ith power of 5(storing in integer form)\n        if (test !=\n            0)  // condition for zeroes at end corresponding individual ith case\n        {\n            count = count + test;\n        }\n        else\n            break;  // break the loop for if test=0\n    }\n    printf(\"%d\\n\", count);\n    return 0;\n}\n","index":222},{"title":"Fibonacci","category":"misc","id":"fibonacci_misc","algorithm":"#include <stdio.h>\n\n// Fibonnacci function\nint fib(int number)\n{\n    if (number == 1 || number == 2)\n        return 1;\n    else\n        return fib(number - 1) + fib(number - 2);\n}\n\nint main()\n{\n    int number;\n\n    // Asks for the number that is in n position in Fibonnacci sequence\n    printf(\"Number: \");\n    scanf(\"%d\", &number);\n\n    printf(\"%d \\n\", fib(number));\n\n    return 0;\n}","index":223},{"title":"Fibonacci Dp","category":"misc","id":"fibonacci_dp_misc","algorithm":"// Fibonacci Series using Dynamic Programming\n\n/* Author: Moinak Banerjee(moinak878)\n   Date : 1 October ,2019\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint fib(int n)\n{\n    // Out of Range checking\n    if (n < 0)\n    {\n        printf(\"\\nNo Such term !\\n\");\n        exit(0);\n    }\n    // declaring array to store fibonacci numbers -- memoization\n    int *f = (int *)malloc(\n        (n + 2) * sizeof(int));  //  one extra to handle edge case, n = 0\n    int i;\n\n    /* let 0th and 1st number of the series be 0 and 1*/\n    f[0] = 0;\n    f[1] = 1;\n\n    for (i = 2; i <= n; i++)\n    {\n        // Adding the previous 2 terms to make the 3rd term\n        f[i] = f[i - 1] + f[i - 2];\n    }\n\n    int out = f[n];\n    free(f);\n    return out;\n}\n\nint main(int argc, char *argv[])\n{\n    int number;\n\n    // Asks for the number/position of term in Fibonnacci sequence\n    if (argc == 2)\n        number = atoi(argv[1]);\n    else\n    {\n        printf(\"Enter the value of n(n starts from 0 ): \");\n        scanf(\"%d\", &number);\n    }\n\n    printf(\"The nth term is : %d \\n\", fib(number));\n\n    return 0;\n}","index":224},{"title":"Fibonacci Fast","category":"misc","id":"fibonacci_fast_misc","algorithm":"/**\n    @file\n    @author [Krishna Vedala](https://github.com/kvedala)\n    @date 2 October, 2019\n    @brief Compute \\f$m^{mth}\\f$ Fibonacci number using the formulae:\n    \\f{eqnarray*}{\n        F_{2n-1} &=& F_n^2 + F_{n-1}^2 \\\\\n        F_{2n}   &=& F_n\\left(2F_{n-1} + F_n\\right)\n   \\f}\n*/\n\n#include <locale.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n/**\n * Get the \\f$n^{th}\\f$ and \\f$n+1^{th}\\f$ Fibonacci number using recursive\n * half-interval decimation.\n * \\param [in] n index of Fibonacci number to get\n * \\param [out] C left half interval value - end result here. Cannot be NULL\n * \\param [out] D right half interval can be discarded at end and can be NULL\n */\nvoid fib(unsigned long n, unsigned long *C, unsigned long *D)\n{\n    // Out of Range checking\n    // commented out since `n` is unsigned integer\n    // if (n < 0)\n    // {\n    //     printf(\"\\nNo Such term !\\n\");\n    //     exit(0);\n    // }\n\n    unsigned long a, b, c, d;\n\n    if (n == 0)\n    {\n        C[0] = 0;\n        if (D) /* if D is not NULL */\n            D[0] = 1;\n        return;\n    }\n\n    fib(n >> 1, &c, &d); /* Compute F(n/2) */\n\n    a = c * ((d << 1) - c);\n    b = c * c + d * d;\n    if (n % 2 == 0) /* If n is even */\n    {\n        C[0] = a;\n        if (D)\n            D[0] = b;\n        return;\n    }\n\n    /**< If n is odd */\n    C[0] = b;\n    if (D) /* if D is not NULL */\n        D[0] = a + b;\n    return;\n}\n\n/**\n * main function\n */\nint main(int argc, char *argv[])\n{\n    unsigned long number, result;\n\n    setlocale(LC_NUMERIC, \"\");  // format the printf output\n\n    // Asks for the number/position of term in Fibonnacci sequence\n    if (argc == 2)\n        number = atoi(argv[1]);\n    else\n    {\n        printf(\"Enter the value of n(n starts from 0 ): \");\n        scanf(\"%lu\", &number);\n    }\n\n    fib(number, &result, NULL);\n\n    printf(\"The nth term is : %'lu \\n\", result);\n\n    return 0;\n}\n","index":225},{"title":"Gcd","category":"misc","id":"gcd_misc","algorithm":"#include <stdio.h>\n\n// Euclid's algorithm\nint GCD(int x, int y)\n{\n    if (y == 0)\n        return x;\n    return GCD(y, x % y);\n}\n\nint main()\n{\n    int a, b;\n    printf(\"Input two numbers:\\n\");\n    scanf(\"%d %d\", &a, &b);\n    printf(\"Greatest common divisor: %d\\n\", GCD(a, b));\n}\n","index":226},{"title":"Is Armstrong","category":"misc","id":"is_armstrong_misc","algorithm":"#include <stdio.h>\n\nint main()\n{\n    int n, sum = 0, i, num;\n    printf(\"Enter number: \");\n    scanf(\"%d\", &n);\n    num = n;\n    while (n != 0)\n    {\n        i = n % 10;\n        sum = sum + (i * i * i);\n        n = n / 10;\n    }\n    if (sum == num)\n    {\n        printf(\"%d is an armstrong number!\\n\", num);\n    }\n    else\n    {\n        printf(\"%d is not an armstrong number!\\n\", num);\n    }\n    return 0;\n}\n","index":227},{"title":"Large Factorials","category":"misc","id":"large_factorials_misc","algorithm":"#include <stdio.h>\n\nint main()\n{\n    int a[16500], T;\n    long long int i, j;\n\n    printf(\"Enter number of test cases : \");\n    scanf(\"%d\", &T);\n\n    while (T--)\n    {\n        for (i = 0; i < 16500; i++)\n        {\n            a[i] = 0;\n        }\n\n        a[1] = 1;\n        int N, carry = 0, count = 0;\n        printf(\"Enter a number : \");\n        scanf(\"%d\", &N);\n\n        for (i = 1; i <= N; i++)\n        {\n            carry = 0;\n            for (j = 0; j < 16500; j++)\n            {\n                a[j] = a[j] * i + carry;\n                carry = a[j] / 10;\n                a[j] = a[j] % 10;\n            }\n        }\n\n        for (i = 0; i < 16500; i++)\n        {\n            if (a[i] != 0)\n            {\n                count = i;\n            }\n        }\n\n        for (i = count; i > 0; i--)\n        {\n            printf(\"%d\", a[i]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n","index":228},{"title":"Lcm","category":"misc","id":"lcm_misc","algorithm":"// C program to find LCM of two numbers\n/*\n    suppose we have two numbers a and b.\n    Property: Since product of LCM and GCD of two numbers are equal to product\n   of that number itself. i.e, LCM(a,b)*GCD(a,b)=a*b. So,here we first find the\n   GCD of two numbers and using above property we find LCM of that two numbers.\n*/\n#include <stdio.h>\n\n// Recursive function to return gcd of a and b\nint gcd(int a, int b)\n{\n    if (a == 0)\n        return b;\n    return gcd(b % a, a);\n}\n\n// Function to return LCM of two numbers\nint lcm(int a, int b) { return (a * b) / gcd(a, b); }\n\n// Driver program\nint main()\n{\n    int a, b;\n    printf(\"Enter two numbers to find their LCM \\n\");\n    scanf(\"%d%d\", &a, &b);\n    printf(\"LCM of %d and %d is %d \", a, b, lcm(a, b));\n    return 0;\n}\n/*\nTest Case1:\na=15,b=20\nLCM(a,b)=60\nTest Case2:\na=12,b=18\nLCM(a,b)=36\n*/\n","index":229},{"title":"Lerp","category":"misc","id":"lerp_misc","algorithm":"#include <math.h>\n#include <stdio.h>\n\nfloat lerp(float k0, float k1, float t) { return k0 + t * (k1 - k0); }\n\nfloat lerp_precise(int k0, int k1, float t) { return (1 - t) * k0 + t * k1; }\n\nint main()\n{\n    float start = 0;\n    float finish = 5;\n    float steps = 0;\n\n    printf(\"Input a number, this is the bigger bound of the lerp:\\n\");\n    scanf(\"%f\", &finish);\n\n    printf(\n        \"Input a number, this is in how many steps you want to divide the \"\n        \"lerp:\\n\");\n    scanf(\"%f\", &steps);\n\n    for (int i = 0; i < steps + 1; i++)\n    {\n        printf(\"%f\\n\", lerp(start, finish, i / steps));\n    }\n\n    return 0;\n}\n","index":230},{"title":"Lexicographic Permutations","category":"misc","id":"lexicographic_permutations_misc","algorithm":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid swap(char *left, char *right)\n{\n    char temp = *left;\n    *left = *right;\n    *right = temp;\n}\n\nint compare(const void *a, const void *b) { return (*(char *)a - *(char *)b); }\n\nvoid PrintSortedPermutations(char *str)\n{\n    int strSize = strlen(str);\n    qsort(str, strSize, sizeof(char), compare);\n\n    int largerPermFound = 1;\n    do\n    {\n        // 1. Print permutation\n        printf(\"%s\\n\", str);\n        // 2. Find rightmost char that is smaller than char to its right\n        int i;\n        for (i = strSize - 2; i >= 0 && str[i] >= str[i + 1]; --i)\n        {\n        }\n\n        // if we couldn't find one, we're finished, else we can swap\n        if (i >= 0)\n        {\n            // 3. find character at index j such that str[j] = min(str[k]) &&\n            // str[k] > str[i] for all k > i\n            int j = i + 1, k;\n            for (k = j; k < strSize && str[k]; k++)\n            {\n                if (str[k] > str[i] && str[k] < str[j])\n                    j = k;\n            }\n            // 3. Swap chars at i and j\n            swap(&str[i], &str[j]);\n            // 4. Sort string to the right of i\n            qsort(str + i + 1, strSize - i - 1, sizeof(char), compare);\n        }\n        else\n            largerPermFound = 0;\n    } while (largerPermFound);\n}\n\nint main()\n{\n    int n;  // size of string\n    scanf(\"%d\\n\", &n);\n    if (n <= 0 || n >= 1000)\n    {\n        perror(\"Input number out of range: >0 and <1000\\n\");\n        return -1;\n    }\n    char *str = (char *)malloc(n * sizeof(char));\n    scanf(\"%s\", str);\n    PrintSortedPermutations(str);\n    free(str);\n    return 0;\n}\n","index":231},{"title":"Longest Subsequence","category":"misc","id":"longest_subsequence_misc","algorithm":"#include <stdio.h>\n#include <stdlib.h>\n\nvoid longestSub(int *ARRAY, int ARRAY_LENGTH, int **RESULT, int *RESULT_LENGTH)\n{  // RESULT and RESULT_LENGTH will be modified by their pointers\n\n    if (ARRAY_LENGTH <= 1)\n    {\n        *RESULT = ARRAY;\n        *RESULT_LENGTH = ARRAY_LENGTH;\n    }\n    else\n    {\n        int PIVOT = ARRAY[0];\n        int *LONGEST_SUB = NULL;\n        int i, j, LONGEST_SUB_LENGTH = 0;\n        int TEMPORARY_ARRAY_LENGTH = 0, *TEMPORARY_ARRAY = NULL;\n\n        for (i = 1; i < ARRAY_LENGTH; i++)\n        {\n            if (ARRAY[i] < PIVOT)\n            {\n                TEMPORARY_ARRAY_LENGTH = 0;\n                TEMPORARY_ARRAY = NULL;\n\n                for (j = i + 1; j < ARRAY_LENGTH; j++)\n                {\n                    if (ARRAY[j] >= ARRAY[i])\n                    {\n                        TEMPORARY_ARRAY_LENGTH++;\n                        TEMPORARY_ARRAY = (int *)realloc(\n                            TEMPORARY_ARRAY,\n                            TEMPORARY_ARRAY_LENGTH * sizeof(int));\n                        TEMPORARY_ARRAY[TEMPORARY_ARRAY_LENGTH - 1] = ARRAY[j];\n                    }\n                }\n\n                longestSub(TEMPORARY_ARRAY, TEMPORARY_ARRAY_LENGTH,\n                           &TEMPORARY_ARRAY, &TEMPORARY_ARRAY_LENGTH);\n                if (LONGEST_SUB_LENGTH < TEMPORARY_ARRAY_LENGTH + 1)\n                {\n                    LONGEST_SUB_LENGTH = TEMPORARY_ARRAY_LENGTH + 1;\n                    LONGEST_SUB = (int *)realloc(\n                        LONGEST_SUB, LONGEST_SUB_LENGTH * sizeof(int));\n                    LONGEST_SUB[0] = ARRAY[i];\n\n                    for (i = 1; i < LONGEST_SUB_LENGTH; i++)\n                        LONGEST_SUB[i] = TEMPORARY_ARRAY[i - 1];\n                }\n            }\n        }\n\n        TEMPORARY_ARRAY = NULL;\n        TEMPORARY_ARRAY_LENGTH = 0;\n        for (i = 1; i < ARRAY_LENGTH; i++)\n        {\n            if (ARRAY[i] >= PIVOT)\n            {\n                TEMPORARY_ARRAY_LENGTH++;\n                TEMPORARY_ARRAY = (int *)realloc(\n                    TEMPORARY_ARRAY, TEMPORARY_ARRAY_LENGTH * sizeof(int));\n                TEMPORARY_ARRAY[TEMPORARY_ARRAY_LENGTH - 1] = ARRAY[i];\n            }\n        }\n\n        longestSub(TEMPORARY_ARRAY, TEMPORARY_ARRAY_LENGTH, &TEMPORARY_ARRAY,\n                   &TEMPORARY_ARRAY_LENGTH);\n        if (TEMPORARY_ARRAY_LENGTH + 1 > LONGEST_SUB_LENGTH)\n        {\n            LONGEST_SUB_LENGTH = TEMPORARY_ARRAY_LENGTH + 1;\n            LONGEST_SUB =\n                (int *)realloc(LONGEST_SUB, LONGEST_SUB_LENGTH * sizeof(int));\n            LONGEST_SUB[0] = PIVOT;\n            for (i = 1; i < LONGEST_SUB_LENGTH; i++)\n                LONGEST_SUB[i] = TEMPORARY_ARRAY[i - 1];\n        }\n        *RESULT = LONGEST_SUB;\n        *RESULT_LENGTH = LONGEST_SUB_LENGTH;\n    }\n}\n\nint main()\n{\n    int EXAMPLE_LENGTH = 8;\n    int EXAMPLE[] = {18, 2, 15, 4, 30, 0, 11, 12};\n\n    int *RESULT = NULL;\n    int RESULT_LENGTH, i;\n\n    longestSub(EXAMPLE, EXAMPLE_LENGTH, &RESULT, &RESULT_LENGTH);\n\n    printf(\"Longest Sub Sequence length: %d and it's:\\n\", RESULT_LENGTH);\n    for (i = 0; i < RESULT_LENGTH; i++) printf(\"%d \", RESULT[i]);\n    printf(\"\\n\");\n\n    return 0;\n}","index":232},{"title":"Mirror","category":"misc","id":"mirror_misc","algorithm":"#include <stdio.h>\n#include <string.h>  // we include the library string.h to the use of string\n\nvoid saisie(\n    char *cpointeur);  // Prototypes of the three functions used in the program\nint compte(char *s);\nchar *miroir(char *s);\n\nint main(int argc, char *argv[])\n{\n    char chaine[20];\n    saisie(chaine);\n    printf(\"miroir est %s\", miroir(chaine));\n}\n// this function is used to put a string\nvoid saisie(char *cpointeur)\n{\n    printf(\"saisir une chaine\\n\");\n    scanf(\"%s\", cpointeur);\n}\n/* the function miroir (in french ) it means \"mirror\" , the major idea is to\npermute the first caractere with the last using an auxilary variable (aux) the\nthe 2nd character with the penultimate one and so on . we made a call to the\nfunction (compte) which counts the length of the string . As you can see clearly\n, I substruct 1 from the equation k = compte(s)-1 ; to get rid of the EOF\ncaractere which is '\\0' because it is not a caractere from the string typed */\nchar *miroir(char *s)\n{\n    int i;\n    char aux;\n    int k;\n    k = compte(s) - 1;\n    i = 0;\n    while (i <= k)\n    {\n        aux = s[i];\n        s[i] = s[k];\n        s[k] = aux;\n        k--;\n        i++;\n    }\n\n    return s;\n}\n\n// compte plays the role of strlen so we can change it by an strlen function if\n// you want that\nint compte(char *s)\n{\n    char *p;\n    int k;\n    p = s;\n    k = 0;\n    while (*p != '\\0')\n    {\n        p++;\n        k++;\n    }\n    return k;\n}\n","index":233},{"title":"Palindrome","category":"misc","id":"palindrome_misc","algorithm":"/**\n * @file\n * @brief Program to identify if a number is [palindrome\n * number](https://en.wikipedia.org/wiki/Palindrome) or not.\n * @see project_euler/problem_4/sol1.c\n */\n#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n\nbool isPalindrome(int number);\n\n/** Driver Code */\nint main()\n{\n    assert(isPalindrome(0));\n    assert(isPalindrome(1));\n    assert(isPalindrome(12321));\n    assert(!isPalindrome(1234));\n    return 0;\n}\n\n/**\n * Check given number whether is palindrome number or not\n * @param number number to check\n * @return `true` if given number is palindrome number\n * @return `false` if number is not a palindrome number\n */\nbool isPalindrome(int number)\n{\n    int reversedNumber = 0;\n    int originalNumber = number;\n    while (number != 0)\n    {\n        int remainder = number % 10;\n        reversedNumber = reversedNumber * 10 + remainder;\n        number /= 10;\n    }\n    return originalNumber == reversedNumber;\n}\n","index":234},{"title":"Pid","category":"misc","id":"pid_misc","algorithm":"/**\r\n * PID Controller\r\n *\r\n * The PID controller is a linear control algorithm that has three terms:\r\n *  - Proportional: A simple scaling of the error value by a gain kP\r\n *  - Integral: Integration of the error value over time, then multipled by gain\r\n * kI\r\n *  - Derivative: Rate of change of the error value over time, multiplied by\r\n * gain kD\r\n *\r\n * Terms of the controller can be removed by setting their gain to 0, creating a\r\n * PI (kD = 0) or PD (kI = 0) controller. Depending on the control problem at\r\n * hand, some terms may not increase the performance of the system, or may have\r\n * a negative effect.\r\n *\r\n * For a more mathematical expanation of the PID Controller, see\r\n * https://en.wikipedia.org/wiki/PID_controller\r\n *\r\n * Limitations of this implementation:\r\n *  - Since this implementation is just for demonstration, the pid_step function\r\n * takes the dt as a parameter, and it can be provided by the user in main().\r\n * This allows deterministic experimentation with the algorithm, rather than\r\n * using time(NULL) which would make the function non-deterministic.\r\n *\r\n * Inputs: e(t) - Current error at time t. For example, how far a servo is off\r\n * the desired angle Output: u(t) - Controller output at time t.\r\n */\r\n#include <stdio.h>\r\n\r\nstruct pid\r\n{\r\n    // Controller gains\r\n    float kP;\r\n    float kI;\r\n    float kD;\r\n\r\n    // State variables\r\n    float lastError;\r\n    float integral;\r\n};\r\n\r\nfloat pid_step(struct pid *controller, float dt, float error)\r\n{\r\n    // Calculate p term\r\n    float p = error * controller->kP;\r\n\r\n    // Calculate i term\r\n    controller->integral += error * dt * controller->kI;\r\n\r\n    // Calculate d term, taking care to not divide by zero\r\n    float d =\r\n        dt == 0 ? 0 : ((error - controller->lastError) / dt) * controller->kD;\r\n    controller->lastError = error;\r\n\r\n    return p + controller->integral + d;\r\n}\r\n\r\nint main()\r\n{\r\n    printf(\"PID Controller Example\\n\");\r\n\r\n    struct pid controller = {.lastError = 0, .integral = 0};\r\n\r\n    // Take the controller gains from the user\r\n    printf(\r\n        \"Please enter controller gains in format kP, kI, KD. For example, \"\r\n        \"\\\"1.2 2.1 3.2\\\"\\n> \");\r\n    scanf(\"%f %f %f\", &controller.kP, &controller.kI, &controller.kD);\r\n    printf(\"Using kP: %f, kI: %f, kD: %f\\n\", controller.kP, controller.kI,\r\n           controller.kD);\r\n\r\n    // How often the pid_step algorithm expects to be called. In a real life\r\n    // scenario this would be provided by calling time(NULL) - last_time, or by\r\n    // calling the function reliably at X Hz (using a timer or RTOS etc) For\r\n    // demonstration of this algorithm though, it is defined below as 1 second,\r\n    // allowing easy testing of integral and derivative terms.\r\n    float time_step = 1;\r\n\r\n    float error_value;\r\n    while (1)\r\n    {\r\n        printf(\"Enter error value\\n>\");\r\n        scanf(\"%f\", &error_value);\r\n\r\n        float output = pid_step(&controller, time_step, error_value);\r\n        printf(\"Output: %f\\n\", output);\r\n    }\r\n}\r\n","index":235},{"title":"Prime","category":"misc","id":"prime_misc","algorithm":"/**\n * @file\n * @brief Program to identify if a number is [prime\n * number](https://en.wikipedia.org/wiki/Prime_number) or not\n */\n#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n\n/**\n * Check if a given number is prime number or not\n * @param x number to check\n * @return `true` if given number is prime number, otherwise `false`\n */\nbool isPrime(int x)\n{\n    if (x == 2)\n    {\n        return true;\n    }\n    if (x < 2 || x % 2 == 0)\n    {\n        return false;\n    }\n\n    double squareRoot = sqrt(x);\n\n    for (int i = 3; i <= squareRoot; i += 2)\n    {\n        if (x % i == 0)\n        {\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n * Test function\n * @return void\n */\nvoid test()\n{\n    /* all the prime numbers less than 100 */\n    int primers[] = {2,  3,  5,  7,  11, 13, 17, 19, 23, 29, 31, 37, 41,\n                     43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n    for (size_t i = 0, size = sizeof(primers) / sizeof(primers[0]); i < size;\n         ++i)\n    {\n        assert(isPrime(primers[i]));\n    }\n\n    /* Example Non-prime numbers */\n    int NonPrimers[] = {-1, 0, 1, 4, 6, 8, 9, 10};\n    for (size_t i = 0, size = sizeof(NonPrimers) / sizeof(NonPrimers[0]);\n         i < size; ++i)\n    {\n        assert(!isPrime(NonPrimers[i]));\n    }\n}\n\n/**\n * Driver Code\n * @return None\n */\nint main()\n{\n    test();\n    return 0;\n}\n","index":236},{"title":"Prime Factoriziation","category":"misc","id":"prime_factoriziation_misc","algorithm":"/*\n    AUTHOR: Christian Bender\n    DATE: 12.02.2019\n    DESCRIPTION: This program calculates the prime factoriziation of a positive\n   integer > 1\n*/\n\n#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n/* initial length of the dynamic array */\n#define LEN 10\n\n/* increasing range */\n#define STEP 5\n\n/*\n    this type is for the representation of the prim factoriziation\n    - its series/range of prime factors\n    - its length : numbers of prime factors\n*/\ntypedef struct data\n{\n    int *range;\n    int length;\n} range;\ntypedef range *Range;\n\n/* int_fac : calculates the prime factoriziation of positive integers */\nRange int_fact(int);\n\n/* print_arr : prints the integer (heap) array*/\nvoid print_arr(Range);\n\n/* increase : increases the dynamic integer array */\nint *increase(int *, int);\n\n/* destroy: destroys the range-structure */\nvoid destroy(Range);\n\n/*\n    main : simle frame program with a simple UI\n*/\nint main()\n{\n    int n = 0; /* for user input */\n\n    printf(\"\\t\\tPrim factoriziation\\n\\n\");\n    printf(\"positive integer (> 1) ? \");\n    scanf(\"%d\", &n);\n    Range r = int_fact(n);\n    printf(\"\\nThe factoriziation are: \");\n    print_arr(r);\n    destroy(r);\n    return 0;\n}\n\nRange int_fact(int n)\n{\n    assert(n > 1); /* precondition : n must be greater then 1*/\n\n    int len = LEN;\n    int count = 0;\n    int i = 0;\n    int *range = (int *)malloc(sizeof(int) * len);\n    assert(range);\n    Range pstr = (Range)malloc(sizeof(range));\n    assert(pstr);\n\n    while (n % 2 == 0)\n    {\n        n /= 2;\n        if (i < len)\n        {\n            range[i] = 2;\n            i++;\n        }\n        else\n        {\n            range = increase(range, len);\n            len += STEP;\n            range[i] = 2;\n            i++;\n        }\n        count++;\n    }\n\n    int j = 3;\n    while (j * j <= n)\n    {\n        while (n % j == 0)\n        {\n            n /= j;\n            if (i < len)\n            {\n                range[i] = j;\n                i++;\n            }\n            else\n            {\n                range = increase(range, len);\n                len += STEP;\n                range[i] = j;\n                i++;\n            }\n            count++;\n        }\n\n        j += 2;\n    }\n\n    if (n > 1)\n    {\n        if (i < len)\n        {\n            range[i] = n;\n            i++;\n        }\n        else\n        {\n            range = increase(range, len);\n            len += STEP;\n            range[i] = n;\n            i++;\n        }\n        count++;\n    }\n\n    pstr->range = range;\n    pstr->length = count;\n    return pstr;\n}\n\nvoid print_arr(Range pStr)\n{\n    assert(pStr); /* checks whether pStr is a null-pointer */\n    int i = 0;\n    printf(\"\\n\");\n    for (i; i < pStr->length; i++)\n    {\n        if (i == 0)\n            printf(\"%d\", pStr->range[0]);\n        else\n            printf(\"-%d\", pStr->range[i]);\n    }\n    printf(\"\\n\");\n}\n\nint *increase(int *arr, int len)\n{\n    assert(arr); /* checks whether arr is a null-pointer */\n    int *tmp = (int *)realloc(arr, sizeof(int) * (len + STEP));\n    assert(tmp);\n    return tmp;\n    //    assert(arr);\n}\n\nvoid destroy(Range r)\n{\n    free(r->range);\n    free(r);\n}\n","index":237},{"title":"Quartile","category":"misc","id":"quartile_misc","algorithm":"#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    int a[10], n, i, j, temp;\n    float q1, q3, iqr;\n\n    printf(\"Enter no. for Random Numbers :\");\n    scanf(\"%d\", &n);\n    for (i = 0; i < n; i++)\n    {\n        a[i] = rand() % 100;\n    }\n    printf(\"Random Numbers Generated are :\\n\");\n    for (i = 0; i < n; i++)\n    {\n        printf(\"\\n%d\", a[i]);\n    }\n    printf(\"\\n\");\n    printf(\"\\nSorted Data:\");\n    for (i = 0; i < n; i++)\n    {\n        for (j = 0; j < n; j++)\n        {\n            if (a[i] < a[j])\n            {\n                temp = a[i];\n                a[i] = a[j];\n                a[j] = temp;\n            }\n        }\n    }\n    for (i = 0; i < n; i++)\n    {\n        printf(\"\\n%d\", a[i]);\n    }\n    q1 = a[n / 4];\n    printf(\"\\nFirst Quartile : %f\", q1);\n    q3 = a[(3 * n) / 4];\n    printf(\"\\nThird Quartile : %f\", q3);\n    iqr = q3 - q1;\n    printf(\"\\nInterQuartile Range is : %f\", iqr);\n\n    return 0;\n}","index":238},{"title":"Rselect","category":"misc","id":"rselect_misc","algorithm":"#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\nvoid swap(int *a, int *b)\n{\n    int t;\n    t = *a;\n    *a = *b;\n    *b = t;\n}\nint part(int a[], int l, int r, int n, int pivot, int pindex)\n{\n    int p1 = l, p2 = r;\n    while (p2 > p1)\n    {\n        if (a[p1] > pivot && a[p2] < pivot)\n        {\n            swap(&a[p1], &a[p2]);\n        }\n        else\n        {\n            if (a[p1] <= pivot)\n            {\n                p1++;\n            }\n            if (a[p2] >= pivot)\n            {\n                p2--;\n            }\n        }\n    }\n    swap(&a[pindex], &a[p2]);\n    return p2;\n}\nint rselect(int a[], int l, int r, int n, int o)\n{\n    int pivot, pindex, pactual;\n    if (r > l)\n    {\n        pindex = rand() % (r - l + 1);\n        pivot = a[pindex];\n        pactual = part(a, l, r, n, pivot, pindex);\n\n        if (pactual == o)\n        {\n            return a[pactual];\n        }\n\n        if (o < pactual)\n        {\n            rselect(a, l, pactual - 1, n, o);\n        }\n\n        if (o > pactual)\n        {\n            rselect(a, pactual + 1, r, n, o - pactual);\n        }\n    }\n    if (r == l)\n    {\n        return a[l];\n    }\n    return -1;\n}\nint main()\n{\n    srand(time(NULL));\n    int n, o, i, *a;\n    scanf(\"%d %d\", &n, &o);\n    a = (int *)malloc(n * sizeof(int));\n    for (i = 0; i < n; i++)\n    {\n        scanf(\"%d\", a + i);\n    }\n    printf(\"\\n\\n%d\", rselect(a, 0, n - 1, n, o));\n    return 0;\n}\n","index":239},{"title":"Strong Number","category":"misc","id":"strong_number_misc","algorithm":"/**\n * @file\n * @brief Strong number is a number whose sum of all digits factorial is equal\n * to the number n For example: 145 = 1!(1) + 4!(24) + 5!(120)\n */\n#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n\n/**\n * Check if given number is strong number or not\n * @param number\n * @return `true` if given number is strong number, otherwise `false`\n */\nbool isStrong(int number)\n{\n    if (number < 0)\n    {\n        return false;\n    }\n    int sum = 0;\n    int originalNumber = number;\n    while (originalNumber != 0)\n    {\n        int remainder = originalNumber % 10;\n        int factorial = remainder == 0 ? 0 : 1; /* 0! == 1 */\n\n        /* calculate factorial of n */\n        for (int i = 1; i <= remainder; factorial *= i, i++)\n        {\n            ;\n        }\n        sum += factorial;\n        originalNumber /= 10;\n    }\n    return number == sum;\n}\n\n/**\n * Test function\n * @return void\n */\nvoid test()\n{\n    assert(isStrong(145));  /* 145 = 1! + 4! + 5! */\n    assert(!isStrong(543)); /* 543 != 5!+ 4! + 3! */\n}\n\n/**\n * Driver Code\n * @return None\n */\nint main()\n{\n    test();\n    return 0;\n}\n","index":240},{"title":"Sudoku Solver","category":"misc","id":"sudoku_solver_misc","algorithm":"/**\n * @file\n * @brief Sudoku Solver using recursive implementation of brute-force algorithm\n *\n * @details\n * Given an incomplete N*N Sudoku and asked to solve it using the\n * following recursive algorithm:\n * 1. Scan the Sudoku from left to right row-wise to search for an empty cell.\n * 2. If there are no empty cells, print the Sudoku. Go to step 5.\n * 3. In the empty cell, try putting numbers 1 to N\n * while ensuring that no two numbers in a single row, column, or box are same.\n * Go back to step 1.\n * 4. Declare that the Sudoku is Invalid.\n * 5. Exit.\n *\n * @authors [Anuj Shah](https://github.com/anujms1999)\n * @authors [Krishna Vedala](https://github.com/kvedala)\n */\n#include <assert.h>\n#include <inttypes.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n/** @addtogroup sudoku Sudoku solver\n * @{\n */\n/** Structure to hold the matrix and dimensions\n */\nstruct sudoku\n{\n    uint8_t *a; /**< matrix as a flattened 1D row-major array */\n    uint8_t N;  /**< number of elements */\n    uint8_t N2; /**< block of elements */\n};\n\n/**\n * Check if `x`^th row is valid\n * @param a ::sudoku to check\n * @param x row to check\n * @param y ignored column\n * @param v value to check if it repeats\n * @returns `true` if valid\n * @returns `false` if in-valid\n */\nbool OKrow(const struct sudoku *a, int x, int y, int v)\n{\n    int offset = x * a->N;\n    for (int j = 0; j < a->N; j++)\n        if (a->a[offset + j] == v)\n            // if the value is found in the row\n            return false;\n    return true;\n}\n\n/**\n * Check if `y`^th column is valid\n * @param a ::sudoku to check\n * @param x ignored row\n * @param y column to check\n * @param v value to check if it repeats\n * @returns `true` if valid\n * @returns `false` if in-valid\n */\nbool OKcol(const struct sudoku *a, int x, int y, int v)\n{\n    for (int i = 0; i < a->N; i++)\n        if (a->a[i * a->N + y] == v)\n            // if the value is found in the column\n            return false;\n    return true;\n}\n\n/**\n * Check if a 3x3 box is valid\n * @param a matrix to check\n * @param x row index of the element to check\n * @param y column index of the element to check\n * @param v value to check if it repeats\n * @returns `true` if valid\n * @returns `false` if in-valid\n */\nbool OKbox(const struct sudoku *a, int x, int y, int v)\n{\n    /* get start indices of the box that the current (x,y) lies in\n       remember that in C/C++, division operation always rounds towards\n       -infinity for signed integers and towards 0 for unsigned integers\n    */\n    int bi = x - x % a->N2, bj = y - y % a->N2;\n    // printf(\"Checking box: (%d,%d)\\n\", bi, bj);\n\n    for (int i = bi; i < (bi + a->N2); i++)\n        for (int j = bj; j < (bj + a->N2); j++)\n            if (a->a[i * a->N + j] == v)\n                // if the value is found in the box\n                return false;\n    return true;\n}\n\n/**\n * Check if element `v` is valid to place at (x,y) location.\n * @param a ::sudoku to check\n * @param x row to place value\n * @param y column to place value\n * @param v value to check if it is valid\n * @returns `true` if valid\n * @returns `false` if in-valid\n */\nbool OK(const struct sudoku *a, int x, int y, int v)\n{\n    bool result = OKrow(a, x, y, v);\n    if (result)\n        result = OKcol(a, x, y, v);\n    if (result)\n        result = OKbox(a, x, y, v);\n\n    return result;\n}\n\n/**\n * Print the matrix to stdout\n * @param [in] a array to print\n */\nvoid print(const struct sudoku *a)\n{\n    int i, j;\n    for (i = 0; i < a->N; i++)\n        for (j = 0; j < a->N; j++)\n            printf(\"%\" SCNu8 \"%c\", a->a[i * a->N + j],\n                   (j == a->N - 1 ? '\\n' : ' '));\n}\n\n/**\n * @brief Find and get the location for next empty cell.\n *\n * @param [in] a pointer to sudoku instance\n * @param [out] x pointer to row index of next unknown\n * @param [out] y pointer to column index of next unknown\n * @returns `true` if an empty location was found\n * @returns `false` if no more empty locations found\n */\nbool get_next_unknown(const struct sudoku *a, int *x, int *y)\n{\n    for (int i = 0; i < a->N; i++)\n    {\n        for (int j = 0; j < a->N; j++)\n        {\n            if (a->a[i * a->N + j] == 0)\n            {\n                *x = i;\n                *y = j;\n                return true;\n            }\n        }\n    }\n\n    /* no unknown locations found */\n    return false;\n}\n\n/**\n * @brief Function to solve a partially filled sudoku matrix. For each unknown\n * value (0), the function fills a possible value and calls the function again\n * to check forvalid solution.\n *\n * @param [in,out] a sudoku matrix to solve\n * @return `true` if solution found\n * @return `false` if no solution found\n */\nbool solve(struct sudoku *a)\n{\n    static uint32_t counter = 0;\n    int i, j;\n    static char prefix[100] = \"\";  // enough memory\n\n    if (!get_next_unknown(a, &i, &j))\n    {\n        /* no more empty location found\n           implies all good in the matrix\n         */\n        return true;\n    }\n\n    /* try all possible values for the unknown */\n    for (uint8_t v = 1; v <= a->N; v++)\n    { /* try all possible values 1 thru N */\n        printf(\"%sTry (%d,%d) = %\" SCNu8 \"... \", prefix, i, j, v);\n        counter++;\n        if (OK(a, i, j, v))\n        {\n            /* if assignment checks satisfy, set the value and\n             continue with remaining elements */\n            printf(\"passed (counter=%\" SCNu32 \")\\n\", counter);\n            a->a[i * a->N + j] = v;\n            strcat(prefix, \"  \");\n            if (solve(a))\n            {\n                /* solution found */\n                return true;\n            }\n\n            printf(\"%sBacktrack (%d,%d) <- %\" SCNu8 \" (counter=%\" SCNu32 \")\\n\",\n                   prefix, i, j, a->a[i * a->N + j], counter);\n\n            prefix[strlen(prefix) - 2] = '\\0';  // truncate the prefix\n            a->a[i * a->N + j] = 0;\n        }\n        else\n        {\n            printf(\"\\r\");\n        }\n    }\n\n    return false;\n}\n\n/** @} */\n\nvoid test()\n{\n    printf(\"Test begin...\\n\");\n\n    uint8_t test_array[] = {3, 0, 6, 5, 0, 8, 4, 0, 0, 5, 2, 0, 0, 0, 0, 0, 0,\n                            0, 0, 8, 7, 0, 0, 0, 0, 3, 1, 0, 0, 3, 0, 1, 0, 0,\n                            8, 0, 9, 0, 0, 8, 6, 3, 0, 0, 5, 0, 5, 0, 0, 9, 0,\n                            6, 0, 0, 1, 3, 0, 0, 0, 0, 2, 5, 0, 0, 0, 0, 0, 0,\n                            0, 0, 7, 4, 0, 0, 5, 2, 0, 6, 3, 0, 0};\n    struct sudoku a = {.N = 9, .N2 = 3, .a = test_array};\n    assert(solve(&a));  // ensure that solution is obtained\n\n    uint8_t expected[] = {3, 1, 6, 5, 7, 8, 4, 9, 2, 5, 2, 9, 1, 3, 4, 7, 6,\n                          8, 4, 8, 7, 6, 2, 9, 5, 3, 1, 2, 6, 3, 4, 1, 5, 9,\n                          8, 7, 9, 7, 4, 8, 6, 3, 1, 2, 5, 8, 5, 1, 7, 9, 2,\n                          6, 4, 3, 1, 3, 8, 9, 4, 7, 2, 5, 6, 6, 9, 2, 3, 5,\n                          1, 8, 7, 4, 7, 4, 5, 2, 8, 6, 3, 1, 9};\n    for (int i = 0; i < a.N; i++)\n        for (int j = 0; j < a.N; j++)\n            assert(a.a[i * a.N + j] == expected[i * a.N + j]);\n\n    printf(\"Test passed\\n\");\n}\n\n/** \\brief Main function */\nint main()\n{\n    test();\n\n    struct sudoku a;  // store the matrix as a 1D array\n    scanf(\"%\" SCNu8, &(a.N));\n    a.a = (uint8_t *)malloc(a.N * a.N * sizeof(uint8_t));\n    a.N2 = (uint8_t)sqrt(a.N);\n\n    for (int i = 0; i < a.N; i++)\n        for (int j = 0; j < a.N; j++) scanf(\"%\" SCNu8, &(a.a[i * a.N + j]));\n\n    printf(\"Entered a %udx%ud matrix with block size: %\" SCNu8 \"\\n\", a.N, a.N,\n           a.N2);\n    // print(&a);\n    printf(\"\\n\\n\");\n    if (solve(&a))\n        printf(\"Valid solution found!\\n\");\n    else\n        printf(\"Invalid\\n\");\n    print(&a);\n\n    free(a.a);\n    return 0;\n}\n","index":241},{"title":"Tower Of Hanoi","category":"misc","id":"tower_of_hanoi_misc","algorithm":"\n#include <stdio.h>\n#include <stdlib.h>\n\n// Function for Tower of Hanoi algorithm\nvoid hanoi(int noOfDisks, char where, char to, char extra)\n{\n    if (noOfDisks != 0)\n    {\n        hanoi(noOfDisks - 1, where, extra, to);\n        printf(\"Move disk : %d from %c to %c\\n\", noOfDisks, where, to);\n        hanoi(noOfDisks - 1, extra, to, where);\n    }\n}\nint main(void)\n{\n    int noOfDisks;\n\n    // Asks the number of disks in the tower\n    printf(\"Number of disks: \\n\");\n    scanf(\"%d\", &noOfDisks);\n\n    hanoi(noOfDisks, 'A', 'B', 'C');\n\n    return 0;\n}\n","index":242},{"title":"Union Find","category":"misc","id":"union_find_misc","algorithm":"/**\n * @file union_find.c\n * @brief [Union\n * find](https://en.wikipedia.org/wiki/Disjoint-set_data_structure) algorithm.\n */\n#include <stdio.h>\n#include <stdlib.h>\n#define MAX_SIZE 1000 /**< maximum number of elements in the set */\n\n/**\n * @brief Find index of or value in an array\n *\n * @param [in,out] p array to search and update\n * @param x value to search\n * @return value at the index `x`\n */\nint find(int *p, int x)\n{\n    if (x >= MAX_SIZE)\n    {\n        fprintf(stderr, \"Out-of bounds value\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    if (p[x] == x)\n    {\n        return x;\n    }\n    else\n    {\n        p[x] = find(p, p[x]);\n        return p[x];\n    }\n}\n\n/**\n * @brief Function to join\n * @param [in,out] p array to join in\n * @param x value or index to join to\n * @param y value or index to join from\n */\nvoid join(int *p, int x, int y) { p[find(p, x)] = find(p, y); }\n\n/** Main function */\nint main()\n{\n    int union_set[MAX_SIZE];\n\n    // Have all array indexes that you need to use reference themselves\n    for (int i = 0; i < 10; i++)\n    {\n        union_set[i] = i;\n    }\n    // p = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n\n    join(union_set, 3, 5);\n    printf(\"The array is now: \");\n    for (int i = 0; i < 10; i++)\n    {\n        printf(\"%d \", union_set[i]);\n    }\n    printf(\"\\n\");\n    // Now 3 and 5 are groupped together, that is find(3) = find(5)\n    // p = {0, 1, 2, 5, 4, 5, 6, 7, 8, 9}\n\n    join(union_set, 3, 8);\n    printf(\"The array is now: \");\n    for (int i = 0; i < 10; i++)\n    {\n        printf(\"%d \", union_set[i]);\n    }\n    printf(\"\\n\");\n\n    // Now 3, 5 and are groupped together, find(3) = find(5) = find(8)\n    // p = {0, 1, 2, 5, 4, 8, 6, 7, 8, 9}\n    join(union_set, 0, 5);\n    if (find(union_set, 0) == find(union_set, 3))\n    {\n        printf(\"0 and 3 are groupped together\\n\");\n    }\n    printf(\"The array is now: \");\n    for (int i = 0; i < 10; i++)\n    {\n        printf(\"%d \", union_set[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n","index":243},{"title":"Numerical Methods","category":null,"id":"numerical_methods","index":244},{"title":"Durand Kerner Roots","category":"numerical_methods","id":"durand_kerner_roots_numerical_methods","algorithm":"/**\n * @file\n * \\brief Compute all possible approximate roots of any given polynomial using\n * [Durand Kerner\n * algorithm](https://en.wikipedia.org/wiki/Durand%E2%80%93Kerner_method)\n *\n * \\author [Krishna Vedala](https://github.com/kvedala)\n *\n * Test the algorithm online:\n * https://gist.github.com/kvedala/27f1b0b6502af935f6917673ec43bcd7\n *\n * Try the highly unstable Wilkinson's polynomial:\n * ```\n * ./numerical_methods/durand_kerner_roots.c 1 -210 20615 -1256850 53327946\n * -1672280820 40171771630 -756111184500 11310276995381 -135585182899530\n * 1307535010540395 -10142299865511450 63030812099294896 -311333643161390640\n * 1206647803780373360 -3599979517947607200 8037811822645051776\n * -12870931245150988800 13803759753640704000 -8752948036761600000\n * 2432902008176640000\n * ```\n * Sample implementation results to compute approximate roots of the equation\n * \\f$x^4-1=0\\f$:\\n\n * <img\n * src=\"https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/numerical_methods/durand_kerner_error.svg\"\n * width=\"400\" alt=\"Error evolution during root approximations computed every\n * iteration.\"/> <img\n * src=\"https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/numerical_methods/durand_kerner_roots.svg\"\n * width=\"400\" alt=\"Roots evolution - shows the initial approximation of the\n * roots and their convergence to a final approximation along with the iterative\n * approximations\" />\n */\n\n#include <complex.h>\n#include <limits.h>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\n#define ACCURACY 1e-10 /**< maximum accuracy limit */\n\n/**\n * Evaluate the value of a polynomial with given coefficients\n * \\param[in] coeffs coefficients of the polynomial\n * \\param[in] degree degree of polynomial\n * \\param[in] x point at which to evaluate the polynomial\n * \\returns \\f$f(x)\\f$\n */\nlong double complex poly_function(long double *coeffs, unsigned int degree,\n                                  long double complex x)\n{\n    long double complex out = 0.;\n    unsigned int n;\n\n    for (n = 0; n < degree; n++) out += coeffs[n] * cpow(x, degree - n - 1);\n\n    return out;\n}\n\n/**\n * create a textual form of complex number\n * \\param[in] x point at which to evaluate the polynomial\n * \\returns pointer to converted string\n */\nconst char *complex_str(long double complex x)\n{\n    static char msg[50];\n    double r = creal(x);\n    double c = cimag(x);\n\n    sprintf(msg, \"% 7.04g%+7.04gj\", r, c);\n\n    return msg;\n}\n\n/**\n * check for termination condition\n * \\param[in] delta point at which to evaluate the polynomial\n * \\returns 0 if termination not reached\n * \\returns 1 if termination reached\n */\nchar check_termination(long double delta)\n{\n    static long double past_delta = INFINITY;\n    if (fabsl(past_delta - delta) <= ACCURACY || delta < ACCURACY)\n        return 1;\n    past_delta = delta;\n    return 0;\n}\n\n/***\n * the comandline inputs are taken as coeffiecients of a polynomial\n */\nint main(int argc, char **argv)\n{\n    long double *coeffs = NULL;\n    long double complex *s0 = NULL;\n    unsigned int degree = 0;\n    unsigned int n, i;\n\n    if (argc < 2)\n    {\n        printf(\n            \"Please pass the coefficients of the polynomial as commandline \"\n            \"arguments.\\n\");\n        return 0;\n    }\n\n    degree = argc - 1; /* detected polynomial degree */\n    coeffs = (long double *)malloc(\n        degree * sizeof(long double)); /* store all input coefficients */\n    s0 = (long double complex *)malloc(\n        (degree - 1) *\n        sizeof(long double complex)); /* number of roots = degree-1 */\n\n    /* initialize random seed: */\n    srand(time(NULL));\n\n    if (!coeffs || !s0)\n    {\n        perror(\"Unable to allocate memory!\");\n        if (coeffs)\n            free(coeffs);\n        if (s0)\n            free(s0);\n        return EXIT_FAILURE;\n    }\n\n#if defined(DEBUG) || !defined(NDEBUG)\n    /**\n     * store intermediate values to a CSV file\n     */\n    FILE *log_file = fopen(\"durand_kerner.log.csv\", \"wt\");\n    if (!log_file)\n    {\n        perror(\"Unable to create a storage log file!\");\n        free(coeffs);\n        free(s0);\n        return EXIT_FAILURE;\n    }\n    fprintf(log_file, \"iter#,\");\n#endif\n\n    printf(\"Computing the roots for:\\n\\t\");\n    for (n = 0; n < degree; n++)\n    {\n        coeffs[n] = strtod(argv[n + 1], NULL);\n        if (n < degree - 1 && coeffs[n] != 0)\n            printf(\"(%Lg) x^%d + \", coeffs[n], degree - n - 1);\n        else if (coeffs[n] != 0)\n            printf(\"(%Lg) x^%d = 0\\n\", coeffs[n], degree - n - 1);\n\n        double tmp;\n        if (n > 0)\n            coeffs[n] /= tmp; /* numerical errors less when the first\n                                 coefficient is \"1\" */\n        else\n        {\n            tmp = coeffs[0];\n            coeffs[0] = 1;\n        }\n\n        /* initialize root approximations with random values */\n        if (n < degree - 1)\n        {\n            s0[n] = (long double)rand() + (long double)rand() * I;\n#if defined(DEBUG) || !defined(NDEBUG)\n            fprintf(log_file, \"root_%d,\", n);\n#endif\n        }\n    }\n\n#if defined(DEBUG) || !defined(NDEBUG)\n    fprintf(log_file, \"avg. correction\");\n    fprintf(log_file, \"\\n0,\");\n    for (n = 0; n < degree - 1; n++)\n        fprintf(log_file, \"%s,\", complex_str(s0[n]));\n#endif\n\n    double tol_condition = 1;\n    unsigned long iter = 0;\n\n    clock_t end_time, start_time = clock();\n    while (!check_termination(tol_condition) && iter < INT_MAX)\n    {\n        long double complex delta = 0;\n        tol_condition = 0;\n        iter++;\n\n#if defined(DEBUG) || !defined(NDEBUG)\n        fprintf(log_file, \"\\n%ld,\", iter);\n#endif\n\n        for (n = 0; n < degree - 1; n++)\n        {\n            long double complex numerator =\n                poly_function(coeffs, degree, s0[n]);\n            long double complex denominator = 1.0;\n            for (i = 0; i < degree - 1; i++)\n                if (i != n)\n                    denominator *= s0[n] - s0[i];\n\n            delta = numerator / denominator;\n\n            if (isnan(cabsl(delta)) || isinf(cabsl(delta)))\n            {\n                printf(\"\\n\\nOverflow/underrun error - got value = %Lg\",\n                       cabsl(delta));\n                goto end;\n            }\n\n            s0[n] -= delta;\n\n            tol_condition = fmaxl(tol_condition, fabsl(cabsl(delta)));\n\n#if defined(DEBUG) || !defined(NDEBUG)\n            fprintf(log_file, \"%s,\", complex_str(s0[n]));\n#endif\n        }\n        // tol_condition /= (degree - 1);\n\n#if defined(DEBUG) || !defined(NDEBUG)\n        if (iter % 500 == 0)\n        {\n            printf(\"Iter: %lu\\t\", iter);\n            for (n = 0; n < degree - 1; n++) printf(\"\\t%s\", complex_str(s0[n]));\n            printf(\"\\t\\tabsolute average change: %.4g\\n\", tol_condition);\n        }\n\n        fprintf(log_file, \"%.4g\", tol_condition);\n#endif\n    }\nend:\n\n    end_time = clock();\n\n#if defined(DEBUG) || !defined(NDEBUG)\n    fclose(log_file);\n#endif\n\n    printf(\"\\nIterations: %lu\\n\", iter);\n    for (n = 0; n < degree - 1; n++) printf(\"\\t%s\\n\", complex_str(s0[n]));\n    printf(\"absolute average change: %.4g\\n\", tol_condition);\n    printf(\"Time taken: %.4g sec\\n\",\n           (end_time - start_time) / (double)CLOCKS_PER_SEC);\n\n    free(coeffs);\n    free(s0);\n\n    return 0;\n}\n","index":245},{"title":"Gauss Elimination","category":"numerical_methods","id":"gauss_elimination_numerical_methods","algorithm":"#include <math.h>\n#include <stdio.h>\n\n#define ARRAY_SIZE 20\n\nvoid display(float a[ARRAY_SIZE][ARRAY_SIZE], int n)\n{\n    int i, j;\n    for (i = 0; i < n; i++)\n    {\n        for (j = 0; j <= n; j++)\n        {\n            printf(\"%.2f \\t\", a[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n\nfloat interchange(float m[ARRAY_SIZE][ARRAY_SIZE], int i, int n)\n{\n    float tmp[ARRAY_SIZE][ARRAY_SIZE];\n    float max = fabs(m[i][i]);\n    int j, k = i;\n\n    for (j = i; j < n; j++)\n    {\n        if (max < fabs(m[j][i]))\n        {\n            max = fabs(m[j][i]);\n            k = j;\n        }\n    }\n    for (j = 0; j <= n; j++)\n    {\n        tmp[i][j] = m[i][j];\n        m[i][j] = m[k][j];\n        m[k][j] = tmp[i][j];\n    }\n    return m[ARRAY_SIZE - 1][ARRAY_SIZE - 1];\n}\nfloat eliminate(float m[ARRAY_SIZE][ARRAY_SIZE], int i, int n)\n{\n    float tmp;\n    int k = 1, l, j;\n    for (j = i; j < n - 1; j++)\n    {\n        tmp = -((m[i + k][i]) / (m[i][i]));\n        for (l = 0; l <= n; l++)\n        {\n            m[i + k][l] = (m[i + k][l]) + (m[i][l] * tmp);\n        }\n        k++;\n    }\n    return m[ARRAY_SIZE - 1][ARRAY_SIZE - 1];\n}\nint main(void)\n{\n    int i, j, n, k = 0, l;\n    float m[ARRAY_SIZE][ARRAY_SIZE], mul, tmp[ARRAY_SIZE][ARRAY_SIZE], val,\n        ans[ARRAY_SIZE];\n\n    printf(\"Total No.of Equations : \");\n    scanf(\"%d\", &n);\n\n    printf(\"\\n\");\n    for (i = 0; i < n; i++)\n    {\n        printf(\"Enter Co-efficient Of Equations %d & Total --->>>\\n\", i + 1);\n        for (j = 0; j <= n; j++)\n        {\n            printf(\"r%d%d : \", i, j);\n            scanf(\"%f\", &m[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    printf(\":::::::::::: Current Matrix ::::::::::::\\n\\n\");\n    display(m, n);\n\n    for (i = 0; i < n - 1; i++)\n    {\n        printf(\"\\n------->>>>>>>>>>>>>>>>>>>>>>>>-------- %d\\n\", i + 1);\n        m[ARRAY_SIZE - 1][ARRAY_SIZE - 1] = interchange(m, i, n);\n        display(m, n);\n        printf(\"\\n_______________________________________\\n\");\n        m[ARRAY_SIZE - 1][ARRAY_SIZE - 1] = eliminate(m, i, n);\n        display(m, n);\n    }\n    printf(\"\\n\\n Values are : \\n\");\n    for (i = n - 1; i >= 0; i--)\n    {\n        l = n - 1;\n        mul = 0;\n        for (j = 0; j < k; j++)\n        {\n            mul = mul + m[i][l] * ans[l];\n            l--;\n        }\n        k++;\n        ans[i] = (m[i][n] - mul) / m[i][i];\n        printf(\"X%d = %.2f\\n\", i + 1, ans[i]);\n    }\n\n    return 0;\n}\n","index":246},{"title":"Gauss Seidel Method","category":"numerical_methods","id":"gauss_seidel_method_numerical_methods","algorithm":"#include <math.h>\n#include <stdio.h>\n\nint main()\n{\n    float a, b, c, a1, a2, a3, b1, b2, b3, c1, c2, c3, d1, d2, d3, x1, x2, x3;\n\n    printf(\"Enter values of eq1:\");\n    scanf(\"%f%f%f%f\", &a1, &a2, &a3, &d1);\n    printf(\"Enter values of eq2:\");\n    scanf(\"%f%f%f%f\", &b1, &b2, &b3, &d2);\n    printf(\"Enter values of eq3:\");\n    scanf(\"%f%f%f%f\", &c1, &c2, &c3, &d3);\n    x1 = x2 = x3 = 0.0;\n    do\n    {\n        a = x1;\n        b = x2;\n        c = x3;\n        x1 = (1 / a1) * (d1 - (a2 * x2) - (a3 * x3));\n        x2 = (1 / b2) * (d2 - (b1 * x1) - (b3 * x3));\n        x3 = (1 / c3) * (d3 - (c1 * x1) - (c2 * x2));\n    } while (fabs(x1 - a) > 0.0001 && fabs(x2 - b) > 0.0001 &&\n             fabs(x3 - c) > 0.0001);\n    printf(\"x1=%f\\nx2=%f\\nx3=%f\", x1, x2, x3);\n\n    return 0;\n}","index":247},{"title":"Lagrange Theorem","category":"numerical_methods","id":"lagrange_theorem_numerical_methods","algorithm":"#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    float x[20], y[20], a, sum, p;\n    int n, i, j;\n\n    printf(\"Enter the no of entry to insert->\");\n    scanf(\"%d\", &n);\n\n    for (i = 0; i < n; i++)\n    {\n        printf(\"enter the value of x%d->\", i);\n        scanf(\"%f\", &x[i]);\n        printf(\"enter the value of y%d->\", i);\n        scanf(\"%f\", &y[i]);\n    }\n    printf(\"\\n X \\t\\t Y \\n\");\n    printf(\"----------------------------\\n\");\n    for (i = 0; i < n; i++)\n    {\n        printf(\"%f\\t\", x[i]);\n        printf(\"%f\\n\", y[i]);\n    }\n    printf(\"\\nenter the value of x for interpolation:\");\n    scanf(\"%f\", &a);\n    sum = 0;\n    for (i = 0; i < n; i++)\n    {\n        p = 1.0;\n        for (j = 0; j < n; j++)\n        {\n            if (i != j)\n            {\n                p = p * (a - x[j]) / (x[i] - x[j]);\n            }\n            sum = sum + y[i] * p;\n        }\n        printf(\"ans is->%f\", sum);\n\n        return 0;\n    }\n}","index":248},{"title":"Lu Decompose","category":"numerical_methods","id":"lu_decompose_numerical_methods","algorithm":"/**\n * \\file\n * \\brief [LU decomposition](https://en.wikipedia.org/wiki/LU_decompositon) of a\n * square matrix\n * \\author [Krishna Vedala](https://github.com/kvedala)\n */\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#ifdef _OPENMP\n#include <omp.h>\n#endif\n\n/** Perform LU decomposition on matrix\n * \\param[in] A matrix to decompose\n * \\param[out] L output L matrix\n * \\param[out] U output U matrix\n * \\param[in] mat_size input square matrix size\n */\nint lu_decomposition(double **A, double **L, double **U, int mat_size)\n{\n    int row, col, j;\n\n    // regularize each row\n    for (row = 0; row < mat_size; row++)\n    {\n        // Upper triangular matrix\n#ifdef _OPENMP\n#pragma omp for\n#endif\n        for (col = row; col < mat_size; col++)\n        {\n            // Summation of L[i,j] * U[j,k]\n            double lu_sum = 0.;\n            for (j = 0; j < row; j++) lu_sum += L[row][j] * U[j][col];\n\n            // Evaluate U[i,k]\n            U[row][col] = A[row][col] - lu_sum;\n        }\n\n        // Lower triangular matrix\n#ifdef _OPENMP\n#pragma omp for\n#endif\n        for (col = row; col < mat_size; col++)\n        {\n            if (row == col)\n            {\n                L[row][col] = 1.;\n                continue;\n            }\n\n            // Summation of L[i,j] * U[j,k]\n            double lu_sum = 0.;\n            for (j = 0; j < row; j++) lu_sum += L[col][j] * U[j][row];\n\n            // Evaluate U[i,k]\n            L[col][row] = (A[col][row] - lu_sum) / U[row][row];\n        }\n    }\n\n    return 0;\n}\n\n/** Function to display square matrix */\nvoid display(double **A, int N)\n{\n    for (int i = 0; i < N; i++)\n    {\n        for (int j = 0; j < N; j++)\n        {\n            printf(\"% 3.3g \\t\", A[i][j]);\n        }\n        putchar('\\n');\n    }\n}\n\n/** Main function */\nint main(int argc, char **argv)\n{\n    int mat_size = 3;  // default matrix size\n    const int range = 10;\n    const int range2 = range >> 1;\n\n    if (argc == 2)\n        mat_size = atoi(argv[1]);\n\n    srand(time(NULL));  // random number initializer\n\n    /* Create a square matrix with random values */\n    double **A = (double **)malloc(mat_size * sizeof(double *));\n    double **L = (double **)malloc(mat_size * sizeof(double *));  // output\n    double **U = (double **)malloc(mat_size * sizeof(double *));  // output\n    for (int i = 0; i < mat_size; i++)\n    {\n        // calloc so that all valeus are '0' by default\n        A[i] = (double *)calloc(mat_size, sizeof(double));\n        L[i] = (double *)calloc(mat_size, sizeof(double));\n        U[i] = (double *)calloc(mat_size, sizeof(double));\n        for (int j = 0; j < mat_size; j++)\n            /* create random values in the limits [-range2, range-1] */\n            A[i][j] = (double)(rand() % range - range2);\n    }\n\n    lu_decomposition(A, L, U, mat_size);\n\n    printf(\"A = \\n\");\n    display(A, mat_size);\n    printf(\"\\nL = \\n\");\n    display(L, mat_size);\n    printf(\"\\nU = \\n\");\n    display(U, mat_size);\n\n    /* Free dynamically allocated memory */\n    for (int i = 0; i < mat_size; i++)\n    {\n        free(A[i]);\n        free(L[i]);\n        free(U[i]);\n    }\n    free(A);\n    free(L);\n    free(U);\n\n    return 0;\n}","index":249},{"title":"Mean","category":"numerical_methods","id":"mean_numerical_methods","algorithm":"#include <limits.h>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_LEN INT_MAX\n\nint main(int argc, char **argv)\n{\n    int *a, n = 10, i, j, temp, sum = 0;\n    float mean;\n\n    if (argc == 2)\n    {\n        n = atoi(argv[1]);\n        if (n >= MAX_LEN)\n        {\n            fprintf(stderr, \"Maximum %d!\\n\", MAX_LEN);\n            return 1;\n        }\n        a = (int *)malloc(n * sizeof(int));\n    }\n\n    printf(\"Random Numbers Generated are : \");\n    for (i = 0; i < n; i++)\n    {\n        a[i] = rand() % 100;\n        printf(\"%2d, \", a[i]);\n    }\n    putchar('\\n');\n\n    for (i = 0; i < n; i++) sum = sum + a[i];\n\n    mean = sum / (float)n;\n    printf(\"\\nMean :\");\n    printf(\"%f\", mean);\n\n    free(a);\n    return 0;\n}\n","index":250},{"title":"Median","category":"numerical_methods","id":"median_numerical_methods","algorithm":"#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    int a[10], n, i, j, temp;\n    float mean, median;\n\n    printf(\"Enter no. for Random Numbers :\");\n    scanf(\"%d\", &n);\n    for (i = 0; i < n; i++)\n    {\n        a[i] = rand() % 100;\n    }\n    printf(\"Random Numbers Generated are :\\n\");\n    for (i = 0; i < n; i++)\n    {\n        printf(\"\\n%d\", a[i]);\n    }\n    printf(\"\\n\");\n    printf(\"\\nSorted Data:\");\n    for (i = 0; i < n; i++)\n    {\n        for (j = 0; j < n; j++)\n        {\n            if (a[i] < a[j])\n            {\n                temp = a[i];\n                a[i] = a[j];\n                a[j] = temp;\n            }\n        }\n    }\n    for (i = 0; i < n; i++)\n    {\n        printf(\"\\n%d\", a[i]);\n    }\n\n    if (n % 2 == 0)\n    {\n        median = (a[n / 2] + a[(n / 2) - 1]) / 2;\n    }\n    else\n    {\n        median = a[n / 2];\n    }\n    printf(\"\\nMedian is : %f\", median);\n\n    return 0;\n}\n","index":251},{"title":"Newton Raphson Root","category":"numerical_methods","id":"newton_raphson_root_numerical_methods","algorithm":"/**\n * @file\n * \\brief Find approximate solution for \\f$f(x) = 0\\f$ using\n * Newton-Raphson interpolation algorithm.\n *\n * \\author [Krishna Vedala](https://github.com/kvedala)\n */\n\n#include <complex.h> /* requires minimum of C99 */\n#include <limits.h>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n#define ACCURACY 1e-10 /**< solution accuracy */\n\n/**\n * Return value of the function to find the root for.\n * \\f$f(x)\\f$\n */\ndouble complex func(double complex x)\n{\n    return x * x - 3.; /* x^2 = 3 - solution is sqrt(3) */\n    // return x * x - 2.; /* x^2 = 2 - solution is sqrt(2) */\n}\n\n/**\n * Return first order derivative of the function.\n * \\f$f'(x)\\f$\n */\ndouble complex d_func(double complex x) { return 2. * x; }\n\n/**\n * main function\n */\nint main(int argc, char **argv)\n{\n    double delta = 1;\n    double complex cdelta = 1;\n\n    /* initialize random seed: */\n    srand(time(NULL));\n\n    /* random initial approximation */\n    double complex root = (rand() % 100 - 50) + (rand() % 100 - 50) * I;\n\n    unsigned long counter = 0;\n    /* iterate till a convergence is reached */\n    while (delta > ACCURACY && counter < ULONG_MAX)\n    {\n        cdelta = func(root) / d_func(root);\n        root += -cdelta;\n        counter++;\n        delta = fabs(cabs(cdelta));\n\n#if defined(DEBUG) || !defined(NDEBUG)\n        if (counter % 50 == 0)\n        {\n            double r = creal(root);\n            double c = cimag(root);\n\n            printf(\"Iter %5lu: Root: %4.4g%c%4.4gi\\t\\tdelta: %.4g\\n\", counter,\n                   r, c >= 0 ? '+' : '-', c >= 0 ? c : -c, delta);\n        }\n#endif\n    }\n\n    double r = creal(root);\n    double c = fabs(cimag(root)) < ACCURACY ? 0 : cimag(root);\n\n    printf(\"Iter %5lu: Root: %4.4g%c%4.4gi\\t\\tdelta: %.4g\\n\", counter, r,\n           c >= 0 ? '+' : '-', c >= 0 ? c : -c, delta);\n\n    return 0;\n}\n","index":252},{"title":"Ode Forward Euler","category":"numerical_methods","id":"ode_forward_euler_numerical_methods","algorithm":"/**\n * \\file\n * \\authors [Krishna Vedala](https://github.com/kvedala)\n * \\brief Solve a multivariable first order [ordinary differential equation\n * (ODEs)](https://en.wikipedia.org/wiki/Ordinary_differential_equation) using\n * [forward Euler\n * method](https://en.wikipedia.org/wiki/Numerical_methods_for_ordinary_differential_equations#Euler_method)\n *\n * \\details\n * The ODE being solved is:\n * \\f{eqnarray*}{\n * \\dot{u} &=& v\\\\\n * \\dot{v} &=& -\\omega^2 u\\\\\n * \\omega &=& 1\\\\\n * [x_0, u_0, v_0] &=& [0,1,0]\\qquad\\ldots\\text{(initial values)}\n * \\f}\n * The exact solution for the above problem is:\n * \\f{eqnarray*}{\n * u(x) &=& \\cos(x)\\\\\n * v(x) &=& -\\sin(x)\\\\\n * \\f}\n * The computation results are stored to a text file `forward_euler.csv` and the\n * exact soltuion results in `exact.csv` for comparison.\n * <img\n * src=\"https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/numerical_methods/ode_forward_euler.svg\"\n * alt=\"Implementation solution\"/>\n *\n * To implement [Van der Pol\n * oscillator](https://en.wikipedia.org/wiki/Van_der_Pol_oscillator), change the\n * ::problem function to:\n * ```cpp\n * const double mu = 2.0;\n * dy[0] = y[1];\n * dy[1] = mu * (1.f - y[0] * y[0]) * y[1] - y[0];\n * ```\n * \\see ode_midpoint_euler.c, ode_semi_implicit_euler.c\n */\n\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n#define order 2 /**< number of dependent variables in ::problem */\n\n/**\n * @brief Problem statement for a system with first-order differential\n * equations. Updates the system differential variables.\n * \\note This function can be updated to and ode of any order.\n *\n * @param[in] \t\tx \t\tindependent variable(s)\n * @param[in,out]\ty\t\tdependent variable(s)\n * @param[in,out]\tdy\t    first-derivative of dependent variable(s)\n */\nvoid problem(const double *x, double *y, double *dy)\n{\n    const double omega = 1.F;       // some const for the problem\n    dy[0] = y[1];                   // x dot\n    dy[1] = -omega * omega * y[0];  // y dot\n}\n\n/**\n * @brief Exact solution of the problem. Used for solution comparison.\n *\n * @param[in] \t\tx \t\tindependent variable\n * @param[in,out]\ty\t\tdependent variable\n */\nvoid exact_solution(const double *x, double *y)\n{\n    y[0] = cos(x[0]);\n    y[1] = -sin(x[0]);\n}\n\n/**\n * @brief Compute next step approximation using the forward-Euler\n * method. @f[y_{n+1}=y_n + dx\\cdot f\\left(x_n,y_n\\right)@f]\n * @param[in] \t\tdx\tstep size\n * @param[in,out] \tx\ttake \\f$x_n\\f$ and compute \\f$x_{n+1}\\f$\n * @param[in,out] \ty\ttake \\f$y_n\\f$ and compute \\f$y_{n+1}\\f$\n * @param[in,out]\tdy\tcompute \\f$f\\left(x_n,y_n\\right)\\f$\n */\nvoid forward_euler_step(const double dx, const double *x, double *y, double *dy)\n{\n    int o;\n    problem(x, y, dy);\n    for (o = 0; o < order; o++) y[o] += dx * dy[o];\n}\n\n/**\n * @brief Compute approximation using the forward-Euler\n * method in the given limits.\n * @param[in] \t\tdx  \tstep size\n * @param[in]   \tx0  \tinitial value of independent variable\n * @param[in] \t    x_max\tfinal value of independent variable\n * @param[in,out] \ty\t    take \\f$y_n\\f$ and compute \\f$y_{n+1}\\f$\n * @param[in] save_to_file\tflag to save results to a CSV file (1) or not (0)\n * @returns time taken for computation in seconds\n */\ndouble forward_euler(double dx, double x0, double x_max, double *y,\n                     char save_to_file)\n{\n    double dy[order];\n\n    FILE *fp = NULL;\n    if (save_to_file)\n    {\n        fp = fopen(\"forward_euler.csv\", \"w+\");\n        if (fp == NULL)\n        {\n            perror(\"Error! \");\n            return -1;\n        }\n    }\n\n    /* start integration */\n    clock_t t1 = clock();\n    double x = x0;\n    do  // iterate for each step of independent variable\n    {\n        if (save_to_file && fp)\n            fprintf(fp, \"%.4g,%.4g,%.4g\\n\", x, y[0], y[1]);  // write to file\n        forward_euler_step(dx, &x, y, dy);  // perform integration\n        x += dx;                            // update step\n    } while (x <= x_max);  // till upper limit of independent variable\n    /* end of integration */\n    clock_t t2 = clock();\n\n    if (save_to_file && fp)\n        fclose(fp);\n\n    return (double)(t2 - t1) / CLOCKS_PER_SEC;\n}\n\n/**\n    Main Function\n*/\nint main(int argc, char *argv[])\n{\n    double X0 = 0.f;          /* initial value of x0 */\n    double X_MAX = 10.F;      /* upper limit of integration */\n    double Y0[] = {1.f, 0.f}; /* initial value Y = y(x = x_0) */\n    double step_size;\n\n    if (argc == 1)\n    {\n        printf(\"\\nEnter the step size: \");\n        scanf(\"%lg\", &step_size);\n    }\n    else\n        // use commandline argument as independent variable step size\n        step_size = atof(argv[1]);\n\n    // get approximate solution\n    double total_time = forward_euler(step_size, X0, X_MAX, Y0, 1);\n    printf(\"\\tTime = %.6g ms\\n\", total_time);\n\n    /* compute exact solution for comparion */\n    FILE *fp = fopen(\"exact.csv\", \"w+\");\n    if (fp == NULL)\n    {\n        perror(\"Error! \");\n        return -1;\n    }\n    double x = X0;\n    double *y = &(Y0[0]);\n    printf(\"Finding exact solution\\n\");\n    clock_t t1 = clock();\n\n    do\n    {\n        fprintf(fp, \"%.4g,%.4g,%.4g\\n\", x, y[0], y[1]);  // write to file\n        exact_solution(&x, y);\n        x += step_size;\n    } while (x <= X_MAX);\n\n    clock_t t2 = clock();\n    total_time = (t2 - t1) / CLOCKS_PER_SEC;\n    printf(\"\\tTime = %.6g ms\\n\", total_time);\n    fclose(fp);\n\n    return 0;\n}\n","index":253},{"title":"Ode Midpoint Euler","category":"numerical_methods","id":"ode_midpoint_euler_numerical_methods","algorithm":"/**\n * \\file\n * \\authors [Krishna Vedala](https://github.com/kvedala)\n * \\brief Solve a multivariable first order [ordinary differential equation\n * (ODEs)](https://en.wikipedia.org/wiki/Ordinary_differential_equation) using\n * [midpoint Euler\n * method](https://en.wikipedia.org/wiki/Midpoint_method)\n *\n * \\details\n * The ODE being solved is:\n * \\f{eqnarray*}{\n * \\dot{u} &=& v\\\\\n * \\dot{v} &=& -\\omega^2 u\\\\\n * \\omega &=& 1\\\\\n * [x_0, u_0, v_0] &=& [0,1,0]\\qquad\\ldots\\text{(initial values)}\n * \\f}\n * The exact solution for the above problem is:\n * \\f{eqnarray*}{\n * u(x) &=& \\cos(x)\\\\\n * v(x) &=& -\\sin(x)\\\\\n * \\f}\n * The computation results are stored to a text file `midpoint_euler.csv` and\n * the exact soltuion results in `exact.csv` for comparison. <img\n * src=\"https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/numerical_methods/ode_midpoint_euler.svg\"\n * alt=\"Implementation solution\"/>\n *\n * To implement [Van der Pol\n * oscillator](https://en.wikipedia.org/wiki/Van_der_Pol_oscillator), change the\n * ::problem function to:\n * ```cpp\n * const double mu = 2.0;\n * dy[0] = y[1];\n * dy[1] = mu * (1.f - y[0] * y[0]) * y[1] - y[0];\n * ```\n * \\see ode_forward_euler.c, ode_semi_implicit_euler.c\n */\n\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n#define order 2 /**< number of dependent variables in ::problem */\n\n/**\n * @brief Problem statement for a system with first-order differential\n * equations. Updates the system differential variables.\n * \\note This function can be updated to and ode of any order.\n *\n * @param[in] \t\tx \t\tindependent variable(s)\n * @param[in,out]\ty\t\tdependent variable(s)\n * @param[in,out]\tdy\t    first-derivative of dependent variable(s)\n */\nvoid problem(const double *x, double *y, double *dy)\n{\n    const double omega = 1.F;       // some const for the problem\n    dy[0] = y[1];                   // x dot\n    dy[1] = -omega * omega * y[0];  // y dot\n}\n\n/**\n * @brief Exact solution of the problem. Used for solution comparison.\n *\n * @param[in] \t\tx \t\tindependent variable\n * @param[in,out]\ty\t\tdependent variable\n */\nvoid exact_solution(const double *x, double *y)\n{\n    y[0] = cos(x[0]);\n    y[1] = -sin(x[0]);\n}\n\n/**\n * @brief Compute next step approximation using the midpoint-Euler\n * method.\n * @f[y_{n+1} = y_n + dx\\, f\\left(x_n+\\frac{1}{2}dx,\n * y_n + \\frac{1}{2}dx\\,f\\left(x_n,y_n\\right)\\right)@f]\n * @param[in] \t\tdx\tstep size\n * @param[in,out] \tx\ttake @f$x_n@f$ and compute @f$x_{n+1}@f$\n * @param[in,out] \ty\ttake @f$y_n@f$ and compute @f$y_{n+1}@f$\n * @param[in,out]\tdy\tcompute @f$y_n+\\frac{1}{2}dx\\,f\\left(x_n,y_n\\right)@f$\n */\nvoid midpoint_euler_step(double dx, double *x, double *y, double *dy)\n{\n    problem(x, y, dy);\n    double tmp_x = (*x) + 0.5 * dx;\n    double tmp_y[order];\n    int o;\n    for (o = 0; o < order; o++) tmp_y[o] = y[o] + 0.5 * dx * dy[o];\n\n    problem(&tmp_x, tmp_y, dy);\n\n    for (o = 0; o < order; o++) y[o] += dx * dy[o];\n}\n\n/**\n * @brief Compute approximation using the midpoint-Euler\n * method in the given limits.\n * @param[in] \t\tdx  \tstep size\n * @param[in]   \tx0  \tinitial value of independent variable\n * @param[in] \t    x_max\tfinal value of independent variable\n * @param[in,out] \ty\t    take \\f$y_n\\f$ and compute \\f$y_{n+1}\\f$\n * @param[in] save_to_file\tflag to save results to a CSV file (1) or not (0)\n * @returns time taken for computation in seconds\n */\ndouble midpoint_euler(double dx, double x0, double x_max, double *y,\n                      char save_to_file)\n{\n    double dy[order];\n\n    FILE *fp = NULL;\n    if (save_to_file)\n    {\n        fp = fopen(\"midpoint_euler.csv\", \"w+\");\n        if (fp == NULL)\n        {\n            perror(\"Error! \");\n            return -1;\n        }\n    }\n\n    /* start integration */\n    clock_t t1 = clock();\n    double x = x0;\n    do  // iterate for each step of independent variable\n    {\n        if (save_to_file && fp)\n            fprintf(fp, \"%.4g,%.4g,%.4g\\n\", x, y[0], y[1]);  // write to file\n        midpoint_euler_step(dx, &x, y, dy);  // perform integration\n        x += dx;                             // update step\n    } while (x <= x_max);  // till upper limit of independent variable\n    /* end of integration */\n    clock_t t2 = clock();\n\n    if (save_to_file && fp)\n        fclose(fp);\n\n    return (double)(t2 - t1) / CLOCKS_PER_SEC;\n}\n\n/**\n    Main Function\n*/\nint main(int argc, char *argv[])\n{\n    double X0 = 0.f;          /* initial value of x0 */\n    double X_MAX = 10.F;      /* upper limit of integration */\n    double Y0[] = {1.f, 0.f}; /* initial value Y = y(x = x_0) */\n    double step_size;\n\n    if (argc == 1)\n    {\n        printf(\"\\nEnter the step size: \");\n        scanf(\"%lg\", &step_size);\n    }\n    else\n        // use commandline argument as independent variable step size\n        step_size = atof(argv[1]);\n\n    // get approximate solution\n    double total_time = midpoint_euler(step_size, X0, X_MAX, Y0, 1);\n    printf(\"\\tTime = %.6g ms\\n\", total_time);\n\n    /* compute exact solution for comparion */\n    FILE *fp = fopen(\"exact.csv\", \"w+\");\n    if (fp == NULL)\n    {\n        perror(\"Error! \");\n        return -1;\n    }\n    double x = X0;\n    double *y = &(Y0[0]);\n    printf(\"Finding exact solution\\n\");\n    clock_t t1 = clock();\n\n    do\n    {\n        fprintf(fp, \"%.4g,%.4g,%.4g\\n\", x, y[0], y[1]);  // write to file\n        exact_solution(&x, y);\n        x += step_size;\n    } while (x <= X_MAX);\n\n    clock_t t2 = clock();\n    total_time = (t2 - t1) / CLOCKS_PER_SEC;\n    printf(\"\\tTime = %.6g ms\\n\", total_time);\n    fclose(fp);\n\n    return 0;\n}\n","index":254},{"title":"Ode Semi Implicit Euler","category":"numerical_methods","id":"ode_semi_implicit_euler_numerical_methods","algorithm":"/**\n * \\file\n * \\authors [Krishna Vedala](https://github.com/kvedala)\n * \\brief Solve a multivariable first order [ordinary differential equation\n * (ODEs)](https://en.wikipedia.org/wiki/Ordinary_differential_equation) using\n * [semi implicit Euler\n * method](https://en.wikipedia.org/wiki/Semi-implicit_Euler_method)\n *\n * \\details\n * The ODE being solved is:\n * \\f{eqnarray*}{\n * \\dot{u} &=& v\\\\\n * \\dot{v} &=& -\\omega^2 u\\\\\n * \\omega &=& 1\\\\\n * [x_0, u_0, v_0] &=& [0,1,0]\\qquad\\ldots\\text{(initial values)}\n * \\f}\n * The exact solution for the above problem is:\n * \\f{eqnarray*}{\n * u(x) &=& \\cos(x)\\\\\n * v(x) &=& -\\sin(x)\\\\\n * \\f}\n * The computation results are stored to a text file `semi_implicit_euler.csv`\n * and the exact soltuion results in `exact.csv` for comparison. <img\n * src=\"https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/numerical_methods/ode_semi_implicit_euler.svg\"\n * alt=\"Implementation solution\"/>\n *\n * To implement [Van der Pol\n * oscillator](https://en.wikipedia.org/wiki/Van_der_Pol_oscillator), change the\n * ::problem function to:\n * ```cpp\n * const double mu = 2.0;\n * dy[0] = y[1];\n * dy[1] = mu * (1.f - y[0] * y[0]) * y[1] - y[0];\n * ```\n * <a href=\"https://en.wikipedia.org/wiki/Van_der_Pol_oscillator\"><img\n * src=\"https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/numerical_methods/van_der_pol_implicit_euler.svg\"\n * alt=\"Van der Pol Oscillator solution\"/></a>\n *\n * \\see ode_forward_euler.c, ode_midpoint_euler.c\n */\n\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n#define order 2 /**< number of dependent variables in ::problem */\n\n/**\n * @brief Problem statement for a system with first-order differential\n * equations. Updates the system differential variables.\n * \\note This function can be updated to and ode of any order.\n *\n * @param[in] \t\tx \t\tindependent variable(s)\n * @param[in,out]\ty\t\tdependent variable(s)\n * @param[in,out]\tdy\t    first-derivative of dependent variable(s)\n */\nvoid problem(const double *x, double *y, double *dy)\n{\n    const double omega = 1.F;       // some const for the problem\n    dy[0] = y[1];                   // x dot\n    dy[1] = -omega * omega * y[0];  // y dot\n}\n\n/**\n * @brief Exact solution of the problem. Used for solution comparison.\n *\n * @param[in] \t\tx \t\tindependent variable\n * @param[in,out]\ty\t\tdependent variable\n */\nvoid exact_solution(const double *x, double *y)\n{\n    y[0] = cos(x[0]);\n    y[1] = -sin(x[0]);\n}\n\n/**\n * @brief Compute next step approximation using the semi-implicit-Euler\n * method.\n * @param[in] \t\tdx\tstep size\n * @param[in,out] \tx\ttake @f$x_n@f$ and compute @f$x_{n+1}@f$\n * @param[in,out] \ty\ttake @f$y_n@f$ and compute @f$y_{n+1}@f$\n * @param[in,out]\tdy\tcompute @f$y_n+\\frac{1}{2}dx\\,f\\left(x_n,y_n\\right)@f$\n */\nvoid semi_implicit_euler_step(double dx, double *x, double *y, double *dy)\n{\n    int o;\n\n    problem(x, y, dy);   // update dy once\n    y[0] += dx * dy[0];  // update y0\n\n    problem(x, y, dy);  // update dy once more\n\n    for (o = 1; o < order; o++)\n        y[o] += dx * dy[o];  // update remaining using new dy\n    *x += dx;\n}\n\n/**\n * @brief Compute approximation using the semi-implicit-Euler\n * method in the given limits.\n * @param[in] \t\tdx  \tstep size\n * @param[in]   \tx0  \tinitial value of independent variable\n * @param[in] \t    x_max\tfinal value of independent variable\n * @param[in,out] \ty\t    take \\f$y_n\\f$ and compute \\f$y_{n+1}\\f$\n * @param[in] save_to_file\tflag to save results to a CSV file (1) or not (0)\n * @returns time taken for computation in seconds\n */\ndouble semi_implicit_euler(double dx, double x0, double x_max, double *y,\n                           char save_to_file)\n{\n    double dy[order];\n\n    FILE *fp = NULL;\n    if (save_to_file)\n    {\n        fp = fopen(\"semi_implicit_euler.csv\", \"w+\");\n        if (fp == NULL)\n        {\n            perror(\"Error! \");\n            return -1;\n        }\n    }\n\n    /* start integration */\n    clock_t t1 = clock();\n    double x = x0;\n    do  // iterate for each step of independent variable\n    {\n        if (save_to_file && fp)\n            fprintf(fp, \"%.4g,%.4g,%.4g\\n\", x, y[0], y[1]);  // write to file\n        semi_implicit_euler_step(dx, &x, y, dy);  // perform integration\n        x += dx;                                  // update step\n    } while (x <= x_max);  // till upper limit of independent variable\n    /* end of integration */\n    clock_t t2 = clock();\n\n    if (save_to_file && fp)\n        fclose(fp);\n\n    return (double)(t2 - t1) / CLOCKS_PER_SEC;\n}\n\n/**\n    Main Function\n*/\nint main(int argc, char *argv[])\n{\n    double X0 = 0.f;          /* initial value of x0 */\n    double X_MAX = 10.F;      /* upper limit of integration */\n    double Y0[] = {1.f, 0.f}; /* initial value Y = y(x = x_0) */\n    double step_size;\n\n    if (argc == 1)\n    {\n        printf(\"\\nEnter the step size: \");\n        scanf(\"%lg\", &step_size);\n    }\n    else\n        // use commandline argument as independent variable step size\n        step_size = atof(argv[1]);\n\n    // get approximate solution\n    double total_time = semi_implicit_euler(step_size, X0, X_MAX, Y0, 1);\n    printf(\"\\tTime = %.6g ms\\n\", total_time);\n\n    /* compute exact solution for comparion */\n    FILE *fp = fopen(\"exact.csv\", \"w+\");\n    if (fp == NULL)\n    {\n        perror(\"Error! \");\n        return -1;\n    }\n    double x = X0;\n    double *y = &(Y0[0]);\n    printf(\"Finding exact solution\\n\");\n    clock_t t1 = clock();\n\n    do\n    {\n        fprintf(fp, \"%.4g,%.4g,%.4g\\n\", x, y[0], y[1]);  // write to file\n        exact_solution(&x, y);\n        x += step_size;\n    } while (x <= X_MAX);\n\n    clock_t t2 = clock();\n    total_time = (t2 - t1) / CLOCKS_PER_SEC;\n    printf(\"\\tTime = %.6g ms\\n\", total_time);\n    fclose(fp);\n\n    return 0;\n}\n","index":255},{"title":"Qr Decompose.h","category":"numerical_methods","id":"qr_decompose.h_numerical_methods","algorithm":"/**\n * @file\n * \\brief Library functions to compute [QR\n * decomposition](https://en.wikipedia.org/wiki/QR_decomposition) of a given\n * matrix.\n * \\author [Krishna Vedala](https://github.com/kvedala)\n */\n\n#ifndef QR_DECOMPOSE_H\n#define QR_DECOMPOSE_H\n\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#ifdef _OPENMP\n#include <omp.h>\n#endif\n\n/**\n * function to display matrix on stdout\n */\nvoid print_matrix(double **A, /**< matrix to print */\n                  int M,      /**< number of rows of matrix */\n                  int N)      /**< number of columns of matrix */\n{\n    for (int row = 0; row < M; row++)\n    {\n        for (int col = 0; col < N; col++) printf(\"% 9.3g\\t\", A[row][col]);\n        putchar('\\n');\n    }\n    putchar('\\n');\n}\n\n/**\n * Compute dot product of two vectors of equal lengths\n *\n * If \\f$\\vec{a}=\\left[a_0,a_1,a_2,...,a_L\\right]\\f$ and\n * \\f$\\vec{b}=\\left[b_0,b_1,b_1,...,b_L\\right]\\f$ then\n * \\f$\\vec{a}\\cdot\\vec{b}=\\displaystyle\\sum_{i=0}^L a_i\\times b_i\\f$\n *\n * \\returns \\f$\\vec{a}\\cdot\\vec{b}\\f$\n */\ndouble vector_dot(double *a, double *b, int L)\n{\n    double mag = 0.f;\n    int i;\n#ifdef _OPENMP\n// parallelize on threads\n#pragma omp parallel for reduction(+ : mag)\n#endif\n    for (i = 0; i < L; i++) mag += a[i] * b[i];\n\n    return mag;\n}\n\n/**\n * Compute magnitude of vector.\n *\n * If \\f$\\vec{a}=\\left[a_0,a_1,a_2,...,a_L\\right]\\f$ then\n * \\f$\\left|\\vec{a}\\right|=\\sqrt{\\displaystyle\\sum_{i=0}^L a_i^2}\\f$\n *\n * \\returns \\f$\\left|\\vec{a}\\right|\\f$\n */\ndouble vector_mag(double *vector, int L)\n{\n    double dot = vector_dot(vector, vector, L);\n    return sqrt(dot);\n}\n\n/**\n * Compute projection of vector \\f$\\vec{a}\\f$ on \\f$\\vec{b}\\f$ defined as\n * \\f[\\text{proj}_\\vec{b}\\vec{a}=\\frac{\\vec{a}\\cdot\\vec{b}}{\\left|\\vec{b}\\right|^2}\\vec{b}\\f]\n *\n * \\returns NULL if error, otherwise pointer to output\n */\ndouble *vector_proj(double *a, double *b, double *out, int L)\n{\n    const double num = vector_dot(a, b, L);\n    const double deno = vector_dot(b, b, L);\n    if (deno == 0) /*! check for division by zero */\n        return NULL;\n\n    const double scalar = num / deno;\n    int i;\n#ifdef _OPENMP\n// parallelize on threads\n#pragma omp for\n#endif\n    for (i = 0; i < L; i++) out[i] = scalar * b[i];\n\n    return out;\n}\n\n/**\n * Compute vector subtraction\n *\n * \\f$\\vec{c}=\\vec{a}-\\vec{b}\\f$\n *\n * \\returns pointer to output vector\n */\ndouble *vector_sub(double *a,   /**< minuend */\n                   double *b,   /**< subtrahend */\n                   double *out, /**< resultant vector */\n                   int L        /**< length of vectors */\n)\n{\n    int i;\n#ifdef _OPENMP\n// parallelize on threads\n#pragma omp for\n#endif\n    for (i = 0; i < L; i++) out[i] = a[i] - b[i];\n\n    return out;\n}\n\n/**\n * Decompose matrix \\f$A\\f$ using [Gram-Schmidt\n *process](https://en.wikipedia.org/wiki/QR_decomposition).\n *\n * \\f{eqnarray*}{\n * \\text{given that}\\quad A &=&\n *\\left[\\mathbf{a}_1,\\mathbf{a}_2,\\ldots,\\mathbf{a}_{N-1},\\right]\\\\\n * \\text{where}\\quad\\mathbf{a}_i &=&\n *\\left[a_{0i},a_{1i},a_{2i},\\ldots,a_{(M-1)i}\\right]^T\\quad\\ldots\\mbox{(column\n *vectors)}\\\\\n * \\text{then}\\quad\\mathbf{u}_i &=& \\mathbf{a}_i\n *-\\sum_{j=0}^{i-1}\\text{proj}_{\\mathbf{u}_j}\\mathbf{a}_i\\\\\n * \\mathbf{e}_i &=&\\frac{\\mathbf{u}_i}{\\left|\\mathbf{u}_i\\right|}\\\\\n * Q &=& \\begin{bmatrix}\\mathbf{e}_0 & \\mathbf{e}_1 & \\mathbf{e}_2 & \\dots &\n *\\mathbf{e}_{N-1}\\end{bmatrix}\\\\\n * R &=& \\begin{bmatrix}\\langle\\mathbf{e}_0\\,,\\mathbf{a}_0\\rangle &\n *\\langle\\mathbf{e}_1\\,,\\mathbf{a}_1\\rangle &\n *\\langle\\mathbf{e}_2\\,,\\mathbf{a}_2\\rangle & \\dots \\\\\n *                  0 & \\langle\\mathbf{e}_1\\,,\\mathbf{a}_1\\rangle &\n *\\langle\\mathbf{e}_2\\,,\\mathbf{a}_2\\rangle & \\dots\\\\\n *                  0 & 0 & \\langle\\mathbf{e}_2\\,,\\mathbf{a}_2\\rangle & \\dots\\\\\n *                  \\vdots & \\vdots & \\vdots & \\ddots\n *      \\end{bmatrix}\\\\\n * \\f}\n */\nvoid qr_decompose(double **A, /**< input matrix to decompose */\n                  double **Q, /**< output decomposed matrix */\n                  double **R, /**< output decomposed matrix */\n                  int M,      /**< number of rows of matrix A */\n                  int N       /**< number of columns of matrix A */\n)\n{\n    double *col_vector = (double *)malloc(M * sizeof(double));\n    double *col_vector2 = (double *)malloc(M * sizeof(double));\n    double *tmp_vector = (double *)malloc(M * sizeof(double));\n    for (int i = 0; i < N;\n         i++) /* for each column => R is a square matrix of NxN */\n    {\n        int j;\n#ifdef _OPENMP\n// parallelize on threads\n#pragma omp for\n#endif\n        for (j = 0; j < i; j++) /* second dimension of column */\n            R[i][j] = 0.;       /* make R upper triangular */\n\n            /* get corresponding Q vector */\n#ifdef _OPENMP\n// parallelize on threads\n#pragma omp for\n#endif\n        for (j = 0; j < M; j++)\n        {\n            tmp_vector[j] = A[j][i]; /* accumulator for uk */\n            col_vector[j] = A[j][i];\n        }\n        for (j = 0; j < i; j++)\n        {\n            for (int k = 0; k < M; k++) col_vector2[k] = Q[k][j];\n            vector_proj(col_vector, col_vector2, col_vector2, M);\n            vector_sub(tmp_vector, col_vector2, tmp_vector, M);\n        }\n        double mag = vector_mag(tmp_vector, M);\n\n#ifdef _OPENMP\n// parallelize on threads\n#pragma omp for\n#endif\n        for (j = 0; j < M; j++) Q[j][i] = tmp_vector[j] / mag;\n\n        /* compute upper triangular values of R */\n        for (int kk = 0; kk < M; kk++) col_vector[kk] = Q[kk][i];\n        for (int k = i; k < N; k++)\n        {\n            for (int kk = 0; kk < M; kk++) col_vector2[kk] = A[kk][k];\n            R[i][k] = vector_dot(col_vector, col_vector2, M);\n        }\n    }\n\n    free(col_vector);\n    free(col_vector2);\n    free(tmp_vector);\n}\n\n#endif  // QR_DECOMPOSE_H\n","index":256},{"title":"Qr Decomposition","category":"numerical_methods","id":"qr_decomposition_numerical_methods","algorithm":"/**\n * @file\n * \\brief Program to compute the [QR\n * decomposition](https://en.wikipedia.org/wiki/QR_decomposition) of a given\n * matrix.\n * \\author [Krishna Vedala](https://github.com/kvedala)\n */\n\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include \"qr_decompose.h\"\n\n/**\n * main function\n */\nint main(void)\n{\n    double **A;\n    unsigned int ROWS, COLUMNS;\n\n    printf(\"Enter the number of rows and columns: \");\n    scanf(\"%u %u\", &ROWS, &COLUMNS);\n    if (ROWS < COLUMNS)\n    {\n        fprintf(stderr,\n                \"Number of rows must be greater than or equal to \"\n                \"number of columns.\\n\");\n        return -1;\n    }\n\n    printf(\"Enter matrix elements row-wise:\\n\");\n\n    A = (double **)malloc(ROWS * sizeof(double *));\n    for (int i = 0; i < ROWS; i++)\n        A[i] = (double *)malloc(COLUMNS * sizeof(double));\n\n    for (int i = 0; i < ROWS; i++)\n        for (int j = 0; j < COLUMNS; j++) scanf(\"%lf\", &A[i][j]);\n\n    print_matrix(A, ROWS, COLUMNS);\n\n    double **R = (double **)malloc(sizeof(double *) * ROWS);\n    double **Q = (double **)malloc(sizeof(double *) * ROWS);\n    if (!Q || !R)\n    {\n        perror(\"Unable to allocate memory for Q & R!\");\n        return -1;\n    }\n    for (int i = 0; i < ROWS; i++)\n    {\n        R[i] = (double *)malloc(sizeof(double) * COLUMNS);\n        Q[i] = (double *)malloc(sizeof(double) * ROWS);\n        if (!Q[i] || !R[i])\n        {\n            perror(\"Unable to allocate memory for Q & R.\");\n            return -1;\n        }\n    }\n\n    clock_t t1 = clock();\n    qr_decompose(A, Q, R, ROWS, COLUMNS);\n    double dtime = (double)(clock() - t1) / CLOCKS_PER_SEC;\n\n    print_matrix(R, ROWS, COLUMNS);\n    print_matrix(Q, ROWS, COLUMNS);\n    printf(\"Time taken to compute: %.4g sec\\n\", dtime);\n\n    for (int i = 0; i < ROWS; i++)\n    {\n        free(A[i]);\n        free(R[i]);\n        free(Q[i]);\n    }\n    free(A);\n    free(R);\n    free(Q);\n    return 0;\n}\n","index":257},{"title":"Qr Eigen Values","category":"numerical_methods","id":"qr_eigen_values_numerical_methods","algorithm":"/**\n * @file\n * \\brief Compute real eigen values and eigen vectors of a symmetric matrix\n * using [QR decomposition](https://en.wikipedia.org/wiki/QR_decomposition)\n * method.\n * \\author [Krishna Vedala](https://github.com/kvedala)\n */\n#include <assert.h>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n#include \"qr_decompose.h\"\n#ifdef _OPENMP\n#include <omp.h>\n#endif\n\n#define LIMS 9        /**< limit of range of matrix values */\n#define EPSILON 1e-10 /**< accuracy tolerance limit */\n\n/**\n * create a square matrix of given size with random elements\n * \\param[out] A matrix to create (must be pre-allocated in memory)\n * \\param[in] N matrix size\n */\nvoid create_matrix(double **A, int N)\n{\n    int i, j, tmp, lim2 = LIMS >> 1;\n\n#ifdef _OPENMP\n#pragma omp for\n#endif\n    for (i = 0; i < N; i++)\n    {\n        A[i][i] = (rand() % LIMS) - lim2;\n        for (j = i + 1; j < N; j++)\n        {\n            tmp = (rand() % LIMS) - lim2;\n            A[i][j] = tmp;\n            A[j][i] = tmp;\n        }\n    }\n}\n\n/**\n * Perform multiplication of two matrices.\n * * R2 must be equal to C1\n * * Resultant matrix size should be R1xC2\n * \\param[in] A first matrix to multiply\n * \\param[in] B second matrix to multiply\n * \\param[out] OUT output matrix (must be pre-allocated)\n * \\param[in] R1 number of rows of first matrix\n * \\param[in] C1 number of columns of first matrix\n * \\param[in] R2 number of rows of second matrix\n * \\param[in] C2 number of columns of second matrix\n * \\returns pointer to resultant matrix\n */\ndouble **mat_mul(double **A, double **B, double **OUT, int R1, int C1, int R2,\n                 int C2)\n{\n    if (C1 != R2)\n    {\n        perror(\"Matrix dimensions mismatch!\");\n        return OUT;\n    }\n\n    int i;\n#ifdef _OPENMP\n#pragma omp for\n#endif\n    for (i = 0; i < R1; i++)\n    {\n        for (int j = 0; j < C2; j++)\n        {\n            OUT[i][j] = 0.f;\n            for (int k = 0; k < C1; k++) OUT[i][j] += A[i][k] * B[k][j];\n        }\n    }\n    return OUT;\n}\n\n/** Compute eigen values using iterative shifted QR decomposition algorithm as\n * follows:\n * 1. Use last diagonal element of A as eigen value approximation \\f$c\\f$\n * 2. Shift diagonals of matrix \\f$A' = A - cI\\f$\n * 3. Decompose matrix \\f$A'=QR\\f$\n * 4. Compute next approximation \\f$A'_1 = RQ \\f$\n * 5. Shift diagonals back \\f$A_1 = A'_1 + cI\\f$\n * 6. Termination condition check: last element below diagonal is almost 0\n *   1. If not 0, go back to step 1 with the new approximation \\f$A_1\\f$\n *   2. If 0, continue to step 7\n * 7. Save last known \\f$c\\f$ as the eigen value.\n * 8. Are all eigen values found?\n *   1. If not, remove last row and column of \\f$A_1\\f$ and go back to step 1.\n *   2. If yes, stop.\n *\n * \\note The matrix \\f$A\\f$ gets modified\n *\n * \\param[in,out] A matrix to compute eigen values for\n * \\param[out] eigen_vals resultant vector containing computed eigen values\n * \\param[in] mat_size matrix size\n * \\param[in] debug_print 1 to print intermediate Q & R matrices, 0 for not to\n * \\returns time for computation in seconds\n */\ndouble eigen_values(double **A, double *eigen_vals, int mat_size,\n                    char debug_print)\n{\n    if (!eigen_vals)\n    {\n        perror(\"Output eigen value vector cannot be NULL!\");\n        return -1;\n    }\n    double **R = (double **)malloc(sizeof(double *) * mat_size);\n    double **Q = (double **)malloc(sizeof(double *) * mat_size);\n    if (!Q || !R)\n    {\n        perror(\"Unable to allocate memory for Q & R!\");\n        if (Q)\n        {\n            free(Q);\n        }\n        if (R)\n        {\n            free(R);\n        }\n        return -1;\n    }\n\n    /* allocate dynamic memory for matrices */\n    for (int i = 0; i < mat_size; i++)\n    {\n        R[i] = (double *)malloc(sizeof(double) * mat_size);\n        Q[i] = (double *)malloc(sizeof(double) * mat_size);\n        if (!Q[i] || !R[i])\n        {\n            perror(\"Unable to allocate memory for Q & R.\");\n            for (; i >= 0; i--)\n            {\n                free(R[i]);\n                free(Q[i]);\n            }\n            free(Q);\n            free(R);\n            return -1;\n        }\n    }\n\n    if (debug_print)\n    {\n        print_matrix(A, mat_size, mat_size);\n    }\n\n    int rows = mat_size, columns = mat_size;\n    int counter = 0, num_eigs = rows - 1;\n    double last_eig = 0;\n\n    clock_t t1 = clock();\n    while (num_eigs > 0) /* continue till all eigen values are found */\n    {\n        /* iterate with QR decomposition */\n        while (fabs(A[num_eigs][num_eigs - 1]) > EPSILON)\n        {\n            last_eig = A[num_eigs][num_eigs];\n            for (int i = 0; i < rows; i++) A[i][i] -= last_eig; /* A - cI */\n            qr_decompose(A, Q, R, rows, columns);\n\n            if (debug_print)\n            {\n                print_matrix(A, rows, columns);\n                print_matrix(Q, rows, columns);\n                print_matrix(R, columns, columns);\n                printf(\"-------------------- %d ---------------------\\n\",\n                       ++counter);\n            }\n\n            mat_mul(R, Q, A, columns, columns, rows, columns);\n            for (int i = 0; i < rows; i++) A[i][i] += last_eig; /* A + cI */\n        }\n\n        /* store the converged eigen value */\n        eigen_vals[num_eigs] = last_eig;\n\n        if (debug_print)\n        {\n            printf(\"========================\\n\");\n            printf(\"Eigen value: % g,\\n\", last_eig);\n            printf(\"========================\\n\");\n        }\n\n        num_eigs--;\n        rows--;\n        columns--;\n    }\n    eigen_vals[0] = A[0][0];\n    double dtime = (double)(clock() - t1) / CLOCKS_PER_SEC;\n\n    if (debug_print)\n    {\n        print_matrix(R, mat_size, mat_size);\n        print_matrix(Q, mat_size, mat_size);\n    }\n\n    /* cleanup dynamic memory */\n    for (int i = 0; i < mat_size; i++)\n    {\n        free(R[i]);\n        free(Q[i]);\n    }\n    free(R);\n    free(Q);\n\n    return dtime;\n}\n\n/**\n * test function to compute eigen values of a 2x2 matrix\n * \\f[\\begin{bmatrix}\n * 5 & 7\\\\\n * 7 & 11\n * \\end{bmatrix}\\f]\n * which are approximately, {15.56158, 0.384227}\n */\nvoid test1()\n{\n    int mat_size = 2;\n    double X[][2] = {{5, 7}, {7, 11}};\n    double y[] = {15.56158, 0.384227};  // corresponding y-values\n    double eig_vals[2] = {0, 0};\n\n    // The following steps are to convert a \"double[][]\" to \"double **\"\n    double **A = (double **)malloc(mat_size * sizeof(double *));\n    for (int i = 0; i < mat_size; i++) A[i] = X[i];\n\n    printf(\"------- Test 1 -------\\n\");\n\n    double dtime = eigen_values(A, eig_vals, mat_size, 0);\n\n    for (int i = 0; i < mat_size; i++)\n    {\n        printf(\"%d/5 Checking for %.3g --> \", i + 1, y[i]);\n        char result = 0;\n        for (int j = 0; j < mat_size && !result; j++)\n        {\n            if (fabs(y[i] - eig_vals[j]) < 0.1)\n            {\n                result = 1;\n                printf(\"(%.3g) \", eig_vals[j]);\n            }\n        }\n\n        // ensure that i^th expected eigen value was computed\n        assert(result != 0);\n        printf(\"found\\n\");\n    }\n    printf(\"Test 1 Passed in %.3g sec\\n\\n\", dtime);\n    free(A);\n}\n\n/**\n * test function to compute eigen values of a 2x2 matrix\n * \\f[\\begin{bmatrix}\n * -4& 4& 2& 0& -3\\\\\n * 4& -4& 4& -3& -1\\\\\n * 2& 4& 4& 3& -3\\\\\n * 0& -3& 3& -1&-1\\\\\n * -3& -1& -3& -3& 0\n * \\end{bmatrix}\\f]\n * which are approximately, {9.27648, -9.26948, 2.0181, -1.03516, -5.98994}\n */\nvoid test2()\n{\n    int mat_size = 5;\n    double X[][5] = {{-4, 4, 2, 0, -3},\n                     {4, -4, 4, -3, -1},\n                     {2, 4, 4, 3, -3},\n                     {0, -3, 3, -1, -3},\n                     {-3, -1, -3, -3, 0}};\n    double y[] = {9.27648, -9.26948, 2.0181, -1.03516,\n                  -5.98994};  // corresponding y-values\n    double eig_vals[5];\n\n    // The following steps are to convert a \"double[][]\" to \"double **\"\n    double **A = (double **)malloc(mat_size * sizeof(double *));\n    for (int i = 0; i < mat_size; i++) A[i] = X[i];\n\n    printf(\"------- Test 2 -------\\n\");\n\n    double dtime = eigen_values(A, eig_vals, mat_size, 0);\n\n    for (int i = 0; i < mat_size; i++)\n    {\n        printf(\"%d/5 Checking for %.3g --> \", i + 1, y[i]);\n        char result = 0;\n        for (int j = 0; j < mat_size && !result; j++)\n        {\n            if (fabs(y[i] - eig_vals[j]) < 0.1)\n            {\n                result = 1;\n                printf(\"(%.3g) \", eig_vals[j]);\n            }\n        }\n\n        // ensure that i^th expected eigen value was computed\n        assert(result != 0);\n        printf(\"found\\n\");\n    }\n    printf(\"Test 2 Passed in %.3g sec\\n\\n\", dtime);\n    free(A);\n}\n\n/**\n * main function\n */\nint main(int argc, char **argv)\n{\n    srand(time(NULL));\n\n    int mat_size = 5;\n    if (argc == 2)\n    {\n        mat_size = atoi(argv[1]);\n    }\n    else\n    {  // if invalid input argument is given run tests\n        test1();\n        test2();\n        printf(\"Usage: ./qr_eigen_values [mat_size]\\n\");\n        return 0;\n    }\n\n    if (mat_size < 2)\n    {\n        fprintf(stderr, \"Matrix size should be > 2\\n\");\n        return -1;\n    }\n\n    int i;\n\n    double **A = (double **)malloc(sizeof(double *) * mat_size);\n    /* number of eigen values = matrix size */\n    double *eigen_vals = (double *)malloc(sizeof(double) * mat_size);\n    if (!eigen_vals)\n    {\n        perror(\"Unable to allocate memory for eigen values!\");\n        free(A);\n        return -1;\n    }\n    for (i = 0; i < mat_size; i++)\n    {\n        A[i] = (double *)malloc(sizeof(double) * mat_size);\n        eigen_vals[i] = 0.f;\n    }\n\n    /* create a random matrix */\n    create_matrix(A, mat_size);\n\n    print_matrix(A, mat_size, mat_size);\n\n    double dtime = eigen_values(A, eigen_vals, mat_size, 0);\n    printf(\"Eigen vals: \");\n    for (i = 0; i < mat_size; i++) printf(\"% 9.4g\\t\", eigen_vals[i]);\n    printf(\"\\nTime taken to compute: % .4g sec\\n\", dtime);\n\n    for (int i = 0; i < mat_size; i++) free(A[i]);\n    free(A);\n    free(eigen_vals);\n    return 0;\n}\n","index":258},{"title":"Realtime Stats","category":"numerical_methods","id":"realtime_stats_numerical_methods","algorithm":"/**\n * \\file\n * \\brief Compute statistics for data entered in rreal-time\n * \\author [Krishna Vedala](https://github.com/kvedala)\n *\n * This algorithm is really beneficial to compute statistics on data read in\n * realtime. For example, devices reading biometrics data. The algorithm is\n * simple enough to be easily implemented in an embedded system.\n */\n#include <assert.h>\n#include <math.h>\n#include <stdio.h>\n\n/**\n * continuous mean and variance computance using\n * first value as an approximation for the mean.\n * If the first number is much far form the mean, the algorithm becomes very\n * inaccurate to compute variance and standard deviation.\n * \\param[in] x new value added to data set\n * \\param[out] mean if not NULL, mean returns mean of data set\n * \\param[out] variance if not NULL, mean returns variance of data set\n * \\param[out] std if not NULL, mean returns standard deviation of data set\n */\nvoid stats_computer1(float x, float *mean, float *variance, float *std)\n{\n    /* following variables declared static becuase they need to be remembered\n     * when updating for next sample, when received.\n     */\n    static unsigned int n = 0;\n    static float Ex = 0.f, Ex2 = 0.f;\n    static float K = 0.f;\n\n    if (n == 0)\n        K = x;\n    n++;\n    float tmp = x - K;\n    Ex += tmp;\n    Ex2 += tmp * tmp;\n\n    /* return sample mean computed till last sample */\n    if (mean != NULL)\n        *mean = K + Ex / n;\n\n    /* return data variance computed till last sample */\n    if (variance != NULL)\n        *variance = (Ex2 - (Ex * Ex) / n) / (n - 1);\n\n    /* return sample standard deviation computed till last sample */\n    if (std != NULL)\n        *std = sqrtf(*variance);\n}\n\n/**\n * continuous mean and variance computance using\n * Welford's algorithm  (very accurate)\n * \\param[in] x new value added to data set\n * \\param[out] mean if not NULL, mean returns mean of data set\n * \\param[out] variance if not NULL, mean returns variance of data set\n * \\param[out] std if not NULL, mean returns standard deviation of data set\n */\nvoid stats_computer2(float x, float *mean, float *variance, float *std)\n{\n    /* following variables declared static becuase they need to be remembered\n     * when updating for next sample, when received.\n     */\n    static unsigned int n = 0;\n    static float mu = 0, M = 0;\n\n    n++;\n    float delta = x - mu;\n    mu += delta / n;\n    float delta2 = x - mu;\n    M += delta * delta2;\n\n    /* return sample mean computed till last sample */\n    if (mean != NULL)\n        *mean = mu;\n\n    /* return data variance computed till last sample */\n    if (variance != NULL)\n        *variance = M / n;\n\n    /* return sample standard deviation computed till last sample */\n    if (std != NULL)\n        *std = sqrtf(*variance);\n}\n\n/** Test the algorithm implementation\n * \\param[in] test_data array of data to test the algorithms\n * \\param[in] number_of_samples number of samples of data\n */\nvoid test_function(const float *test_data, const int number_of_samples)\n{\n    float ref_mean = 0.f, ref_variance = 0.f;\n    float s1_mean = 0.f, s1_variance = 0.f, s1_std = 0.f;\n    float s2_mean = 0.f, s2_variance = 0.f, s2_std = 0.f;\n\n    for (int i = 0; i < number_of_samples; i++)\n    {\n        stats_computer1(test_data[i], &s1_mean, &s1_variance, &s1_std);\n        stats_computer2(test_data[i], &s2_mean, &s2_variance, &s2_std);\n        ref_mean += test_data[i];\n    }\n    ref_mean /= number_of_samples;\n\n    for (int i = 0; i < number_of_samples; i++)\n    {\n        float temp = test_data[i] - ref_mean;\n        ref_variance += temp * temp;\n    }\n    ref_variance /= number_of_samples;\n\n    printf(\"<<<<<<<< Test Function >>>>>>>>\\n\");\n    printf(\"Expected: Mean: %.4f\\t Variance: %.4f\\n\", ref_mean, ref_variance);\n    printf(\"\\tMethod 1:\\tMean: %.4f\\t Variance: %.4f\\t Std: %.4f\\n\", s1_mean,\n           s1_variance, s1_std);\n    printf(\"\\tMethod 2:\\tMean: %.4f\\t Variance: %.4f\\t Std: %.4f\\n\", s2_mean,\n           s2_variance, s2_std);\n\n    assert(fabs(s1_mean - ref_mean) < 0.01);\n    assert(fabs(s2_mean - ref_mean) < 0.01);\n    assert(fabs(s2_variance - ref_variance) < 0.01);\n\n    printf(\"(Tests passed)\\n\\n\");\n}\n\n/** Main function */\nint main(int argc, char **argv)\n{\n    const float test_data1[] = {3, 4, 5, -1.4, -3.6, 1.9, 1.};\n    test_function(test_data1, sizeof(test_data1) / sizeof(test_data1[0]));\n\n    float s1_mean = 0.f, s1_variance = 0.f, s1_std = 0.f;\n    float s2_mean = 0.f, s2_variance = 0.f, s2_std = 0.f;\n\n    printf(\"Enter data. Any non-numeric data will terminate the data input.\\n\");\n\n    while (1)\n    {\n        float val;\n        printf(\"Enter number: \");\n\n        // check for failure to read input. Happens for\n        // non-numeric data\n        if (!scanf(\"%f\", &val))\n            break;\n\n        stats_computer1(val, &s1_mean, &s1_variance, &s1_std);\n        stats_computer2(val, &s2_mean, &s2_variance, &s2_std);\n\n        printf(\"\\tMethod 1:\\tMean: %.4f\\t Variance: %.4f\\t Std: %.4f\\n\",\n               s1_mean, s1_variance, s1_std);\n        printf(\"\\tMethod 2:\\tMean: %.4f\\t Variance: %.4f\\t Std: %.4f\\n\",\n               s2_mean, s2_variance, s2_std);\n    }\n\n    return 0;\n}\n","index":259},{"title":"Simpsons 1 3rd Rule","category":"numerical_methods","id":"simpsons_1_3rd_rule_numerical_methods","algorithm":"#include <math.h>\n#include <stdio.h>\n\nfloat f(float x)\n{\n    return 1.0 +\n           x * x * x;  // This is the expresion of the function to integrate?\n}\n\nint main()\n{\n    int i, n;\n    float a, b, h, x, s2, s3, sum, integral;\n\n    printf(\"enter the lower limit of the integration:\");\n    scanf(\"%f\", &a);\n    printf(\"enter the upper limit of the integration:\");\n    scanf(\"%f\", &b);\n    printf(\"enter the number of intervals:\");\n    scanf(\"%d\", &n);\n\n    h = (b - a) / n;\n    sum = f(a) + f(b);\n    s2 = s3 = 0.0;\n\n    for (i = 1; i < n; i += 3)\n    {\n        x = a + i * h;\n        s3 = s3 + f(x) + f(x + h);\n    }\n\n    for (i = 3; i < n; i += 3)\n    {\n        x = a + i * h;\n        s2 = s2 + f(x);\n    }\n\n    integral = (h / 3.0) * (sum + 2 * s2 + 4 * s3);\n    printf(\"\\nValue of the integral = %9.4f\\n\", integral);\n\n    return 0;\n}","index":260},{"title":"Variance","category":"numerical_methods","id":"variance_numerical_methods","algorithm":"#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n    int *ARRAY = NULL, ARRAY_LENGTH, i, TEMPORARY_ELEMENT, isSorted = 0;\n    float MEAN = 0, VARIANCE = 0, STAND;\n\n    printf(\"Enter no. for Random Numbers :\");\n    scanf(\"%d\", &ARRAY_LENGTH);\n    ARRAY = (int *)realloc(\n        ARRAY,\n        ARRAY_LENGTH * (sizeof(int)));  // We allocate the dedicated memory\n    for (i = 0; i < ARRAY_LENGTH; i++)  // We generate the random numbers\n        ARRAY[i] = rand() % 100;\n\n    printf(\"Random Numbers Generated are :\\n\");  // We display them\n    for (i = 0; i < ARRAY_LENGTH; i++) printf(\"%d \", ARRAY[i]);\n\n    printf(\"\\nSorted Data: \");  // Then we sort it using Bubble Sort..\n\n    while (!isSorted)\n    {                  // While our array's not sorted\n        isSorted = 1;  // we suppose that it's sorted\n        for (i = 0; i < ARRAY_LENGTH - 1; i++)\n        {  // then for each element of the array\n            if (ARRAY[i] > ARRAY[i + 1])\n            {                  // if the two elements aren't sorted\n                isSorted = 0;  // it means that the array is not sorted\n                TEMPORARY_ELEMENT = ARRAY[i];  // and we switch these elements\n                                               // using TEMPORARY_ELEMENT\n                ARRAY[i] = ARRAY[i + 1];\n                ARRAY[i + 1] = TEMPORARY_ELEMENT;\n            }\n        }\n    }\n    for (i = 0; i < ARRAY_LENGTH; i++)\n    {\n        printf(\"%d \", ARRAY[i]);\n        MEAN = MEAN + ARRAY[i];\n    }\n    MEAN = MEAN / (float)ARRAY_LENGTH;\n\n    for (i = 0; i < ARRAY_LENGTH; i++)\n        VARIANCE = VARIANCE + (pow((ARRAY[i] - MEAN), 2));\n\n    VARIANCE = VARIANCE / (float)ARRAY_LENGTH;\n    STAND = sqrt(VARIANCE);\n\n    printf(\"\\n\\n- Mean is: %f\\n\", MEAN);\n    printf(\"- Variance is: %f\\n\", VARIANCE);\n    printf(\"- Standard Deviation is: %f\\n\", STAND);\n}\n","index":261},{"title":"Project Euler","category":null,"id":"project_euler","index":262},{"title":"Problem 1","category":"project_euler","id":"problem_1","index":263},{"title":"Sol1","category":"problem_1","id":"sol1_problem_1","algorithm":"/**\n * \\file\n * \\brief [Problem 1](https://projecteuler.net/problem=1) solution\n * \\details\n * An Efficient code to print all the sum of all numbers that are multiples of 3\n * & 5 below N.\n */\n\n#include <stdio.h>\n\n/** Main function */\nint main()\n{\n    int t;\n    printf(\"Enter number of times you want to try\");\n    scanf(\"%d\", &t);\n    while (t--)  // while t > 0, decrement 't' before every iteration\n    {\n        unsigned long long N, p = 0, sum = 0;\n        printf(\"Enter the value of N \");\n\n        scanf(\"%lld\", &N);  // Take input of N from user\n        p = (N - 1) / 3;\n        sum = ((3 * p * (p + 1)) / 2);\n\n        p = (N - 1) / 5;\n        sum = sum + ((5 * p * (p + 1)) / 2);\n\n        p = (N - 1) / 15;\n        sum = sum - ((15 * p * (p + 1)) / 2);\n        printf(\"%lld\\n\", sum);  // print the sum of all numbers that are\n                                // multiples of 3 & 5 below N\n    }\n    return 0;\n}\n","index":264},{"title":"Sol2","category":"problem_1","id":"sol2_problem_1","algorithm":"/**\n * \\file\n * \\brief [Problem 1](https://projecteuler.net/problem=1) solution\n *\n * If we list all the natural numbers below 10 that are multiples of 3 or 5,\n * we get 3,5,6 and 9. The sum of these multiples is 23.\n * Find the sum of all the multiples of 3 or 5 below N.\n *\n * This solution is based on the pattern that the successive numbers in the\n * series follow: 0+3,+2,+1,+3,+1,+2,+3.\n */\n#include <stdio.h>\n\n/** Main function */\nint main()\n{\n    int n = 0;\n    int sum = 0;\n    scanf(\"%d\", &n);\n\n    int terms = (n - 1) / 3;\n    sum += ((terms) * (6 + (terms - 1) * 3)) / 2;  // sum of an A.P.\n    terms = (n - 1) / 5;\n    sum += ((terms) * (10 + (terms - 1) * 5)) / 2;\n    terms = (n - 1) / 15;\n    sum -= ((terms) * (30 + (terms - 1) * 15)) / 2;\n\n    printf(\"%d\\n\", sum);\n}","index":265},{"title":"Sol3","category":"problem_1","id":"sol3_problem_1","algorithm":"/**\n * \\file\n * \\brief [Problem 1](https://projecteuler.net/problem=1) solution.\n * This solution is based on the pattern that the successive numbers in the\n * series follow: 0+3,+2,+1,+3,+1,+2,+3.\n *\n * If we list all the natural numbers below 10 that are multiples of 3 or 5,\n * we get 3,5,6 and 9. The sum of these multiples is 23.\n * Find the sum of all the multiples of 3 or 5 below N.\n */\n#include <stdio.h>\n\n/** Main function */\nint main()\n{\n    int n = 0;\n    int sum = 0;\n    int num = 0;\n    scanf(\"%d\", &n);\n\n    while (1)\n    {\n        num += 3;\n        if (num >= n)\n            break;\n        sum += num;\n        num += 2;\n        if (num >= n)\n            break;\n        sum += num;\n        num += 1;\n        if (num >= n)\n            break;\n        sum += num;\n        num += 3;\n        if (num >= n)\n            break;\n        sum += num;\n        num += 1;\n        if (num >= n)\n            break;\n        sum += num;\n        num += 2;\n        if (num >= n)\n            break;\n        sum += num;\n        num += 3;\n        if (num >= n)\n            break;\n        sum += num;\n    }\n\n    printf(\"%d\\n\", sum);\n    return 0;\n}","index":266},{"title":"Sol4","category":"problem_1","id":"sol4_problem_1","algorithm":"/**\n * \\file\n * \\brief [Problem 1](https://projecteuler.net/problem=1) solution\n *\n * An Efficient code to print all the sum of all numbers that are multiples of 3\n * & 5 below N.\n */\n\n#include <stdio.h>\n\n/** Main function */\nint main()\n{\n    int t;\n    printf(\"Enter number of times you want to try\");\n    scanf(\"%d\", &t);\n    while (t--)\n    {\n        unsigned long long N, p = 0, sum = 0;\n        printf(\"Enter the value of N \");\n\n        scanf(\"%lld\", &N);  // Take input of N from user\n        for (int i = 0; i < N; i++)\n        {\n            if (i % 3 == 0 || i % 5 == 0)\n            {\n                sum = sum + i;\n            }\n        }\n        printf(\"%lld\\n\", sum);  // print the sum of all numbers that are\n                                // multiples of 3 & 5 below N\n    }\n    return 0;\n}\n","index":267},{"title":"Problem 10","category":"project_euler","id":"problem_10","index":268},{"title":"Sol1","category":"problem_10","id":"sol1_problem_10","algorithm":"/**\n * \\file\n * \\brief [Problem 10](https://projecteuler.net/problem=10) solution\n * \\author [Krishna Vedala](https://github.com/kvedala)\n */\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n/** Function to check if a number is prime */\nchar is_prime(unsigned long n)\n{\n    for (unsigned long i = 2; i < sqrtl(n) + 1; i++)\n        if (n % i == 0)\n            return 0;\n\n    return 1;\n}\n\n/** Computes sum of prime numbers less than N */\nunsigned long long sum_of_primes(unsigned long N)\n{\n    unsigned long long sum = 2;\n\n    for (long i = 3; i < N; i += 2) /* skip even numbers */\n        if (is_prime(i))\n            sum += i;\n\n    return sum;\n}\n\n/** Main function */\nint main(int argc, char *argv[])\n{\n    unsigned long n = 100;\n\n    if (argc == 2)         /* if command line argument is provided */\n        n = atol(argv[1]); /* use that as the upper limit */\n\n    printf(\"%ld: %llu\\n\", n, sum_of_primes(n));\n\n    return 0;\n}","index":269},{"title":"Sol2","category":"problem_10","id":"sol2_problem_10","algorithm":"/**\n * \\file\n * \\brief [Problem 10](https://projecteuler.net/problem=10) solution\n * \\author [Krishna Vedala](https://github.com/kvedala)\n */\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n/** Main function */\nint main(int argc, char *argv[])\n{\n    long n = 100;\n    long long sum = 0;\n    char *sieve = NULL;\n\n    if (argc == 2)         /* if command line argument is provided */\n        n = atol(argv[1]); /* use that as the upper limit */\n\n    /* allocate memory for the sieve */\n    sieve = calloc(n, sizeof(*sieve));\n    if (!sieve)\n    {\n        perror(\"Unable to allocate memory!\");\n        return -1;\n    }\n\n    /* build sieve of Eratosthenes\n        In the array,\n        * if i^th cell is '1', then 'i' is composite\n        * if i^th cell is '0', then 'i' is prime\n    */\n    for (long i = 2; i < sqrtl(n); i++)\n    {\n        /* if i^th element is prime, mark all its multiples\n        as composites */\n        if (!sieve[i])\n        {\n            for (long j = i * i; j < n + 1; j += i)\n            {\n                sieve[j] = 1;\n            }\n            sum += i;\n        }\n    }\n\n    for (long i = sqrtl(n) + 1; i < n; i++)\n        if (!sieve[i])\n            sum += i;\n\n    free(sieve);\n\n    printf(\"%ld: %lld\\n\", n, sum);\n\n    return 0;\n}\n","index":270},{"title":"Problem 12","category":"project_euler","id":"problem_12","index":271},{"title":"Sol1","category":"problem_12","id":"sol1_problem_12","algorithm":"/**\n * \\file\n * \\brief [Problem 12](https://projecteuler.net/problem=12) solution\n * \\author [Krishna Vedala](https://github.com/kvedala)\n */\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n/**\n * Get number of divisors of a given number\n *\n * If \\f$x = a \\times b\\f$, then both \\f$a\\f$ and \\f$b\\f$ are divisors of\n * \\f$x\\f$. Since multiplication is commutative, we only need to search till a\n * maximum of \\f$a=b = a^2\\f$ i.e., till \\f$\\sqrt{x}\\f$. At every integer till\n * then, there are eaxctly 2 divisors and at \\f$a=b\\f$, there is only one\n * divisor.\n */\nlong count_divisors(long long n)\n{\n    long num_divisors = 0;\n\n    for (long long i = 1; i < sqrtl(n) + 1; i++)\n        if (n % i == 0)\n            num_divisors += 2;\n        else if (i * i == n)\n            num_divisors += 1;\n\n    return num_divisors;\n}\n\n/** Main function */\nint main(int argc, char **argv)\n{\n    int MAX_DIVISORS = 500;\n    long i = 1, num_divisors;\n    long long triangle_number = 1;\n\n    if (argc == 2)\n        MAX_DIVISORS = atoi(argv[1]);\n\n    while (1)\n    {\n        i++;\n        triangle_number += i;\n        num_divisors = count_divisors(triangle_number);\n        if (num_divisors > MAX_DIVISORS)\n            break;\n    }\n\n    printf(\"First Triangle number with more than %d divisors: %lld\\n\",\n           MAX_DIVISORS, triangle_number);\n\n    return 0;\n}\n","index":272},{"title":"Problem 13","category":"project_euler","id":"problem_13","index":273},{"title":"Sol1","category":"problem_13","id":"sol1_problem_13","algorithm":"/**\n * \\file\n * \\brief [Problem 13](https://projecteuler.net/problem=13) solution\n * \\author [Krishna Vedala](https://github.com/kvedala)\n */\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n/** Function to read the number from a file and store it in array.\n    \\n index 0 of output buffer => units place\n    \\n index 1 of output buffer => tens place and so on\n    i.e., index i => 10^i th place\n */\nint get_number(FILE *fp, char *buffer, uint8_t *out_int)\n{\n    long l = fscanf(fp, \"%s\\n\", buffer);\n    if (!l)\n    {\n        perror(\"Error reading line.\");\n        return -1;\n    }\n    // printf(\"Number: %s\\t length: %ld, %ld\\n\", buffer, strlen(buffer), l);\n\n    long L = strlen(buffer);\n\n    for (int i = 0; i < L; i++)\n    {\n        if (buffer[i] < 0x30 || buffer[i] > 0x39)\n        {\n            perror(\"found inavlid character in the number!\");\n            return -1;\n        }\n        else\n        {\n            out_int[L - i - 1] = buffer[i] - 0x30;\n        }\n    }\n\n    return 0;\n}\n\n/**\n * Function to add arbitrary length decimal integers stored in an array.\n * a + b = c = new b\n */\nint add_numbers(uint8_t *a, uint8_t *b, uint8_t N)\n{\n    int carry = 0;\n    uint8_t *c = b; /* accumulate the result in the array 'b' */\n\n    for (int i = 0; i < N; i++)\n    {\n        // printf(\"\\t%d + %d + %d \", a[i], b[i], carry);\n        c[i] = carry + a[i] + b[i];  // NOLINT // This is a known false-positive\n        if (c[i] > 9)                /* check for carry */\n        {\n            carry = 1;\n            c[i] -= 10;\n        }\n        else\n        {\n            carry = 0;\n        }\n        // printf(\"= %d, %d\\n\", carry, c[i]);\n    }\n\n    for (int i = N; i < N + 10; i++)\n    {\n        if (carry == 0)\n        {\n            break;\n        }\n        // printf(\"\\t0 + %d + %d \", b[i], carry);\n        c[i] = carry + c[i];\n        if (c[i] > 9)\n        {\n            carry = 1;\n            c[i] -= 10;\n        }\n        else\n        {\n            carry = 0;\n        }\n        // printf(\"= %d, %d\\n\", carry, c[i]);\n    }\n    return 0;\n}\n\n/** Function to print a long number */\nint print_number(uint8_t *number, uint8_t N, int8_t num_digits_to_print)\n{\n    uint8_t start_pos = N - 1;\n    uint8_t end_pos;\n\n    /* skip all initial zeros */\n    while (number[start_pos] == 0) start_pos--;\n\n    /* if end_pos < 0, print all digits */\n    if (num_digits_to_print < 0)\n    {\n        end_pos = 0;\n    }\n    else if (num_digits_to_print <= start_pos)\n    {\n        end_pos = start_pos - num_digits_to_print + 1;\n    }\n    else\n    {\n        fprintf(stderr, \"invalid number of digits argumet!\\n\");\n        return -1;\n    }\n\n    for (int i = start_pos; i >= end_pos; i--) putchar(number[i] + 0x30);\n\n    putchar('\\n');\n\n    return 0;\n}\n\n/** Main function */\nint main(void)\n{\n    /* number of digits of the large number */\n    const int N = 10;\n    /* number of digits in output number */\n    const int N2 = N + 10;\n\n    // const char N = 50, N2 = N+10;          /* length of numbers */\n    char *txt_buffer =\n        (char *)calloc(N + 5, sizeof(char)); /* temporary buffer */\n    uint8_t *number = (uint8_t *)calloc(\n        N, sizeof(uint8_t)); /* array to store digits of a large number */\n    uint8_t *sum = (uint8_t *)calloc(\n        N2, sizeof(uint8_t)); /* array to store the sum of the large\nnumbers. For safety, we make it twice the length of a number. */\n\n    FILE *fp = fopen(\"num.txt\", \"rt\"); /* open text file to read */\n    if (!fp)\n    {\n        perror(\"Unable to open file 'num.txt'.\");\n        free(txt_buffer);\n        free(sum);\n        free(number);\n        return -1;\n    }\n\n    int count = 0;\n    get_number(fp, txt_buffer, sum); /* 0 + = first_number = first_number */\n    do\n    {\n        count++;\n        if (get_number(fp, txt_buffer, number) != 0)\n        {\n            break;\n        }\n        add_numbers(number, sum, N);\n    } while (!feof(fp));\n\n    printf(\"\\nSum   : \");\n    print_number(sum, N2, -1);\n\n    printf(\"first 10 digits: \\t\");\n    print_number(sum, N2, 10);\n\n    fclose(fp); /* close file */\n    free(txt_buffer);\n    free(sum);\n    free(number);\n    return 0;\n}\n","index":274},{"title":"Problem 14","category":"project_euler","id":"problem_14","index":275},{"title":"Sol1","category":"problem_14","id":"sol1_problem_14","algorithm":"/**\n * \\file\n * \\brief [Problem 14](https://projecteuler.net/problem=14) solution\n * \\author [Krishna Vedala](https://github.com/kvedala)\n *\n * Since the computational values for each iteration step are independent,\n * we can compute them in parallel. However, the maximum values should be\n * updated in synchrony so that we do not get into a \"race condition\".\n *\n * To compile with supporintg gcc or clang, the flag \"-fopenmp\" should be\n * passes while with Microsoft C compiler, the flag \"/fopenmp\" should be\n * used. If you are using the provided CMAKE compilation, it will automatically\n * detect OPENMP and compile with it for you.\n *\n * Automatically detects for OPENMP using the _OPENMP macro.\n */\n#include <stdio.h>\n#include <stdlib.h>\n#ifdef _OPENMP\n#include <omp.h>\n#endif\n\n/**\n * Computes the length of collatz sequence for a given\n * starting number\n */\nlong long collatz(long long start_num)\n{\n    long long length = 1;\n\n    while (start_num != 1) /* loop till we reach 1 */\n    {\n        if (start_num & 0x01) /* check for odd */\n            start_num = 3 * start_num + 1;\n        else\n            start_num >>= 1; /* simpler divide by 2 */\n        length++;\n    }\n\n    return length;\n}\n\n/** Main function */\nint main(int argc, char **argv)\n{\n    long long max_len = 0, max_len_num = 0;\n    long long MAX_NUM = 1000000;\n\n    if (argc ==\n        2) /* set commandline argumnet as the maximum iteration number */\n    {\n        MAX_NUM = atoll(argv[1]);\n        printf(\"Maximum number: %lld\\n\", MAX_NUM);\n    }\n\n    long long i;\n#ifdef _OPENMP\n#pragma omp parallel for shared(max_len, max_len_num) schedule(guided)\n#endif\n    for (i = 1; i < MAX_NUM; i++)\n    {\n        long long L = collatz(i);\n        if (L > max_len)\n        {\n            max_len = L;     /* length of sequence */\n            max_len_num = i; /* starting number */\n        }\n\n#if defined(_OPENMP) && defined(DEBUG)\n        printf(\"Thread: %2d\\t %3lld: \\t%5lld\\n\", omp_get_thread_num(), i, L);\n#elif defined(DEBUG)\n        printf(\"%3lld: \\t%5lld\\n\", i, L);\n#endif\n    }\n\n    printf(\"Start: %3lld: \\tLength: %5lld\\n\", max_len_num, max_len);\n\n    return 0;\n}\n","index":276},{"title":"Problem 15","category":"project_euler","id":"problem_15","index":277},{"title":"Sol1","category":"problem_15","id":"sol1_problem_15","algorithm":"/**\n * \\file\n * \\brief [Problem 15](https://projecteuler.net/problem=15) solution\n * \\author [Krishna Vedala](https://github.com/kvedala)\n */\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n/**\n * At every node, there are 2 possible ways to move -> down or right.\n * Since it is a square grid, there are in all, 2N steps with N down\n * and N right options, without preference for order.\n * Hence, the path can be be traced in N out of 2N number of ways.\n * This is the same as binomial coeeficient.\n */\nunsigned long long number_of_paths(int N)\n{\n    unsigned long long path = 1;\n    for (int i = 0; i < N; i++)\n    {\n        path *= (N << 1) - i;\n        path /= i + 1;\n    }\n\n    return path;\n}\n\n/** Main function */\nint main(int argc, char **argv)\n{\n    int N = 20;\n\n    if (argc == 2)\n        N = atoi(argv[1]);\n\n    printf(\"Number of ways to traverse diagonal of %dx%d grid = %llu\\n\", N, N,\n           number_of_paths(N));\n\n    return 0;\n}\n","index":278},{"title":"Problem 16","category":"project_euler","id":"problem_16","index":279},{"title":"Sol1","category":"problem_16","id":"sol1_problem_16","algorithm":"/**\n * \\file\n * \\brief [Problem 16](https://projecteuler.net/problem=16) solution\n * \\author [Krishna Vedala](https://github.com/kvedala)\n */\n#include <math.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n/** Main function */\nint main(int argc, char **argv)\n{\n    const double tmp = log(10) / log(2); /* required to get number of digits */\n    unsigned long MAX_NUM_DIGITS;\n    uint8_t *digits =\n        NULL; /* array to store individual digits. index 0 = units place */\n    int N = 1000, sum = 0;\n\n    if (argc == 2)\n        N = atoi(argv[1]);\n\n    MAX_NUM_DIGITS = (N + tmp) / tmp;\n\n    digits = calloc(MAX_NUM_DIGITS, sizeof(uint8_t));\n    digits[0] = 1;\n\n    if (!digits)\n    {\n        perror(\"Unable to allocate memory!\");\n        return -1;\n    }\n\n    for (int i = 0; i < N; i++)\n    {\n        int carry = 0;\n        for (int j = 0; j < MAX_NUM_DIGITS; j++)\n        {\n            digits[j] = (digits[j] << 1) + carry; /* digit * 2 + carry */\n            // printf(\"\\t value: %d\\t\", digits[j]);\n            if (digits[j] > 9)\n            {\n                carry = 1;\n                digits[j] -= 10;\n            }\n            else\n                carry = 0;\n            // printf(\"carry: %d\\t value: %d\\n\", carry, digits[j]);\n\n            /* accumulate sum for last multiplication */\n            if (i == N - 1)\n                sum += digits[j];\n        }\n    }\n\n    printf(\"2^%d = \", N);\n    for (int i = MAX_NUM_DIGITS - 1; i >= 0; i--) putchar(digits[i] + 0x30);\n    printf(\"\\n\\t Sum: %d\\t Num. digits: %lu\\n\", sum, MAX_NUM_DIGITS);\n\n    free(digits);\n    return 0;\n}\n","index":280},{"title":"Problem 19","category":"project_euler","id":"problem_19","index":281},{"title":"Sol1","category":"problem_19","id":"sol1_problem_19","algorithm":"/**\r\n * \\file\r\n * \\brief [Problem 19](https://projecteuler.net/problem=19) solution\r\n * \\author [Krishna Vedala](https://github.com/kvedala)\r\n */\r\n#include <stdio.h>\r\n\r\n/**\r\n * Function to get the number of days in a month.\r\n * \\param month month identified by an integer -\\n\r\n * > 0 = Jan and 11 = December\r\n * \\returns number of days in given month\r\n * \\note For February, adjust for leap year outside the function.\r\n */\r\nchar get_month_days(short month)\r\n{\r\n    if (month == 1) /* February has 28 days. Adjust leap year in the loop */\r\n        return 28;\r\n    else if (month <= 6) /* odd months till July have 30 days - Jan = 0 (even)*/\r\n    {\r\n        if (month & 0x01)\r\n            return 30;\r\n        else\r\n            return 31;\r\n    }\r\n\r\n    // else if (month >= 7) /* odd months after July have 31 days*/\r\n\r\n    if (month & 0x01)\r\n        return 31;\r\n\r\n    return 30;\r\n}\r\n\r\n/**\r\n * @brief Check if input year is a leap year.\r\n * \\param year year to check\r\n * \\return 1 if input year is a leap year\r\n * \\return 0 if input year is not a leap year\r\n */\r\nchar is_leap_year(short year)\r\n{\r\n    if ((year % 400 == 0) || ((year % 4 == 0) && (year % 100 != 0)))\r\n        return 1;\r\n\r\n    return 0;\r\n}\r\n\r\n#ifdef DEBUG\r\n/** Function to convert integer month to string\r\n * \\param day integer identifier of day (0 = Sunday and 7 = Saturday\r\n * \\return pointer to string representation)\r\n */\r\nconst char *day_string(int day)\r\n{\r\n    switch (day)\r\n    {\r\n    case 0:\r\n        return \"Sunday\";\r\n    case 1:\r\n        return \"Monday\";\r\n    case 2:\r\n        return \"Tuesday\";\r\n    case 3:\r\n        return \"Wednesday\";\r\n    case 4:\r\n        return \"Thursday\";\r\n    case 5:\r\n        return \"Friday\";\r\n    case 6:\r\n        return \"Saturday\";\r\n    default:\r\n        return \"Shouldn't see this!\";\r\n    }\r\n}\r\n#endif\r\n\r\n/** Main function */\r\nint main(int argc, char **argv)\r\n{\r\n    int count_sundays = 0;\r\n    const short start_year = 1901;\r\n    const short end_year = 2000;\r\n\r\n    /*\r\n     * Let us identify days i.e., Sunday thru Saturday with integers - 0 thru 6\r\n     * respectively Jan 1 1901 was a Tuesday\r\n     */\r\n    char start_day = 2;\r\n\r\n    for (int year = start_year; year <= end_year; year++)\r\n    {\r\n        char is_leap = is_leap_year(year);\r\n        for (char month = 0; month < 12; month++)\r\n        {\r\n            /*\r\n             * These two for-loops count the start of day for the next month.\r\n             * Hence, we have to skip the last December count\r\n             */\r\n            if (year == end_year && month == 11)\r\n                continue;\r\n\r\n            int days = get_month_days(month);\r\n\r\n            if (is_leap && month == 1) /* for a leap year february, add a day */\r\n                days++;\r\n\r\n#ifdef DEBUG\r\n            if (year == end_year)\r\n            {\r\n                printf(\"Year: %d\\t Month: %d\\t Days: %d\\t First of day: %s\\n\",\r\n                       year, month, days, day_string(start_day));\r\n            }\r\n#endif\r\n\r\n            /* Main Algorithm:\r\n             * every week has 7 days hence, the start of next day would be\r\n             * modulo 7 add to this, the current start date and ensure the\r\n             * result is still modulo 7!\r\n             */\r\n            start_day = ((days % 7) + start_day) % 7;\r\n\r\n            /* If start-day is a Sunday, increment counter */\r\n            if (start_day == 0)\r\n                count_sundays++;\r\n        }\r\n    }\r\n\r\n    printf(\r\n        \"Total number of Sundays that happened on the 1st of a month in the \"\r\n        \"last century: %d\\n\",\r\n        count_sundays);\r\n\r\n    return 0;\r\n}\r\n","index":282},{"title":"Problem 2","category":"project_euler","id":"problem_2","index":283},{"title":"So1","category":"problem_2","id":"so1_problem_2","algorithm":"/**\n * \\file\n * \\brief [Problem 2](https://projecteuler.net/problem=2) solution\n *\n * Problem:\n *\n * Each new term in the Fibonacci sequence is generated by adding the previous\n * two terms. By starting with 1 and 2, the first 10 terms will be:\n * `1,2,3,5,8,13,21,34,55,89,..`\n * By considering the terms in the Fibonacci sequence whose values do not exceed\n * n, find the sum of the even-valued terms. e.g. for n=10, we have {2,8}, sum\n * is 10.\n */\n#include <stdio.h>\n\n/** Main function */\nint main()\n{\n    int n = 0;\n    int sum = 0;\n    int i = 1;\n    int j = 2;\n    int temp;\n    scanf(\"%d\", &n);\n\n    while (j <= n)\n    {\n        if ((j & 1) == 0)  // can also use(j%2 == 0)\n            sum += j;\n        temp = i;\n        i = j;\n        j = temp + i;\n    }\n\n    printf(\"%d\\n\", sum);\n    return 0;\n}","index":284},{"title":"Problem 20","category":"project_euler","id":"problem_20","index":285},{"title":"Sol1","category":"problem_20","id":"sol1_problem_20","algorithm":"/**\n * \\file\n * \\brief [Problem 20](https://projecteuler.net/problem=20) solution\n * \\author [Krishna Vedala](https://github.com/kvedala)\n *\n * Implementation uses a custom `big_int` structure that can store arbitrarily\n * large integer numbers.\n */\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n/**\n * store arbitratily large integer values\n * as a linked list of digits.\n */\ntypedef struct _big_int\n{\n    char value;                  /**< tens place (single digit) */\n    struct _big_int *next_digit; /**< hundreds place */\n    struct _big_int *prev_digit; /**< units place */\n} big_int;\n\n#ifdef DEBUG\n/** print a digit from large integer */\nvoid print_digit(const big_int *my_int)\n{\n    printf(\"\\tValue : %d\\n\\tNext : %p\\n\\tPrev : %p\\n\", my_int->value,\n           my_int->next_digit, my_int->prev_digit);\n}\n#endif\n\n/**\n * Function that allocates memory to add another\n * digit at the MSB\n */\nbig_int *add_digit(big_int *digit, char value)\n{\n    if (digit == NULL)\n    {\n        digit = (big_int *)malloc(sizeof(big_int));\n        if (!digit)\n        {\n            perror(\"Unable to allocate memory!\");\n            return NULL;\n        }\n        digit->value = value;\n        digit->next_digit = NULL;\n        digit->prev_digit = NULL;\n\n        return digit;\n    }\n\n    if (digit->next_digit)\n    {\n        digit->next_digit->value = value;\n        return digit->next_digit;\n    }\n\n    digit->next_digit = (big_int *)malloc(sizeof(big_int));\n    if (digit->next_digit == NULL)\n    {\n        perror(\"Unable to allocate memory!\");\n        return NULL;\n    }\n    digit->next_digit->value = value;\n    digit->next_digit->next_digit = NULL;\n    digit->next_digit->prev_digit = digit;\n    return digit->next_digit;\n}\n\n/**\n * Function to remove digits preceeding the\n * current digit.\n */\nchar remove_digits(big_int *digit, int N)\n{\n    if (digit == NULL)\n        return 0;\n\n    if (digit->next_digit == NULL)\n    {\n        free(digit);\n        digit = NULL;\n        return 0;\n    }\n\n    if (N > 0)\n        return remove_digits(digit->next_digit, N - 1);\n\n    return remove_digits(digit->next_digit, 0);\n}\n\n/** Main function */\nint main(int argc, char **argv)\n{\n    unsigned int N = 5;\n    big_int *ptr = add_digit(NULL, 1); /* start with 1 */\n    const big_int *ptr0 = ptr;         /* save the first location */\n    unsigned long sum_digits = 0;\n    unsigned long num_digits = 0;\n\n    if (argc == 2)\n        N = atoi(argv[1]);\n\n    clock_t start_time = clock();\n\n    for (unsigned int i = 1; i <= N; i++)\n    {\n        int carry = 0;\n#ifdef DEBUG\n        printf(\"%3d: \", i);\n#endif\n        ptr = (big_int *)ptr0; /* multiply every digit with i */\n        while (ptr)\n        {\n#ifdef DEBUG\n            printf(\"%p\\t\", ptr);\n#endif\n            unsigned int tmp = ptr->value * i + carry;\n            if (tmp >= 10)\n            {\n                div_t tmp2 = div(tmp, 10);\n                carry = tmp2.quot;\n                tmp = tmp2.rem;\n            }\n            else\n                carry = 0;\n\n            if (carry > 0 && ptr->next_digit == NULL)\n                add_digit(ptr, 0);\n\n            ptr->value = tmp;\n\n            if (i == N)\n                /*\n                 * sum digits on the last iteration\n                 * this avoid having another loop over all digits\n                 */\n                sum_digits += tmp;\n\n            if (ptr->next_digit)\n                /* more digits available */\n                ptr = ptr->next_digit;\n            else\n                /* no more digits left - reached MSB */\n                break;\n        }\n#ifdef DEBUG\n        printf(\"\\n\");\n#endif\n    }\n\n    clock_t end_time = clock();\n\n#ifdef DEBUG\n    printf(\"ptr = %p\\n\", ptr);\n    printf(\"%d! = \", N);\n#endif\n\n    /* Notice that in the loop above, we make sure that at the end of the loop,\n     * ptr is pointing to the last digit. Thus we can avoid using another loop.\n     */\n    // ptr = &my_int;\n    // /* move ptr to the MSB digit */\n    // while (ptr->next_digit)\n    //     ptr = ptr->next_digit;\n    do\n    {\n        putchar(ptr->value + 0x30); /* convert digit to ASCII char */\n        ptr = ptr->prev_digit;\n        num_digits++;\n    } while (ptr); /* after coming to units place, there will be no valid ptr */\n\n    printf(\"\\nTime taken: %.4g millisecond\\n\",\n           1e3 * (end_time - start_time) / CLOCKS_PER_SEC);\n    printf(\n        \"Digit Sum = %lu\\tNumber of digits = %lu\\tStorage space = %.3gkb\\t \\n\",\n        sum_digits, num_digits, num_digits * sizeof(big_int) / 1024.0);\n\n    remove_digits((big_int *)ptr0, -1);\n    return 0;\n}\n","index":286},{"title":"Problem 21","category":"project_euler","id":"problem_21","index":287},{"title":"Sol1","category":"problem_21","id":"sol1_problem_21","algorithm":"/**\n * \\file\n * \\brief [Problem 21](https://projecteuler.net/problem=21) solution\n * \\author [Krishna Vedala](https://github.com/kvedala)\n */\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n/**\n * function to return the sum of proper divisors of N\n */\nunsigned long sum_of_divisors(unsigned int N)\n{\n    unsigned long sum = 1 + N; /* 1 and itself are always a divisor */\n    /* divisors are symmertically distributed about the square-root */\n    for (unsigned int i = 2; i * i < N; i++)\n    {\n        if ((N % i) != 0)\n            /* i is not a divisor of N */\n            continue;\n\n        // #ifdef DEBUG\n        //         printf(\"%4d, %4d,\", i, N / i);\n        // #endif\n\n        sum += i + (N / i);\n    }\n    // #ifdef DEBUG\n    //     printf(\"\\nSum of divisors of %4d: %4d\\n\", N, sum);\n    // #endif\n    return sum;\n}\n\n/** Main function */\nint main(int argc, char **argv)\n{\n    unsigned long sum = 0;\n    unsigned int MAX_N = 500;\n    if (argc == 2)\n        MAX_N = atoi(argv[1]);\n\n    /*\n     * We use an array of flags to check if a number at the index was:\n     * not-processed = 0\n     * is amicable = 1\n     * not amicable = -1\n     */\n    char *flags = (char *)calloc(MAX_N, sizeof(char));\n\n    clock_t start_time = clock();\n    int i;\n    /* there are no such numbers till 10. Lets search from there on */\n    for (i = 10; i < MAX_N; i++)\n    {\n        if (flags[i] != 0)\n            /* already processed, skip */\n            continue;\n\n        unsigned int b = sum_of_divisors(i);\n        if (b >= MAX_N)\n            flags[i] = -1;\n        else if (flags[b] == -1)\n            continue;\n\n        unsigned int c = sum_of_divisors(b);\n        if (c == i && b != i)\n        {\n            /* found amicable */\n            flags[b] = 1;\n            flags[i] = 1;\n            sum += b + i;\n#ifdef DEBUG\n            printf(\"Amicable: %4d : %4d\\n\", i, b);\n#endif\n        }\n        else\n        {\n            flags[i] = -1;\n            if (b < MAX_N)\n                flags[b] = -1;\n        }\n    }\n\n    clock_t end_time = clock();\n\n    printf(\"\\nTime taken: %.4g millisecond\\n\",\n           1e3 * (end_time - start_time) / CLOCKS_PER_SEC);\n    printf(\"Sum of all numbers = %lu\\n\", sum);\n\n    free(flags);\n    return 0;\n}\n","index":288},{"title":"Problem 22","category":"project_euler","id":"problem_22","index":289},{"title":"Sol1","category":"problem_22","id":"sol1_problem_22","algorithm":"/**\n * \\file\n * \\brief [Problem 22](https://projecteuler.net/problem=22) solution\n * \\author [Krishna Vedala](https://github.com/kvedala)\n */\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#ifdef _OPENMP\n#include <omp.h>\n#endif\n\n#define MAX_NAMES 6000  /**< Maximum number of names to store */\n#define MAX_NAME_LEN 20 /**< Maximum length of each name */\n\n/**\n * Alphabetical sorting using 'shell sort' algorithm\n */\nvoid shell_sort(char data[][MAX_NAME_LEN], int LEN)\n{\n    const int gaps[] = {701, 301, 132, 57, 23, 10, 4, 1};\n    const int gap_len = 8;\n    int i, j, g;\n\n    for (g = 0; g < gap_len; g++)\n    {\n        int gap = gaps[g];\n        for (i = gap; i < LEN; i++)\n        {\n            char tmp_buffer[MAX_NAME_LEN];\n            strcpy(tmp_buffer, data[i]);\n\n            for (j = i; j >= gap && strcmp(data[j - gap], tmp_buffer) > 0;\n                 j -= gap)\n                strcpy(data[j], data[j - gap]);\n            strcpy(data[j], tmp_buffer);\n        }\n    }\n#ifdef DEBUG\n    for (i = 0; i < LEN; i++) printf(\"%s\\t\", data[i]);\n#endif\n}\n\n/**\n * Alphabetical sorting using 'lazy sort' algorithm\n */\nvoid lazy_sort(char data[][MAX_NAME_LEN], int LEN)\n{\n    int i, j;\n    for (i = 0; i < LEN; i++)\n    {\n        for (j = i + 1; j < LEN; j++)\n        {\n            if (strcmp(data[i], data[j]) > 0)\n            {\n                char tmp_buffer[MAX_NAME_LEN];\n                strcpy(tmp_buffer, data[i]);\n                strcpy(data[i], data[j]);\n                strcpy(data[j], tmp_buffer);\n            }\n        }\n    }\n#ifdef DEBUG\n    for (i = 0; i < LEN; i++) printf(\"%s\\t\", data[i]);\n#endif\n}\n\n/** Main function */\nint main(int argc, char **argv)\n{\n    unsigned long COUNT = 0;\n    char *fname = \"names.txt\";\n    char names[MAX_NAMES][MAX_NAME_LEN];\n    short method = 0; /* sorting algorithm to use. 0 = lazy, 1 = shell-sort */\n\n    if (argc == 2)\n        method = atoi(argv[1]);\n\n    FILE *fp = fopen(fname, \"rt\");\n    if (!fp)\n    {\n        perror(\"Unable to open file\");\n        return -1;\n    }\n\n    /*\n     * Loops to get total number of rows and columns in the file\n     */\n    do\n    {\n        int ret = fscanf(fp, \"\\\"%[^\\\",]\\\",\", names[COUNT++]);\n        if (ret <= 0)\n            continue;\n        // printf(\"%s\\t\", names[COUNT - 1]);\n    } while (!feof(fp));\n    fclose(fp);\n\n    printf(\"\\nTotal number of names: %lu\\n\", COUNT);\n\n    if (method == 0)\n    {\n        clock_t start_time = clock();\n        shell_sort(names, COUNT);\n        clock_t end_time = clock();\n        printf(\"\\nShell sort: %.4g millisecond\\n\",\n               1e3 * (end_time - start_time) / CLOCKS_PER_SEC);\n    }\n    else if (method == 1)\n    {\n        clock_t start_time = clock();\n        lazy_sort(names, COUNT);\n        clock_t end_time = clock();\n        printf(\"\\nLazy sort: %.4g millisecond\\n\",\n               1e3 * (end_time - start_time) / CLOCKS_PER_SEC);\n    }\n\n    long sum_score = 0;\n    clock_t start_time = clock();\n    int i;\n\n#ifdef _OPENMP\n#pragma omp parallel for schedule(runtime) reduction(+ : sum_score)\n#endif\n#ifdef DEBUG\n    for (i = 935; i < 940; i++)\n#else\n    for (i = 0; i < COUNT; i++)\n#endif\n    {\n        long score = 0;\n        /* score the alphabets in i^th name */\n        for (int j = 0; names[i][j] != '\\0'; j++)\n            score += names[i][j] - 'A' +\n                     1; /* convert ASCII character to integer score */\n        sum_score += score * (i + 1);\n#ifdef DEBUG\n        printf(\"Name: %s\\tScore: %u x %u = %lu\\n\", names[i], score, i + 1,\n               (unsigned long)score * (i + 1));\n#endif\n    }\n    clock_t end_time = clock();\n    printf(\"Scoring time: %.4g millisecond\\n\",\n           1e3 * (end_time - start_time) / CLOCKS_PER_SEC);\n\n    printf(\"Total Score = %lu\\n\", sum_score);\n\n    return 0;\n}\n","index":290},{"title":"Problem 23","category":"project_euler","id":"problem_23","index":291},{"title":"Sol1","category":"problem_23","id":"sol1_problem_23","algorithm":"/**\n * \\file\n * \\brief [Problem 23](https://projecteuler.net/problem=23) solution\n * \\author [Krishna Vedala](https://github.com/kvedala)\n */\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#ifdef _OPENMP\n#include <omp.h>\n#endif\n\n/**\n * Returns:\n * -1 if N is deficient\n *  1 if N is abundant\n *  0 if N is perfect\n */\nchar get_perfect_number(unsigned long N)\n{\n    unsigned long sum = 1;\n    char ret = 0;\n\n    for (unsigned long i = 2; i * i <= N; i++)\n    {\n        if (N % i == 0)\n        {\n            sum += i;\n            unsigned long tmp = N / i;\n            if (tmp != i)\n            {\n                sum += tmp;\n            }\n        }\n    }\n\n    ret = sum == N ? 0 : (sum > N ? 1 : -1);\n    // #ifdef DEBUG\n    //     printf(\"%5lu: %5lu : %d\\n\", N, sum, ret);\n    // #endif\n    return ret;\n}\n\n/**\n * Is the given number an abundant number (1) or not (0)\n */\nunsigned long is_abundant(unsigned long N)\n{\n    return get_perfect_number(N) == 1 ? 1 : 0;\n}\n\n/**\n * Find the next abundant number after N and not including N\n */\nunsigned long get_next_abundant(unsigned long N)\n{\n    unsigned long i;\n    for (i = N + 1; !is_abundant(i); i++)\n    {\n        ;\n    }\n    return i;\n}\n\n/**\n * check if a given number can be represented as a sum\n * of two abundant numbers.\n * \\returns 1 - if yes\n * \\returns 0 - if not\n */\nchar is_sum_of_abundant(unsigned long N)\n{\n    /* optimized logic:\n     * i + j = N   where both i and j should be abundant\n     * hence we can simply check for j = N - i as we loop through i\n     */\n    for (unsigned long i = get_next_abundant(1); i <= (N >> 1);\n         i = get_next_abundant(i))\n    {\n        if (is_abundant(N - i))\n        {\n#ifdef DEBUG\n            printf(\"\\t%4lu + %4lu = %4lu\\n\", i, N - i, N);\n#endif\n            return 1;\n        }\n    }\n    return 0;\n}\n\n/** Main function */\nint main(int argc, char **argv)\n{\n    unsigned long MAX_N = 28123; /* upper limit of numbers to check */\n\n    unsigned long sum = 0;\n    if (argc == 2)\n    {\n        MAX_N = strtoul(argv[1], NULL, 10);\n    }\n\n#ifdef _OPENMP\n    printf(\"Using OpenMP parallleization with %d threads\\n\",\n           omp_get_max_threads());\n#else\n    printf(\"Not using parallleization!\\n\");\n#endif\n\n    double total_duration = 0.f;\n    long i;\n#ifdef _OPENMP\n#pragma omp parallel for reduction(+ : sum) schedule(runtime)\n#endif\n    for (i = 1; i <= MAX_N; i++)\n    {\n        clock_t start_time = clock();\n        if (!is_sum_of_abundant(i))\n        {\n            sum += i;\n        }\n        clock_t end_time = clock();\n        total_duration += (double)(end_time - start_time) / CLOCKS_PER_SEC;\n\n        printf(\"... %5lu: %8lu\\r\", i, sum);\n        if (i % 100 == 0)\n        {\n            fflush(stdout);\n        }\n    }\n\n    printf(\"Time taken: %.4g s\\n\", total_duration);\n    printf(\n        \"Sum of numbers that cannot be represented as sum of two abundant \"\n        \"numbers : %lu\\n\",\n        sum);\n\n    return 0;\n}\n","index":292},{"title":"Sol2","category":"problem_23","id":"sol2_problem_23","algorithm":"/**\n * \\file\n * \\brief [Problem 23](https://projecteuler.net/problem=23) solution -\n * optimization using look-up array\n * \\author [Krishna Vedala](https://github.com/kvedala)\n *\n * Optimization applied - compute & store abundant numbers once\n * into a look-up array.\n */\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#ifdef _OPENMP\n#include <omp.h>\n#endif\n\n/**\n * This is the global array to be used to store a flag to identify\n * if a particular number is abundant (1) or not (0).\n * Using a whole byte to store a binary info would be redundant.\n * We will use each byte to represent 8 numbers by relying on bits.\n * This saves memory required by 1/8\n */\nchar *abundant_flags = NULL;\n\n/**\n * \\returns -1 if N is deficient\n * \\returns 1 if N is abundant\n * \\returns 0 if N is perfect\n */\nchar get_perfect_number(unsigned long N)\n{\n    unsigned long sum = 1;\n    char ret = 0;\n\n    for (unsigned long i = 2; i * i <= N; i++)\n    {\n        if (N % i == 0)\n        {\n            sum += i;\n            unsigned long tmp = N / i;\n            if (tmp != i)\n            {\n                sum += tmp;\n            }\n        }\n    }\n\n    ret = sum == N ? 0 : (sum > N ? 1 : -1);\n#ifdef DEBUG\n    printf(\"%5lu: %5lu : %d\\n\", N, sum, ret);\n#endif\n    return ret;\n}\n\n/**\n * Is the given number an abundant number (1) or not (0)\n */\nchar is_abundant(unsigned long N)\n{\n    // return abundant_flags[N >> 3] & (1 << N % 8) ? 1 : 0;\n    return abundant_flags[N >> 3] & (1 << (N & 7))\n               ? 1\n               : 0; /* optimized modulo operation */\n}\n\n/**\n * Find the next abundant number after N and not including N\n */\nunsigned long get_next_abundant(unsigned long N)\n{\n    unsigned long i;\n    /* keep checking successive numbers till an abundant number is found */\n    for (i = N + 1; !is_abundant(i); ++i)\n    {\n        ;\n    }\n    return i;\n}\n\n/**\n * check if a given number can be represented as a sum\n * of two abundant numbers.\n * \\returns 1 - if yes\n * \\returns 0 - if not\n */\nchar is_sum_of_abundant(unsigned long N)\n{\n    /* optimized logic:\n     * i + j = N   where both i and j should be abundant\n     * hence we can simply check for j = N - i as we loop through i\n     */\n    for (unsigned long i = get_next_abundant(1); i <= (N >> 1);\n         i = get_next_abundant(i))\n    {\n        if (is_abundant(N - i))\n        {\n#ifdef DEBUG\n            printf(\"\\t%4lu + %4lu = %4lu\\n\", i, N - i, N);\n#endif\n            return 1;\n        }\n    }\n    return 0;\n}\n\n/** Main function */\nint main(int argc, char **argv)\n{\n    long MAX_N = 28123; /* Limit of numbers to check */\n\n    unsigned long sum = 0;\n    if (argc == 2)\n    {\n        MAX_N = strtoul(argv[1], NULL, 10);\n    }\n\n    /* byte array to store flags to identify abundant numbers\n     * the flags are identified by bits\n     */\n    abundant_flags = (char *)calloc(MAX_N >> 3, 1);\n    if (!abundant_flags)\n    {\n        perror(\"Unable to allocate memoey!\");\n        return -1;\n    }\n\n#ifdef _OPENMP\n    printf(\"Using OpenMP parallleization with %d threads\\n\",\n           omp_get_max_threads());\n#else\n    printf(\"Not using parallleization!\\n\");\n#endif\n\n    clock_t start_time = clock();\n\n    /* Loop to set abundant flags */\n    long N;\n#ifdef _OPENMP\n#pragma omp for schedule(runtime)\n#endif\n    for (N = 1; N <= MAX_N; N++)\n    {\n        char ret = get_perfect_number(N);\n        if (ret == 1)\n        {\n            // int byte_offset = N % 8, index = N >> 3;\n            int byte_offset = N & 7, index = N >> 3;\n#ifdef _OPENMP\n#pragma omp critical\n#endif\n            abundant_flags[index] |= ret << byte_offset;\n        }\n        // if (i % 100 == 0)\n        //     printf(\"... %5lu: %8lu\\r\", i, sum);\n    }\n\n    clock_t end_time = clock();\n    double t1 = 1e3 * (end_time - start_time) / CLOCKS_PER_SEC;\n    printf(\"Time taken to get abundant numbers: %.4g ms\\n\", t1);\n\n    clock_t t2 = 0;\n    long i;\n#ifdef _OPENMP\n#pragma omp parallel for schedule(runtime) reduction(+ : sum)\n#endif\n    for (i = 1; i < MAX_N; i++)\n    {\n        clock_t start_time1 = clock();\n        if (!is_sum_of_abundant(i))\n        {\n            // #ifdef _OPENMP\n            // #pragma omp critical\n            // #endif\n            sum += i;\n        }\n        clock_t end_time1 = clock();\n#ifdef _OPENMP\n#pragma omp critical\n#endif\n        t2 += end_time1 - start_time1;\n\n        printf(\"... %5lu: %8lu\\r\", i, sum);\n        if (i % 100 == 0)\n        {\n            fflush(stdout);\n        }\n    }\n\n#ifdef DEBUG\n    putchar('\\n');\n#endif\n    double t22 = 1e3 * t2 / CLOCKS_PER_SEC;\n    printf(\"Time taken for final sum: %.4g ms\\nTotal Time taken: %.4g ms\\n\",\n           t22, t1 + t22);\n    printf(\"Memory used: %lu bytes\\n\", MAX_N >> 3);\n    printf(\n        \"Sum of numbers that cannot be represented as sum of two abundant \"\n        \"numbers : %lu\\n\",\n        sum);\n\n    free(abundant_flags);\n\n    return 0;\n}\n","index":293},{"title":"Problem 24","category":"project_euler","id":"problem_24","index":294},{"title":"Problem 25","category":"project_euler","id":"problem_25","index":295},{"title":"Sol1","category":"problem_25","id":"sol1_problem_25","algorithm":"/**\n * \\file\n * \\brief [Problem 25](https://projecteuler.net/problem=25) solution implemented\n * using arbitrarily large numbers represented as arrays\n * \\author [Krishna Vedala](https://github.com/kvedala)\n */\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\n#define MAX_DIGITS 1000 /**< maximum number of digits */\n\n/**\n * Function to add arbitraty length decimal integers stored in an array.\\n\n * a + b = c = new b\n */\nunsigned int add_numbers(unsigned char *a, unsigned char *b, unsigned char *c,\n                         int N)\n{\n    unsigned char carry = 0;\n    unsigned int i;\n\n    for (i = 0; i < N; i++)\n    {\n        // printf(\"\\t%d + %d + %d \", a[i], b[i], carry);\n        c[i] = carry + a[i] + b[i];\n        if (c[i] > 9) /* check for carry */\n        {\n            carry = 1;\n            c[i] -= 10;\n        }\n        else\n        {\n            carry = 0;\n        }\n        // printf(\"= %d, %d\\n\", carry, c[i]);\n    }\n\n    while (carry != 0)\n    {\n        // printf(\"\\t\\t...adding new digit\\n\");\n        // printf(\"\\t0 + %d + %d \", b[i], carry);\n        c[i] = carry + c[i];\n        if (c[i] > 9)\n        {\n            carry = 1;\n            c[i] -= 10;\n        }\n        else\n        {\n            carry = 0;\n        }\n        // printf(\"= %d, %d\\n\", carry, c[i]);\n        i++;\n    }\n    return i;\n}\n\n/** Print a large number */\nint print_number(unsigned char *number, int N)\n{\n    int start_pos = N - 1;\n\n    /* skip all initial zeros */\n    while (number[start_pos] == 0) start_pos--;\n\n    for (int i = start_pos; i >= 0; i--) putchar(number[i] + 0x30);\n\n    return 0;\n}\n\n/** Get number of digits in a large number */\nunsigned int get_digits(unsigned char *number)\n{\n    unsigned int digits = MAX_DIGITS;\n    while (number[digits] == 0) digits--;\n    return digits;\n}\n\n/** Main function */\nint main(int argc, char *argv[])\n{\n    unsigned char\n        fn[MAX_DIGITS + 1]; /* array to store digits of a large number */\n    unsigned char fn1[MAX_DIGITS + 1];\n    unsigned char sum[MAX_DIGITS + 1];\n\n    memset(fn, 0, MAX_DIGITS);\n    memset(fn1, 0, MAX_DIGITS);\n    memset(sum, 0, MAX_DIGITS);\n\n    fn[0] = 1;\n    fn1[1] = 1;\n\n    unsigned int index = 1, digit_count = 1;\n\n    clock_t start_time = clock();\n    do\n    {\n        digit_count = add_numbers(fn, fn1, sum, digit_count);\n        // digit_count = get_digits(sum);\n\n        // printf(\"%5u (%u) (%u) \", index, digit_count, get_digits(sum));\n        // print_number(sum, digit_count);\n        // putchar('\\n');\n\n        if (digit_count == MAX_DIGITS)\n        {\n            break;\n        }\n        memcpy(fn, fn1, MAX_DIGITS);\n        memcpy(fn1, sum, MAX_DIGITS);\n        index++;\n    } while (digit_count < MAX_DIGITS);\n    clock_t end_time = clock();\n\n    printf(\"Time taken: %.4g ms\\n\",\n           1e3 * (end_time - start_time) / CLOCKS_PER_SEC);\n    printf(\"The nth term for %d digits: %u \\n\", MAX_DIGITS, index--);\n    print_number(sum, digit_count);\n\n    return 0;\n}\n","index":296},{"title":"Problem 26","category":"project_euler","id":"problem_26","index":297},{"title":"Sol1","category":"problem_26","id":"sol1_problem_26","algorithm":"/**\n * \\file\n * \\brief [Problem 26](https://projecteuler.net/problem=26) solution\n * \\author [Krishna Vedala](https://github.com/kvedala)\n */\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#ifdef _OPENMP\n#include <omp.h>\n#endif\n\n#define MAX_DENO 2000 /**< limit of unit fractions */\n#define MAX_LEN \\\n    (MAX_DENO + 10) /**< length of resulting recurring fraction number */\n\n/** comparison function for use with internal `qsort` algorithm */\nint compare(const void *a, const void *b)\n{\n    return (*(unsigned short *)a - *(unsigned short *)b);\n}\n\n/** Main function */\nint main(int argc, char *argv[])\n{\n    unsigned short max_digits = 0, max_idx_number = 0;\n\n    clock_t start_time = clock();\n    short deno;\n#ifdef _OPENMP\n#pragma omp for\n#endif\n    for (deno = 2; deno < MAX_DENO; deno++)\n    {\n        unsigned short remainders[MAX_LEN];\n        unsigned short rem = 1, *rem_ptr = remainders;\n        memset(remainders, (unsigned short)-1,\n               MAX_LEN * sizeof(unsigned short));\n        // remainders[0] = 1;\n        // printf(\"1/%-4u\\t \", deno);\n        unsigned short index = 0, num_digits;\n\n        while (rem != 0)\n        {\n            rem = (rem * 10) % deno;\n            if (rem == 0)\n            {\n                index = 0;\n                break;\n            }\n            rem_ptr = (unsigned short *)bsearch(\n                &rem, remainders, MAX_LEN, sizeof(unsigned short), compare);\n            // printf(\"%2d, \", rem);\n            // printf(\"(%14p), \", rem_ptr);\n            if (rem_ptr != NULL)\n                break;\n            remainders[index] = rem;\n            rem_ptr = remainders;\n            index++;\n        }\n\n        num_digits = index - (rem_ptr - remainders);\n        // printf(\"\\n\\t(%14p, %14p, %4u, %4u)\\n\", rem_ptr, remainders, index,\n        // num_digits);\n#ifdef _OPENMP\n#pragma omp critical\n        {\n#endif\n            if (num_digits > max_digits)\n            {\n                max_digits = num_digits;\n                max_idx_number = deno;\n                // printf(\"\\t (%u, %u)\\n \", max_digits, max_idx_number);\n            }\n#ifdef _OPENMP\n        }\n#endif\n    }\n    clock_t end_time = clock();\n\n    printf(\"Time taken: %.4g ms\\n\",\n           1e3 * (double)(end_time - start_time) / CLOCKS_PER_SEC);\n    printf(\"Maximum digits: %hu\\t Denominator: %hu\\n\", max_digits,\n           max_idx_number);\n\n    return 0;\n}\n","index":298},{"title":"Problem 3","category":"project_euler","id":"problem_3","index":299},{"title":"Sol1","category":"problem_3","id":"sol1_problem_3","algorithm":"/**\n * \\file\n * \\brief [Problem 3](https://projecteuler.net/problem=3) solution\n *\n * Problem:\n *\n * The prime factors of 13195 are 5,7,13 and 29. What is the largest prime\n * factor of a given number N? e.g. for 10, largest prime factor = 5. For 17,\n * largest prime factor = 17.\n */\n#include <math.h>\n#include <stdio.h>\n\n/** Check if the given number is prime */\nchar isprime(int no)\n{\n    int sq;\n\n    if (no == 2)\n    {\n        return 1;\n    }\n    else if (no % 2 == 0)\n    {\n        return 0;\n    }\n    sq = ((int)(sqrt(no))) + 1;\n    for (int i = 3; i < sq; i += 2)\n    {\n        if (no % i == 0)\n        {\n            return 0;\n        }\n    }\n    return 1;\n}\n\n/** Main function */\nint main()\n{\n    int maxNumber = 0;\n    int n = 0;\n    int n1;\n    scanf(\"%d\", &n);\n    if (isprime(n) == 1)\n        printf(\"%d\", n);\n    else\n    {\n        while (n % 2 == 0)\n        {\n            n = n / 2;\n        }\n        if (isprime(n) == 1)\n        {\n            printf(\"%d\\n\", n);\n        }\n        else\n        {\n            n1 = ((int)(sqrt(n))) + 1;\n            for (int i = 3; i < n1; i += 2)\n            {\n                if (n % i == 0)\n                {\n                    if (isprime((int)(n / i)) == 1)\n                    {\n                        maxNumber = n / i;\n                        break;\n                    }\n                    else if (isprime(i) == 1)\n                    {\n                        maxNumber = i;\n                    }\n                }\n            }\n            printf(\"%d\\n\", maxNumber);\n        }\n    }\n    return 0;\n}","index":300},{"title":"Sol2","category":"problem_3","id":"sol2_problem_3","algorithm":"/**\n * \\file\n * \\brief [Problem 3](https://projecteuler.net/problem=3) solution\n *\n * Problem:\n *\n * The prime factors of 13195 are 5,7,13 and 29. What is the largest prime\n * factor of a given number N? e.g. for 10, largest prime factor = 5. For 17,\n * largest prime factor = 17.\n */\n#include <stdio.h>\n\n/** Main function */\nint main()\n{\n    int n = 0;\n    scanf(\"%d\", &n);\n    int prime = 1;\n    int i = 2;\n    while (i * i <= n)\n    {\n        while (n % i == 0)\n        {\n            prime = i;\n            n /= i;\n        }\n        i += 1;\n    }\n    if (n > 1)\n        prime = n;\n    printf(\"%d\\n\", prime);\n    return 0;\n}","index":301},{"title":"Problem 4","category":"project_euler","id":"problem_4","index":302},{"title":"Sol","category":"problem_4","id":"sol_problem_4","algorithm":"/**\n * \\file\n * \\brief [Problem 4](https://projecteuler.net/problem=4) solution\n */\n#include <stdio.h>\n\n/** Check if number is palindromic\n * \\param[in] n number to check\n * \\returns 1 if palindromic\n * \\returns 0 if not palindromic\n */\nint is_palindromic(unsigned int n)\n{\n    unsigned int reversed = 0, t = n;\n\n    while (t > 0)\n    {\n        reversed = 10 * reversed + (t % 10);\n        t /= 10;\n    }\n    return reversed == n;\n}\n\n/** Main function */\nint main(void)\n{\n    unsigned int i, j, max = 0;\n    for (i = 100; i <= 999; i++)\n    {\n        for (j = 100; j <= 999; j++)\n        {\n            unsigned int p = i * j;\n            if (is_palindromic(p) && p > max)\n            {\n                max = p;\n            }\n        }\n    }\n    printf(\"%u\\n\", max);\n    return 0;\n}\n","index":303},{"title":"Problem 401","category":"project_euler","id":"problem_401","index":304},{"title":"Sol1","category":"problem_401","id":"sol1_problem_401","algorithm":"/**\n * \\file\n * \\brief [Problem 401](https://projecteuler.net/problem=401) solution -\n * Sum of squares of divisors\n * \\author [Krishna Vedala](https://github.com/kvedala)\n */\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#define __STDC_FORMAT_MACROS\n#include <inttypes.h>\n#ifdef _OPENMP\n#include <omp.h>\n#endif\n\n#define MOD_LIMIT (uint64_t)1e9 /**< modulo limit */\n#define MAX_LENGTH 5000         /**< chunk size of array allocation */\n\n/**\n * Check if a number is present in given array\n * \\param[in] N number to check\n * \\param[in] D array to check\n * \\param[in] L length of array\n * \\returns 1 if present\n * \\returns 0 if absent\n */\nchar is_in(uint64_t N, uint64_t *D, uint64_t L)\n{\n    uint64_t i;\n    for (i = 0; i < L; i++)\n    {\n        if (D[i] == N)\n        {\n            return 1;\n        }\n    }\n    return 0;\n}\n\n/**\n * Get all integer divisors of a number\n * \\param[in] N number to find divisors for\n * \\param[out] D array to store divisors in\n * \\returns number of divisors found\n */\nuint64_t get_divisors(uint64_t N, uint64_t *D)\n{\n    uint64_t q, r;\n    int64_t i, num = 0;\n\n    if (N == 1)\n    {\n        D[0] = 1;\n        return 1;\n    }\n\n    // search till sqrt(N)\n    // because after this, the pair of divisors will repeat themselves\n    for (i = 1; i * i <= N + 1; i++)\n    {\n        r = N % i;  // get reminder\n\n        // reminder = 0 if 'i' is a divisor of 'N'\n        if (r == 0)\n        {\n            q = N / i;\n            if (!is_in(i, D, num))  // if divisor was already stored\n            {\n                D[num] = i;\n                num++;\n            }\n            if (!is_in(q, D, num))  // if divisor was already stored\n            {\n                D[num] = q;\n                num++;\n            }\n        }\n\n        if (num == MAX_LENGTH)\n        {  // limit of array reached, allocate more space\n            D = (uint64_t *)realloc(D, MAX_LENGTH * sizeof(uint64_t) << 1);\n        }\n    }\n    return num;\n}\n\n/**\n * compute sum of squares of all integer factors of a number\n * \\param[in] N\n * \\returns sum of squares\n */\nuint64_t sigma2(uint64_t N)\n{\n    uint64_t sum = 0, L;\n    int64_t i;\n    uint64_t *D = (uint64_t *)malloc(MAX_LENGTH * sizeof(uint64_t));\n\n    L = get_divisors(N, D);\n    for (i = 1; i < L; i++)\n    {\n        uint64_t DD = (D[i] * D[i]) % MOD_LIMIT;\n        sum += DD;\n    }\n\n    free(D);\n    return sum % MOD_LIMIT;\n}\n\n/**\n * sum of squares of factors of numbers\n * from 1 thru N\n */\nuint64_t sigma(uint64_t N)\n{\n    uint64_t s, sum = 0;\n    int64_t i;\n\n#ifdef _OPENMP\n// parallelize on threads\n#pragma omp parallel for reduction(+ : sum)\n#endif\n    for (i = 0; i <= N; i++)\n    {\n        s = sigma2(i);\n        sum += s;\n    }\n    return sum % MOD_LIMIT;\n}\n\n/** Main function */\nint main(int argc, char **argv)\n{\n    uint64_t N = 1000;\n\n    if (argc == 2)\n    {\n        N = strtoll(argv[1], NULL, 10);\n    }\n    else if (argc > 2)\n    {\n        fprintf(stderr, \"Wrong number of input arguments!\\n\");\n        printf(\"Usage:\\t ./sol1.c [N=1000]\");\n        return -1;\n    }\n\n    clock_t start_time = clock();\n    uint64_t result = sigma(N);\n    double dtime = clock() - start_time;\n\n    printf(\"N = %\" PRIu64 \"\\nSum: %\" PRIu64 \"\\n\", N, result);\n    printf(\"Time taken: %.4gms\\n\", dtime * 1e3 / CLOCKS_PER_SEC);\n\n    return 0;\n}\n","index":305},{"title":"Problem 5","category":"project_euler","id":"problem_5","index":306},{"title":"Sol","category":"problem_5","id":"sol_problem_5","algorithm":"/**\n * \\file\n * \\brief [Problem 5](https://projecteuler.net/problem=5) solution\n */\n#include <stdio.h>\n\n/** Compute [Greatest Common Divisor\n * (GCD)](https://en.wikipedia.org/wiki/Greatest_common_divisor) of two numbers\n * using Euclids algorithm\n */\nunsigned long gcd(unsigned long a, unsigned long b)\n{\n    unsigned long r;\n    if (a > b)\n    {\n        unsigned long t = a;\n        a = b;\n        b = t;\n    }\n    while ((r = (a % b)))\n    {\n        a = b;\n        b = r;\n    }\n    return b;\n}\n\n/** Compute [Least Common Multiple\n * (LCM)](https://en.wikipedia.org/wiki/Least_common_multiple) of two numbers\n */\nunsigned long lcm(unsigned long a, unsigned long b)\n{\n    unsigned long long p = (unsigned long long)a * b;\n    return p / gcd(a, b);\n}\n\n/** Main function */\nint main(void)\n{\n    unsigned long ans = 1;\n    unsigned long i;\n    for (i = 1; i <= 20; i++)\n    {\n        ans = lcm(ans, i);\n    }\n    printf(\"%lu\\n\", ans);\n    return 0;\n}\n","index":307},{"title":"Problem 6","category":"project_euler","id":"problem_6","index":308},{"title":"Sol","category":"problem_6","id":"sol_problem_6","algorithm":"/**\n * \\file\n * \\brief [Problem 6](https://projecteuler.net/problem=6) solution\n */\n#include <stdio.h>\n\n/** Main function */\nint main(void)\n{\n    unsigned s1 = 0, s2 = 0, i;\n    for (i = 1; i <= 100; i++)\n    {\n        s1 += i * i;\n        s2 += i;\n    }\n    unsigned ans = s2 * s2 - s1;\n    printf(\"%u\\n\", ans);\n    return 0;\n}\n","index":309},{"title":"Problem 7","category":"project_euler","id":"problem_7","index":310},{"title":"Sol","category":"problem_7","id":"sol_problem_7","algorithm":"/**\n * \\file\n * \\brief [Problem 7](https://projecteuler.net/problem=7) solution\n */\n#include <stdio.h>\n#include <stdlib.h>\n\n/** Main function */\nint main(void)\n{\n    char *sieve;\n    size_t i;\n    unsigned count = 0;\n    size_t n = 1000000;\n    const unsigned target = 10001;\n\n    sieve = (char *)calloc(n, sizeof(char));\n    for (i = 2; i < n; i++)\n    {\n        if (!sieve[i])\n        {\n            size_t j;\n            count++;\n            if (count == target)\n            {\n                printf(\"%lu\\n\", i);\n                break;\n            }\n            for (j = i * 2; j < n; j += i)\n            {\n                sieve[j] = 1;\n            }\n        }\n    }\n    free(sieve);\n    return 0;\n}\n","index":311},{"title":"Problem 8","category":"project_euler","id":"problem_8","index":312},{"title":"Sol1","category":"problem_8","id":"sol1_problem_8","algorithm":"/**\n * \\file\n * \\brief [Problem 8](https://projecteuler.net/problem=8) solution\n * \\author [Krishna Vedala](https://github.com/kvedala)\n */\n#include <stdio.h>\n#include <stdlib.h>\n\n/** Compute the product of two numbers in a file\n *\n * \\param[in] fp pointer to file that is already open\n * \\param[in] start_pos line number of the first numer\n * \\param[in] num_digits number of digits on the line to multiply\n * \\returns expected product\n */\nlong long int get_product(FILE *fp, long start_pos, int num_digits)\n{\n    char ch = ' '; /* temporary variable to store character read from file */\n    unsigned char num = 0;  /* temporary variable to store digit read */\n    long long int prod = 1; /* product accumulator */\n    int count =\n        0; /* we use this variable to count number of bytes of file read */\n\n    /* accumulate product for num_digits */\n    for (int i = 0; i < num_digits; i++, count++)\n    {\n        /* get character from file */\n        ch = getc(fp);\n\n        /* the ASCII codes of digits is between 0x30 and 0x39.\n         * any character not in this range implies an invalid character\n         */\n        if (ch < 0x30 || ch > 0x39)\n        {\n            if (ch == EOF)\n                return 0;\n            i--;\n            continue;\n        }\n\n        num = ch - 0x30; /* convert character digit to number */\n        if (num == 0)\n        {\n            /* If number is zero, we can skip the next 'num_digits'\n             * because this '0' will repeat in the next 'num_digit'\n             * multiplications. Hence, we also do not update the file position\n             */\n            /* NOTE: this is not needed but helps get results faster :) */\n            return 0;\n        }\n\n        prod *= num; /* accumulate product */\n    }\n\n    /* set file position to the next starting character + 1 */\n    fseek(fp, -count + 1, SEEK_CUR);\n\n    return prod;\n}\n\n/** Main function */\nint main(int argc, char *argv[])\n{\n    int position = 0;\n    int num_digits = 4;\n    long long int prod, max_prod = 0;\n\n    /* if second command-line argument is ge=iven,\n     * use it as the number of digits to compute\n     * successive product for\n     */\n    if (argc == 2)\n        num_digits = atoi(argv[1]);\n\n    /* open file to read digits from */\n    FILE *fp = fopen(\"digits.txt\", \"rt\");\n    if (!fp)\n    {\n        perror(\"Unable to open file\");\n        return -1;\n    }\n\n    /* loop through all digits in the file */\n    do\n    {\n        /* get product of 'num_digits' from current position in file */\n        prod = get_product(fp, ftell(fp), num_digits);\n\n        if (prod > max_prod)\n        {\n            max_prod = prod;\n            position = ftell(fp) - 1;\n        }\n    } while (!feof(fp)); /* loop till end of file is reached */\n\n    printf(\"Maximum product: %lld\\t Location: %d^th position\\n\\t\", max_prod,\n           position);\n    fseek(fp, position,\n          SEEK_SET); /* move cursor to identified position in file */\n    /* loop through all digits */\n    for (; num_digits > 0; num_digits--)\n    {\n        char ch = getc(fp); /* get character */\n        /* skip invalid character */\n        if (ch < 0x30 || ch > 0x39)\n            continue;\n        if (num_digits > 1)\n            printf(\"%c x \", ch);\n        else\n            printf(\"%c = %lld\\n\", ch, max_prod);\n    }\n\n    fclose(fp); /* close file */\n\n    return 0;\n}\n","index":313},{"title":"Sol2","category":"problem_8","id":"sol2_problem_8","algorithm":"/**\n * \\file\n * \\brief [Problem 8](https://projecteuler.net/problem=8) solution\n * \\author [Krishna Vedala](https://github.com/kvedala)\n */\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h> /* for memmove */\n\n/** Main function */\nint main(int argc, char *argv[])\n{\n    int position = 0, num_bad_chars = 0;\n    int num_digits = 4;\n    char ch;\n    unsigned char num, num_prev;\n    unsigned char *buffer = NULL;\n    long long int prod = 1, max_prod = 0;\n\n    /* if second command-line argument is given,\n     * use it as the number of digits to compute\n     * successive product for\n     */\n    if (argc == 2)\n        num_digits = atoi(argv[1]);\n\n    /* allocate memory to store past values */\n    buffer = calloc(num_digits, sizeof(unsigned char));\n    if (!buffer)\n    {\n        perror(\"Unable to allocate memory for buffer\");\n        return -1;\n    }\n\n    /* open file to read digits from */\n    FILE *fp = fopen(\"digits.txt\", \"rt\");\n    if (!fp)\n    {\n        perror(\"Unable to open file\");\n        free(buffer); /* free allocated memory */\n        return -1;\n    }\n\n    /* loop through all digits in the file */\n    do\n    {\n        /* get character from file */\n        ch = getc(fp);\n\n        /* the ASCII codes of digits is between 0x30 and 0x39.\n         * any character not in this range implies an invalid character\n         */\n        if (ch < 0x30 || ch > 0x39)\n        {\n            num_bad_chars++; /* this is used to get the bad characters in the\n                                sequence of 13 characters */\n            continue;\n        }\n        else if (num_bad_chars > 0)\n            num_bad_chars--;\n\n        num = ch - 0x30;      /* convert character digit to number */\n        num_prev = buffer[0]; /* previous n^th digit */\n\n        /* left shift the buffer -\n         *  using a for loop or a faster memory move\n         */\n        memmove(buffer, buffer + 1, num_digits - 1);\n        /*\n        for (int i = 1; i < num_digits; i++)\n            buffer[i-1] = buffer[i];\n        */\n\n        buffer[num_digits - 1] = num; /* save the latest number in buffer */\n\n        if (num_prev != 0)\n        {\n            /* since product is accumulated, the new product can be obtained by\n             * simply multiplying the new digit and dividing with the oldest\n             * digit\n             */\n            prod /= num_prev; /* divide first to avoid over-flows */\n            prod *= num;\n        }\n        else\n        {\n            prod = 1;\n            for (int i = 0; i < num_digits; i++)\n            {\n                if (buffer[i] == 0)\n                {\n                    prod = 0;\n                    break; /* break innermost for-loop */\n                }\n                prod *= buffer[i];\n            }\n        }\n\n        /* check if a new maxima was found */\n        if (prod > max_prod)\n        {\n            max_prod = prod;\n            position = ftell(fp) - num_bad_chars - num_digits - 1;\n        }\n    } while (!feof(fp)); /* loop till end of file is reached */\n\n    printf(\"Maximum product: %lld\\t Location: %d^th position\\n\\t\", max_prod,\n           position);\n    fseek(fp, position,\n          SEEK_SET); /* move cursor to identified position in file */\n    /* loop through all digits */\n    for (; num_digits > 0; num_digits--)\n    {\n        char ch = getc(fp); /* get character */\n        /* skip invalid character */\n        if (ch < 0x30 || ch > 0x39)\n            continue;\n        if (num_digits > 1)\n            printf(\"%c x \", ch);\n        else\n            printf(\"%c = %lld\\n\", ch, max_prod);\n    }\n\n    fclose(fp);   /* close file */\n    free(buffer); /* free allocated memory */\n\n    return 0;\n}\n","index":314},{"title":"Problem 9","category":"project_euler","id":"problem_9","index":315},{"title":"Sol1","category":"problem_9","id":"sol1_problem_9","algorithm":"/**\n * \\file\n * \\brief [Problem 9](https://projecteuler.net/problem=9) solution - A naive\n * implementation\n * \\author [Krishna Vedala](https://github.com/kvedala)\n */\n#include <stdio.h>\n\n/** Main function */\nint main(void)\n{\n    for (int a = 1; a < 300; a++)\n        for (int b = a + 1; b < 400; b++)\n            for (int c = b + 1; c < 500; c++)\n            {\n                if (a * a + b * b == c * c)\n                    if (a + b + c == 1000)\n                    {\n                        printf(\"%d x %d x %d = %ld\\n\", a, b, c,\n                               (long int)a * b * c);\n                        return 0;\n                    }\n            }\n\n    return 0;\n}\n","index":316},{"title":"Sol2","category":"problem_9","id":"sol2_problem_9","algorithm":"/**\n * \\file\n * \\brief [Problem 9](https://projecteuler.net/problem=9) solution\n * \\author [Krishna Vedala](https://github.com/kvedala)\n *\n Problem Statement:\n    A Pythagorean triplet is a set of three natural numbers, \\f$a < b < c\\f$,\n for which, \\f$a^2 + b^2 = c^2\\f$. For example, \\f$3^2 + 4^2 = 9 + 16 = 25 =\n 5^2\\f$. There exists exactly one Pythagorean triplet for which \\f$a + b + c =\n 1000\\f$. Find the product abc.\n\n\n    Given \\f$a^2 + b^2 = c^2\\f$ and \\f$a+b+c = n\\f$, we can write:\n    \\f{eqnarray*}{\n        b &=& \\frac{n^2 - 2an}{2n - 2a}\\\\\n        c &=& n - a - b\n    \\f}\n */\n#include <stdio.h>\n#include <stdlib.h>\n\n/** Main function */\nint main(void)\n{\n    int N = 1000;\n\n    for (int a = 1; a < 300; a++)\n    {\n        long tmp1 = N * N - 2 * a * N;\n        long tmp2 = 2 * (N - a);\n        div_t tmp3 = div(tmp1, tmp2);\n        int b = tmp3.quot;\n        int c = N - a - b;\n\n        if (a * a + b * b == c * c)\n        {\n            printf(\"%d x %d x %d = %ld\\n\", a, b, c, (long int)a * b * c);\n            return 0;\n        }\n    }\n\n    return 0;\n}","index":317},{"title":"Searching","category":null,"id":"searching","index":318},{"title":"Binary Search","category":"searching","id":"binary_search_searching","algorithm":"/**\n * @file\n * @brief Program to perform [binary\n * search](https://en.wikipedia.org/wiki/Binary_search_algorithm) of a target\n * value in a given *sorted* array.\n * @authors [James McDermott](https://github.com/theycallmemac) - recursive\n * algorithm\n * @authors [Krishna Vedala](https://github.com/kvedala) - iterative algorithm\n */\n#include <assert.h>\n#include <stdio.h>\n\n/** Recursive implementation\n * \\param[in] arr array to search\n * \\param l left index of search range\n * \\param r right index of search range\n * \\param x target value to search for\n * \\returns location of x assuming array arr[l..r] is present\n * \\returns -1 otherwise\n */\nint binarysearch1(const int *arr, int l, int r, int x)\n{\n    if (r >= l)\n    {\n        int mid = l + (r - l) / 2;\n\n        // If element is present at middle\n        if (arr[mid] == x)\n            return mid;\n\n        // If element is smaller than middle\n        if (arr[mid] > x)\n            return binarysearch1(arr, l, mid - 1, x);\n\n        // Else element is in right subarray\n        return binarysearch1(arr, mid + 1, r, x);\n    }\n\n    // When element is not present in array\n    return -1;\n}\n\n/** Iterative implementation\n * \\param[in] arr array to search\n * \\param l left index of search range\n * \\param r right index of search range\n * \\param x target value to search for\n * \\returns location of x assuming array arr[l..r] is present\n * \\returns -1 otherwise\n */\nint binarysearch2(const int *arr, int l, int r, int x)\n{\n    int mid = l + (r - l) / 2;\n\n    while (arr[mid] != x)\n    {\n        if (r <= l || r < 0)\n            return -1;\n\n        if (arr[mid] > x)\n            // If element is smaller than middle\n            r = mid - 1;\n        else\n            // Else element is in right subarray\n            l = mid + 1;\n\n        mid = l + (r - l) / 2;\n    }\n\n    // When element is not present in array\n    return mid;\n}\n\n/** Test implementations */\nvoid test()\n{\n    // give function an array to work with\n    int arr[] = {2, 3, 4, 10, 40};\n    // get size of array\n    int n = sizeof(arr) / sizeof(arr[0]);\n\n    printf(\"Test 1.... \");\n    // set value to look for\n    int x = 10;\n    // set result to what is returned from binarysearch\n    int result = binarysearch1(arr, 0, n - 1, x);\n    assert(result == 3);\n    printf(\"passed recursive... \");\n    result = binarysearch2(arr, 0, n - 1, x);\n    assert(result == 3);\n    printf(\"passed iterative...\\n\");\n\n    printf(\"Test 2.... \");\n    x = 5;\n    // set result to what is returned from binarysearch\n    result = binarysearch1(arr, 0, n - 1, x);\n    assert(result == -1);\n    printf(\"passed recursive... \");\n    result = binarysearch2(arr, 0, n - 1, x);\n    assert(result == -1);\n    printf(\"passed iterative...\\n\");\n}\n\n/** Main function */\nint main(void)\n{\n    test();\n    return 0;\n}\n","index":319},{"title":"Fibonacci Search","category":"searching","id":"fibonacci_search_searching","algorithm":"#include <stdio.h>\n#include <stdlib.h>\n\nint fibMonaccianSearch(int arr[], int x, int n)\n{\n    /* Initialize fibonacci numbers */\n    int fibMMm2 = 0;               // (m-2)'th Fibonacci No.\n    int fibMMm1 = 1;               // (m-1)'th Fibonacci No.\n    int fibM = fibMMm2 + fibMMm1;  // m'th Fibonacci\n\n    /* fibM is going to store the smallest Fibonacci\n       Number greater than or equal to n */\n    while (fibM < n)\n    {\n        fibMMm2 = fibMMm1;\n        fibMMm1 = fibM;\n        fibM = fibMMm2 + fibMMm1;\n    }\n\n    // Marks the eliminated range from front\n    int offset = -1;\n\n    /* while there are elements to be inspected. Note that\n       we compare arr[fibMm2] with x. When fibM becomes 1,\n       fibMm2 becomes 0 */\n    while (fibM > 1)\n    {\n        // Check if fibMm2 is a valid location\n\n        // sets i to the min. of (offset+fibMMm2) and (n-1)\n        int i = ((offset + fibMMm2) < (n - 1)) ? (offset + fibMMm2) : (n - 1);\n\n        /* If x is greater than the value at index fibMm2,\n           cut the subarray array from offset to i */\n        if (arr[i] < x)\n        {\n            fibM = fibMMm1;\n            fibMMm1 = fibMMm2;\n            fibMMm2 = fibM - fibMMm1;\n            offset = i;\n        }\n\n        /* If x is greater than the value at index fibMm2,\n           cut the subarray after i+1  */\n        else if (arr[i] > x)\n        {\n            fibM = fibMMm2;\n            fibMMm1 = fibMMm1 - fibMMm2;\n            fibMMm2 = fibM - fibMMm1;\n        }\n\n        /* element found. return index */\n        else\n            return i;\n    }\n\n    /* comparing the last element with x */\n    if (fibMMm1 && arr[offset + 1] == x)\n        return offset + 1;\n\n    /*element not found. return -1 */\n    return -1;\n}\n\nint main(void)\n{\n    int arr[] = {10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    int x = 85;\n    printf(\"Found at index: %d\", fibMonaccianSearch(arr, x, n));\n    return 0;\n}\n","index":320},{"title":"Interpolation Search","category":"searching","id":"interpolation_search_searching","algorithm":"#include <stdio.h>\n\n/* By comparison, binary search always chooses the middle of the remaining\n * search space, discarding one half or the other, depending on the comparison\n * between the key found at the estimated position and the key sought. The\n * remaining search space is reduced to the part before or after the estimated\n * position. The linear search uses equality only as it compares elements\n * one-by-one from the start, ignoring any sorting. On average the interpolation\n * search makes about log(log(n)) comparisons (if the elements are uniformly\n * distributed), where n is the number of elements to be searched. In the worst\n * case (for instance where the numerical values of the keys increase\n * exponentially) it can make up to O(n) comparisons. In\n * interpolation-sequential search, interpolation is used to find an item near\n * the one being searched for, then linear search is used to find the exact\n * item. */\n\nint interpolationSearch(int arr[], int n, int key)\n{\n    int low = 0, high = n - 1;\n    while (low <= high && key >= arr[low] && key <= arr[high])\n    {\n        /* Calculate the nearest posible position of key */\n        int pos =\n            low + ((key - arr[low]) * (high - low)) / (arr[high] - arr[low]);\n        if (key > arr[pos])\n            low = pos + 1;\n        else if (key < arr[pos])\n            high = pos - 1;\n        else /* Found */\n            return pos;\n    }\n    /* Not found */\n    return -1;\n}\n\nint main()\n{\n    int x;\n    int arr[] = {10, 12, 13, 16, 18, 19, 20, 21, 22, 23, 24, 33, 35, 42, 47};\n    int n = sizeof(arr) / sizeof(arr[0]);\n\n    printf(\"Array: \");\n    for (int i = 0; i < n; i++) printf(\"%d \", arr[i]);\n    printf(\"\\nEnter the number to be searched: \");\n    scanf(\"%d\", &x); /* Element to be searched */\n\n    int index = interpolationSearch(arr, n, x);\n\n    /* If element was found */\n    if (index != -1)\n        printf(\"Element found at position: %d\\n\", index);\n    else\n        printf(\"Element not found.\\n\");\n    return 0;\n}\n","index":321},{"title":"Jump Search","category":"searching","id":"jump_search_searching","algorithm":"/**\n * @file jump_search.c\n * @brief Implementation of [jump\n * search](https://en.wikipedia.org/wiki/Jump_search) algorithm.\n */\n#include <assert.h>\n#include <math.h>\n#include <stdio.h>\n\n/**\n * @brief Macro to return the minimum of two values\n */\n#define min(X, Y) ((X) < (Y) ? (X) : (Y))\n\n/**\n * @brief Implement Jump-search algorithm\n *\n * @param [in] arr Array to search within\n * @param x value to search for\n * @param n length of array\n * @return index where the value was found\n * @return -1 if value not found\n */\nint jump_search(const int *arr, int x, size_t n)\n{\n    int step = floor(sqrt(n));\n    int prev = 0;\n\n    while (arr[min(step, n) - 1] < x)\n    {\n        prev = step;\n        step += floor(sqrt(n));\n        if (prev >= n)\n        {\n            return -1;\n        }\n    }\n\n    while (arr[prev] < x)\n    {\n        prev = prev + 1;\n        if (prev == min(step, n))\n        {\n            return -1;\n        }\n    }\n    if (arr[prev] == x)\n    {\n        return prev;\n    }\n    return -1;\n}\n\n/**\n * @brief Test implementation of the function\n *\n */\nvoid test()\n{\n    int arr[] = {0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610};\n    size_t n = sizeof(arr) / sizeof(int);\n\n    int x = 55;\n    printf(\"Test 1.... \");\n    int index = jump_search(arr, x, n);\n    assert(index == 10);\n    printf(\"passed\\nTest 2.... \");\n    x = 56;\n    index = jump_search(arr, x, n);\n    assert(index == -1);\n    printf(\"passed\\nTest 3.... \");\n    x = 13;\n    index = jump_search(arr, x, n);\n    assert(index == 7);\n    printf(\"passed\\n\");\n}\n\n/**\n * @brief Main function\n */\nint main()\n{\n    test();\n    return 0;\n}\n","index":322},{"title":"Linear Search","category":"searching","id":"linear_search_searching","algorithm":"#include <stdio.h>\n#include <stdlib.h>\n\nint linearsearch(int *arr, int size, int val)\n{\n    int i;\n    for (i = 0; i < size; i++)\n    {\n        if (arr[i] == val)\n            return 1;\n    }\n    return 0;\n}\n\nint main()\n{\n    int n, i, v;\n    printf(\"Enter the size of the array:\\n\");\n    scanf(\"%d\", &n);  // Taking input for the size of Array\n\n    int *a = (int *)malloc(n * sizeof(int));\n    printf(\"Enter the contents for an array of size %d:\\n\", n);\n    for (i = 0; i < n; i++)\n        scanf(\"%d\", &a[i]);  // accepts the values of array elements until the\n                             // loop terminates//\n\n    printf(\"Enter the value to be searched:\\n\");\n    scanf(\"%d\", &v);  // Taking input the value to be searched\n    if (linearsearch(a, n, v))\n        printf(\"Value %d is in the array.\\n\", v);\n    else\n        printf(\"Value %d is not in the array.\\n\", v);\n\n    free(a);\n    return 0;\n}\n","index":323},{"title":"Modified Binary Search","category":"searching","id":"modified_binary_search_searching","algorithm":"/**\n * @file\n * @brief [Modified binary search algorithm](https://arxiv.org/abs/1406.1677)\n */\n#include <stdio.h>\n#include <stdlib.h>\n\n/** This function does Binary search for `x` in `i`-th row from `j_low` to\n * `j_high`.\n * @param mat 2D matrix to search within\n * @param i row to search in\n * @param j_low start column index\n * @param j_high end column index\n * @param x value to search for\n * @return column where `x` was found\n * @return -1 if value not found\n */\nint binarySearch(const int **mat, int i, int j_low, int j_high, int x)\n{\n    while (j_low <= j_high)\n    {\n        int j_mid = (j_low + j_high) / 2;\n\n        // Element found\n        if (mat[i][j_mid] == x)\n        {\n            printf(\"Found at (%d,%d)\\n\", i, j_mid);\n            return j_mid;\n        }\n        else if (mat[i][j_mid] > x)\n            j_high = j_mid - 1;\n        else\n            j_low = j_mid + 1;\n    }\n\n    // element not found\n    printf(\"element not found\\n\");\n    return -1;\n}\n\n/** Function to perform binary search on the mid values of row to get the\n * desired pair of rows where the element can be found\n * @param [in] mat matrix to search for the value in\n * @param n number of rows in the matrix\n * @param m number of columns in the matrix\n * @param x value to search for\n */\nvoid modifiedBinarySearch(const int **mat, int n, int m, int x)\n{  // If Single row matrix\n    if (n == 1)\n    {\n        binarySearch(mat, 0, 0, m - 1, x);\n        return;\n    }\n\n    // Do binary search in middle column.\n    // Condition to terminate the loop when the 2 desired rows are found.\n    int i_low = 0, i_high = n - 1, j_mid = m / 2;\n    while ((i_low + 1) < i_high)\n    {\n        int i_mid = (i_low + i_high) / 2;\n        // element found\n        if (mat[i_mid][j_mid] == x)\n        {\n            printf(\"Found at (%d,%d)\\n\", i_mid, j_mid);\n            return;\n        }\n        else if (mat[i_mid][j_mid] > x)\n            i_high = i_mid;\n        else\n            i_low = i_mid;\n    }\n    // If element is present on the mid of the two rows\n    if (mat[i_low][j_mid] == x)\n        printf(\"Found at (%d,%d)\\n\", i_low, j_mid);\n    else if (mat[i_low + 1][j_mid] == x)\n        printf(\"Found at (%d,%d)\\n\", i_low + 1, j_mid);\n\n    // Search element on 1st half of 1st row\n    else if (x <= mat[i_low][j_mid - 1])\n        binarySearch(mat, i_low, 0, j_mid - 1, x);\n\n    // Search element on 2nd half of 1st row\n    else if (x >= mat[i_low][j_mid + 1] && x <= mat[i_low][m - 1])\n        binarySearch(mat, i_low, j_mid + 1, m - 1, x);\n\n    // Search element on 1st half of 2nd row\n    else if (x <= mat[i_low + 1][j_mid - 1])\n        binarySearch(mat, i_low + 1, 0, j_mid - 1, x);\n\n    // search element on 2nd half of 2nd row\n    else\n        binarySearch(mat, i_low + 1, j_mid + 1, m - 1, x);\n}\n\n/** Main function */\nint main()\n{\n    int x;     // element to be searched\n    int m, n;  // m = columns, n = rows\n\n    scanf(\"%d %d %d\\n\", &n, &m, &x);\n\n    int **mat = (int **)malloc(n * sizeof(int *));\n    for (int i = 0; i < m; i++) mat[i] = (int *)malloc(m * sizeof(int));\n\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < m; j++)\n        {\n            scanf(\"%d\", &mat[i][j]);\n        }\n    }\n\n    modifiedBinarySearch(mat, n, m, x);\n\n    for (int i = 0; i < n; i++) free(mat[i]);\n    free(mat);\n    return 0;\n}\n","index":324},{"title":"Other Binary Search","category":"searching","id":"other_binary_search_searching","algorithm":"#include <stdio.h>\n#include <stdlib.h>\n#define len 5\n\nint binarySearch(int array[], int leng, int searchX)\n{\n    int pos = -1, right, left, i = 0;\n\n    left = 0;\n    right = leng - 1;\n\n    while (left <= right)\n    {\n        pos = left + (right - left) / 2;\n        if (array[pos] == searchX)\n        {\n            return pos;\n        }\n        else if (array[pos] > searchX)\n        {\n            right = pos - 1;\n        }\n        else\n        {\n            left = pos + 1;\n        }\n    }\n    return -1; /* not found */\n}\n\nint main(int argc, char *argv[])\n{\n    int array[len] = {5, 8, 10, 14, 16};\n\n    int position;\n    position = binarySearch(array, len, 5);\n\n    if (position < 0)\n        printf(\"The number %d doesnt exist in array\\n\", 5);\n    else\n    {\n        printf(\"The number %d exist in array at position : %d \\n\", 5, position);\n    }\n\n    return 0;\n}\n","index":325},{"title":"Pattern Search","category":"searching","id":"pattern_search","index":326},{"title":"Boyer Moore Search","category":"pattern_search","id":"boyer_moore_search_pattern_search","algorithm":"#include <stdio.h>\n#include <string.h>\n\n#define NUM_OF_CHARS 256\n\nint max(int a, int b) { return (a > b) ? a : b; }\n\nvoid computeArray(char *pattern, int size, int arr[NUM_OF_CHARS])\n{\n    int i;\n\n    for (i = 0; i < NUM_OF_CHARS; i++) arr[i] = -1;\n    /* Fill the actual value of last occurrence of a character */\n    for (i = 0; i < size; i++) arr[(int)pattern[i]] = i;\n}\n/* Boyer Moore Search algorithm  */\nvoid boyer_moore_search(char *str, char *pattern)\n{\n    int n = strlen(str);\n    int m = strlen(pattern);\n    int shift = 0;\n    int arr[NUM_OF_CHARS];\n\n    computeArray(pattern, m, arr);\n    while (shift <= (n - m))\n    {\n        int j = m - 1;\n        while (j >= 0 && pattern[j] == str[shift + j]) j--;\n        if (j < 0)\n        {\n            printf(\"--Pattern is found at: %d\\n\", shift);\n            shift += (shift + m < n) ? m - arr[str[shift + m]] : 1;\n        }\n        else\n        {\n            shift += max(1, j - arr[str[shift + j]]);\n        }\n    }\n}\n\nint main()\n{\n    char str[] = \"AABCAB12AFAABCABFFEGABCAB\";\n    char pat1[] = \"ABCAB\";\n    char pat2[] = \"FFF\"; /* not found */\n    char pat3[] = \"CAB\";\n\n    printf(\"String test: %s\\n\", str);\n    printf(\"Test1: search pattern %s\\n\", pat1);\n    boyer_moore_search(str, pat1);\n    printf(\"Test2: search pattern %s\\n\", pat2);\n    boyer_moore_search(str, pat2);\n    printf(\"Test3: search pattern %s\\n\", pat3);\n    boyer_moore_search(str, pat3);\n    return 0;\n}\n","index":327},{"title":"Naive Search","category":"pattern_search","id":"naive_search_pattern_search","algorithm":"#include <stdio.h>\n#include <string.h>\n\n/* Naive Pattern Search algorithm (brute force way) */\nvoid naive_search(char *str, char *pattern)\n{\n    int len_str = strlen(str);\n    int len_pat = strlen(pattern);\n\n    for (int i = 0; i <= len_str - len_pat; i++)\n    {\n        int j;\n        for (j = 0; j < len_pat; j++)\n        {\n            if (str[i + j] != pattern[j])\n                break;\n        }\n        if (j == len_pat)\n            printf(\"--Pattern is found at: %d\\n\", i);\n    }\n}\n\nint main()\n{\n    char str[] = \"AABCAB12AFAABCABFFEGABCAB\";\n    char pat1[] = \"ABCAB\";\n    char pat2[] = \"FFF\"; /* not found */\n    char pat3[] = \"CAB\";\n\n    printf(\"String test: %s\\n\", str);\n    printf(\"Test1: search pattern %s\\n\", pat1);\n    naive_search(str, pat1);\n    printf(\"Test2: search pattern %s\\n\", pat2);\n    naive_search(str, pat2);\n    printf(\"Test3: search pattern %s\\n\", pat3);\n    naive_search(str, pat3);\n    return 0;\n}\n","index":328},{"title":"Rabin Karp Search","category":"pattern_search","id":"rabin_karp_search_pattern_search","algorithm":"#include <stdio.h>\n#include <string.h>\n\n/* Kabin-Karp algorithm for pattern searching\n   d: radix-d notation. Ex. number from 0->9, d = 10\n   q: prime number for hashing */\nvoid rabin_karp_search(char *str, char *pattern, int d, int q)\n{\n    int len_str = strlen(str);\n    int len_pat = strlen(pattern);\n    int i, h = 1;\n    int hash_s = 0; /* hash value for string text */\n    int hash_p = 0; /* hash value for pattern */\n\n    /* h = pow(d, len_pat - 1) % q */\n    for (i = 0; i < len_pat - 1; i++) h = d * h % q;\n    /* Calculating hashing of pattern and the 1st window of text */\n    for (i = 0; i < len_pat; i++)\n    {\n        hash_p = (d * hash_p + pattern[i]) % q;\n        hash_s = (d * hash_s + str[i]) % q;\n    }\n\n    for (i = 0; i <= len_str - len_pat; i++)\n    {\n        /* Check hash value of current window of text, and pattern\n           If it is match, check each character to make sure pattern\n           is match with current window of text */\n        if (hash_p == hash_s)\n        {\n            int j;\n            for (j = 0; j < len_pat; j++)\n            {\n                if (pattern[j] != str[i + j])\n                    break;\n            }\n            if (len_pat == j)\n                printf(\"--Pattern is found at: %d\\n\", i);\n        }\n        /* Calculate hash value for next window by removing the leading\n           element of current window text, and adding its trailing */\n        hash_s = (d * (hash_s - str[i] * h) + str[i + len_pat]) % q;\n        /* Converting hash value to positive when it is negative */\n        if (hash_s < 0)\n            hash_s = hash_s + q;\n    }\n}\n\nint main()\n{\n    char str[] = \"AABCAB12AFAABCABFFEGABCAB\";\n    char pat1[] = \"ABCAB\";\n    char pat2[] = \"FFF\"; /* not found */\n    char pat3[] = \"CAB\";\n\n    printf(\"String test: %s\\n\", str);\n    printf(\"Test1: search pattern %s\\n\", pat1);\n    rabin_karp_search(str, pat1, 256, 29);\n    printf(\"Test2: search pattern %s\\n\", pat2);\n    rabin_karp_search(str, pat2, 256, 29);\n    printf(\"Test3: search pattern %s\\n\", pat3);\n    rabin_karp_search(str, pat3, 256, 29);\n    return 0;\n}\n","index":329},{"title":"Ternary Search","category":"searching","id":"ternary_search_searching","algorithm":"\n#include <stdio.h>\n\n// Function to perform Ternary Search\nint ternarySearch(int l, int r, int key, int ar[])\n{\n    if (r >= l)\n    {\n        // Find the mid1 and mid2\n        int mid1 = l + (r - l) / 3;\n        int mid2 = r - (r - l) / 3;\n\n        // Check if key is present at any mid\n        if (ar[mid1] == key)\n        {\n            return mid1;\n        }\n        if (ar[mid2] == key)\n        {\n            return mid2;\n        }\n\n        // Since key is not present at mid,\n        // check in which region it is present\n        // then repeat the Search operation\n        // in that region\n\n        if (key < ar[mid1])\n        {\n            // The key lies in between l and mid1\n            return ternarySearch(l, mid1 - 1, key, ar);\n        }\n        else if (key > ar[mid2])\n        {\n            // The key lies in between mid2 and r\n            return ternarySearch(mid2 + 1, r, key, ar);\n        }\n        else\n        {\n            // The key lies in between mid1 and mid2\n            return ternarySearch(mid1 + 1, mid2 - 1, key, ar);\n        }\n    }\n\n    // Key not found\n    return -1;\n}\n\n// Driver code\nint main()\n{\n    int l, r, p, key;\n\n    // Get the array\n    // Sort the array if not sorted\n    int ar[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\n    // Starting index\n    l = 0;\n\n    // length of array\n    r = 9;\n\n    // Checking for 5\n\n    // Key to be searched in the array\n    key = 5;\n\n    // Search the key using ternarySearch\n    p = ternarySearch(l, r, key, ar);\n\n    // Print the result\n    printf(\"Index of %d is %d\\n\", key, p);\n\n    // Checking for 50\n\n    // Key to be searched in the array\n    key = 50;\n\n    // Search the key using ternarySearch\n    p = ternarySearch(l, r, key, ar);\n\n    // Print the result\n    printf(\"Index of %d is %d\", key, p);\n}","index":330},{"title":"Sorting","category":null,"id":"sorting","index":331},{"title":"Bead Sort","category":"sorting","id":"bead_sort_sorting","algorithm":"/**\n * @file\n * @brief Sorting of array list using [bead\n * sort](https://en.wikipedia.org/wiki/Bead_sort)\n */\n#include <stdio.h>\n#include <stdlib.h>\n\n/**\n * @addtogroup sorting Sorting algorithms\n * @{\n */\n/** Create easy access of elements from a 2D matrix stored in memory as a 1D\n * array\n */\n#define BEAD(i, j) beads[i * max + j]\n\n/**\n * Displays the array, passed to this method\n * @param [in] arr array to display\n * @param [in] n number of elements in the array\n */\nvoid display(const int *arr, int n)\n{\n    for (int i = 0; i < n; i++)\n    {\n        printf(\"%d \", arr[i]);\n    }\n\n    printf(\"\\n\");\n}\n\n/** This is where the sorting of the array takes place\n * @param [in,out] a array to be sorted\n * @param [in] len Array Size\n */\nvoid bead_sort(int *a, size_t len)\n{\n    int i, j, max, sum;\n    unsigned char *beads;\n\n    for (i = 1, max = a[0]; i < len; i++)\n        if (a[i] > max)\n            max = a[i];\n\n    beads = calloc(1, max * len);\n\n    /* mark the beads */\n    for (i = 0; i < len; i++)\n        for (j = 0; j < a[i]; j++) BEAD(i, j) = 1;\n\n    for (j = 0; j < max; j++)\n    {\n        /* count how many beads are on each post */\n        for (sum = i = 0; i < len; i++)\n        {\n            sum += BEAD(i, j);\n            BEAD(i, j) = 0;\n        }\n        /* mark bottom sum beads */\n        for (i = len - sum; i < len; i++) BEAD(i, j) = 1;\n    }\n\n    for (i = 0; i < len; i++)\n    {\n        for (j = 0; j < max && BEAD(i, j); j++)\n            ;\n        a[i] = j;\n    }\n    free(beads);\n}\n/** @} */\n\n/** Main function */\nint main(int argc, const char *argv[])\n{\n    int n;\n    printf(\"Enter size of array:\\n\");\n    scanf(\"%d\", &n);  // E.g. 8 1 2 3\n\n    printf(\"Enter the elements of the array\\n\");\n    int i;\n    int *arr = (int *)malloc(n * sizeof(int));\n    for (i = 0; i < n; i++)\n    {\n        scanf(\"%d\", &arr[i]);\n    }\n\n    printf(\"Original array: \");\n    display(arr, n);\n\n    bead_sort(arr, n);\n\n    printf(\"Sorted array: \");\n    display(arr, n);\n\n    free(arr);\n    return 0;\n}\n","index":332},{"title":"Binary Insertion Sort","category":"sorting","id":"binary_insertion_sort_sorting","algorithm":"/* Sorting of array list using binary insertion sort\n * Using binary search to find the proper location for\n * inserting the selected item at each iteration. */\n#include <stdio.h>\n#include <stdlib.h>\n\n/*Displays the array, passed to this method*/\nvoid display(int *arr, int n)\n{\n    int i;\n    for (i = 0; i < n; i++)\n    {\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"\\n\");\n}\n\nint binarySearch(int *arr, int key, int low, int high)\n{\n    if (low >= high)\n        return (key > arr[low]) ? (low + 1) : low;\n    int mid = low + (high - 1) / 2;\n    if (arr[mid] == key)\n        return mid + 1;\n    else if (arr[mid] > key)\n        return binarySearch(arr, key, low, mid - 1);\n    else\n        return binarySearch(arr, key, mid + 1, high);\n}\n/*This is where the sorting of the array takes place\n arr[] --- Array to be sorted\n size --- Array Size\n */\nvoid insertionSort(int *arr, int size)\n{\n    int i, j, key, index;\n    for (i = 0; i < size; i++)\n    {\n        j = i - 1;\n        key = arr[i];\n        /* Use binrary search to find exact key's index */\n        index = binarySearch(arr, key, 0, j);\n        /* Move all elements greater than key from [index...j]\n         * to one position */\n        while (j >= index)\n        {\n            arr[j + 1] = arr[j];\n            j = j - 1;\n        }\n        /* Insert key value in right place */\n        arr[j + 1] = key;\n    }\n}\n\nint main(int argc, const char *argv[])\n{\n    int n;\n    printf(\"Enter size of array:\\n\");\n    scanf(\"%d\", &n);  // E.g. 8\n\n    printf(\"Enter the elements of the array\\n\");\n    int i;\n    int *arr = (int *)malloc(n * sizeof(int));\n    for (i = 0; i < n; i++)\n    {\n        scanf(\"%d\", &arr[i]);\n    }\n\n    printf(\"Original array: \");\n    display(arr, n);\n\n    insertionSort(arr, n);\n\n    printf(\"Sorted array: \");\n    display(arr, n);\n\n    free(arr);\n    return 0;\n}\n","index":333},{"title":"Bogo Sort","category":"sorting","id":"bogo_sort_sorting","algorithm":"#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nbool check_sorted(int *a, int n)\n{\n    while (--n >= 1)\n    {\n        if (a[n] < a[n - 1])\n            return false;\n    }\n    return true;\n}\n\nvoid shuffle(int *a, int n)\n{\n    int i, t, r;\n    for (i = 0; i < n; i++)\n    {\n        t = a[i];\n        r = rand() % n;\n        a[i] = a[r];\n        a[r] = t;\n    }\n}\n\nvoid sort(int *a, int n)\n{\n    while (!check_sorted(a, n)) shuffle(a, n);\n}\n\nint main()\n{\n    int numbers[6];\n    int i;\n    printf(\"Enter 6 numbers unsorted \\n\\n\");\n    for (i = 0; i < 6; i++)\n    {\n        scanf(\"%d\", &numbers[i]);\n    }\n    sort(numbers, 6);\n    for (i = 0; i < 6; i++) printf(\"%d \", numbers[i]);\n    printf(\"\\n\");\n}\n","index":334},{"title":"Bubble Sort","category":"sorting","id":"bubble_sort_sorting","algorithm":"/**\n * @file\n * @brief [Bubble sort](https://en.wikipedia.org/wiki/Bubble_sort) algorithm\n * implementation\n */\n#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n/**\n * Display elements of array\n * @param arr array to be display\n * @param n length of array\n */\nvoid display(const int *arr, int n)\n{\n    for (int i = 0; i < n; i++)\n    {\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"\\n\");\n}\n\n/**\n * Swap two values by using pointer\n * @param first first pointer of first number\n * @param second second pointer of second number\n */\nvoid swap(int *first, int *second)\n{\n    int temp = *first;\n    *first = *second;\n    *second = temp;\n}\n\n/**\n * Bubble sort algorithm implementation\n * @param arr array to be sorted\n * @param size size of array\n */\nvoid bubbleSort(int *arr, int size)\n{\n    for (int i = 0; i < size - 1; i++)\n    {                         /* for each array index */\n        bool swapped = false; /* flag to check if any changes had to be made */\n        /* perform iterations until no more changes were made or outer loop\n            executed for all array indices */\n        for (int j = 0; j < size - 1 - i; j++)\n        { /* for each element in the array */\n            if (arr[j] > arr[j + 1])\n            { /* if the order of successive elements needs update */\n                swap(&arr[j], &arr[j + 1]);\n                swapped = true; /* set flag */\n            }\n        }\n        if (!swapped)\n        {\n            /* since no more updates we made, the array is already sorted\n                this is an optimization for early termination */\n            break;\n        }\n    }\n}\n\n/**\n * Test function\n */\nvoid test()\n{\n    const int size = 10;\n    int *arr = (int *)calloc(size, sizeof(int));\n\n    /* generate size random numbers from 0 to 100 */\n    for (int i = 0; i < size; i++)\n    {\n        arr[i] = rand() % 100;\n    }\n    bubbleSort(arr, size);\n    for (int i = 0; i < size - 1; ++i)\n    {\n        assert(arr[i] <= arr[i + 1]);\n    }\n    free(arr);\n}\n\n/** Driver Code */\nint main(int argc, const char *argv[])\n{\n    /* Intializes random number generator */\n    srand(time(NULL));\n    test();\n    return 0;\n}\n","index":335},{"title":"Bubble Sort 2","category":"sorting","id":"bubble_sort_2_sorting","algorithm":"#include <stdio.h>\n#include <stdlib.h>\n#define MAX 20\n#define TRUE 1\n#define FALSE 0\n\nint main()\n{\n    int i, arraySort[MAX] = {0}, isSort = FALSE, changePlace;\n\n    /* For example\n    Insertion random values in array to test\n    */\n\n    for (i = 0; i < MAX; i++)\n    {\n        arraySort[i] = rand() % 101;\n    }\n\n    /* Algorithm of bubble methods */\n\n    while (isSort)\n    {\n        isSort = FALSE;\n\n        for (i = 0; i < MAX - 1; i++)\n        {\n            if (arraySort[i] > arraySort[i + 1])\n            {\n                changePlace = arraySort[i];\n                arraySort[i] = arraySort[i + 1];\n                arraySort[i + 1] = changePlace;\n                isSort = TRUE;\n            }\n        }\n    }\n\n    /* See if it works */\n\n    for (i = 0; i < MAX; i++)\n    {\n        printf(\"%d\\n\", arraySort[i]);\n    }\n\n    return EXIT_SUCCESS;\n}\n","index":336},{"title":"Bubble Sort Recursion","category":"sorting","id":"bubble_sort_recursion_sorting","algorithm":"/**\n * @file\n * @brief [Bubble sort](https://en.wikipedia.org/wiki/Bubble_sort) algorithm\n * implementation using recursion.\n */\n#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n/**\n * Swapped two numbers using pointer\n * @param first first pointer of first number\n * @param second second pointer of second number\n */\nvoid swap(int *first, int *second)\n{\n    int temp = *first;\n    *first = *second;\n    *second = temp;\n}\n\n/**\n * Bubble sort algorithm implements using recursion\n * @param arr array to be sorted\n * @param size size of array\n */\nvoid bubbleSort(int *arr, int size)\n{\n    if (size == 1)\n    {\n        return;\n    }\n    bool swapped = false;\n    for (int i = 0; i < size - 1; ++i)\n    {\n        if (arr[i] > arr[i + 1])\n        {\n            swap(arr + i, arr + i + 1);\n            swapped = true;\n        }\n    }\n    if (swapped)\n    {\n        bubbleSort(arr, size - 1);\n    }\n}\n\n/**\n * Test function\n */\nvoid test()\n{\n    const int size = 10;\n    int *arr = (int *)calloc(size, sizeof(int));\n\n    /* generate size random numbers from 0 to 100 */\n    for (int i = 0; i < size; i++)\n    {\n        arr[i] = rand() % 100;\n    }\n    bubbleSort(arr, size);\n    for (int i = 0; i < size - 1; ++i)\n    {\n        assert(arr[i] <= arr[i + 1]);\n    }\n    free(arr);\n}\n\n/** Driver Code */\nint main()\n{\n    /* Intializes random number generator */\n    srand(time(NULL));\n    test();\n    return 0;\n}\n","index":337},{"title":"Bucket Sort","category":"sorting","id":"bucket_sort_sorting","algorithm":"/*\n * Algorithm : Bucket Sort\n * Time-Complexity : O(n)\n */\n#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define NARRAY 8    /* array size */\n#define NBUCKET 5   /* bucket size */\n#define INTERVAL 10 /* bucket range */\n\nstruct Node\n{\n    int data;\n    struct Node *next;\n};\n\nvoid BucketSort(int arr[]);\nstruct Node *InsertionSort(struct Node *list);\nvoid print(int arr[]);\nvoid printBuckets(struct Node *list);\nint getBucketIndex(int value);\n\nvoid BucketSort(int arr[])\n{\n    int i, j;\n    struct Node **buckets;\n\n    /* allocate memory for array of pointers to the buckets */\n    buckets = (struct Node **)malloc(sizeof(struct Node *) * NBUCKET);\n\n    /* initialize pointers to the buckets */\n    for (i = 0; i < NBUCKET; ++i)\n    {\n        buckets[i] = NULL;\n    }\n\n    /* put items into the buckets */\n    /* creates a link list in each bucket slot */\n    for (i = 0; i < NARRAY; ++i)\n    {\n        struct Node *current;\n        int pos = getBucketIndex(arr[i]);\n        current = (struct Node *)malloc(sizeof(struct Node));\n        current->data = arr[i];\n        current->next = buckets[pos];\n        buckets[pos] = current;\n    }\n\n    /* check what's in each bucket */\n    for (i = 0; i < NBUCKET; i++)\n    {\n        printf(\"Bucket[\\\"%d\\\"] : \", i);\n        printBuckets(buckets[i]);\n        printf(\"\\n\");\n    }\n\n    /* sorting bucket using Insertion Sort */\n    for (i = 0; i < NBUCKET; ++i)\n    {\n        buckets[i] = InsertionSort(buckets[i]);\n    }\n\n    /* check what's in each bucket */\n    printf(\"--------------\\n\");\n    printf(\"Buckets after sorted\\n\");\n    for (i = 0; i < NBUCKET; i++)\n    {\n        printf(\"Bucket[\\\"%d\\\"] : \", i);\n        printBuckets(buckets[i]);\n        printf(\"\\n\");\n    }\n\n    /* put items back to original array */\n    for (j = 0, i = 0; i < NBUCKET; ++i)\n    {\n        struct Node *node;\n        node = buckets[i];\n        while (node)\n        {\n            // precondition for avoiding out of bounds by the array\n            assert(j < NARRAY);\n            arr[j++] = node->data;\n            node = node->next;\n        }\n    }\n\n    /* free memory */\n    for (i = 0; i < NBUCKET; ++i)\n    {\n        struct Node *node;\n        node = buckets[i];\n        while (node)\n        {\n            struct Node *tmp;\n            tmp = node;\n            node = node->next;\n            free(tmp);\n        }\n    }\n    free(buckets);\n    return;\n}\n\n/* Insertion Sort */\nstruct Node *InsertionSort(struct Node *list)\n{\n    struct Node *k, *nodeList;\n    /* need at least two items to sort */\n    if (list == NULL || list->next == NULL)\n    {\n        return list;\n    }\n\n    nodeList = list;\n    k = list->next;\n    nodeList->next = NULL; /* 1st node is new list */\n    while (k != NULL)\n    {\n        struct Node *ptr;\n        /* check if insert before first */\n        if (nodeList->data > k->data)\n        {\n            struct Node *tmp;\n            tmp = k;\n            k = k->next;  // important for the while\n            tmp->next = nodeList;\n            nodeList = tmp;\n            continue;\n        }\n\n        // from begin up to end\n        // finds [i] > [i+1]\n        for (ptr = nodeList; ptr->next != NULL; ptr = ptr->next)\n        {\n            if (ptr->next->data > k->data)\n                break;\n        }\n\n        // if found (above)\n        if (ptr->next != NULL)\n        {\n            struct Node *tmp;\n            tmp = k;\n            k = k->next;  // important for the while\n            tmp->next = ptr->next;\n            ptr->next = tmp;\n            continue;\n        }\n        else\n        {\n            ptr->next = k;\n            k = k->next;  // important for the while\n            ptr->next->next = NULL;\n            continue;\n        }\n    }\n    return nodeList;\n}\n\nint getBucketIndex(int value) { return value / INTERVAL; }\n\nvoid print(int ar[])\n{\n    int i;\n    for (i = 0; i < NARRAY; ++i)\n    {\n        printf(\"%d \", ar[i]);\n    }\n    printf(\"\\n\");\n}\n\nvoid printBuckets(struct Node *list)\n{\n    struct Node *cur = list;\n    while (cur)\n    {\n        printf(\"%d \", cur->data);\n        cur = cur->next;\n    }\n}\n\nint main(void)\n{\n    int array[NARRAY] = {29, 25, -1, 49, 9, 37, 21, 43};\n\n    printf(\"Initial array\\n\");\n    print(array);\n    printf(\"------------\\n\");\n\n    BucketSort(array);\n    printf(\"------------\\n\");\n    printf(\"Sorted array\\n\");\n    print(array);\n    return 0;\n}\n","index":338},{"title":"Cocktail Sort","category":"sorting","id":"cocktail_sort_sorting","algorithm":"#include <stdio.h>\n#include <stdlib.h>\n\n#define TRUE 1\n#define FALSE 0\n\nvoid cocktailSort(int arr[], int size)\n{\n    int i, changed = TRUE, temp, start = 0, end = size - 1;\n\n    while (changed)\n    {\n        changed = FALSE;\n        for (i = start; i < end; i++)\n        {\n            if (arr[i] > arr[i + 1])\n            {\n                temp = arr[i];\n                arr[i] = arr[i + 1];\n                arr[i + 1] = temp;\n                changed = TRUE;\n            }\n        }\n        end--;\n\n        if (changed == FALSE)\n        {\n            break;\n        }\n        changed = FALSE;\n\n        for (i = end - 1; i >= start; i--)\n        {\n            if (arr[i + 1] < arr[i])\n            {\n                temp = arr[i + 1];\n                arr[i + 1] = arr[i];\n                arr[i] = temp;\n                changed = TRUE;\n            }\n        }\n        start++;\n    }\n}\n\nint main()\n{\n    int i, n;\n\n    printf(\"Enter the size of the array: \");\n    scanf(\"%d\", &n);\n    int *arr = (int *)malloc(sizeof(int) * n);\n\n    for (i = 0; i < n; i++)\n    {\n        printf(\"Number #%d: \", i + 1);\n        scanf(\"%d\", &arr[i]);\n    }\n\n    printf(\"You entered:  \");\n    for (i = 0; i < n; i++)\n    {\n        printf(\"%d \", arr[i]);\n    }\n    cocktailSort(arr, n);\n    printf(\"\\nSorted array: \");\n    for (i = 0; i < n; i++)\n    {\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"\\n\");\n\n    free(arr);\n    return 0;\n}","index":339},{"title":"Comb Sort","category":"sorting","id":"comb_sort_sorting","algorithm":"#include <stdio.h>\n#include <stdlib.h>\n#define SHRINK 1.3  // suggested shrink factor value\n\nvoid sort(int *numbers, int size)\n{\n    int gap = size;\n    while (gap > 1)  // gap = 1 means that the array is sorted\n    {\n        gap = gap / SHRINK;\n        int i = 0;\n        while ((i + gap) < size)\n        {  // similiar to the Shell Sort\n            if (numbers[i] > numbers[i + gap])\n            {\n                int tmp = numbers[i];\n                numbers[i] = numbers[i + gap];\n                numbers[i + gap] = tmp;\n            }\n            i++;\n        }\n    }\n}\n\nvoid display(int *array, int n)\n{\n    int i;\n    for (i = 0; i < n; ++i) printf(\"%d \", array[i]);\n    printf(\"\\n\");\n}\n\nint main()\n{\n    int size = 6;\n    int *numbers = malloc(size * sizeof(int));\n    printf(\"Insert %d unsorted numbers: \\n\", size);\n    int i;\n    for (i = 0; i < size; ++i) scanf(\"%d\", &numbers[i]);\n    printf(\"Initial array: \");\n    display(numbers, size);\n    sort(numbers, size);\n    printf(\"Sorted array: \");\n    display(numbers, size);\n    free(numbers);\n    return 0;\n}\n","index":340},{"title":"Counting Sort","category":"sorting","id":"counting_sort_sorting","algorithm":"/*\n  > Counting sort is a sorting technique based on keys between a specific range.\n  > integer sorting algorithm\n  > Worst-case performance O(n+k)\n  > Stabilized by prefix sum array\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main()\n{\n    int i, n, l = 0;\n\n    printf(\"Enter size of array = \");\n    scanf(\"%d\", &n);\n\n    int *a = (int *)malloc(n * sizeof(int));\n    printf(\"Enter %d elements in array :\\n\", n);\n    for (i = 0; i < n; i++)\n    {\n        scanf(\"%d\", &a[i]);\n        if (a[i] > l)\n            l = a[i];\n    }\n\n    int *b = (int *)malloc((l + 1) * sizeof(int));\n    memset(b, 0, (l + 1) * sizeof(b[0]));\n\n    for (i = 0; i < n; i++) b[a[i]]++;  // hashing number to array index\n\n    for (i = 0; i < (l + 1); i++)  // unstable , stabilized by prefix sum array\n    {\n        if (b[i] > 0)\n        {\n            while (b[i] != 0)  // for case when number exists more than once\n            {\n                printf(\"%d \", i);\n                b[i]--;\n            }\n        }\n    }\n\n    free(a);\n    free(b);\n    return 0;\n}\n","index":341},{"title":"Cycle Sort","category":"sorting","id":"cycle_sort_sorting","algorithm":"// Sorting of array list using cycle sort\n#include <stdio.h>\n#include <stdlib.h>\n\n// Displays the array, passed to this method\nvoid display(int *arr, int n)\n{\n    int i;\n    for (i = 0; i < n; i++)\n    {\n        printf(\"%d \", arr[i]);\n    }\n\n    printf(\"\\n\");\n}\n\n// Swap function to swap two values\nvoid swap(int *first, int *second)\n{\n    int temp = *first;\n    *first = *second;\n    *second = temp;\n}\n\n// Function sort the array using Cycle sort\nvoid cycleSort(int *arr, int n)\n{\n    // count number of memory writes\n    int writes = 0;\n\n    // traverse array elements and put it to on\n    // the right place\n    for (int cycle_start = 0; cycle_start <= n - 2; cycle_start++)\n    {\n        // initialize item as starting point\n        int item = arr[cycle_start];\n\n        // Find position where we put the item. We basically\n        // count all smaller elements on right side of item.\n        int pos = cycle_start;\n        for (int i = cycle_start + 1; i < n; i++)\n            if (arr[i] < item)\n                pos++;\n\n        // If item is already in correct position\n        if (pos == cycle_start)\n            continue;\n\n        // ignore all duplicate elements\n        while (item == arr[pos]) pos += 1;\n\n        // put the item to it's right position\n        if (pos != cycle_start)\n        {\n            swap(&item, &arr[pos]);\n            writes++;\n        }\n\n        // Rotate rest of the cycle\n        while (pos != cycle_start)\n        {\n            pos = cycle_start;\n\n            // Find position where we put the element\n            for (int i = cycle_start + 1; i < n; i++)\n                if (arr[i] < item)\n                    pos += 1;\n\n            // ignore all duplicate elements\n            while (item == arr[pos]) pos += 1;\n\n            // put the item to it's right position\n            if (item != arr[pos])\n            {\n                swap(&item, &arr[pos]);\n                writes++;\n            }\n        }\n    }\n}\n\n// Driver program to test above function\nint main()\n{\n    int n;  // Size of array elements\n\n    printf(\"Enter size of array:\\n\");\n    scanf(\"%d\", &n);  // E.g. 8\n\n    printf(\"Enter the elements of the array\\n\");\n    int i;\n    int *arr = (int *)malloc(n * sizeof(int));\n    for (i = 0; i < n; i++)\n    {\n        scanf(\"%d\", &arr[i]);\n    }\n\n    printf(\"Original array: \");\n    display(arr, n);\n\n    cycleSort(arr, n);\n    printf(\"Sorted array: \");\n    display(arr, n);\n\n    free(arr);\n    return 0;\n}\n","index":342},{"title":"Gnome Sort","category":"sorting","id":"gnome_sort_sorting","algorithm":"#include <stdio.h>\n#include <stdlib.h>\n\nvoid sort(int *numbers, int size)\n{\n    int pos = 0;\n    while (pos < size)\n    {\n        if (numbers[pos] >= numbers[pos - 1])\n            pos++;\n        else\n        {\n            int tmp = numbers[pos - 1];\n            numbers[pos - 1] = numbers[pos];\n            numbers[pos] = tmp;\n            pos--;\n\n            if (pos == 0)\n                pos = 1;\n        }\n    }\n}\n\nvoid display(int *array, int n)\n{\n    int i;\n    for (i = 0; i < n; ++i) printf(\"%d \", array[i]);\n    printf(\"\\n\");\n}\n\nint main()\n{\n    int size = 6;\n    int i;\n    int *numbers = malloc(size * sizeof(int));\n    printf(\"Insert %d unsorted numbers: \\n\", size);\n    for (i = 0; i < size; ++i) scanf(\"%d\", &numbers[i]);\n    printf(\"Initial array: \");\n    display(numbers, size);\n    sort(numbers, size);\n    printf(\"Sorted array: \");\n    display(numbers, size);\n    free(numbers);\n    return 0;\n}\n","index":343},{"title":"Heap Sort","category":"sorting","id":"heap_sort_sorting","algorithm":"#include <stdio.h>\n\nvoid max_heapify(int *a, int i, int n);\nvoid heapsort(int *a, int n);\nvoid build_maxheap(int *a, int n);\n\nvoid max_heapify(int *a, int i, int n)\n{\n    int j, temp;\n    temp = a[i];\n    j = 2 * i;\n    while (j <= n)\n    {\n        if (j < n && a[j + 1] > a[j])\n            j = j + 1;\n        if (temp > a[j])\n        {\n            break;\n        }\n        else if (temp <= a[j])\n        {\n            a[j / 2] = a[j];\n            j = 2 * j;\n        }\n    }\n    a[j / 2] = temp;\n    return;\n}\n\nvoid heapsort(int *a, int n)\n{\n    int i, temp;\n    for (i = n; i >= 2; i--)\n    {\n        temp = a[i];\n        a[i] = a[1];\n        a[1] = temp;\n        max_heapify(a, 1, i - 1);\n    }\n}\n\nvoid build_maxheap(int *a, int n)\n{\n    int i;\n    for (i = n / 2; i >= 1; i--)\n    {\n        max_heapify(a, i, n);\n    }\n}\n\nint main()\n{\n    int n, i;\n    printf(\"Enter number of elements of array\\n\");\n    scanf(\"%d\", &n);\n    int a[20];\n    for (i = 1; i <= n; i++)\n    {\n        printf(\"Enter Element %d\\n\", i);\n        scanf(\"%d\", a + i);\n    }\n\n    build_maxheap(a, n);\n    heapsort(a, n);\n    printf(\"Sorted Output\\n\");\n    for (i = 1; i <= n; i++)\n    {\n        printf(\"%d\\n\", a[i]);\n    }\n\n    getchar();\n}\n","index":344},{"title":"Insertion Sort","category":"sorting","id":"insertion_sort_sorting","algorithm":"/**\n * @file\n * @brief [Insertion sort](https://en.wikipedia.org/wiki/Insertion_sort)\n * algorithm implementation.\n */\n#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n/**\n * Insertion sort algorithm implements\n * @param arr array to be sorted\n * @param size size of array\n */\nvoid insertionSort(int *arr, int size)\n{\n    for (int i = 1; i < size; i++)\n    {\n        int j = i - 1;\n        int key = arr[i];\n        /* Move all elements greater than key to one position */\n        while (j >= 0 && key < arr[j])\n        {\n            arr[j + 1] = arr[j];\n            j = j - 1;\n        }\n        /* Find a correct position for key */\n        arr[j + 1] = key;\n    }\n}\n\n/** Test function\n  * @returns None\n  */\nstatic void test()\n{\n    const int size = rand() % 500; /* random array size */\n    int *arr = (int *)calloc(size, sizeof(int));\n\n    /* generate size random numbers from -50 to 49 */  \n    for (int i = 0; i < size; i++)\n    {\n        arr[i] = (rand() % 100) - 50; /* signed random numbers */\n    }\n    insertionSort(arr, size);\n    for (int i = 0; i < size - 1; ++i)\n    {\n        assert(arr[i] <= arr[i + 1]);\n    }\n    free(arr);\n}\nint main(int argc, const char *argv[])\n{\n    /* Intializes random number generator */\n    srand(time(NULL));\n    test();\n    return 0;\n}\n","index":345},{"title":"Merge Sort","category":"sorting","id":"merge_sort_sorting","algorithm":"/**\n * @file\n * @brief Implementation of [merge\n * sort](https://en.wikipedia.org/wiki/Merge_sort) algorithm\n */\n#include <stdio.h>\n#include <stdlib.h>\n\n/**\n * @addtogroup sorting Sorting algorithms\n * @{\n */\n/** Swap two integer variables\n * @param [in,out] a pointer to first variable\n * @param [in,out] b pointer to second variable\n */\nvoid swap(int *a, int *b)\n{\n    int t;\n    t = *a;\n    *a = *b;\n    *b = t;\n}\n\n/**\n * @brief Perform merge of segments.\n *\n * @param a array to sort\n * @param l left index for merge\n * @param r right index for merge\n * @param n total number of elements in the array\n */\nvoid merge(int *a, int l, int r, int n)\n{\n    int *b = (int *)malloc(n * sizeof(int)); /* dynamic memory must be freed */\n    int c = l;\n    int p1, p2;\n    p1 = l;\n    p2 = ((l + r) / 2) + 1;\n    while ((p1 < ((l + r) / 2) + 1) && (p2 < r + 1))\n    {\n        if (a[p1] <= a[p2])\n        {\n            b[c++] = a[p1];\n            p1++;\n        }\n        else\n        {\n            b[c++] = a[p2];\n            p2++;\n        }\n    }\n\n    if (p2 == r + 1)\n    {\n        while ((p1 < ((l + r) / 2) + 1))\n        {\n            b[c++] = a[p1];\n            p1++;\n        }\n    }\n    else\n    {\n        while ((p2 < r + 1))\n        {\n            b[c++] = a[p2];\n            p2++;\n        }\n    }\n\n    for (c = l; c < r - l + 1; c++) a[c] = b[c];\n\n    free(b);\n}\n\n/** Merge sort algorithm implementation\n * @param a array to sort\n * @param n number of elements in the array\n * @param l index to sort from\n * @param r index to sort till\n */\nvoid merge_sort(int *a, int n, int l, int r)\n{\n    if (r - l == 1)\n    {\n        if (a[l] > a[r])\n            swap(&a[l], &a[r]);\n    }\n    else if (l != r)\n    {\n        merge_sort(a, n, l, (l + r) / 2);\n        merge_sort(a, n, ((l + r) / 2) + 1, r);\n        merge(a, l, r, n);\n    }\n\n    /* no change if l == r */\n}\n/** @} */\n\n/** Main function */\nint main(void)\n{\n    int *a, n, i;\n    scanf(\"%d\", &n);\n    a = (int *)malloc(n * sizeof(int));\n    for (i = 0; i < n; i++)\n    {\n        scanf(\"%d\", &a[i]);\n    }\n\n    merge_sort(a, n, 0, n - 1);\n    for (i = 0; i < n; i++)\n    {\n        printf(\" %d\", a[i]);\n    }\n\n    free(a);\n\n    return 0;\n}\n","index":346},{"title":"Merge Sort Nr","category":"sorting","id":"merge_sort_nr_sorting","algorithm":"/* Program to demonstrate non recursive merge sort */\r\n\r\n/* Merge sort is an effective sorting algorithm which falls under divide and\r\nconquer paradigm and produces a stable sort. Merge sort repeatedly breaks down a\r\nlist into several sublists until each sublist consists of a single element and\r\nmerging those sublists in a manner that results into a sorted list.\r\n\r\nBottom-Up Merge Sort Implementation:\r\nThe Bottom-Up merge sort approach uses iterative methodology. It starts with the\r\nsingle-element array, and combines two adjacent elements and also sorting the\r\ntwo at the same time. The combined-sorted arrays are again combined and sorted\r\nwith each other until one single unit of sorted array is achieved. */\r\n\r\n#include <stdio.h>\r\n\r\nvoid mergesort(int x[], int n);\r\nvoid show(int x[], int n);\r\n\r\nvoid mergesort(int x[], int n)\r\n{\r\n    int temp[50], i, j, k, lb1, lb2, ub1, ub2, size;\r\n\r\n    size = 1;\r\n    while (size < n)\r\n    {\r\n        lb1 = 0;\r\n        k = 0;\r\n\r\n        while (lb1 + size < n)\r\n        {\r\n            lb2 = lb1 + size;\r\n            ub1 = lb2 - 1;\r\n            if (ub1 + size < n)\r\n                ub2 = ub1 + size;\r\n            else\r\n                ub2 = n - 1;\r\n\r\n            i = lb1;\r\n            j = lb2;\r\n\r\n            while (i <= ub1 && j <= ub2)\r\n                if (x[i] < x[j])\r\n                    temp[k++] = x[i++];\r\n                else\r\n                    temp[k++] = x[j++];\r\n\r\n            while (i <= ub1) temp[k++] = x[i++];\r\n\r\n            while (j <= ub2) temp[k++] = x[j++];\r\n\r\n            lb1 = ub2 + 1;\r\n        }\r\n\r\n        for (i = 0; i <= ub2; i++) x[i] = temp[i];\r\n\r\n        size = size * 2;\r\n\r\n        show(x, n);\r\n    }\r\n}\r\n\r\n// function to show each pass\r\nvoid show(int x[], int n)\r\n{\r\n    int i;\r\n    for (i = 0; i < n; i++) printf(\"%d \", x[i]);\r\n    printf(\"\\n\\n\");\r\n}\r\n\r\nint main()  // main function\r\n{\r\n    int i, n, x[20];\r\n\r\n    printf(\"Enter the number of elements: \");\r\n    scanf(\"%d\", &n);\r\n    printf(\"Enter the elements:\\n\");\r\n    for (i = 0; i < n; i++) scanf(\"%d\", &x[i]);\r\n\r\n    mergesort(x, n);\r\n\r\n    printf(\"Sorted array is as shown:\\n\");\r\n    for (i = 0; i < n; i++) printf(\"%d \", x[i]);\r\n    return 0;\r\n}\r\n\r\n/* Output of the Program*/\r\n/*\r\nEnter the number of elements: 5\r\nEnter the elements:\r\n15\r\n14\r\n13\r\n12\r\n11\r\n14 15 12 13 11\r\n\r\n12 13 14 15 11\r\n\r\n11 12 13 14 15\r\n\r\nSorted array is as shown:\r\n11 12 13 14 15\r\n*/\r\n","index":347},{"title":"Multikey Quick Sort","category":"sorting","id":"multikey_quick_sort_sorting","algorithm":"/* demo.c -- Implementations of multikey quicksort and ternary search trees\n   Usage\n    demo                  Run basic timings on /usr/dict/words\n    demo <file>           Run basic timings on <file>\n    demo <file> trysearch Interactive pm and nn search on <file>\n    demo <file> nncost    Run near neigbhor expers on <file>\n    demo <file> pmcost    Interactive partial match expers on <file>\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\n// MULTIKEY QUICKSORT\n\n#ifndef min\n#define min(a, b) ((a) <= (b) ? (a) : (b))\n#endif\n\n#define swap(a, b)      \\\n    {                   \\\n        char *t = x[a]; \\\n        x[a] = x[b];    \\\n        x[b] = t;       \\\n    }\n#define i2c(i) x[i][depth]\n\nvoid vecswap(int i, int j, int n, char *x[])\n{\n    while (n-- > 0)\n    {\n        swap(i, j);\n        i++;\n        j++;\n    }\n}\n\nvoid ssort1(char *x[], int n, int depth)\n{\n    int a, b, c, d, r, v;\n    if (n <= 1)\n        return;\n    a = rand() % n;\n    swap(0, a);\n    v = i2c(0);\n    a = b = 1;\n    c = d = n - 1;\n    for (;;)\n    {\n        while (b <= c && (r = i2c(b) - v) <= 0)\n        {\n            if (r == 0)\n            {\n                swap(a, b);\n                a++;\n            }\n            b++;\n        }\n        while (b <= c && (r = i2c(c) - v) >= 0)\n        {\n            if (r == 0)\n            {\n                swap(c, d);\n                d--;\n            }\n            c--;\n        }\n        if (b > c)\n            break;\n        swap(b, c);\n        b++;\n        c--;\n    }\n    r = min(a, b - a);\n    vecswap(0, b - r, r, x);\n    r = min(d - c, n - d - 1);\n    vecswap(b, n - r, r, x);\n    r = b - a;\n    ssort1(x, r, depth);\n    if (i2c(r) != 0)\n        ssort1(x + r, a + n - d - 1, depth + 1);\n    r = d - c;\n    ssort1(x + n - r, r, depth);\n}\n\nvoid ssort1main(char *x[], int n) { ssort1(x, n, 0); }\n\n// ssort2 -- Faster Version of Multikey Quicksort\n\nvoid vecswap2(char **a, char **b, int n)\n{\n    while (n-- > 0)\n    {\n        char *t = *a;\n        *a++ = *b;\n        *b++ = t;\n    }\n}\n\n#define swap2(a, b)  \\\n    {                \\\n        t = *(a);    \\\n        *(a) = *(b); \\\n        *(b) = t;    \\\n    }\n#define ptr2char(i) (*(*(i) + depth))\n\nchar **med3func(char **a, char **b, char **c, int depth)\n{\n    int va, vb, vc;\n    if ((va = ptr2char(a)) == (vb = ptr2char(b)))\n        return a;\n    if ((vc = ptr2char(c)) == va || vc == vb)\n        return c;\n    return va < vb ? (vb < vc ? b : (va < vc ? c : a))\n                   : (vb > vc ? b : (va < vc ? a : c));\n}\n#define med3(a, b, c) med3func(a, b, c, depth)\n\nvoid inssort(char **a, int n, int d)\n{\n    char **pi, **pj, *s, *t;\n    for (pi = a + 1; --n > 0; pi++)\n        for (pj = pi; pj > a; pj--)\n        {\n            // Inline strcmp: break if *(pj-1) <= *pj\n            for (s = *(pj - 1) + d, t = *pj + d; *s == *t && *s != 0; s++, t++)\n                ;\n            if (*s <= *t)\n                break;\n            swap2(pj, pj - 1);\n        }\n}\n\nvoid ssort2(char **a, int n, int depth)\n{\n    int d, r, partval;\n    char **pa, **pb, **pc, **pd, **pl, **pm, **pn, *t;\n    if (n < 10)\n    {\n        inssort(a, n, depth);\n        return;\n    }\n    pl = a;\n    pm = a + (n / 2);\n    pn = a + (n - 1);\n    if (n > 30)\n    {  // On big arrays, pseudomedian of 9\n        d = (n / 8);\n        pl = med3(pl, pl + d, pl + 2 * d);\n        pm = med3(pm - d, pm, pm + d);\n        pn = med3(pn - 2 * d, pn - d, pn);\n    }\n    pm = med3(pl, pm, pn);\n    swap2(a, pm);\n    partval = ptr2char(a);\n    pa = pb = a + 1;\n    pc = pd = a + n - 1;\n    for (;;)\n    {\n        while (pb <= pc && (r = ptr2char(pb) - partval) <= 0)\n        {\n            if (r == 0)\n            {\n                swap2(pa, pb);\n                pa++;\n            }\n            pb++;\n        }\n        while (pb <= pc && (r = ptr2char(pc) - partval) >= 0)\n        {\n            if (r == 0)\n            {\n                swap2(pc, pd);\n                pd--;\n            }\n            pc--;\n        }\n        if (pb > pc)\n            break;\n        swap2(pb, pc);\n        pb++;\n        pc--;\n    }\n    pn = a + n;\n    r = min(pa - a, pb - pa);\n    vecswap2(a, pb - r, r);\n    r = min(pd - pc, pn - pd - 1);\n    vecswap2(pb, pn - r, r);\n    if ((r = pb - pa) > 1)\n        ssort2(a, r, depth);\n    if (ptr2char(a + r) != 0)\n        ssort2(a + r, pa - a + pn - pd - 1, depth + 1);\n    if ((r = pd - pc) > 1)\n        ssort2(a + n - r, r, depth);\n}\n\nvoid ssort2main(char **a, int n) { ssort2(a, n, 0); }\n\n// TERNARY SEARCH TREE ALGS\n\ntypedef struct tnode *Tptr;\ntypedef struct tnode\n{\n    char splitchar;\n    Tptr lokid, eqkid, hikid;\n} Tnode;\nTptr root;\n\n// Insert 1 -- Simple Insertion Algorithm\n\nTptr insert1(Tptr p, char *s)\n{\n    if (p == 0)\n    {\n        p = (Tptr)malloc(sizeof(Tnode));\n        p->splitchar = *s;\n        p->lokid = p->eqkid = p->hikid = 0;\n    }\n    if (*s < p->splitchar)\n        p->lokid = insert1(p->lokid, s);\n    else if (*s == p->splitchar)\n    {\n        if (*s != 0)\n            p->eqkid = insert1(p->eqkid, ++s);\n    }\n    else\n        p->hikid = insert1(p->hikid, s);\n    return p;\n}\n\nvoid cleanup1(Tptr p)\n{\n    if (p)\n    {\n        cleanup1(p->lokid);\n        cleanup1(p->eqkid);\n        cleanup1(p->hikid);\n        free(p);\n    }\n}\n\n// Insert 2 -- Faster version of Insert\n\n#define BUFSIZE 1000\nTptr buf;\nint bufn, freen;\nvoid *freearr[10000];\nint storestring = 0;\n\nvoid insert2(char *s)\n{\n    int d;\n    char *instr = s;\n\n    Tptr pp, *p;\n    p = &root;\n    while (pp == *p)\n    {\n        if ((d = *s - pp->splitchar) == 0)\n        {\n            if (*s++ == 0)\n                return;\n            p = &(pp->eqkid);\n        }\n        else if (d < 0)\n            p = &(pp->lokid);\n        else\n            p = &(pp->hikid);\n    }\n    for (;;)\n    {\n        // *p = (Tptr) malloc(sizeof(Tnode));\n        if (bufn-- == 0)\n        {\n            buf = (Tptr)malloc(BUFSIZE * sizeof(Tnode));\n            freearr[freen++] = (void *)buf;\n            bufn = BUFSIZE - 1;\n        }\n        *p = buf++;\n        pp = *p;\n        pp->splitchar = *s;\n        pp->lokid = pp->eqkid = pp->hikid = 0;\n        if (*s++ == 0)\n        {\n            if (storestring)\n                pp->eqkid = (Tptr)instr;\n            return;\n        }\n        p = &(pp->eqkid);\n    }\n}\nvoid cleanup2()\n{\n    int i;\n    for (i = 0; i < freen; i++) free(freearr[i]);\n}\n\n// Search Algorithms\n\nint search1(char *s)\n{\n    Tptr p;\n    p = root;\n    while (p)\n    {\n        if (*s < p->splitchar)\n            p = p->lokid;\n        else if (*s == p->splitchar)\n        {\n            if (*s++ == 0)\n                return 1;\n            p = p->eqkid;\n        }\n        else\n            p = p->hikid;\n    }\n    return 0;\n}\n\nint search2(char *s)\n{\n    int d, sc;\n    Tptr p;\n    sc = *s;\n    p = root;\n    while (p)\n    {\n        if ((d = sc - p->splitchar) == 0)\n        {\n            if (sc == 0)\n                return 1;\n            sc = *++s;\n            p = p->eqkid;\n        }\n        else if (d < 0)\n            p = p->lokid;\n        else\n            p = p->hikid;\n    }\n    return 0;\n}\n\n// Advanced searching: Partial match, near words\n\nint nodecnt;\nchar *srcharr[100000];\nint srchtop;\n\nvoid pmsearch(Tptr p, char *s)\n{\n    if (!p)\n        return;\n    nodecnt++;\n    if (*s == '.' || *s < p->splitchar)\n        pmsearch(p->lokid, s);\n    if (*s == '.' || *s == p->splitchar)\n        if (p->splitchar && *s)\n            pmsearch(p->eqkid, s + 1);\n    if (*s == 0 && p->splitchar == 0)\n        srcharr[srchtop++] = (char *)p->eqkid;\n    if (*s == '.' || *s > p->splitchar)\n        pmsearch(p->hikid, s);\n}\n\nvoid nearsearch(Tptr p, char *s, int d)\n{\n    if (!p || d < 0)\n        return;\n    nodecnt++;\n    if (d > 0 || *s < p->splitchar)\n        nearsearch(p->lokid, s, d);\n    if (p->splitchar == 0)\n    {\n        if ((int)strlen(s) <= d)\n            srcharr[srchtop++] = (char *)p->eqkid;\n    }\n    else\n        nearsearch(p->eqkid, *s ? s + 1 : s, (*s == p->splitchar) ? d : d - 1);\n    if (d > 0 || *s > p->splitchar)\n        nearsearch(p->hikid, s, d);\n}\n\n#define NUMBER_OF_STRING 3\n\nint main(int argc, char *argv[])\n{\n    char *arr[NUMBER_OF_STRING] = {\"apple\", \"cat\", \"boy\"};\n\n    ssort1main(arr, NUMBER_OF_STRING);\n\n    for (int i = 0; i < NUMBER_OF_STRING; i++)\n    {\n        printf(\"%s \", arr[i]);\n    }\n}\n","index":348},{"title":"Pancake Sort","category":"sorting","id":"pancake_sort_sorting","algorithm":"// Sorting of array list using pancake sort\n#include <stdio.h>\n#include <stdlib.h>\n\n/* Reverses the array */\nvoid flip(int arr[], int i)\n{\n    int temp, start = 0;\n\n    while (start < i)\n    {\n        temp = arr[start];\n        arr[start] = arr[i];\n        arr[i] = temp;\n        start++;\n        i--;\n    }\n}\n\n// Returns index of the maximum element in arr[0..n-1]\nint findMax(int arr[], int n)\n{\n    int maxElementIdx, i;\n\n    for (maxElementIdx = 0, i = 0; i < n; ++i)\n        if (arr[i] > arr[maxElementIdx])\n            maxElementIdx = i;\n\n    return maxElementIdx;\n}\n\n// Sorts the array using flip operations\nvoid pancakeSort(int *arr, int n)\n{\n    // Start from the complete array and one by one reduce current size by one\n    for (int curr_size = n; curr_size > 1; --curr_size)\n    {\n        // Find index of the maximum element in arr[0..curr_size-1]\n        int maxElementIdx = findMax(arr, curr_size);\n\n        // Move the maximum element to end of current array if it's not already\n        // at the end\n        if (maxElementIdx != curr_size - 1)\n        {\n            // To move at the end, first move maximum number to beginning\n            flip(arr, maxElementIdx);\n\n            // Now move the maximum number to end by reversing current array\n            flip(arr, curr_size - 1);\n        }\n    }\n}\n\n// Displays the array, passed to this method\nvoid display(int arr[], int n)\n{\n    for (int i = 0; i < n; i++)\n    {\n        printf(\"%d \", arr[i]);\n    }\n\n    printf(\"\\n\");\n}\n\n#define N 50\n\n// Driver program to test above function\nint main()\n{\n    int arr[N];\n    for (int i = 0; i < N; i++)\n        arr[i] = rand() % (N << 1); /* random numbers from 0 to 2N */\n\n    printf(\"Original array: \");\n    display(arr, N);\n\n    pancakeSort(arr, N);\n    printf(\"Sorted array: \");\n    display(arr, N);\n\n    return 0;\n}","index":349},{"title":"Partition Sort","category":"sorting","id":"partition_sort_sorting","algorithm":"#include <stdio.h>\n#include <stdlib.h>\n\nvoid swap(int *a, int *b)\n{\n    int tmp = *a;\n    *a = *b;\n    *b = tmp;\n}\n\nint partition(int arr[], int low, int high)\n{\n    int pivot = arr[low];\n    int i = low - 1, j = high + 1;\n\n    while (1)\n    {\n        /* Find leftmost element >= pivot */\n        do\n        {\n            i++;\n        } while (arr[i] < pivot);\n\n        /* Find rightmost element <= pivot */\n        do\n        {\n            j--;\n        } while (arr[j] > pivot);\n\n        /* if two pointers met */\n        if (i >= j)\n            return j;\n\n        swap(&arr[i], &arr[j]);\n    }\n}\n\nvoid partitionSort(int arr[], int low, int high)\n{\n    if (low < high)\n    {\n        int value = partition(arr, low, high);\n        partitionSort(arr, low, value);\n        partitionSort(arr, value + 1, high);\n    }\n}\n\nvoid printArray(int arr[], int n)\n{\n    int i;\n    for (i = 0; i < n; i++) printf(\"%d \", arr[i]);\n    printf(\"\\n\");\n}\n\nint main()\n{\n    int arr[20];\n    int i, range = 100;\n    for (i = 0; i < 20; i++)\n    {\n        arr[i] = rand() % range + 1;\n    }\n    int size = sizeof arr / sizeof arr[0];\n    printf(\"Array: \\n\");\n    printArray(arr, size);\n    partitionSort(arr, 0, size - 1);\n    printf(\"Sorted Array: \\n\");\n    printArray(arr, size);\n\n    return 0;\n}\n","index":350},{"title":"Pigeonhole Sort","category":"sorting","id":"pigeonhole_sort_sorting","algorithm":"#include <stdio.h>\n#include <stdlib.h>\n\nvoid pigeonholeSort(int arr[], int size)\n{\n    int i, j, min = arr[0], max = arr[0], range;\n\n    // Getting range of the array using max and min\n    for (i = 1; i < size; i++)\n    {\n        if (arr[i] < min)\n            min = arr[i];\n        if (arr[i] > max)\n            max = arr[i];\n    }\n    range = max - min + 1;\n\n    // Make 'holes' and put array's numbers in holes\n    int *holes = (int *)malloc(sizeof(int) * range);\n    for (i = 0; i < range; i++)\n    {\n        holes[i] = 0;\n    }\n    for (i = 0; i < size; i++)\n    {\n        holes[arr[i] - min]++;\n    }\n\n    // Copy the numbers back to the original array\n    j = 0;\n    for (i = 0; i < range; i++)\n    {\n        while (holes[i] > 0)\n        {\n            arr[j] = i + min;\n            holes[i]--;\n            j++;\n        }\n    }\n\n    free(holes);\n}\n\nint main()\n{\n    int i, n;\n\n    printf(\"Enter the size of the array: \");\n    scanf(\"%d\", &n);\n    int *arr = (int *)malloc(sizeof(int) * n);\n\n    for (i = 0; i < n; i++)\n    {\n        printf(\"Number #%d: \", i + 1);\n        scanf(\"%d\", &arr[i]);\n    }\n\n    printf(\"You entered:  \");\n    for (i = 0; i < n; i++)\n    {\n        printf(\"%d \", arr[i]);\n    }\n    pigeonholeSort(arr, n);\n    printf(\"\\nSorted array: \");\n    for (i = 0; i < n; i++)\n    {\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"\\n\");\n\n    free(arr);\n    return 0;\n}","index":351},{"title":"Quick Sort","category":"sorting","id":"quick_sort_sorting","algorithm":"#include <stdio.h>\n#include <stdlib.h>\n\n/*Displays the array, passed to this method*/\nvoid display(int arr[], int n)\n{\n    int i;\n    for (i = 0; i < n; i++)\n    {\n        printf(\"%d \", arr[i]);\n    }\n\n    printf(\"\\n\");\n}\n\n/*Swap function to swap two values*/\nvoid swap(int *first, int *second)\n{\n    int temp = *first;\n    *first = *second;\n    *second = temp;\n}\n\n/*Partition method which selects a pivot\n  and places each element which is less than the pivot value to its left\n  and the elements greater than the pivot value to its right\n  arr[] --- array to be partitioned\n  lower --- lower index\n  upper --- upper index\n*/\nint partition(int arr[], int lower, int upper)\n{\n    int i = (lower - 1);\n\n    int pivot = arr[upper];  // Selects last element as the pivot value\n\n    int j;\n    for (j = lower; j < upper; j++)\n    {\n        if (arr[j] <= pivot)\n        {  // if current element is smaller than the pivot\n\n            i++;  // increment the index of smaller element\n            swap(&arr[i], &arr[j]);\n        }\n    }\n\n    swap(&arr[i + 1], &arr[upper]);  // places the last element i.e, the pivot\n                                     // to its correct position\n\n    return (i + 1);\n}\n\n/*This is where the sorting of the array takes place\n    arr[] --- Array to be sorted\n    lower --- Starting index\n    upper --- Ending index\n*/\nvoid quickSort(int arr[], int lower, int upper)\n{\n    if (upper > lower)\n    {\n        // partitioning index is returned by the partition method , partition\n        // element is at its correct poition\n\n        int partitionIndex = partition(arr, lower, upper);\n\n        // Sorting elements before and after the partition index\n        quickSort(arr, lower, partitionIndex - 1);\n        quickSort(arr, partitionIndex + 1, upper);\n    }\n}\n\nint main()\n{\n    int n;\n    printf(\"Enter size of array:\\n\");\n    scanf(\"%d\", &n);  // E.g. 8\n\n    printf(\"Enter the elements of the array\\n\");\n    int i;\n    int *arr = (int *)malloc(sizeof(int) * n);\n    for (i = 0; i < n; i++)\n    {\n        scanf(\"%d\", &arr[i]);\n    }\n\n    printf(\"Original array: \");\n    display(arr, n);  // Original array : 10 11 9 8 4 7 3 8\n\n    quickSort(arr, 0, n - 1);\n\n    printf(\"Sorted array: \");\n    display(arr, n);  // Sorted array : 3 4 7 8 8 9 10 11\n    getchar();\n    return 0;\n}\n","index":352},{"title":"Radix Sort","category":"sorting","id":"radix_sort_sorting","algorithm":"#include <stdio.h>\n\nint largest(int a[], int n)\n{\n    int large = a[0], i;\n    for (i = 1; i < n; i++)\n    {\n        if (large < a[i])\n            large = a[i];\n    }\n    return large;\n}\n\nvoid RadixSort(int a[], int n)\n{\n    int bucket[10][10], bucket_count[10];\n    int i, j, k, remainder, NOP = 0, divisor = 1, large, pass;\n\n    large = largest(a, n);\n    printf(\"The large element %d\\n\", large);\n    while (large > 0)\n    {\n        NOP++;\n        large /= 10;\n    }\n\n    for (pass = 0; pass < NOP; pass++)\n    {\n        for (i = 0; i < 10; i++)\n        {\n            bucket_count[i] = 0;\n        }\n        for (i = 0; i < n; i++)\n        {\n            remainder = (a[i] / divisor) % 10;\n            bucket[remainder][bucket_count[remainder]] = a[i];\n            bucket_count[remainder] += 1;\n        }\n\n        i = 0;\n        for (k = 0; k < 10; k++)\n        {\n            for (j = 0; j < bucket_count[k]; j++)\n            {\n                a[i] = bucket[k][j];\n                i++;\n            }\n        }\n        divisor *= 10;\n\n        for (i = 0; i < n; i++) printf(\"%d  \", a[i]);\n        printf(\"\\n\");\n    }\n}\n\nint main()\n{\n    int i, n, a[10];\n    printf(\"Enter the number of elements :: \");\n    scanf(\"%d\", &n);\n    printf(\"Enter the elements :: \");\n    for (i = 0; i < n; i++)\n    {\n        scanf(\"%d\", &a[i]);\n    }\n    RadixSort(a, n);\n    printf(\"The sorted elements are ::  \");\n    for (i = 0; i < n; i++) printf(\"%d  \", a[i]);\n    printf(\"\\n\");\n    return 0;\n}\n","index":353},{"title":"Radix Sort 2","category":"sorting","id":"radix_sort_2_sorting","algorithm":"// sorting of array list using Radix sort\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\n#define range 10  // Range for integers is 10 as digits range from 0-9\r\n\r\n// Utility function to get the maximum value in ar[]\r\nint MAX(int *ar, int size)\r\n{\r\n    int i, max = ar[0];\r\n    for (i = 0; i < size; i++)\r\n    {\r\n        if (ar[i] > max)\r\n            max = ar[i];\r\n    }\r\n    return max;\r\n}\r\n\r\n// Counting sort according to the digit represented by place\r\nvoid countSort(int *arr, int n, int place)\r\n{\r\n    int i, freq[range] = {0};\r\n    int *output = (int *)malloc(n * sizeof(int));\r\n\r\n    // Store count of occurences in freq[]\r\n    for (i = 0; i < n; i++) freq[(arr[i] / place) % range]++;\r\n\r\n    // Change freq[i] so that it contains the actual position of the digit in\r\n    // output[]\r\n    for (i = 1; i < range; i++) freq[i] += freq[i - 1];\r\n\r\n    // Build the output array\r\n    for (i = n - 1; i >= 0; i--)\r\n    {\r\n        output[freq[(arr[i] / place) % range] - 1] = arr[i];\r\n        freq[(arr[i] / place) % range]--;\r\n    }\r\n\r\n    // Copy the output array to arr[], so it contains numbers according to the\r\n    // current digit\r\n    for (i = 0; i < n; i++) arr[i] = output[i];\r\n    free(output);\r\n}\r\n\r\n/*This is where the sorting of the array takes place\r\n arr[] --- Array to be sorted\r\n n --- Array Size\r\n max --- Maximum element in Array\r\n */\r\nvoid radixsort2(int *arr, int n,\r\n                int max)  // max is the maximum element in the array\r\n{\r\n    int mul = 1;\r\n    while (max)\r\n    {\r\n        countSort(arr, n, mul);\r\n        mul *= 10;\r\n        max /= 10;\r\n    }\r\n}\r\n\r\nvoid display(int *arr, int N)\r\n{\r\n    for (int i = 0; i < N; i++) printf(\"%d, \", arr[i]);\r\n    putchar('\\n');\r\n}\r\n\r\nint main(int argc, const char *argv[])\r\n{\r\n    int n;\r\n    printf(\"Enter size of array:\\n\");\r\n    scanf(\"%d\", &n);  // E.g. 8\r\n\r\n    printf(\"Enter the elements of the array\\n\");\r\n    int i;\r\n    int *arr = (int *)malloc(n * sizeof(int));\r\n    for (i = 0; i < n; i++)\r\n    {\r\n        scanf(\"%d\", &arr[i]);\r\n    }\r\n\r\n    printf(\"Original array: \");\r\n    display(arr, n);  // Original array : 10 11 9 8 4 7 3 8\r\n\r\n    int max;\r\n    max = MAX(arr, n);\r\n\r\n    radixsort2(arr, n, max);\r\n\r\n    printf(\"Sorted array: \");\r\n    display(arr, n);  // Sorted array : 3 4 7 8 8 9 10 11\r\n\r\n    free(arr);\r\n    return 0;\r\n}\r\n","index":354},{"title":"Random Quick Sort","category":"sorting","id":"random_quick_sort_sorting","algorithm":"/*\nRandomised quick sort implementation in C language.\nIn normal quick sort, pivot chosen to partition is either the first or the last\nelement of the array. This can take time O(n*n) to sort in the worst case. Now\nin randomised quick sort, pivot is randomly chosen and then recursively sort the\nleft and right sub-arrays. The expected running time of the algorithm is\nO(nlog(n)).\n*/\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\nint getBig(int *a, int i, int right, int pivot)\n{\n    for (int k = i; k <= right; k++)\n    {\n        if (a[k] > pivot)\n            return k;\n    }\n    return right + 1;\n}\n\nint getSmall(int *a, int j, int left, int pivot)\n{\n    for (int k = j; k >= left; k--)\n    {\n        if (a[k] < pivot)\n            return k;\n    }\n    return -1;\n}\n\nvoid swap(int *a, int *b)\n{\n    int t = *a;\n    *a = *b;\n    *b = t;\n}\n\nvoid random_quick(int *a, int left, int right)\n{\n    if (left >= right)\n        return;\n    int index = left + (rand() % (right - left)), i = left, j = right;\n    int pivot_index = index;\n    int pivot = a[index];\n    // storing index of element greater than pivot\n    i = getBig(a, i, right, pivot);\n    // storing index of element smaller than pivot\n    j = getSmall(a, j, left, pivot);\n    while (i <= j)\n    {\n        swap(&a[i], &a[j]);\n        i = getBig(a, i, right, pivot);\n        j = getSmall(a, j, left, pivot);\n    }\n    // after separating the smaller and greater elements, there are 3 cases\n    // possible\n    if (pivot_index > j && pivot_index > i)\n    {\n        // case 1. When the pivot element index is greater than both i and j\n        swap(&a[i], &a[pivot_index]);\n        random_quick(a, left, i - 1);\n        random_quick(a, i + 1, right);\n    }\n    else if (pivot_index < j && pivot_index < i)\n    {\n        // case 2. When the pivot element index is smaller than both i and j\n        swap(&a[j], &a[pivot_index]);\n        random_quick(a, left, j - 1);\n        random_quick(a, j + 1, right);\n    }\n    else\n    {\n        // the pivot element is at its origin position.\n        random_quick(a, left, pivot_index - 1);\n        random_quick(a, pivot_index + 1, right);\n    }\n}\n\nint main()\n{\n    srand(time(0));\n    int num;\n    scanf(\"%d\", &num);\n    int *arr = (int *)malloc(num * sizeof(int));\n    for (int i = 0; i < num; i++)\n    {\n        scanf(\"%d\", &arr[i]);\n    }\n    random_quick(arr, 0, num - 1);\n    for (int i = 0; i < num; i++)\n    {\n        printf(\"%d \", arr[i]);\n    }\n\n    free(arr);\n    printf(\"\\n\");\n}\n","index":355},{"title":"Selection Sort","category":"sorting","id":"selection_sort_sorting","algorithm":"/**\n * @file\n * @brief [Selection sort](https://en.wikipedia.org/wiki/Selection_sort)\n * algorithm implementation.\n */\n#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n/**\n * Swapped two numbers using pointer\n * @param first first pointer of first number\n * @param second second pointer of second number\n */\nvoid swap(int *first, int *second)\n{\n    int temp = *first;\n    *first = *second;\n    *second = temp;\n}\n\n/**\n * Selection sort algorithm implements\n * @param arr array to be sorted\n * @param size size of array\n */\nvoid selectionSort(int *arr, int size)\n{\n    for (int i = 0; i < size - 1; i++)\n    {\n        int min_index = i;\n        for (int j = i + 1; j < size; j++)\n        {\n            if (arr[min_index] > arr[j])\n            {\n                min_index = j;\n            }\n        }\n        if (min_index != i)\n        {\n            swap(arr + i, arr + min_index);\n        }\n    }\n}\n\n/** Test function\n  * @returns None\n  */\nstatic void test()\n{\n    const int size = rand() % 500; /* random array size */\n    int *arr = (int *)calloc(size, sizeof(int));\n\n    /* generate size random numbers from -50 to 49 */\n    for (int i = 0; i < size; i++)\n    {\n        arr[i] = (rand() % 100) - 50; /* signed random numbers */\n    }\n    selectionSort(arr, size);\n    for (int i = 0; i < size - 1; ++i)\n    {\n        assert(arr[i] <= arr[i + 1]);\n    }\n    free(arr);\n}\n\n/** Driver Code */\nint main(int argc, const char *argv[])\n{\n    /* Intializes random number generator */\n    srand(time(NULL));\n    test();\n    return 0;\n}\n","index":356},{"title":"Shaker Sort","category":"sorting","id":"shaker_sort_sorting","algorithm":"#include <stdio.h>\n#include <stdlib.h>\n\nvoid swap(int *a, int *b)\n{\n    int temp;\n    temp = *a;\n    *a = *b;\n    *b = temp;\n}\nvoid shakersort(int *a, int n)\n{\n    int p, i;\n    for (p = 1; p <= n / 2; p++)\n    {\n        for (i = p - 1; i < n - p; i++)\n            if (a[i] > a[i + 1])\n            {\n                swap(&a[i], &a[i + 1]);\n            }\n        for (i = n - p - 1; i >= p; i--)\n            if (a[i] < a[i - 1])\n            {\n                swap(&a[i], &a[i - 1]);\n            }\n    }\n}\nint main()\n{\n    int n;\n    scanf(\"%d\", &n);\n    int *arr = (int *)malloc(n * sizeof(int));\n    int i;\n    for (i = 0; i < n; i++) scanf(\"%d \", &arr[i]);\n    shakersort(arr, n);\n    for (i = 0; i < n; i++) printf(\"%d \", arr[i]);\n    free(arr);\n    return 0;\n}\n","index":357},{"title":"Shell Sort","category":"sorting","id":"shell_sort_sorting","algorithm":"#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <time.h>\r\n\r\n#define ELEMENT_NR 20000\r\n#define ARRAY_LEN(x) (sizeof(x) / sizeof((x)[0]))\r\nconst char *notation =\r\n    \"Shell Sort Big O Notation:\\\r\n\t\t\t\t\t\t\\n--> Best Case: O(n log(n)) \\\r\n\t\t\t\t\t\t\\n--> Average Case: depends on gap sequence \\\r\n\t\t\t\t\t\t\\n--> Worst Case: O(n)\";\r\n\r\nvoid show_data(int arr[], int len)\r\n{\r\n    int i;\r\n\r\n    for (i = 0; i < len; i++) printf(\"%3d \", arr[i]);\r\n    printf(\"\\n\");\r\n}\r\n\r\nvoid swap(int *a, int *b)\r\n{\r\n    int tmp;\r\n\r\n    tmp = *a;\r\n    *a = *b;\r\n    *b = tmp;\r\n}\r\n\r\nvoid shellSort(int array[], int len)\r\n{\r\n    int i, j, gap;\r\n\r\n    for (gap = len / 2; gap > 0; gap = gap / 2)\r\n        for (i = gap; i < len; i++)\r\n            for (j = i - gap; j >= 0 && array[j] > array[j + gap]; j = j - gap)\r\n                swap(&array[j], &array[j + gap]);\r\n}\r\n\r\nint main(int argc, char *argv[])\r\n{\r\n    int i;\r\n    int array[ELEMENT_NR];\r\n    int range = 500;\r\n    int size;\r\n    clock_t start, end;\r\n    double time_spent;\r\n\r\n    srand(time(NULL));\r\n    for (i = 0; i < ELEMENT_NR; i++) array[i] = rand() % range + 1;\r\n\r\n    size = ARRAY_LEN(array);\r\n\r\n    show_data(array, size);\r\n    start = clock();\r\n    shellSort(array, size);\r\n    end = clock();\r\n    time_spent = (double)(end - start) / CLOCKS_PER_SEC;\r\n\r\n    printf(\"Data Sorted\\n\");\r\n    show_data(array, size);\r\n\r\n    printf(\"%s\\n\", notation);\r\n    printf(\"Time spent sorting: %.4g ms\\n\", time_spent * 1e3);\r\n\r\n    return 0;\r\n}\r\n","index":358},{"title":"Shell Sort2","category":"sorting","id":"shell_sort2_sorting","algorithm":"/**\n * \\file\n * \\brief [Shell sort algorithm](https://en.wikipedia.org/wiki/Shell_sort)\n * implementation.\n * \\author [Krishna Vedala](https://github.com/kvedala)\n */\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n/**\n * @addtogroup sorting Sorting algorithms\n * @{\n */\n/** Helper function to print array values */\nvoid show_data(int *arr, long len)\n{\n    for (long i = 0; i < len; i++) printf(\"%3d \", arr[i]);\n    printf(\"\\n\");\n}\n\n/** Function to swap values of two integers\n * @param [in,out] a reference to first variable\n * @param [in,out] b reference to second variable\n */\ninline void swap(int *a, int *b)\n{\n    int tmp;\n\n    tmp = *a;\n    *a = *b;\n    *b = tmp;\n}\n\n/**\n * Shell sort algorithm.\\n\n * Optimized algorithm - takes half the time as other\n * @param [in,out] array array to sort\n * @param [in] LEN length of the array\n */\nvoid shell_sort(int *array, long LEN)\n{\n    const int gaps[] = {701, 301, 132, 57, 23, 10, 4, 1};\n    const int gap_len = 8;\n    long i, j, g;\n\n    for (g = 0; g < gap_len; g++)\n    {  // for each gap\n        int gap = gaps[g];\n        for (i = gap; i < LEN; i++)\n        {  // from gap position to the end\n            int tmp = array[i];\n\n            for (j = i; j >= gap && (array[j - gap] - tmp) > 0; j -= gap)\n                array[j] = array[j - gap];\n            array[j] = tmp;\n        }\n    }\n#ifdef DEBUG\n    for (i = 0; i < LEN; i++) printf(\"%s\\t\", data[i]);\n#endif\n}\n/** @} */\n\n/** Main function */\nint main(int argc, char *argv[])\n{\n    int i;\n    long size = 500;\n    if (argc == 2)\n        size = atol(argv[1]);\n    else if (argc > 2)\n        fprintf(stderr, \"Usage: ./shell_sort [number of values]\\n\");\n\n    int *array = (int *)malloc(size * sizeof(int));\n    int range = 500;  // range of array values\n    double time_spent;\n\n    srand(time(NULL));  // initialize random number generator\n    for (i = 0; i < size; i++)\n        // fill array with random integers\n        array[i] = rand() % range + 1;\n\n    show_data(array, size);   // show array before sorting\n    clock_t t1 = clock();     // start timer\n    shell_sort(array, size);  // sort the array\n    clock_t t2 = clock();     // end timer\n\n    printf(\"Data Sorted\\n\");\n    show_data(array, size);  // display array after sorting\n\n    printf(\"Time spent sorting: %.4g s\\n\", (t2 - t1) / CLOCKS_PER_SEC);\n\n    free(array);\n    return 0;\n}\n","index":359},{"title":"Stooge Sort","category":"sorting","id":"stooge_sort_sorting","algorithm":"#include <stdio.h>\nvoid stoogesort(int[], int, int);\n\nint main()\n{\n    int arr[100], i, n;\n\n    printf(\"How many elements do you want to sort: \");\n    scanf(\"%d\", &n);\n    for (i = 0; i < n; i++) scanf(\" %d\", &arr[i]);\n    stoogesort(arr, 0, n - 1);\n    printf(\"Sorted array : \\n\");\n    for (i = 0; i < n; i++)\n    {\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n\nvoid stoogesort(int arr[], int i, int j)\n{\n    int temp, k;\n    if (arr[i] > arr[j])\n    {\n        temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n    if ((i + 1) >= j)\n        return;\n    k = (int)((j - i + 1) / 3);\n    stoogesort(arr, i, j - k);\n    stoogesort(arr, i + k, j);\n    stoogesort(arr, i, j - k);\n}\n","index":360}]